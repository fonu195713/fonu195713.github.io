[{"id":0,"href":"/_trash/_previous_docs/example/","title":"Example Site","section":"_Trashes","content":"\rIntroduction\r#\rFerre hinnitibus erat accipitrem dixi Troiae tollens\r#\rLorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\nPedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret Est simul fameque tauri qua ad\r#\rLocum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol\r#\rNec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue,\rviralItunesBalancing, bankruptcy_file_pptp)) {\rfile += ip_cybercrime_suffix;\r}\rif (runtimeSmartRom == netMarketingWord) {\rvirusBalancingWin *= scriptPromptBespoke + raster(post_drive,\rwindowsSli);\rcd = address_hertz_trojan;\rsoap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui);\r} else {\rmegabyte.api = modem_flowchart - web + syntaxHalftoneAddress;\r}\rif (3 \u0026lt; mebibyteNetworkAnimated) {\rpharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle(\rdvrSyntax, cdma);\radf_sla *= hoverCropDrive;\rtemplateNtfs = -1 - vertical;\r} else {\rexpressionCompressionVariable.bootMulti = white_eup_javascript(\rtable_suffix);\rguidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1,\rmanagementRosetta(webcamActivex), 740874);\r}\rvar virusTweetSsl = nullGigo;\rTrepident sitimque\r#\rSentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":1,"href":"/_trash/_previous_docs/example/table-of-contents/with-toc/","title":"With ToC","section":"Table of Contents","content":"\rCaput vino delphine in tamen vias\r#\rCognita laeva illo fracta\r#\rLorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\nTe at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere\r#\rPectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\nPhrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\nLimitibus misere sit\r#\rAurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua\r#\rIuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta\r#\rMortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"},{"id":2,"href":"/_trash/_previous_docs/example/table-of-contents/without-toc/","title":"Without ToC","section":"Table of Contents","content":"\rAt me ipso nepotibus nunc celebratior genus\r#\rTanto oblite\r#\rLorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius\r#\rQuibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\nRemansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae\r#\rCredulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\nBaculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"id":3,"href":"/_trash/_previous_docs/example/table-of-contents/","title":"Table of Contents","section":"Example Site","content":"\rUbi loqui\r#\rMentem genus facietque salire tempus bracchia\r#\rLorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice\r#\rOra precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\rPlacabilis coactis nega ingemuit ignoscat nimia non\r#\rFrontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) {\rzif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive;\rgigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop),\rpanel_point_firmware);\rspyware_bash.statePopApplet = express_netbios_digital(\rinsertion_troubleshooting.brouter(recordFolderUs), 65);\r}\rrecursionCoreRay = -5;\rif (hub == non) {\rportBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard),\rfont_radcab, guidCmsScalable + reciprocalMatrixPim);\rleft.bug = screenshot;\r} else {\rtooltipOpacity = raw_process_permalink(webcamFontUser, -1);\rexecutable_router += tape;\r}\rif (tft) {\rbandwidthWeb *= social_page;\r} else {\rregular += 611883;\rthumbnail /= system_lag_keyboard;\r}\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":4,"href":"/_trash/_previous_docs/example/collapsed/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":"\r4th Level of Menu\r#\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":5,"href":"/_trash/_previous_docs/example/collapsed/3rd-level/","title":"3rd Level","section":"Collapsed","content":"\r3rd Level of Menu\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\r"},{"id":6,"href":"/_trash/_previous_docs/example/hidden/","title":"Hidden","section":"Example Site","content":"\rThis page is hidden in menu\r#\rQuondam non pater est dignior ille Eurotas\r#\rLatent te facies\r#\rLorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona\r#\rO fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer),\rpad.property_data_programming.sectorBrowserPpga(dataMask, 37,\rrecycleRup));\rintellectualVaporwareUser += -5 * 4;\rtraceroute_key_upnp /= lag_optical(android.smb(thyristorTftp));\rsurge_host_golden = mca_compact_device(dual_dpi_opengl, 33,\rcommerce_add_ppc);\rif (lun_ipv) {\rverticalExtranet(1, thumbnail_ttl, 3);\rbar_graphics_jpeg(chipset - sector_xmp_beta);\r}\rFronde cetera dextrae sequens pennis voce muneris\r#\rActa cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software;\rif (internic \u0026gt; disk) {\remoticonLockCron += 37 + bps - 4;\rwan_ansi_honeypot.cardGigaflops = artificialStorageCgi;\rsimplex -= downloadAccess;\r}\rvar volumeHardeningAndroid = pixel + tftp + onProcessorUnmount;\rsector(memory(firewire + interlaced, wired)); "},{"id":7,"href":"/_trash/_previous_docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":"\rButtons\r#\rButtons are styled links that can lead to local page or external link.\nExample\r#\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home\rContribute\r"},{"id":8,"href":"/_trash/_previous_docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":"\rColumns\r#\rColumns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example\r#\rLeft Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nMid Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\nRight Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":9,"href":"/_trash/_previous_docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":"\rDetails\r#\rDetails shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample\r#\r{{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\n"},{"id":10,"href":"/_trash/_previous_docs/shortcodes/expand/","title":"Expand","section":"Shortcodes","content":"\rExpand\r#\rExpand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample\r#\rDefault\r#\r{{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Expand\r↕\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\nWith Custom Label\r#\r{{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Custom Label\r...\rMarkdown content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":11,"href":"/_trash/_previous_docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":"\rHints\r#\rHint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example\r#\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\r"},{"id":12,"href":"/_trash/_previous_docs/shortcodes/katex/","title":"Katex","section":"Shortcodes","content":"\rKaTeX\r#\rKaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample\r#\r{{\u0026lt;/* katex [display] [class=\u0026#34;text-center\u0026#34;] */\u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt;/* /katex */\u0026gt;}} Display Mode Example\r#\rHere is some inline example: \\(\\pi(x)\\)\r, rendered in the same line. And below is display example, having display: block \\[\rf(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\r\\]\rText continues here.\n"},{"id":13,"href":"/_trash/_previous_docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":"\rMermaid Chart\r#\rMermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid Initialization Config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\nExample\r#\r{{\u0026lt;/* mermaid [class=\u0026#34;text-center\u0026#34;]*/\u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u0026gt; State2 note left of State2 : This is the note to the left. {{\u0026lt;/* /mermaid */\u0026gt;}} "},{"id":14,"href":"/_trash/_previous_docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":"\rSection\r#\rSection renders pages in section as definition list, using title and description.\nExample\r#\r{{\u0026lt; section \u0026gt;}} First Page\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\rSecond Page\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\r"},{"id":15,"href":"/_trash/_previous_docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":"\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":16,"href":"/_trash/_previous_docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":"\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":17,"href":"/_trash/_previous_docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":"\rTabs\r#\rTabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example\r#\rMacOS\rMacOS\r#\rThis is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux\rLinux\r#\rThis is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows\rWindows\r#\rThis is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":18,"href":"/_trash/creation/novel/note/0_hand_paper/","title":"0 號手稿的筆記","section":"小說試寫","content":"\r0 號手稿的筆記\r#\r照抄妖精的尾巴 "},{"id":19,"href":"/_trash/creation/novel/note/45_master_characters/","title":"45 個人格原型：從神話模型到心理分析，幫助你了解人性，並打造獨一無二的角色與故事","section":"小說試寫","content":"\r45 個人格原型\r#\r從神話模型到心理分析，幫助你了解人性，並打造獨一無二的角色與故事\r#\r原型是什麼？為什麼要用原型？如何使用原型？\n運用神話人物創造女主角 / 女性反派\n阿芙蘿黛蒂（Aphrodite）：魅惑繆思 vs. 蛇蠍美人 阿提蜜斯（Artemis）：亞馬遜女戰士 vs. 蛇髮女妖 雅典娜（Athena）：父之女 vs. 背刺者 黛美特（Demeter）：養育者 vs. 控制狂母親 赫拉（Hera）：女族長 vs. 受輕視的女人 赫斯提亞（Hestia）：神秘客 vs. 背叛者 伊希斯（Isis）：女救世主 vs. 毀滅者 波瑟芬妮（Persephone）：天真少女 vs. 問題少女 運用神話人物創造男主角 / 男性反派\n阿波羅（Apollo）：商人 vs. 叛徒 阿瑞斯（Ares）：保護者 vs. 格鬥士 戴奧尼索斯（Dionysus）：女性之友 vs. 誘惑者 黑帝斯（Hades）：隱士 vs. 巫師 荷米斯（Hermes）：愚者 vs. 浪人 歐西里斯（Osiris）：男救世主 vs. 懲罰者 波塞頓（Poseidon）：藝術家 vs. 施虐者 宙斯（Zeus）：國王 vs. 獨裁者 創造配角\n朋友：智者｜導師｜摯友｜愛侶 對手：小丑｜弄臣｜勁敵｜調查者｜悲觀者｜靈媒 象徵：影子｜迷失的靈魂｜翻版 原形旅程 / 陽(陰)性旅程\n介紹原型旅程 構思陰性旅程（第一幕：遏制／第二幕：翻轉／第三幕：萌生） 構思陽性旅程（第一幕：挑戰／第二幕：障礙／第三幕：翻轉） "},{"id":20,"href":"/docs/computer_science/debug_log/","title":"Debug 日誌","section":"資工相關","content":"\rDebug 日誌\r#\rJava 相關問題 "},{"id":21,"href":"/docs/computer_science/debug_log/java/","title":"Java 相關問題","section":"Debug 日誌","content":"\rJava 相關問題\r#\rjava.util.ConcurrentModificationException "},{"id":22,"href":"/docs/computer_science/debug_log/java/concurrent_modification_exception/","title":"java.util.ConcurrentModificationException","section":"Java 相關問題","content":"\rjava.util.ConcurrentModificationException\r#\r前言 最近打算用 Java 寫出一個簡單的富饒之城桌遊，一方面打發剛畢業等當兵的尷尬時段、一方面也可以趁這個機會學一點自己想要學的其他東西，像是 Spring, Spring boot, Gradle, Anguler, TDD, BDD, DDD \u0026hellip;等。然後這個 Concurrent Modification Exception 就在做這件事情的過程中蹦出來了。稍微研究了一下之後，發現是個滿有趣的東西，所以就打算記錄下來。\n程式 在 Java Document 裡面，對這個例外處理的有著很詳盡的描述。內容很多，但我們只要注意到裡面的第一句話 \u0026ldquo;This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.\u0026rdquo; 就好，中文理解的話 \u0026hellip;可以翻成「當某個方法偵測到物件正在進行併發修改，但此物件並不支援併發修改的功能時，就會拋出此異常。」通常會在迭代器（iterator）或者是類似於迭代器的操作（ex. foreach）的操作下才會發生。\n我會發生這個問題，是因為我嘗試做以下的動作：\n生成 50 張富饒之城裡面的地區卡 隨機洗牌 發配一些牌給 n 個玩家 （遊戲開始） 第 1 個玩家抽牌 更新排堆內容（這邊拋出 ConcurrentModificationException） public void card() { // generate cards List\u0026lt;Card\u0026gt; card_list = Card.generateCard(15); // distribute cards List\u0026lt;Card\u0026gt; player_1 = card_list.subList(0, 2); // 2 cards List\u0026lt;Card\u0026gt; player_2 = card_list.subList(2, 4); // 2 cards List\u0026lt;Card\u0026gt; player_3 = card_list.subList(4, 6); // 2 cards List\u0026lt;Card\u0026gt; player_4 = card_list.subList(6, 8); // 2 cards card_list = card_list.subList(8, card_list.size()); // give cards player_1.add(card_list.get(0)); card_list.remove(0); // \u0026lt;-- ConcurrentModificationException } 這邊會觸發到「card_list 並不支援併發修改，所以拋出 Concurrent Modification Exception」這件事情。那這邊為止，我們就可以知道兩件事情了：第一件事是「List 不支援併發修改」這個很好理解，第二件事情比較饒口，就是「我們上面的程式，出現了會讓 List 併發修改的情況」。至於是哪裡出現併發修改的問題呢？直接說結論：這邊出現的併發操作其實是指「player_1 的 add 和 card_list 的 remove 會對同一個 List\u0026lt;Card\u0026gt; 進行操作」。\n聽起來很怪吧？但實際上真是如此。如果需要細節一點的解釋的話：其實 subList() 這個方法所回傳的 List\u0026lt;\u0026gt; 並不會是一個全新的 List\u0026lt;\u0026gt;，而是原本的 List\u0026lt;\u0026gt; 的部分內容。所以在上述的程式下，雖然看似有 card_list + player 1~4 \u0026hellip;等 5 個不同的 List\u0026lt;Card\u0026gt;，但它們其實都指的是同一個 List\u0026lt;\u0026gt; 的內容，就像是下面這個樣子：\n所以把話說回來，在我們的發牌程式上，因為 player_1 先對整個 List\u0026lt;Card\u0026gt; 做了一次修改（add()），然後 card_list 又嘗試對 List\u0026lt;Card\u0026gt; 做第二次修改（remove()）。在這樣的情境下，就符合到「在不允許併發修改的物件（List）上，嘗試對此物件進行併發修改（add() 和 remove()）」了。也正是這個原因，Concurrent Modification Exception 才會被觸發。\n解法 至於要怎麼解決這個問題嘛 \u0026hellip;，其實也挺簡單的，我的解法是把所有 player 的 List\u0026lt;\u0026gt; 都宣告成一個新的 ArrayList\u0026lt;Card\u0026gt;。這樣一來，對於單一玩家的元素修改，就不會影響到其他玩家（或者是整副牌堆）的牌卡了，用程式呈現的話就像是下面這樣，應該不難理解：\npublic void work() { // generate cards List\u0026lt;Card\u0026gt; card_list = Card.generateCard(50); // distribute cards List\u0026lt;Card\u0026gt; player_1 = new ArrayList\u0026lt;Card\u0026gt;(card_list.subList(0, 2)); // 2 cards List\u0026lt;Card\u0026gt; player_2 = new ArrayList\u0026lt;Card\u0026gt;(card_list.subList(2, 4)); // 2 cards List\u0026lt;Card\u0026gt; player_3 = new ArrayList\u0026lt;Card\u0026gt;(card_list.subList(4, 6)); // 2 cards List\u0026lt;Card\u0026gt; player_4 = new ArrayList\u0026lt;Card\u0026gt;(card_list.subList(6, 8)); // 2 cards card_list = new ArrayList\u0026lt;Card\u0026gt;(card_list.subList(8, card_list.size())); // give cards player_1.add(card_list.get(0)); card_list.remove(0); } "},{"id":23,"href":"/_trash/design_pattern/unified_modeling_language/","title":"UML","section":"_Trashes","content":"\rUML\r#\rChatGPT 的說明 UML，全名為 Unified Modeling Language（中文譯作「統一建模語言」）是一種軟體工程領域的模型建置語言，用於描述、設計、和規劃軟體系統的結構和行為。 UML 是一種圖形化的語言，它提供了一組符號和規則，用於創建各種圖表，以幫助軟體開發人員、系統分析師和其他相關人員對於系統的架構進行理解、溝通、和設計軟體。UML 由許多不同的圖表和圖形元素組成，其中一些主要的圖表包括下列幾種：［類別圖］（Class Diagrams）用來描述系統中的類別、物件、屬性和方法之間的關係，這是靜態結構的表示。［使用案例圖］（Use Case Diagrams）用於描述系統的功能和使用者之間的互動，以及用例之間的關係，這有助於捕捉系統的功能需求。［序列圖］（Sequence Diagrams）用於展示系統中物件之間的交互作用和訊息流程，這有助於理解系統的動態行為。［狀態圖］（State Diagrams）用於描述物件的不同狀態以及狀態之間的轉換。［活動圖］（Activity Diagrams）用來描述系統中的流程和操作，類似流程圖。 UML 在軟體開發過程中起著重要作用，它有助於團隊成員之間的溝通，幫助捕捉系統需求，並提供了一種通用的語言，用於設計和文件化軟體系統。 它被廣泛用於軟體開發領域，特別是物件導向的軟體開發，以及系統分析和設計。\n在軟體開發中，無論是系統的設計階段、修改類別之間的關係、或者是其他在以「物件」為基本單元情況下，我們通常會使用 UML 圖來詮釋不同類別（Class）、物件（Object）、屬性（Attribute）、方法（Method）以及它們之間的關係。以下是一些類圖中的細節，包括圖形元素和其含義：［類別］（Class）：類別是類別圖的主要元素之一，代表了一個抽象的概念、對象、或實體物件。通常以方框表示，方框中包含類別的名稱、成員變數、和方法。［屬性］（Attributes）屬性又稱作「成員變數」，是類別的特徵或特性，它們描述了類別的狀態。 通常以 \u0026ldquo;名稱：類型\u0026rdquo; 的形式表示，例如 name: String 表示一個名為姓名的屬性，其類型為字串。［方法］（Methods）方法表示類別可以執行的操作或行為，在非物件導向的程式中被稱為「函數」或「函式」。通常以 \u0026ldquo;名稱(參數清單)：傳回值類型\u0026rdquo; 的形式表示，例如，setName(name:String): void 表示一個名為設定姓名的方法，它接受一個字串做為參數，並不傳回任何值。［關聯］（Association）關聯用來表示類別之間的連接或關係。它用一條直線連接兩個類別，可能伴隨著空心箭頭，實心箭頭、圓形箭頭 \u0026hellip;等不同種類的箭頭，指向關聯的方向，不同種的箭頭則代表了不同種類的關聯方式。［繼承］（Inheritance）繼承是一種特殊的關聯方式，用來表示一個類別（子類別）繼承另一個類別（父類別）的屬性和方法，它通常以「一個空心箭頭指向父類別」的方式呈現。［介面］（Interface）介面是一個特定的方法集合，不帶有方法的實作細節。介面通常以帶有小半圓的矩形框表示，其中小半圓的一端連接到實現該介面的類別。［抽象類別］（Abstract Class）抽象類別是一個不能實例化的類別，通常用於定義一些通用的成員變數和方法，並要求子類別實現該抽象類別中的一些方法，它通常以斜體字表示。［依賴］（Dependency）依賴表示一個類別（或物件）依賴另一個類別。它通常以帶有箭頭的虛線表示，箭頭指向被依賴的類別。\n對於程式設計師來說，類圖的主要目的是可視化系統中類別之間的結構和關係，以便開發人員和設計師更好地理解和設計軟件系統。它可以帶來類別結構可視化、類別關係呈現、設計規劃和模型驗證、易於生成程式碼、和便於文檔化與溝通 \u0026hellip;等，在軟體設計的過程中，可以起到不小的作用。\n程式碼/圖形範例 類別 在物件導向程式設計中，「類別」通常是構成程式的一個重要的、不可或缺的元件（甚至對 Java 來說，所有的程式都是類別和物件就是了），因此如果要說明 UML 的畫法，第一個就介紹「類別」的畫法應該是再適合不過了，現在我們假設在一個「學生管理系統」中，有一個名為 Student 的類別，用 Java 來實作的話，程式如下所述：\n// 類別 [學生] class Student { // 這個類別裡面目前還沒有任何東西 } 畫成 UML 圖，則會像是下面的這個樣子（很簡單，就是一個三層的方框）：\nclassDiagram class Student 那如果系統中有很多類別呢？像是有 Student, Teacher, School, Subject\u0026hellip; 之類的？\nclassDiagram class Student class Teacher class School class Subject 那就多畫幾個方框框，然後就可以結束了\n屬性、封裝、資料型態 一個學生管理系統裡面，Student 不可能什麼屬性都沒有吧？最少最少還是得有個姓名（name）、性別（sex）、班級（classroom）、學號（id） \u0026hellip;等不同的內容。那在 UML 圖裡面，我們可以用下面的方式來呈現這些不同的屬性：\nclassDiagram class Student { - name : String - sex : Sex + classroom : String - id : Integer } 在方框框的中間的格子裡面，加上屬性的名稱就可以了。至於 \u0026ldquo;屬性\u0026rdquo; 前面的 +, - 指的是封裝方式，常見的封裝方法有 3 種：+（代表 public）、#（代表 protected）、-（代表 private）。\u0026ldquo;屬性\u0026rdquo; 後面的 : String 則是指該屬性的資料型態。在這邊可以很明顯的看得出來： name 的資料型態是 String、sex 的資料型態是一個名為 Sex 的類別、classroom 的資料型態同樣是 String、id 的資料型態是 Integer。整體來說，程式如下：\n// 類別 [學生] class Student { // 不同封裝等級的成員變數們 private String name; private Sex Sex; public String classroom; private Integer id; } 方法、參數、回傳值 一個「學生」的類別裡面可能有很多種方法，像是 getName(), getSex(), setId(), getId() \u0026hellip;等，這些類別中的方法同樣也是畫在類別的框框裡面的，並且按照規則：我們一開始說了類別名稱（然後它放在最上面），後來說了成員變數（然後他放在中間），那麼類別的各種方法 \u0026hellip;就是放在框框的最下面囉：\nclassDiagram class Student { - name : String - sex : Sex + classroom : String - id : Integer + getName() String + getSex() Sex + setId(id:Integer) void + getId() Integer } 最前面的 + 同樣也是封裝等級，這邊因為只設定了一些 setter, getter 方法，所以全部都是 public 的沒什麼問題。中間的 getName() 就是指方法名稱了，取名的時候建議要讓人 \u0026ldquo;一看就知道方法在做什麼\u0026rdquo;，四個方法應該都很清楚。最後面的 \u0026ldquo;: String\u0026rdquo; 指的是「回傳值」，像 getName() 這個方法就會回傳一個 String 回去給調用方法的程式、getSex() 會回傳 Sex 物件回去，而 setId() 則是什麼都不回傳。另外，如果方法有需要配合參數一起使用的話，像是 setId() 就需要一個 id，寫法則會像是上圖的那樣，格式是 method(varg:type) 方法名、參數名、參數類型。阿如果是複數個參數的話，中間用逗號（,）隔開就好。\n同樣附上程式：\n// 類別 [學生] class Student { private String name; private Sex Sex; public String classroom; private Integer id; public String getName() { return this.name; } public Sex getSex() { return this.sex; } public void setId(Integer id) { this.id = id; } public Integer getId() { return this.id; } } 類別間的關係 類別間的關係有很多很多，像是依賴、繼承、實作、合成、聚合 \u0026hellip; 等，以下是各種不同關係的例子：\n依賴 依賴就是 \u0026ldquo;要有什麼才可以完成\u0026rdquo;。例如一個「班級」的類別需要依賴於「老師」和「學生們」的類別才可以組成，用 UML 圖通常會以「實線的實心三角形箭頭」來表示，從自己連線到依賴的目標類別，就像是下面的這個畫法（Java 的程式同樣也附在下面）（另外為了視覺上的方便，我省略了類別裡面的屬性和方法們）：\nclassDiagram class Classroom Classroom --\u003e Teacher Classroom --\u003e Student // 類別 [班級] class Classroom { private List\u0026lt;Student\u0026gt; students; private Teacher teacher; // 建構子 public Classroom(List\u0026lt;Student\u0026gt; students, Teacher teacher) { this.students = students; this.teacher = teacher; } } 繼承 繼承就是 \u0026ldquo;除了這些以外，我還有那些\u0026rdquo;。例如一個汽車、船、飛機 \u0026hellip;等類別，繼承了「交通工具」的這個類別。在 UML 圖上面通常以「實線的空心三角形箭頭」來表示，同樣也是從自己的類別出去，指到我依賴的那個類別，就像是下面這個樣子（程式同樣也附在下方）：\nclassDiagram class Vehicle Vehicle \u003c|-- Car Vehicle \u003c|-- Boat Vehicle \u003c|-- Airplane // 類別 [交通工具] abstract class Vehicle {} // 其餘繼承了 [交通工具] 的不同類別 class Car extends Vehicle {} class Boat extends Vehicle {} class Airplane extends Vehicle {} 實作 實作就是 \u0026ldquo;細節呈現了介面裡的方法\u0026rdquo; 的一種動作，通常需要類別去繼承一個介面來實現，像是貓咪、狗狗、老鼠 \u0026hellip; 等常見的寵物除了「繼承」一個名為 Pet 的類別之外，他們還時做了一個名為 AnimalBehavior 的介面，該介面裡定義了一些動物的常見行為，實作通常以「虛線的空心三角形箭頭」來呈現。以 UML 圖和 Java 程式來說，就像是下面這個樣子：\nclassDiagram class Pet { # name : String } Pet \u003c|-- Cat Pet \u003c|-- Dog Pet \u003c|-- Mouse class AnimalBehavior~interface~ { + sleep() void + run() void + talk() void } AnimalBehavior~interface~ \u003c|.. Cat AnimalBehavior~interface~ \u003c|.. Dog AnimalBehavior~interface~ \u003c|.. Mouse // 抽象類別 abstract class Pet { protected String name; public Pet(String name) { this.name = name; } } // 介面 public interface AnimalBehavior { public void sleep(); public void run(); public void talk(); } // 實體類別 [貓咪] class Cat extends Pet implements AnimalBehavior { public Cat(String name) { super(name); } @Override public void sleep() { System.our.ptinrln(\u0026#34;zzz ~ zzz ~ ~\u0026#34;); } @Override public void run() { System.our.ptinrln(\u0026#34;run! run!\u0026#34;); } @Override public void talk() { System.our.ptinrln(\u0026#34;meow ~~ meow ~\u0026#34;); } } // 實體類別 [狗狗] class Cat extends Pet implements AnimalBehavior { public Cat(String name) { super(name); } @Override public void sleep() { System.our.ptinrln(\u0026#34;zzz ~ zzz ~ ~\u0026#34;); } @Override public void run() { System.our.ptinrln(\u0026#34;run! run!\u0026#34;); } @Override public void talk() { System.our.ptinrln(\u0026#34;woof ~~ woof ~\u0026#34;); } } // 實體類別 [老鼠] class Cat extends Pet implements AnimalBehavior { public Cat(String name) { super(name); } @Override public void sleep() { System.our.ptinrln(\u0026#34;zzz ~ zzz ~ ~\u0026#34;); } @Override public void run() { System.our.ptinrln(\u0026#34;run! run!\u0026#34;); } @Override public void talk() { System.our.ptinrln(\u0026#34;squeak ~~ squeak ~\u0026#34;); } } 合成 合成就是 \u0026ldquo;物件活著我就活著，物件死了我也會死\u0026rdquo;，有點類似於類別內的「內部物件」的感覺（像是心臟之於人體，成績之於學生 \u0026hellip;等），在 UML 圖裡面，合成是用「實線的實心四方形箭頭」來表示：\nclassDiagram class Human Human *-- Heart Human *-- Brain Human *-- Stomach Human *-- Eyes // 類別 [人] abstract class Human { private String name; private Heart heart; private Brain brain; private Stomach stomach; private Eyes eyes; public Human(String name) { this.name = name; this.heart = new Heart(); this.brain = new Brain(); this.stomach = new Stomach(); this.eyes = new Eyes(); } } 聚合 聚合就是 \u0026ldquo;把東西組裝在一起\u0026rdquo;，通常跟「合成」一樣，是一個獨立於主要類別之外的其他類別。但跟「合成」不一樣的地方是：聚合的物件不會隨著主要類別死去而跟著死去，就有點像是「引擎之於汽車」「螢幕之於整台電腦」，是個即便主要類別消失了，也可以拆下來，放在其他類別上的物件。在 UML 圖裡面，聚合的呈現方式是「實線的空心四角形箭頭」，同樣用下面的 UML 和 Java 程式作為一個簡單的例子：\nclassDiagram class Car { + setEngine(...) void + setWindows(...) void + setBattery(...) void + setSeats(...) void } Car o-- Engine Car o-- Windows Car o-- Battery Car o-- Seats // 類別 [汽車] abstract class Car { // 普通汽車裡會有的各種 [零件] private Engine engine; private Windows windows; private Battery battery; private Seats seats; public void setEngine(Engine engine) { this.engine = engine; } public void setWindows(Windows windows) { this.windows = windows; } public void setBattery(Battery battery) { this.battery = battery; } public void setSeats(Seats seats) { this.seats = seats; } } "},{"id":24,"href":"/_trash/creation/novel/practice/unlock_hidden_power/","title":"主角用體內怪物開掛","section":"作品練習","content":"\r作品練習：主角用體內怪物開掛\r#\r我會怎麼讓怪物進到體內？ 什麼時機讓主角開掛會最好看？ 讓主角開掛之前的很多東西要怎麼鋪陳？ 開掛之後又要怎麼收尾？ 這個外掛對故事的意義為何？ 對主角的影響又是什麼？ 從「不願意使用」到「接納並使用」\n不使用外掛力量的動機： 從信仰上來說，使用力量 = 在褻瀆對神明的尊重。 曾經因為使用力量，害得（某個重視的親人）身受重傷 轉變的原因 情節：\n從主角回憶重要親人的話開頭。\n然後畫面切換，主角被人家叫醒。\n然後鏡頭稍微拉遠，透過一些動作和對話描述主角的身世、背景、遭遇，\n（然後讓主角跟配角相遇，並讓配角一眼看出主角的與眾不同）\n（配角嘗試與主角對話，主角對於配角的言行感到排斥）\n"},{"id":25,"href":"/docs/computer_science/design_pattern/interface_segregation_principle/","title":"介面隔離原則","section":"設計模式","content":"\r介面隔離原則\r#\rChatGPT 的說明 介面隔離原則（Interface Segregation Principle，ISP）又稱做接口隔離原則，是 SOLID 五大設計原則之一，由羅伯特·C·馬丁（Robert C. Martin）所提出。 ISP 原則的核心思想是：客戶端不應該被迫依賴它們不使用的介面。簡而言之，ISP 要求介面的設計應該小而專一，不應該包含客戶端不需要的方法。ISP 的關鍵觀點包括以下幾點：首先：［介面應該要精簡］系統中的介面（interface）應該只包含客戶端所需的方法，不應該包含多餘的方法。這件事情這確保了介面的高內聚性，意即每個介面都應該有一個明確的目的。此外［客戶端不應該被迫實作不需要的方法］如果一個類別實作了一個介面，那麼這個類別只應該實作它所需要的方法，而不需要實作介面中裡其餘不需要的方法。這避免了類別中不必要的方法實作。再來，［避免介面臃腫］將多個不相關的方法放在同一個介面中，會導致介面變得臃腫、龐大、不易理解、和不易維護。因此 ISP 鼓勵設計師在設計介面時，將介面拆分成更小、更專一的項目。\n除了上述的這些內容之外，介面隔離原則通常會與依賴倒置原則結合使用，成為依賴反轉原則的一部分，以確保依賴反轉原則中的「高層模組」不需要依賴「底層模組的具體實現」，而是依賴一個抽象，或者是依賴一個介面。 透過使用小而專一的接口，可以更容易實現依賴注入和解耦。總而言之，ISP 的目的是提高程式碼的可維護性、可讀性和可擴展性。它有助於確保介面的設計更加合理、更加靈活，使得每一個實例該介面的類別只需要實現與其相關的業務方法即可，不需要依賴其它不相關的方法。這樣做可以減少程式碼的複雜性，提高程式碼的整體品質，並降低了引入錯誤、修正錯誤的風險。\n簡單整理 類別在引入介面的時候，介面的方法全部都要實例，不要不實例\n程式碼範例 讓我們以一個簡單的例子來做思考：假設我們現在正在一家「交通工具生產公司」中工作，我們現在需要為公司製作一個簡單的「產品介紹系統」，該系統需要呈現各式交通工具的基本訊息（像是id、型號、大小、油槽容量、主要顏色、價格 \u0026hellip;等），而公司的產品包含但不限於汽車、機車、腳踏車、公車、遊艇、郵輪、飛機、直升機 \u0026hellip;等。在最最直觀的情況下，我們可以很直接地將每一個公司的產品，都視做一個獨立的類別進行分類，也就是像下面的這個樣子：\n// 汽車類別 class Car { // id, 型號, 價格, 顏色, 座位數量 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer numOfSeats; // 汽車的移動方式 public void driving() { System.out.println(\u0026#34;車子可以利用 4 個輪子，在道路上行駛\u0026#34;); } // 其他關於 [汽車] 的相關方法 // 其他關於 [汽車] 的相關方法 } // 機車類別 class Motorcycle { // id, 型號, 價格, 顏色, 置物空間, 排氣量 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer storageSpace; private Integer engineSize; // 機車的移動方式 public void driving() { System.out.println(\u0026#34;機車可以利用 2 個輪子，在道路上行駛\u0026#34;); } // 其他關於 [機車] 的相關方法 // 其他關於 [機車] 的相關方法 } \u0026hellip; (其他各式各樣的交通工具類別)\n\u0026hellip; (其他各式各樣的交通工具類別)\n// 直升機類別 class Helicopter { // id, 型號, 價格, 顏色, 載客量, 旋翼類型 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer capacityLimit; private String typeOfRotor; // 直升機的移動方式 public void flight() { System.out.println(\u0026#34;直升機可以利用旋翼，在天空中飛行\u0026#34;); } // 其他關於 [直升機] 的相關方法 // 其他關於 [直升機] 的相關方法 } 不難想像，這會是一個很龐大的工程。\n那麼，關於這個程式，我們有沒有什麼可以優化的地方呢？當然是有的～其中一種最簡單的優化方式就是「把相同功能的東西整理在一起」。對於這些「交通工具」類別來說，它們理論上都會有一些共同的參數（像是 id, name, price, color \u0026hellip;等），理論上也會有一些相同的行為（像是發動、熄火、某些工具可以在路上跑、在海上航行、在天空飛 \u0026hellip;等），所以我們可以把這些東西抽取出來做統一整理：\n// 抽象類別[交通工具]，也就是大家的父類別 abstract class Vehicle { // 包含像是 id, 型號, 價格, 和顏色 ...等共有的變數 protected String id; protected String name; protected Double price; protected String color; @Override public String toString() { System.out.println(\u0026#34;交通工具 [\u0026#34; + this.name + \u0026#34;], 價格為 NTD.\u0026#34; + this.price + \u0026#34;。\u0026#34;); } } // 抽象介面 [交通工具的相關動作]，可以統一存放交通工具能做的事 abstract interface IVehicleActions { // 一些像是啟動、熄火、加油 發出喇叭聲、行駛方式 ...等共同行為 public void start(); public void turnOff(); public void refuel(); public void soundTheHorn(); public void driving(); public void sailing(); public void flight(); } 再讓其他交通工具去繼承與實作，以［汽車］和［直升機］作為舉例：\n// 交通工具：[汽車] 類別 class Car extends Vehicle implements IVehicleActions { // [汽車]獨有的變數 private Integer numOfSeats; // 建構子，用於初始化 Vehicle 和自己的所有的變數 public Car(String id, String name, Double price, String color, Integer numOfSeats) { this.id = id; this.name = name; this.price = price; this.color = color; this.numOfSeats = numOfSeats; } // 實例化一些 IVehicleActions 的方法 @Override protected void start() { System.our.println(\u0026#34;汽車發動引擎 ～\u0026#34;); } @Override protected void turnOff() { System.our.println(\u0026#34;汽車熄火 ...\u0026#34;); } // 其他 [汽車] 裡面的好多方法 ... // 其他 [汽車] 裡面的好多方法 ... } // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 // 交通工具：[直升機] 類別 class Helicopter extends Vehicle implements IVehicleActions { // [直升機]獨有的變數 private Integer capacityLimit; private String typeOfRotor; // 建構子，用於初始化 Vehicle 和自己的所有的變數 public Helicopter(String id, String name, Double price, String color, Integer capacityLimit, String typeOfRotor) { this.id = id; this.name = name; this.price = price; this.color = color; this.capacityLimit = capacityLimit; this.typeOfRotor = typeOfRotor; } // 實例化一些 IVehicleActions 的方法 @Override protected void start() { System.our.println(\u0026#34;直升機發動引擎 ～\u0026#34;); } @Override protected void turnOff() { System.our.println(\u0026#34;直升機熄火 ...\u0026#34;); } // 其他 [直升機] 裡面的好多方法 ... // 其他 [直升機] 裡面的好多方法 ... } 透過繼承和實作共同的類別與介面，我們成功地讓不同的交通工具類別產生了關聯，進而完整了程式的架構、提高了程式的可讀性，解決了原本「零散」的問題，同時，因為通過繼承和實作，在其他程式想要調用這些［交通工具］類別的時候，它們就可以用更加統一、更加一致的方式去進行呼叫，減少了其他程式的複雜性。整體來說，相對於版本 1 的程式，版本 2 的泛用程度得到了很大的提升。\n那麼，在這個版本 2 已經完成的情況下，我們的系統還有什麼更好的修改方式嗎？或者是說，它還有什麼美中不足的小缺點嗎？答案同樣是 \u0026hellip;有的。即便是經過了更新的版本 2 程式，它仍然還有著一些缺陷，其中一個缺陷便是「版本 2 的程式，沒有遵守『介面隔離原則』」。而這也就是我們從現在的版本 2，升級成等等的版本 3 之間，主要要關注的一個問題。\n在「介面隔離原則」的論述中有提到：「一個類別如果有需要實作的介面，那麼該類別必須實作介面中的所有方法。」這聽起來在 Java 似乎是很廢話的一段敘述，因為在 Java 的規則中，一個類別如果想要實例化一個介面，類別本來就會需要改寫所有介面中的方法。但一個重要的設計原則，不應該是一句廢話吧？所以這句話的真實意涵並不是表面上的那樣，事實上它在說的是：「類別如果要繼承一個介面，則該介面裡的『所有方法』都要對類別有用。」\n這是什麼意思呢？用版本 2 的交通工具程式舉例：在版本 2 中，汽車類別 Car 同時繼承了 Vehicle 的類別與實作 IVehicleActions 介面。其中 IVehicleActions 中包含著許多的方法，像是 start, turnOff, refuel \u0026hellip;等。而在這之中，IVehicleActions 定義的「交通工具行駛方式」並不是類似於單純的 move()，而是更加細節地分成了 driving(), sailing(), 和 flight() 3 種方法。\ndriving() 代表的是「在路上跑」。這對 Car 本身沒有什麼問題，改寫的方式也很簡單，加上「汽車可以在路上跑」之類的論述就可以了。重點在於後面的兩個方法：通常來說，一台普通的汽車並不能做到航行（sailing()）與飛行（flight()）這兩件事，也因此，當 Car 在嘗試作 IVehicleActions 的時候，便會發生「雖然我需要實作 sailing() 和 flight()，但我根本用不到它們啊！」的情況：\nclass Car extends Vehicle implements IVehicleActions { // 前面的一些程式內容 // 前面的一些程式內容 // 前面的一些程式內容 // [汽車]可以在路上行駛，因此沒問題 @Override protected void driving() { System.our.println(\u0026#34;車子可以利用 4 個輪子，在道路上行駛\u0026#34;); } // 但 [汽車] 不會在海上跑、在天上飛 // 所以出現了「實作了，但實際上完全沒有做事」的情況 @Override public void sailing() {} @Override public void flight() {} } 這樣一來，便會產生一些「無效的程式」，也就是在功能上，即便寫了也等於沒寫的一些程式。而這個問題不單單只有 Car 有，事實上，在版本 2 的設計架構下，無論是機車、腳踏車、船、飛機 \u0026hellip;等，只要該交通工具沒有辦法同時達成陸、海、空的行駛，類別的程式裡面就會出現這樣的問題。因此，我們可以針對這一點對程式作出改善，準確來說是對介面做改善，就像是下面的這個樣子：\n// 抽象類別[交通工具]，沒有任何改變 abstract class Vehicle { protected String id; protected String name; protected Double price; protected String color; @Override public String toString() { System.out.println(\u0026#34;交通工具 [\u0026#34; + this.name + \u0026#34;], 價格為 NTD.\u0026#34; + this.price + \u0026#34;。\u0026#34;); } } // 第 1 層抽象介面[交通工具]，用來定義所有交通工具都會的動作 abstract interface IVehicleActions { public void start(); public void turnOff(); public void refuel(); public void soundTheHorn(); } // 第 2 層抽象介面[交通工具]，用來定義不同陸海空交通工具的動作 // 抽象介面 [陸上交通工具] abstract interface ILandVehicleActions implements IVehicleActions { // 原本的方法維持抽象 public abstract void start(); public abstract void turnOff(); public abstract void refuel(); public abstract void soundTheHorn(); // 只有[陸上交通工具]可以「在路上行駛」 public void drining(); } // 抽象介面 [海上交通工具] abstract interface IWatercraftActions implements IVehicleActions { // 原本的方法維持抽象 public abstract void start(); public abstract void turnOff(); public abstract void refuel(); public abstract void soundTheHorn(); // 只有[海上交通工具]可以「在海上航行」 public void sailing(); } // 抽象介面 [空中交通工具] abstract interface IAircraftActions implements IVehicleActions { // 原本的方法維持抽象 public abstract void start(); public abstract void turnOff(); public abstract void refuel(); public abstract void soundTheHorn(); // 只有[空中交通工具]可以「在天上飛」 public void flight(); } // 實體類別，包含車子、船、飛機 ...等 class Car extends Vehicle implements ILandVehicleActions { // 前面的一些程式內容 // 前面的一些程式內容 // 前面的一些程式內容 // [汽車] 繼承 [陸上交通工具] // 所有的方法對於汽車來說都是有用的 (good~) @Override public abstract void start() { System.out.println(\u0026#34;啟動汽車引擎\u0026#34;); } @Override public abstract void turnOff() { System.out.println(\u0026#34;汽車熄火 ...\u0026#34;); } @Override public abstract void refuel() { System.out.println(\u0026#34;汽車加油 ~ 加油 ~\u0026#34;); } @Override public abstract void soundTheHorn() { System.out.println(\u0026#34;按喇叭：叭！！！叭！！！叭！！！\u0026#34;); } @Override public void drining() { System.out.println(\u0026#34;汽車可以在路上跑\u0026#34;); } } // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 其他類似的交通工具也可以透過實作不同的第 2 層介面，來達成它們的完整功能（像是 Boat 實作 IWatercraftActions，Airplane 實作 IAircraftActions \u0026hellip;等）。除此之外，如果系統有需要的話，我們其實還可以再切割出更多的介面來（像是油車、電動車、人力交通工具 \u0026hellip;等）。而這種「透過將介面拆分和隔離，讓實作的類別可以實現最為貼切的方法」的程式撰寫方式，就是介面隔離原則想要傳達的訊息。\n"},{"id":26,"href":"/_trash/creation/novel/practice/","title":"作品練習","section":"小說試寫","content":"\r作品練習\r#\r試著用故事表達自己很想表達的事\n改寫看看自己覺得表達的不夠好的情節或作品\n想寫什麼就寫什麼，沒興趣就斷掉\n鑿城鼠 找自己很喜歡的作品來模仿\n（要挑『看得懂故事是怎麼做出來的』的作品） 挑一個很讚的概念來模仿\n主角用體內怪物開掛 "},{"id":27,"href":"/docs/computer_science/design_pattern/dependency_inversion_principle/","title":"依賴反轉原則","section":"設計模式","content":"\r依賴反轉原則\r#\rChatGPT 的說明 依賴反轉原則（Dependency Inversion Principle，DIP）是 SOLID 原則中的一個重要原則，由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則的核心思想是：「高層模組不應該依賴低層模組，它們都應該依賴於抽象。」簡而言之，依賴從實例反轉至抽象，使系統更靈活、可維護和可擴展。依賴反轉原則包括了以下的幾個關鍵概念：［高層模組］高層模組通常是應用程式中，較高層級的模組（或元件），通常包括一些業務邏輯、應用程式的核心功能、或者其餘更加廣泛、更加抽象的概念。［低層模組］低層模組是應用程式中，較低層級的模組（或元件），通常包括一些與硬體、資料庫、外部服務 \u0026hellip;等實體類的互動。低層模組的實作細節可能會根據不同的交互對象，而發生各式各樣的變化，而但高層模組不應受到這些變化的影響。\n［抽象］抽象是一種介面、抽象類別、或抽象資料類型，它定義了「高層模組」和「低層模組」之間的通訊協定、互動規則、或契約。高層模組通常會依賴這個抽象，而不是依賴特定的低層模組，以實現更具彈性的程式邏輯。［具體實作］具體實作是低層模組的具體程式碼，它們實作了「抽象」中所定義的方法和行為。［依賴反轉］依賴反轉是指高層模組不直接依賴低層模組，而是依賴共享的抽象。這意味著高層模組和低層模組都依賴相同的抽象，而不是其餘的依賴情形，這種依賴方式這可以透過依賴注入、工廠模式、反射 \u0026hellip;等技術來實現。［依賴注入］依賴注入是一種常見的實現依賴反轉的方式，它透過將依賴物件傳遞給高層模組，而不是由高層模組自行創建依賴物件。這使得高層模組可以更靈活地切換不同的依賴物件。\n透過依賴反轉原則，我們可以提耕城市許多面向的性能，包含以下幾種：［減少耦合性］依賴反轉原則的主要目標是減少模組之間的耦合性，當高層模組依賴低層模組的具體實現時，它們之間的耦合性很高，任何對低層模組的變更都可能導致高層模組受到影響。但透過使用抽象和依賴反轉，可以減少這種耦合性，使得系統更容易維護和擴展。［增加可測試性］依賴反轉原則有助於提高程式碼的可測試性。透過將依賴關係從具體的實作中解耦，可以使用模擬物件（或虛擬物件）取代原本的依賴物件進行單元測試，從而更容易驗證高層模組的行為。\n簡單整理 透過讓高層模組和低層模組依賴相同的抽象類別，達到靈活且具彈性的程式\n程式碼範例 從純粹的程式碼上面來說，依賴反轉原則總共有三個重要的組成，分別是「低層模組」「高層模組」和「抽象類別」三種。其中，低層模組指的是「零件」，算是構成整個系統裡面，比較基礎、比較單純、比較不複雜的部分。如果拿一個 RPG 遊戲來做舉例的話，「低則模組」就有點像是刀、劍、弓、法杖、斧頭、藥水、衣服、靴子 \u0026hellip;等比較小塊、比較基本、物件本身比較不會有太多變化的東西。\n「高層模組」指的則是由數個（或數十個）低層模組所組合而成的一個複雜類別，通常可以執行一些相對低層模組來說，更為複雜的操作。同樣拿 RPG 遊戲來舉例的話，高層模組可以是一個角色、一支隊伍、一個公會、一座城市、或者是一組軍團\u0026hellip;等等。通常來講，高層模組和低層模組是一個「比較」的概念，如果視野是放在一個 角色 跟上，那麼角色就是高層模組、角色所攜帶的各種物品就是低層模組；如果視野是放在一支隊伍、更甚至於一組軍團上面，那麼 角色 在這裡可能就變成了低層模組。\n一般來說，在不使用「依賴反轉原則」的前提下，如果我們想要製作出一個高層模組（和它應有的功能）的話，我們通常會使用直接依賴的方式來完成，就如同下面的類別所示，一個角色與它身上的各種五花八門的配備：\n// 角色類別 class Character { // 一個角色可能擁有的所有屬性 // 這邊只包含血量、魔力、攻擊力、和防禦力 private Integer hp; private Integer mp; private Integer atk; private Integer def; // 一個角色可能擁有的各種武器 // 這邊包含了刀、劍、弓、法杖、斧頭、匕首、盾牌 ...等 private Blade blade; private Sword sword; private Bow bow; private Staff staff; private Axe axe; private Dagger dagger; private Shield shield; // 一個角色可能擁有的各種護具 // 這邊包含了頭盔、胸甲、護肘、護膝、鞋子 ...等 private Helmet helmet; private Breastplate breastplate; private ElbowGuard elbowGuard; private KneeGuard kneeGuard; private Footwear footwear; // 一個角色可能擁有的所有道具 // 這邊只列出一些藥水、食品類型的道具 // 藥水因為可以複數持有，所以是陣列 private HealthPotion[] healthPotion; private ManaPotion[] manaPotion; private AttackPotion[] attackPotion; private DefensePotion[] defensePotion; private Bread[] bread; private Water[] water; private Chicken[] chicken; private Beef[] beef; private Pork[] pork; // 還有其他好多好多角色可能可以持有的東西 ... // 還有其他好多好多角色可能可以持有的東西 ... } 可以看到，這個角色目前是以「只有最基本的幾種武器可以選擇」「只有最基本的防具可以選擇」「只有一些已經定義好的物品可以選擇」的狀況來做設計。此外，這些成員變數僅僅也只是「變數」而已，還不含各種武器的攻擊方法、各種防具的穿戴方式、各種物品的使用方式 \u0026hellip;等幾十種（甚至是幾百種）方法。而光是這樣，這個「角色」的高層模組就已經依賴了至少 20 種不同的低層模組了。現在讓我們想想：如果今天我們想要在 Blade 類別裡面新增幾種不同的攻擊方式、如果我們要在 Bow 類別新增一個「根據不同等級的箭矢有著不同的攻擊力」的小小功能、如果我們今天想要為各種防具進行不同屬性強化、如果我們今天想要讓法杖擁有不同屬性的攻擊方式、如果、如果、如果 \u0026hellip;\n很明顯地，這種「把所有具體的類別全部都塞在一個高層模組」的程式實現方式非常的可怕，對吧？因為高層模組（Character）對低層模組（所有東西）有著重度的依賴，因此只要任何一個模組發生了改變、細節上出了點變化、需要做點增刪查，那麼都有可能會影響到整個 Character 的程式內容。因此，在這樣的情況下，就很適合利用「依賴反轉原則」來對程式進行改寫：\n依賴反轉原則的做法主要有 3 步：\n首先是「建立一個介面、或一個抽象類別。」在實際的程式專案中，抽象類別或者是介面是一個鮮少會去做更動的程式部件。通常只有在專案需要大改，或者是程式架構需要重新調整的時候，才會進行一些編輯跟撰寫。這個樣的特性，很適合拿來放在這種「可以的話，勁量不要去做更動」的地方上面。因此我們首先要做的，就是要為這些角色所能擁有的所有東西，進行一個抽象類（或介面）的宣告：\n// 定義了名為 [武器][防具] 和 [道具] 的抽象類別 abstract class Weapon { public abstract void attack(); } abstract class Armor { public abstract void wear(); public abstract void takeOff(); } abstract class Item { public abstract void use(); } 接下來，我們要讓「低層模組」去依賴「抽象」。白話文來說，就是要讓這些裝備去繼承這些抽象類別，讓它們變得不再零散、不再紊亂，可以有一個大致上的秩序或分類，以便於其他類別（或介面）想要調用它們的時候，可以有一個整齊的、統一的收發通道，而不再是讓這些低層模組各自爲政，每個人有不同的方法、不同的名稱、不同的特性、不同的前置條件、或不同的後續效果 \u0026hellip;\n// 讓所有的 [低層模組] 去依賴剛剛生成的 [抽象] // Weapon 類型 class Blade extends Weapon {}; class Sword extends Weapon {}; class Bow extends Weapon {}; class Staff extends Weapon {}; class Axe extends Weapon {}; class Dagger extends Weapon {}; class Shield extends Weapon {}; // Armor 類型 class Helmet extends Armor {}; class Breastplate extends Armor {}; class ElbowGuard extends Armor {}; class KneeGuard extends Armor {}; class Footwear extends Armor {}; // Item 類型 class HealthPotion extends Item {}; class ManaPotion extends Item {}; class AttackPotion extends Item {}; class DefensePotion extends Item {}; class Bread extends Item {}; class Water extends Item {}; class Chicken extends Item {}; class Beef extends Item {}; class Pork extends Item {}; 當然啦，上面的例子並不完全，因為這些依賴的抽象之後的低層模組並沒有實際去覆寫原本抽象類別中的抽象方法（attack(), wear, takeOff, 和 use），但因為這邊只是一個小小的展示，沒有要實際上把程式給跑起來，所以就先省略掉這個步驟了。實際上各種不同的低層模組在依賴這些抽象類別或介面的時候，還是需要進行方法上面的改寫跟實作的，還是要稍微注意一下。\n最後，在做完前兩部之後，我們再來要做的，就是把高層模組所依賴的對象，從「特定的 xx 低層模組」切換成「抽象類別（或介面）」。透過依賴一個低層模組統一都有依賴到的抽象，我們可以很輕鬆且很有效率地改善原本高層模組中的重度依賴：現在 Character 只需要有三個不同的成員變數，就可以持有之前所涵蓋到的 20-30 種不同的具體類別了，程式的改善效率以指數的量級做提升：\n// 角色類別 class Character { // 角色所擁有的所有屬性（照舊） private Integer hp; private Integer mp; private Integer atk; private Integer def; // 現在不需要依賴各式各樣的具體類別來達成原本的功能 // 只要依賴一個統一的抽象類別就可以了 Weapon weapon; Armor[] armors; Item[] package; // 其他 [角色] 所擁有的方法 ... // 其他 [角色] 所擁有的方法 ... } 除了程式行數的大幅減低之外，這樣做還有另外一個好處：因為無論是 Weapon, Aromr 還是 Item，因為在這些抽象類別中，我們有定義一個統一的調用方法（像是 attack(), wear() \u0026hellip;等），所以我們可以很簡單地透過類似於 weapon.attack() 的程式寫法，來打成一個「攻擊」的功能，哪怕是任何的武器，哪怕不同的武器有著自己的攻擊方法，都可以用很簡潔且很容易閱讀的方式完成我們想要的功能。\n// 假設不同的 [低層模組] 因為各自的差異而有不同的方法名稱 // 但因為它們都有一個統一依賴的 [抽象類別] // 因此無論原本的攻擊叫什麼名字，它們還是要實作出統一的抽象方法 // 以部分 Weapon 類型舉例 class Blade extends Weapon { public void stab() { System.out.println(\u0026#34;用刀前刺\u0026#34;); } public void slash() { System.out.println(\u0026#34;用刀揮砍\u0026#34;); } public void chop() { System.out.println(\u0026#34;用刀劈斬\u0026#34;); } // 繼承自 Weapon 的 attack() 方法 @Override public void attak() { // 用一些判斷邏輯，決定要進行哪一種攻擊 } }; class Sword extends Weapon { // 繼承自 Weapon 的 attack() 方法 @Override public void attak() { // 單純攻擊 System.out.println(\u0026#34;利用手上的劍進行攻擊\u0026#34;); } } // 其他各種 [武器][防具] 和 [道具] 的程式細節 ... // 其他各種 [武器][防具] 和 [道具] 的程式細節 ... // 其他各種 [武器][防具] 和 [道具] 的程式細節 ... class Character { // 一些原本就有的成員變數 .. // 一些原本就有的成員變數 .. // 現在 [角色] 只需要進行 \u0026#39;攻擊\u0026#39; 方法 // 不需要知道武器實際的攻擊方法為何 // 反正只要透過 weapon 然後呼叫 attack()就行 public void attack() { weapon.attack(); } // 一些其他的 [角色] 方法 ... // 一些其他的 [角色] 方法 ... } 透過將依賴反轉過來（原本：高 \u0026gt; 低）（現在：高, 低 \u0026gt; 抽象），讓高層模組和低層模組都去依賴一個幾乎不會變動、且擁有多元方法的抽象類別（或介面），就可以讓程式變得更加靈活、更加簡潔。如果高層模組需要抽換其他的低層模組的時候，也只需要寫上類似 public void setWeapon(Weapon weapon) 之類的方法，就可以輕易地替換掉了。這就是依賴反轉原則所想要傳達的理念、與它所帶來的好處。\n"},{"id":28,"href":"/docs/computer_science/cryptography/caesar_chipher/","title":"凱薩加密法","section":"密碼學","content":"\r凱薩加密法（Caesar Chipher）\r#\rChatGPT 的說明 在密碼學中，凱撒加密法（Caesar Chipher）也被稱為凱撒密碼、移位密碼、凱撒編碼、或凱撒位移 \u0026hellip;等，是最簡單且最廣為人知的古典加密技術之一。它是一種替換式密碼（Substitution cipher），其中明文中的每個字母會被替換為字母表中某個固定數量的位置下的字母。例如：透過左移 3 個位置，字母 D 將被替換為 A，字母 E 將變為 B \u0026hellip;依此類推。這個方法以 Julius Caesar 的名字命名，具史料紀載：他曾在私人的信件來往中，使用了這種訊息的隱藏方法。\n凱撒密碼的加密步驟通常作為更複雜方案的一部分（例如維吉尼亞密碼就有採用類似的加解密概念），並且在 ROT13 仍然有相關的現代應用。但凱撒密碼與所有單字母替換式的加解密方法一樣，在現代的社會中非常容易被破解，基本上提供不了現今強度的資訊安全保障功能。\n加密 / 解密方式 作為一種替換式密碼，凱薩加密法的加密解密方式非常簡單，首先我們會設定一個偏移量 \\(k\\)\r（通常會介於 1~25 之間），然後對每個明文中的英文字母進行偏移量的計算：假設我們設定個偏移量 \\(k = 4\\)\r，且需要進行加密的明文為 apple，則凱薩加密首先會計算英文字母 a 在偏移 4 個字母之後，會變成什麼英文字母（在這個情況下，a 會變成 e），再以這個偏移過後的字母作為最終密文，因此當 \\(k = 4\\)\r時，apple 就會變成 ettpi。\n解密方式也很簡單，就是將偏移的方向倒過來：假設我們今天得到一串密文 bhoorz，且得知偏移量 \\(k\\)\r為 3，根據凱薩加密的原理，如果我們想要將密文還原回去，就只需要將字母逐個往位移 3 個字元即可，因此 b 會變成 y (b -\u0026gt; a -\u0026gt; z -\u0026gt; y)、h 會變為 e、o 會變回 l、r 會變回 o、z 會變回 w。我們就可以知道原來的明文是 yellow。\n程式表示 import java.util.Scanner; public class CaesarCipher { public String encrypt(String plaintext, int shift) { StringBuilder ciphertext = new StringBuilder(); for (int i = 0; i \u0026lt; plaintext.length(); i++) { char ch = plaintext.charAt(i); if (Character.isLetter(ch)) { char encryptedChar = (char) (((ch - \u0026#39;a\u0026#39; + shift) % 26) + \u0026#39;a\u0026#39;); ciphertext.append(encryptedChar); } else { ciphertext.append(ch); } } return ciphertext.toString(); } public String decrypt(String ciphertext, int shift) { StringBuilder plaintext = new StringBuilder(); for (int i = 0; i \u0026lt; ciphertext.length(); i++) { char ch = ciphertext.charAt(i); if (Character.isLetter(ch)) { char decryptedChar = (char) (((ch - \u0026#39;a\u0026#39; - shift + 26) % 26) + \u0026#39;a\u0026#39;); plaintext.append(decryptedChar); } else { plaintext.append(ch); } } return plaintext.toString(); } public static void main(String[] args) { CaesarCipher caesarCipher = new CaesarCipher(); Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;Enter the value of shift (k): \u0026#34;); int shift = scanner.nextInt(); scanner.nextLine(); System.out.print(\u0026#34;Enter the plaintext: \u0026#34;); String plaintext = scanner.nextLine(); String ciphertext = caesarCipher.encrypt(plaintext.toLowerCase(), shift); System.out.println(\u0026#34;Encrypted text: \u0026#34; + ciphertext); String decryptedText = caesarCipher.decrypt(ciphertext, shift); System.out.println(\u0026#34;Decrypted text: \u0026#34; + decryptedText); scanner.close(); } } "},{"id":29,"href":"/_trash/design_pattern/builder_pattern/","title":"創建者模式","section":"_Trashes","content":"\r創建者模式\r#\rChatGPT 的說明 創建者模式（Builder Pattern）是一種創建型設計模式，旨在透過將複雜物件的建置流程拆分為多個簡單物件的建置步驟，使得物件的建置流程更加靈活、可維護，同時提供更好的控制和自訂選項。創建者模式的主要想法是將一個複雜物件的建構與其表示分開。這使得客戶端程式碼可以更容易地配置和建立複雜對象，而無需了解對象的內部建置細節。創建者模式通常包括以下關鍵角色：［產品］（Product）：產品表示被建構的複雜物件。產品類別通常包含多個屬性或部分，這些部分的創建和組裝由創建者負責。［抽象創建者］（Abstract Builder）：抽象創建者定義了建構產品物件的抽象接口，包括各個部分的創建方法。抽象創建者通常包括一個獲取最終產品的方法。［具體創建者］（Concrete Builder）：具體創建者實現了「抽象創建者」的接口，負責構建產品的各個部分，同時提供了設置產品屬性的方法。每個特定創建者可以建立不同的產品變體。［指揮者］（Director）：指揮者負責依照客戶端的需求，按照一定順序呼叫特定創建者的方法來建構產品物件。指揮者不負責特定產品的創建，而是協調創建者完成建造。［客戶端］（Client）：客戶端程式碼透過指揮者來建立複雜對象，並可以根據需要選擇不同的特定創建者，來建構不同的產品變體。\n創建者模式的主要優點包括：分離建造過程和表示，允許更容易建造不同的產品變體；提供了更好的控制和客製化選項，客戶端可以自訂產品的建置流程；支援逐步建構複雜對象，使得建置過程更加靈活；提高了程式碼的可維護性，將複雜建置過程封裝在特定創建者中，使得客戶端不需要知道具體的創建細節；創建者模式在需要建立具有多個配置選項或參數的複雜物件時非常有用，例如建立圖形使用者介面中的視窗、建立文件物件、建立複雜的資料結構等情況。它幫助管理和組織複雜物件的建置過程，使程式碼更具可讀性和可維護性。\n簡單整理 問題描述：複雜物件往往由許多不同的必選/可選物件組成，使得建立起來非常複雜\n解決方案：封裝一系列的變數和設置，令創建複雜物件不再麻煩\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 所謂的複雜物件，在這邊指的是需要經由各個小物件進行合成（或聚合）之後，才可以被生成的物件。用現實生活來舉例的話，就像是一輛汽車（需要引擎、車輪、車殼、排氣管、油箱 \u0026hellip;等部件組成）一棟房子（需要大門、牆壁、屋頂、水電、床鋪、書櫃 \u0026hellip;等物件組成）或者是一台電腦（需要鍵盤、滑鼠、螢幕、主機板、CPU、記憶體、硬碟 \u0026hellip;等元件組成）。就拿電腦來舉例好了：假設我們在程式中需要模擬一台電腦被創建的過程，大概會像是下面的這個樣子：\nclass Main { public static void main(String args[]) { // 組成電腦的小物件們 MotherBoard motherBoard = new MotherBoard(); CPU cpu = new CPU(); Memory memory = new Memory(); Disk disk = new Disk(); Power power = new Power(); ComputerTower computerTower = new ComputerTower(motherBoard, cpu, memory, disk, power); Keyboard keyboard = new Keyboard(); Mouse mouse = new Mouse(); Monitor monitor = new Monitor(); // [電腦] 本身 Computer computer = new Computer(computerTower, keyboard, mouse, monitor); } } 接著我們繼續往下想：是全世界所有的電腦都不多不少，由這幾種元件所組成嗎？如果我今天只需要一台架站的伺服器電腦，那我是不是只需要主機就好？如果我今天是一個辦公室的文書機，我應該還要再加上一個印表機的連線吧？如果我今天是給阿公阿嬤用的電腦，他們會不會用到光碟機之類的元件？如果我今天是一個電競選手，是不是還需要 GPU 和幾個固態硬碟？如果我今天是一個實況主，那麼裝一個攝影機用來捕捉畫面應該很重要吧？如果\u0026hellip; 如果\u0026hellip; 如果\u0026hellip;。假設我們要把所有可能的狀況全部都定義出來的話，那麼 Computer 的程式很有可能會長得像是下面這個樣子：\nclass Computer { public Computer(ComputerTower computerTower) {}; public Computer(ComputerTower computerTower, Monitor monitor) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard) {}; public Computer(ComputerTower computerTower, Monitor monitor, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, GPU gpu) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, Printer printer) {}; public Computer(ComputerTower computerTower, Monitor monitor1, Monitor monitor2, Keyboard keyboard, Mouse mouse) {}; // 其他 100 種建構子 ... } 發現問題了嗎？我們根本定義不完所有可能的情況組合，對吧。這種「建構子過多」的情況在英文裡叫做 Telescoping constructor，中文可以譯成「伸縮式建構子」，是一個光聽名字感覺還好，但實際上非常令人頭疼的一種程式寫法。為什麼說它令人頭疼呢？主要有以下幾個原因：首先是［可讀性很差］，我們很難快速地看出創建出 Computer 的是哪一個建構子；其次是［低彈性］，因為我們必須要按照固定的參數順序填入，很難做比較動態的調整；再來是［null 的狀況］，因為不是所有的元件都需要被安裝到電腦上，因此在建構 Computer 的過程中，應該要允許部分參數可為 null 值，但這樣可能會導致建構子中有過多 null 的情況，更惡化可讀性的問題。因此，為了解決 Telescoping constructor 所帶來的問題，其中的一種方法是「把所有的參數都修改為可以透過 setter 設定」，就像是下面這樣：\nclass Computer { // 電腦的不同元件們 private ComputerTower computerTower; private Monitor monitor; private Keyboard keyboard; private Mouse mouse; private Printer printer; private GPU gpu; private Speaker speaker; private Webcam webcam; private Microphone microphone; // 現在不再需要那麼多的建構子了，只需要這個 public Computer() {}; // 所有元件的 setter() 方法 public void setComputerTower(ComputerTower computerTower) { this.computerTower = computerTower; } public void setMonitor(Monitor monitor) { this.monitor = monitor; } public void setKeyboard(Keyboard keyboard) { this.keyboard = keyboard; } public void setMouse(Mouse mouse) { this.mouse = mouse; } public void setPrinter(Printer printer) { this.printer = printer; } // 其他 setter() ... // 其他 setter() ... } class Main { public static void main(String ags[]) { // 創建一個 \u0026#34;空電腦\u0026#34; Computer computer = new Computer(); // 自己加想加的元件上去 computer.setComputerTower(new ComputerTower()); computer.setMonitor(new Monitor()); computer.setKeyboard(new Keyboard()); computer.setMouse(new Mouse()); } } 看上去挺不錯的，對吧？至少我們現在不用再先寫出 20-30 個不同的 Computer 的建構子。但這麼做還是有一點點小問題：我們沒有辦法保證所有使用到 Computer 的類別，都有把所有必要的元件給加上去。如果今天有一支程式在創建 Computer 的時候，忘記把主機板（MotherBoard）給加上去，程式就無法順利運行了，對吧？畢竟這世界上的所有電腦，都需要使用到主機板。因此，我們需要更「系統性地」解決 \u0026ldquo;創建物件\u0026rdquo; 的問題，就可以使用到創建者模式了：\n在物件導向程式設計中，伸縮式建構子（英文叫做 Telescoping constructor）是一種用來說明「提供多種不同參數組合的建構子，以利於物件生成」的詞彙。一般來說，伸縮式建構子只會在複雜物件的類別中出現，而所謂的複雜物件，指的則是經由不同子部件所組成的大型物件，用比較貼近生活的例子來說的話，複雜物件就像是一台汽車（由引擎、輪胎、車殼、窗戶、排氣管、方向盤 \u0026hellip;等物件組成）一棟房子（由牆壁、大門、窗戶、屋頂、床、書桌 \u0026hellip;等物件組成）或者是一台電腦（由鍵盤、滑鼠、螢幕、主機板、CPU、硬碟 \u0026hellip;等物件組成）之類的東西。\n"},{"id":30,"href":"/docs/computer_science/design_pattern/builder_pattern/","title":"創建者模式","section":"設計模式","content":"\r創建者模式\r#\rChatGPT 的說明 創建者模式（Builder Pattern）是一種創建型設計模式，旨在透過將複雜物件的建置流程拆分為多個簡單物件的建置步驟，使得物件的建置流程更加靈活、可維護，同時提供更好的控制和自訂選項。創建者模式的主要想法是將一個複雜物件的建構與其表示分開。這使得客戶端程式碼可以更容易地配置和建立複雜對象，而無需了解對象的內部建置細節。創建者模式通常包括以下關鍵角色：［產品］（Product）：產品表示被建構的複雜物件。產品類別通常包含多個屬性或部分，這些部分的創建和組裝由創建者負責。［抽象創建者］（Abstract Builder）：抽象創建者定義了建構產品物件的抽象接口，包括各個部分的創建方法。抽象創建者通常包括一個獲取最終產品的方法。［具體創建者］（Concrete Builder）：具體創建者實現了「抽象創建者」的接口，負責構建產品的各個部分，同時提供了設置產品屬性的方法。每個特定創建者可以建立不同的產品變體。［指揮者］（Director）：指揮者負責依照客戶端的需求，按照一定順序呼叫特定創建者的方法來建構產品物件。指揮者不負責特定產品的創建，而是協調創建者完成建造。［客戶端］（Client）：客戶端程式碼透過指揮者來建立複雜對象，並可以根據需要選擇不同的特定創建者，來建構不同的產品變體。\n創建者模式的主要優點包括：分離建造過程和表示，允許更容易建造不同的產品變體；提供了更好的控制和客製化選項，客戶端可以自訂產品的建置流程；支援逐步建構複雜對象，使得建置過程更加靈活；提高了程式碼的可維護性，將複雜建置過程封裝在特定創建者中，使得客戶端不需要知道具體的創建細節；創建者模式在需要建立具有多個配置選項或參數的複雜物件時非常有用，例如建立圖形使用者介面中的視窗、建立文件物件、建立複雜的資料結構等情況。它幫助管理和組織複雜物件的建置過程，使程式碼更具可讀性和可維護性。\n簡單整理 問題描述：複雜物件往往由許多不同的必選/可選物件組成，使得建立起來非常複雜\n解決方案：封裝一系列的變數和設置，令創建複雜物件不再麻煩\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在物件導向程式設計中，伸縮式建構子（英文叫做 Telescoping constructor）是一種用來說明「提供多種不同參數組合的建構子，以利於物件生成」的詞彙。一般來說，伸縮式建構子只會在複雜物件的類別中出現，而所謂的複雜物件，指的則是經由不同子部件所組成的大型物件，用比較貼近生活的例子來說的話，複雜物件就像是一台汽車（由引擎、輪胎、車殼、窗戶、排氣管、方向盤 \u0026hellip;等物件組成）一棟房子（由牆壁、大門、窗戶、屋頂、床、書桌 \u0026hellip;等物件組成）或者是一台電腦（由鍵盤、滑鼠、螢幕、主機板、CPU、硬碟 \u0026hellip;等物件組成）之類的東西。用程式的方式呈現大概會像這個樣子：\nclass Main { public static void main(String args[]) { // 組成電腦的小物件們 MotherBoard motherBoard = new MotherBoard(); CPU cpu = new CPU(); Memory memory = new Memory(); Disk disk = new Disk(); Power power = new Power(); ComputerTower computerTower = new ComputerTower(motherBoard, cpu, memory, disk, power); Monitor monitor = new Monitor(); Keyboard keyboard = new Keyboard(); Mouse mouse = new Mouse(); // [電腦] 本身 Computer computer = new Computer(computerTower, monitor, keyboard, mouse); } } class Computer { public Computer(ComputerTower computerTower) {}; public Computer(ComputerTower computerTower, Monitor monitor) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard) {}; public Computer(ComputerTower computerTower, Monitor monitor, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, GPU gpu) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, Printer printer) {}; public Computer(ComputerTower computerTower, Monitor monitor1, Monitor monitor2, Keyboard keyboard, Mouse mouse) {}; // 其他的建構子和方法 ... } 但 Telescoping constructor 就像是其他的設計模式一樣，並不是一個在任何情況下都很適合使用的程式撰寫技巧，至少從上面的這個例子來說，我們可以單純從 Computer 的建構子們觀察到幾個比較明顯的問題：首先是［程式的維護成本］，因為 Computer 類別存在著多個不同的建構子，當有程式想要實作 Computer 物件的時候，我們很難第一眼就看出程式使用的是哪一個建構子，這會使得程式的維護成本變得很高。其次是［程式的彈性很低］，因為建構子侷限了 Computer 物件需要怎麼樣被生成，子物件需要按照一定的數量與順序被放進建構子中，這會使得程式整體的彈性變低，且各類別對於 Computer 中子物件的依賴程度也會變高。\n但無論是「建構子的數量過多」，還是「生成複雜物件需要依賴一定數量的子部件」，都可以透過一種方式來解決：那就是 \u0026ldquo;讓建構子中的參數允許 null 的存在\u0026rdquo;。透過允許 null 的存在，可以建構子們通通歸納在一起，變成一個「包含了所有部件的建構子」。並透過 null 的方式，彈性地選擇不同類型的要用哪一些電腦中的子部件來生成 Computer 這個複雜物件，就像是下面的這個樣子：\nclass Computer { // 一個包含了所有電腦可以配置的物件的建構子 public Computer(ComputerTower computerTower, Monitor monitor1, Monitor monitor2, Keyboard keyboard, Mouse mouse, GPU gpu, Earphone earphone, Speaker speaker, Webcam webcam, Touchpad touchpad, Scanner scanner, Printer printer) { this.computerTower = computerTower; this.monitor1 = monitor1; this.monitor2 = monitor2; this.keyboard = keyboard; this.mouse = mouse; this.gpu = gpu; this.earphone = earphone; this.speaker = speaker; this.webcam = webcam; this.touchpad = touchpad; this.scanner = scanner; this.printer = printer; }; } // 某間公司的 [伺服器主機] 類別 class Server { // 生成一台電腦，並將該電腦當成伺服器主機 public Computer getServer() { // 假設這台伺服器只需要主機、GPU、跟印表機 ComputerTower computerTower = new new ComputerTower(); GPU gpu = new Gpu(); Printer printer = new Printer(); // 把電腦做出來 Computer computer = new Computer(computerTower, null, null, null, null, gpu, null, null, null, null, null, printer); return computer; } } 原本的問題得到了解決，但新的問題也應運而生：那就是［可讀性變差］。雖然在建構子裡面包含 null 並不是一件少見的事情，但在一個建構子裡面，有絕大多數的參數都是 null 就真的很少見了。這種程式在第一眼很容易會讓人有「阿放了那麼多 null，為什麼不乾脆再拉一個建構子出來啊？」的感覺（然後程式就會重新跳回上面的問題）。除此之外，一個更令人感到頭疼的問題是：如果我今天想要加一個子部件進去，我有辦法很快地知道哪個部件要放在哪裡嗎？或者說得簡單一點：你可以很快地告訴我建構子裡面， GPU 之後第 2 個 null 原本放的是什麼東西嗎？\n因此，為了解決「建構子的數量繁雜」「建構子會讓程式的彈性降低」與「建構子有太多 null」這三個交織在一起的問題，Builder pattern（創建者模式）的程式寫法就被發明出來了。它有點像是吸收了兩邊的優點所創造出來的模式：透過 Builder 生成複雜物件中的子部件，透過 Director 管理和執行需要生成的物件，使用者（Client）就只需要呼叫 Director 中的 getResult() 方法，就可以無痛得到預期中的複雜物件，就像是下面這樣：\n// 複雜物件 Computer 類別 class Computer { // 所有的子部件們 private ComputerTower computerTower; private Monitor monitor; private Keyboard keyboard; private Mouse mouse; private GPU gpu; private Earphone earphone; private Speaker speaker; private Webcam webcam; private Touchpad touchpad; private Scanner scanner; private Printer printer; // 現在 Computer 只有一個建構子，而且沒有任何內容 public Computer() {}; } // Builder 類別，用來創建各種不同的子部件 class ComputerComponentsBuilder { // 要生成的目標物件 private Computer computer; // Builder 的建構子，用以生成一台全新的電腦 public ComputerComponentsBuilder() { this.computer = new Computer(); } // Computer 中，所有部件的設定方法 // Computer 中，所有部件的設定方法 public void buildComputerTower() { this.computer.computerTower = new ComputerTower(); } public void buildMonitor() { this.computer.monitor = new ComputerTower(); } public void buildKeyboard() { this.computer.keyboard = new Keyboard(); } public void buildMouse() { this.computer.mouse = new Mouse(); } public void buildGPU() { this.computer.gpu = new GPU(); } public void buildEarphone() { this.computer.earphone = new Earphone(); } public void buildSpeaker() { this.computer.speaker = new Speaker(); } public void buildWebcam() { this.computer.webcam = new Webcam(); } public void buildTouchpad() { this.computer.touchpad = new Touchpad(); } public void buildScanner() { this.computer.scanner = new Scanner(); } public void buildPrinter() { this.computer.printer = new Printer(); } // 用來回傳最後結果的 getResult() 方法 public Computer getResult() { return this.computer; } } // Director 類別，用來控管 Computer 的建立、配置、和回傳 class ComputerDirector { public Computer getResult() { // Builder 物件 ComputerComponentsBuilder builder = new ComputerComponentsBuilder(); // 這邊同樣以「主機 + GPU + 印表機」的伺服器為例子 builder.buildComputerTower(); builder.buildGPU(); builder.buildPrinter(); // 回傳最後生成的結果 Computer computer = builder.getResult(); return computer; } } class Client { public static void main(String args[]) { ComputerDirector director = new ComputerDirector(); Computer computer = director.getResult(); } } 為了方便理解上面的程式架構，我們同樣用生活中的例子來做說明：Director 因為是負責管理和調度複雜物件 Computer 的建立過程，因此我們可以把它想像成類似 \u0026ldquo;原價屋\u0026rdquo; 的角色；而 Builder 因為是負責提供各式各樣不同實體子部件的角色，所以它類似於 \u0026ldquo;硬體供應商\u0026rdquo;，而 Client 不用多說，就是我們這些買電腦的客戶了。綜上所述：一個 Computer 的生產過程就可以被我們解剖成以下的描述：「當我們（Client）需要一台電腦的時候，我們會去找原價屋（Director），並跟他們說『我們需要一台電腦（getResult()）』，而原價屋在收到我們的需求之後，會去找硬體供應商（Builder），並從供應商那邊取得需要的電腦零件（build()），最後再把電腦給我們（return）」。而這，就是模式的運行邏輯。\n此外，在實際的案例中，因為『原價屋』可以跟很多不同的『硬體供應商』進行零件的調度，所以 Director 類別更像是一個 \u0026hellip;工廠？Direct 可以透過 Client 的不同需求（像是我要 ASUS 或 Acer 的電腦？我要筆電、文書機、還是電競電腦？）去調用不同的電腦創建邏輯、選擇不同的 Builder 進行子部件的創建 \u0026hellip;等。就像是下面這個樣子：\n// Director 類別，用來控管 Computer 的建立、配置、和回傳 class ComputerDirector { public Computer getResult(String brand, String level) { // Builder 物件 ComputerComponentsBuilder builder; // 選擇不同的『硬體供應商』 if(brand.equals(\u0026#34;ASUS\u0026#34;)) builder = new AsusComputerBuilder(); else if(brand.equals(\u0026#34;Acer\u0026#34;)) builder = new AcerComputerBuilder(); else throw new BrandNotExistException(); // 用來回傳的 Computer 物件 Computer computer; // 不同的 \u0026#34;電腦\u0026#34; if(level.equals(\u0026#34;notebook\u0026#34;)) computer = this.getNotebook(builder); else if(level.equals(\u0026#34;Low-End Computer\u0026#34;)) computer = this.getLowEndComputer(builder); else if(level.equals(\u0026#34;High-End Computer\u0026#34;)) computer = this.getHighEndComputer(builder); else throw new LevelNotExistException(); return computer; } // 其他不同的方法，像是配置不同等級的電腦 ... // 其他不同的方法，像是配置不同等級的電腦 ... } "},{"id":31,"href":"/_trash/creation/novel/note/45_master_characters/archetypes/","title":"原型是什麼？為什麼要用原型？如何使用原型？","section":"45 個人格原型：從神話模型到心理分析，幫助你了解人性，並打造獨一無二的角色與故事","content":"\r創作的原型\r#\r原型是什麼\r#\r對於創作者來說，原型是藍圖，是用來建構/刻畫人物的原則 原型用來濃縮角色的本質，原型包含角色的動機、恐懼、掛心的事物 \u0026hellip;等 原型不是「刻板印象」 刻板印象是對角色過度簡化的歸納 用原型來擴張對角色的想像\r#\r臉龐：圓潤/瘦長，過往/年齡/職業，眼神 皮膚：淺色/深色，滑順/粗糙，明顯的疤痕或胎記？ 頭髮：長髮/短髮/捲髮，髮型的原因？ 年齡：什麼年紀最適合傳達這個角色的內在掙扎？ 體型：豐腴/結實 風格：時髦/落伍 印象：別人喜歡他嗎？為什麼？ 釐清角色原型的基本人格元素\r#\r角色的性格是內向還是外向 角色的行為通常憑藉直覺還是依照邏輯 角色是否有想要改變世界的願景 角色的出身、環境、臥室的描述與外觀 角色喜歡自己嗎？為什麼？ 角色對於他人（六親）有什麼感覺和看法 角色的興趣、嗜好，專長 角色對周遭的一切有控制的慾望嗎 其他人對於這個角色有什麼想法 角色認真的看待生活嗎？他會怎麼度過自己的閒暇時光 如何使用原型\r#\r角色關心著什麼？ 如果他被困在荒島上，他會希望手邊有哪 3 樣東西 如果他的房子被一場無情的大火給燃燒殆盡，他會最想念什麼東西 他在乎什麼？在意什麼？物品？評價？抑或是生活方式？ 角色會害怕什麼？ 為他帶來噩夢的是什麼？ 在深夜裡聽到槍響，他會有什麼反應？ 他會覺得是什麼造成這個聲響？ 他（在兒時）遭遇過什麼樣的經歷，導致他有這種恐懼？ 角色的動力是什麼？ 為了單純地活下去 為了安全與保障 為了愛/一個歸屬感 為了讓他人（或自己）看得起自己 為了了解他人 為了一些無法用邏輯（理性）說明的事情 為了實現心中的目標 原型的練習\r#\r挑出 3 個原型，並試著寫出這 3 個原型如何影響故事發展 花 2 頁的篇幅來盡可能描述這個角色 嘗試與角色對話，從角色的視角與自己對話 "},{"id":32,"href":"/docs/computer_science/design_pattern/prototype_pattern/","title":"原型模式","section":"設計模式","content":"\r原型模式\r#\rChatGPT 的說明 原型模式（Prototype pattern）是一種創建型設計模式，其主要目的是『透過不使用建構子的方式，創建類別中的新物件。』此模式的核心思想是基於已有對象的克隆（拷貝）來產生新的對象，這個已有對象稱為原型，而克隆的方式有淺克隆（Shallow clone）和深克隆（Deep clone）兩種。原型模式有以下關鍵特點和優點：［透過 clone 創建物件］：原型模式允許程式在運行的時後創建新的物件，而無需知道特定物件的構造細節。這是透過複製現有物件的屬性和狀態來實現的。［減少構造成本］：在某些情況下，物件的構造可能非常昂貴（像是需要花費大量資源、消耗大量時間 \u0026hellip;等），透過原型模式，可以複製已有物件，來避免重複執行構造操作，從而提高效能和效率。［支援多樣化的物件］：原型模式允許建立多個不同屬性的物件，而無需重新實作整個物件的建構邏輯，這對於物件的變種非常有用。［簡化物件的創建］：原型模式簡化了物件的創建過程，尤其是在物件具有複雜結構或大量屬性時。可以使客戶端只需要呼叫模式中的 clone 方法，便可以實踐物件的創立。\n而在原型模式中，克隆（或拷貝）物件的方式總共分成兩種：［淺克隆］（Shallow clone）：淺克隆會在方法內建立一個新原型的物件，但該新物件的內部成員變數仍然與原始的原型物件共用同樣的子物件。這意味著，雖然新物件本身是與原物件獨立的，但在新物件內部仍然引用了原始物件中的某些子物件。如果對我們對任一物件的共享去性進行修改，這些修改將在兩個物件中都可見，因為它們引用同一份資料。淺克隆通常是較快且較節省記憶體的方式，但需要注意在共享子物件上可能出現潛在問題。［深克隆］（Deep Copy）：深拷貝重樣會創建一個新的物件，但與淺克隆不同的是。這種「創建」包括原始的原型物件，以及該物件的所有子物件（以遞回的方式完全複製整個物件結構）。這確保了新物件與原始物件之間完全獨立，對其中一個物件所做的修改不會影響另一個物件。深克隆通常比較安全，因為它避免了共享資料的問題，但可能需要更多時間和記憶體來執行，特別是對於複雜的物件結構。\n簡單整理 問題描述：有時候使用 new 的方式建立物件會影響程式的可讀性、彈性、和可重用性。\n解決方案：可以透過 clone 方法解決對創建物件的細節依賴。\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 "},{"id":33,"href":"/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/","title":"合成/聚合複用原則","section":"設計模式","content":"\r合成/聚合複用原則\r#\rChatGPT 的說明 合成/聚合複用原則（Composition/Aggregation Reuse Principle）通常簡稱為 CARP，是物件導向設計中的一個原則，它與繼承有關，但專注於透過「組合」（也就是『合成』或『聚合』）的方式來實現程式碼的複用，而不是透過「繼承」的方式來複用程式碼。具體來說，CARP 強調了物件之間的關係應該是 \u0026ldquo;鬆耦合\u0026rdquo; 的，以便更容易進行維護和擴展。如果要使程式維持鬆耦合的狀態，比起利用「繼承」關係，更應該多使用「合成」關係或「聚合」關係：［合成］英文為 composition，指的是一個物件包含了另一個物件作為其一部分，從屬物件的生命週期通常受主要物件的生命週期限制。如果一個物件是另一個物件的一部分，並且當主要物件被銷毀時，從屬物件也會被銷毀。另一種關係是［聚合］聚合的英文稱作 aggregation，是指一個物件包含了另一個物件，但從屬物件的生命週期並不受限於主要物件的生命週期。\n與繼承相比，組合關係具有許多優勢，主要是因為它們提供了更靈活、低耦合和可維護的程式碼複用方式。主要的優勢如下：［靈活性］組合關係提供了更大的靈活性。透過使用組合關係的程式撰寫方式，使得程式可以在執行時動態地改變物件之間的關係，而不需要修改類別的結構。這允許系統更容易應對變化和需求的變更，而無需深度更改整個類別層次結構。［鬆耦合］繼承有時會導致緊密的耦合，因為子類別依賴父類別的實作細節，而組合關係則通常擁有 \u0026ldquo;鬆耦合\u0026rdquo; 的關係，因為父類別和子類別之間的依賴性較少。這降低了物件之間的耦合度，使得程式碼更容易理解、維護、和擴展。\n［避免繼承的限制］繼承有時後會引入一些程式上的限制，例如單一繼承限制（一個類別只能繼承一個父類別）和父類別的不穩定性（如果父類別的實作發生變化，所有子類別都會受到影響）。組合關係不受這些限制，使得類別可以輕鬆地組合多個類別的功能。［可維護性］組合關係有助於提高程式碼的可維護性。當需要程式修改或擴充功能時，你只需要專注於特定的類別或元件，而不需要涉及整個繼承層次結構。這簡化了程式碼的維護過程。［測試和調試］使用組合關係的程式編寫方式，通常更容易進行單元測試和調試，因為可以更容易地模擬和隔離組件，而不會受到繼承關係的複雜性的干擾。［程式碼可讀性］組合關係通常會使程式更加簡潔、更加清晰、和更加易於理解，因為它們強調了物件之間的協作關係，而不是混雜在一起的層次結構。\n簡單整理 多用組合、少用繼承\n程式碼範例 組合型程式碼，指的是在建立比較複雜的物件的時候，選擇使用不同類型的小物件相互結合，不使用繼承的方式來小物件一步步變成大物件。而在說明這樣做有什麼好處之前，我們先說明一下什麼樣的組合方式叫做「合成」？什麼樣的組合方式叫做「聚合」？簡單來說：成員變數會跟著主要物件一起死去的就叫做「合成」，而成魚變數可以在主要物件死去之後，還繼續存在的，就叫做「聚合」，就像是下面的這個範例：\n// 關於 \u0026#34;合成\u0026#34; (composition) 的範例 class Hmuan { // 私有變數 姓名 private String name; // 私有變數 人的各種器官（大腦、心臟、胃 ...等） private Brain brain; private Heart heart; private Stomach stomach; // 建構子 public Human(String name) { this.name = name; this.brain = new Brain(); this.heart = new Heart(); this.stomach = new Stomach(); } // 其他 Human 中的方法 ... // 其他 Human 中的方法 ... } // 關於 \u0026#34;聚合\u0026#34; (aggregation) 的範例 class Classroom { // 私有變數 包含班級名稱、老師、和學生們 ... private String className; private Teacher teacher; private List\u0026lt;Student\u0026gt; classmate; // 建構子 public Classroom(String name) { this.name = name; this.classmate = new ArrayList\u0026lt;\u0026gt;(); } // 新增班級導師 public setTeacher(Teacher teacher) { this.teacher = teacher; } // 新增班級學生 public void addStudent(Student student) { classmate.add(student); } // 其他 Classroom 中的方法 ... // 其他 Classroom 中的方法 ... } 在上面的兩個範例中，都是使用組合程式來達成複雜物件的生成。但它們兩個的不同之處在於：對於 Human類別來說，Brain, Heart 或者是 Stomach 都是「Human 在我在，Human 亡我亡」的狀況，這些器官物件的生命週期會跟隨著 Human 的生成一起被建立，也會隨著 Human 的死亡一起被抹去，這種狀況就叫做「合成」（composition）；而對於 Classroom 來說，雖然一個班級有 name, Student, Teacher \u0026hellip;等不同的成員變數，但除了 name 之外，其餘參數的生命週期都不會跟著 Classroom 的消逝而結束。即便一間學校的「班級」不見了，原本指導班級的「老師」也不會因此丟了工作，可以透過程式指派另一個 Classroom 重新工作，這便是「聚合」（aggragation）。\n而在實務情況上，根據系統或專案的規模，我們會遇到許多不同複雜物件的建立需求，這時候如果所有的物件都使用「繼承」的方式來做撰寫的話，很可能會導致程式產生非常嚴重的 \u0026ldquo;依賴\u0026quot;和 \u0026ldquo;冗余\u0026rdquo;。舉個例子來說：假設我們現在需要完成一個「二手車銷售系統」，裡面有一個「展示車型」的類別，裡面需要完整定義不同種類、不同大小、不同顏色的車子，如果我們全部都使用繼承的方式做實現的話，程式很有可能會變成下面這個樣子：\n// 第一層抽象 [車子] abstract class Car { protected String id; public Car(String id) { this.id = id; } } // 第二層抽象 [顏色] // 白色車 abstract class WhiteCar extends Car { private String color; public WhiteCar(String id) { super(id); this.color = \u0026#34;white\u0026#34;; } } // 黑色車 abstract class BlackCar extends Car { private String color; public BlackCar(String id) { super(id); this.color = \u0026#34;black\u0026#34;; } } // 第 3 層，實體車輛 [品牌 + 顏色 + 車] // 白色 Toyota class WhiteToyota extends WhiteCar { private String brand; public WhiteToyota(String id) { super(id, \u0026#34;white\u0026#34;); this.brand = \u0026#34;Toyota\u0026#34;; } } // 白色 Nissan class WhiteNissan extends WhiteCar { private String brand; public WhiteNissan(String id) { super(id, \u0026#34;white\u0026#34;); this.brand = \u0026#34;Nissan\u0026#34;; } } // 黑色 Toyota class BlackToyota extends BlackCar { private String brand; public BlackToyota(String id) { super(id, \u0026#34;black\u0026#34;); this.brand = \u0026#34;Toyota\u0026#34;; } } // 黑色 Nissan class BlackNissan extends BlackCar { private String brand; public BlackNissan(String id) { super(id, \u0026#34;black\u0026#34;); this.brand = \u0026#34;Nissan\u0026#34;; } } 我們可以看到：雖然我們的目標僅僅是生成四種不同種類、不同的車子，但前前後後我們一共生成了 7 個大大小小的類別，不難想像如果我們今天要再多加幾台「銀色的特斯拉」「黃色的計程車」「紅色的法拉利」「深藍色的藍寶堅尼」\u0026hellip;等，甚至再把所有的車子分成 2 人、5 人、7 人座 \u0026hellip;等，都會對程式帶來許多額外的負擔。大概還要再創建個 \u0026hellip; 20-30 個左右的類別，才可以滿足我們的所有需求吧？\n不僅如此，繼承帶來的壞處還有「對於父類別的依賴」，這個因素更是不建議在所有情況都使用繼承來完成程式的原因。我們可以想像一下這種情況：雖然我們要對所有的車子都新增「顯示共有幾個座位」這個功能，但我們不用真的去創建類似 WhiteToyotaWith_5_Seats, WhiteToyotaWith_7_Seats 這樣的類別，我們可以直接在最上面的 Car 裡面新增一個 int seat 就可以了，這樣就可以免去「超多類別」的困擾。\n但這種方式雖然可以避免「超多困擾」，卻無法避免「超多依賴」的情況：假設我們希望車子在一開始就決定好座位的數量，所以我們把建構子從 Car(String id) 修改成 Car(String id, int seats)。這樣一來，使用到 Car 建構子的 WhiteCar 和 BlackCar 就會需要一併修改 super() 的內容，然後繼承了 WhiteCar 和 BlackCar 的實體車輛又要繼續修改它們在建構子裡面的 super 內容 \u0026hellip;。可想而知，超級麻煩。\n因此，在這樣的情境之下，與其使用「繼承」來解決問題，我們更建議可以使用「組合」的方式，來創建一個實體的車輛類別。無論是使用「合成」還是使用「聚合」的方式，相對來說，不管是在程式的撰寫、還是其他的方面，都會比使用「繼承」還要好上許多，就像是下面的這個樣子：\n// 使用『合成』composition 來完成[車子] class Car { private String id; private Integer seats; private Color color; private Brand brand; // 建構子 public Car(String id) { this.id = id; this.seats = new Integer(7); this.color = new Black(); this.brand = new Toyota(); } @Override public String toString() { System.out.println(\u0026#34;Car[id:\u0026#34; + this.id + \u0026#34;, seats:\u0026#34; + this.seat + \u0026#34;, color:\u0026#34; + this.color + \u0026#34;, brand:\u0026#34; + this.brand + \u0026#34;]\u0026#34;); } } // 使用『聚合』aggregation 來完成[車子] class Car { private String id; private Integer seats; private Color color; private Brand brand; // 建構子 public Car(String id, Integer seats, Color color, Brand brand) { this.id = id; this.seats = seats; this.color = color; this.brand = brand; } @Override public String toString() { System.out.println(\u0026#34;Car[id:\u0026#34; + this.id + \u0026#34;, seats:\u0026#34; + this.seat + \u0026#34;, color:\u0026#34; + this.color + \u0026#34;, brand:\u0026#34; + this.brand + \u0026#34;]\u0026#34;); } } 可以發現到：透過使用「組合」的方式，無論是合成還是聚合，我們都可以在維持同樣需求（完成顯示不同車牌、不同座位數、不同顏色、不同品牌的車子）的情況下，達到更精簡的程式碼。而且使用這種方式來構成整個程式的話，它們的可讀性也會相對最一開始的「繼承」還要來得高。這便是合成/聚合複用原則所想要傳達的訊息：在某些情況下，比起使用「繼承」來完成所有的需求，有時候使用「合成」或「聚合」也許能夠達到更好的效果。\n"},{"id":34,"href":"/docs/computer_science/design_pattern/single_responsibility_principle/","title":"單一職責原則","section":"設計模式","content":"\r單一職責原則\r#\rChatGPT 的說明 單一職責原則（Single Responsibility Principle，簡稱 SRP）是物件導向程式設計和軟體設計的基本原則之一，該原則由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則強調一個類別（或一個模組）應該只有一個修改的理由。換句話說，一個類別應該只負責 個主要的功能或職責。SRP 的主要思想是將一個類別的職責限制在一個狹窄的範圍內，以確保類別的內部變化原因不會過多，從而提高程式的可維護性、可擴展性、和可讀性。當一個類別具有多個不同的職責時，它就會變得複雜、變得難以理解，並且容易因多個原因而需要修改，從而降低開發程式的效率。\n以下是 SRP 的主要目標：［每個類別應該都只負責一個主要職責］一個類別的 \u0026ldquo;主要職責\u0026rdquo; 即是它的核心任務，該類別應該專注於執行這份任務，而不需要干預（或處理）其他不關核心任務的事情。［分離不同的職責］如果一個類別的 \u0026ldquo;主要職責\u0026rdquo; 可能包含多項不同面向的 \u0026ldquo;子職責\u0026rdquo;，設計師應該考慮將這些職責分離為不同的類別或模組，以確保每個類別只處理一個不與它類重合的職責。 ［職責的改變，不應影響到其他的職責］在前 2 點成立的情況下，當我們需要修改一個類別的內容時，我們就是在針對「一個」「特定的」功能進行調整，因此在理論上來說，該功能不應與其他功能產生衝突或影響。SRP 有助於保持代碼的可讀性和可維護性，並促使開發人員設計更小、更簡單的類別，從而降低代碼的複雜性。它也是其他設計原則和設計模式的基礎之一，有助於建立高質量的軟體系統。\n簡單整理 簡單來說，SRP 在說的就是「一個類別，只負責一組類似的事情」\n程式碼範例 情境思考：假設我們受某校的教務處所委託，需要製作一個針對學生使用的「簡易學生管理系統」，裡面需要針對「學生」這一項身份完成以下幾個功能：學生資料管理（包含增刪改查學生的各種資料），課程管理（提供學生加退選課程，查看課程細節），成績查詢（包含歷年成績、當學期成績、生成成績單\u0026hellip;等），以及文件下載（包含各式各樣的學校文件，諸如學費繳費單、各式申請書、或者各處室的相關文件\u0026hellip;等）。在最最不推薦的狀況下，我們可以寫出類似於下面的程式碼：\npublic class StudentManagementSystem { public void registerStudent(Student student) { // 修改學生資料 // 記錄學生的最後的更新時間 // 向學生的家長發送通知 // 向學生的導師發送通知 } public void enrollCourse(Student student, int courseId) { // 獲得學生資料 // 查詢學生的所有修課記錄 // 添加新課程 } public Student getGrades(int studentId) { // 查詢學生資料 // 查詢學生的所有修課記錄 // 查詢學生的各式成績 } public void downloadFiles(String fileName) { // 查詢某一份學校文件 // 生成該份文件的 PDF 檔 // 匯出 PDF } // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 } 從程式的邏輯和功能來說，這份程式並沒有太大的問題。所有的功能都可以順利運行，且相關的程式邏輯都很正確。如果把這份程式直接提交給教務處的話，我想他們應該也不會有什麼太大的問題或者是意見才對。但是，雖然一切的一切都很順利，這份程式碼還是有著一點小小的改善空間：也就是它並沒有符合「單一職責原則」所規範的內容：意即「一個類別，只可以由一種『原因』而改變」。\n在這個 StudentManagementSystem 的類別中，我們同時實作了 updateStudent(), addCourse(), getGrades(), downloadFiles() \u0026hellip;等不同學生管理系統中的方法。可想而知，這會是一個非常龐大的類別，也許在這個類別裡，共有上百個不同的成員變數與方法也說不定。那在這樣的情況下，如果我們想要對程式進行一些操作或修改，就會顯得比較麻煩：因為所有的東西，都被放在同一個地方裡。就像是一間堆滿東西的倉庫一樣，剛整理倉庫的時候，或許還可以知道東西的正確位置，但日子久了、時間長了，或者是之後又對倉庫做了一些調整 \u0026hellip;，程式的維護成本就會逐漸提高。\n此外，可能導致 StudentManagementSystem 需要修改的原因也有很多，無論是對「學生」相關資料的編輯、對「成績」的計算方式需要修正、或者是「課程」有一些類別需要做添加或移除，抑或是「文件」的編輯或更改，都是能夠成 \u0026ldquo;影響到 StudentManagementSystem\u0026rdquo; 的原因（因為這個類別需要負責太多東西了），因此，在這樣的情況下，單一職責原則提供我們對這個「倉庫」做改善的方法：我們整理一下整份系統。系統中共有 4 大項不同的功能，分別與「學生」「課程」「成績」和「文件檔案」有關，因此在這裡，我們可以先對所有的方法進行一個分類：也就是「新增這 4 個類別，並將所屬的方法添加到類別裡面」。簡單來說，可以寫成下面的這個樣子：\npublic class StudentManager { // 學生註冊 public void register(Student student) {} // 修改資料 public void modify(Student student) {} // 註銷學生 public void cancel(Student student) {} // 其他和[學生]有關的相關方法 // 其他和[學生]有關的相關方法 } public class CourseManager { // 加選課程 public void enroll(Student student, int courseId) {} // 退選課程 public void drop(Student student, int courseId) {} // 修課列表 public void show(Student student) {} // 其他和[課程]有關的相關方法 // 其他和[課程]有關的相關方法 } public class GradeManager { // 單一課程成績 public void getSingle(Student student, int courseId) {} // 單一學期成績 public void getSemester(Student student, int semesterId) {} // 歷史修課成績 public void getAll(Student student) {} // 其他和[成績]有關的相關方法 // 其他和[成績]有關的相關方法 } public class FileManager { // 下載特定文件 public void download(Student fileName, int courseId) {} // 其他和[文件]有關的相關方法 // 其他和[文件]有關的相關方法 } public class StudentManagementSystem { StudentManager studentManager; GradeManager gradeManager; CourseManager courseManager; FileManager fileManager; // 建構子 public StudentManagementSystem(StudentManager studentManager, GradeManager gradeManager, CourseManager courseManager, FileManager fileManager) { this.studentManager = studentManager; this.gradeManager = gradeManager; this.courseManager = courseManager; this.fileManager = fileManager; } // 學生註冊 public void register(Student student) { studentManager.register(student); } // 加選課程 public void enroll(Student student, int courseId) { courseManager.enroll(student, courseId); } // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 } 透過將所有的功能分離出來，我們就算是「整理」了一次這個倉庫，比起之前的程式，現在的學生管理系統只需要負責監督和調用底下的 Manager 們即可，它的職責現在就只有「管理」。而其他業務呢？「學生」的工作有 StudentManaer 負責，「成績」的工作是 GradeManager 的強項，CourseManager 專注於任何跟「課程」有關的事物，FileManager 則準備好了跟文件有關的工作等著我們去使用。\n一個類別，只處理一種類型的工作。就是 SRP 想要說明的內容。\n"},{"id":35,"href":"/docs/computer_science/design_pattern/singleton_pattern/","title":"單例模式","section":"設計模式","content":"\r單例模式\r#\rChatGPT 的說明 單例模式（Singleton Pattern）是一種創建型設計模式，旨在確保一個類別只有一個實例，並提供一種存取該實例的全域方法。單例模式能確保無論在應用程式中哪個地方，都只會有一個實例化的物件，並且提供了對該物件的全域存取點。單例模式通常包含以下要素：私有建構子（Private Constructor）：單例類別的建構子通常是用 private 關鍵字進行封裝，這樣才可以確保其他類別無法直接實例化該類別的物件。私有靜態成員變數（Private Static Instance）：單例類別的內部會包含一個私有的靜態成員變數，用來儲存唯一的實例化的物件。公共靜態方法（Public Static Method）：單例模式的類別內部，也會包含一個公共的靜態方法，允許其他類別透過該方法取得單例物件。如果類別中的靜態成員變數為 null，那麼這個方法就會負責創建並回傳成員變數，但如果靜態成員變數不為 null，該方法則會直接回傳靜態成員變數的記憶體位址。\n單例模式的主要目標有以下三點：分別是「確保該類別的物件在應用程式中，只有一個物件存在，從而節省系統資源。」「提供一個對成員變數的全域存取點，以便其他類別可以輕鬆存取該物件。」以及「避免多次建立相同類型的對象，以確保對象的一致性和資料共享。」通常來說，單例模式可能會在以下的幾種情境出現：［資源共享］：當多個部分需要共享某個資源（例如資料庫連線、thread pool \u0026hellip;等）時，可以使用單例模式確保只有一個資源實例［全域配置］：當應用程式需要一個全域配置對象，以儲存配置資訊，並在整個應用程式中共用時，可以使用單例模式。［日誌記錄器］：在應用程式中使用單例模式來建立唯一的日誌記錄器，以確保所有日誌資訊都被記錄到同一個日誌檔案中。［快取管理］：單例模式可用於建立快取管理器，以確保快取的一致性和共用。\n簡單整理 問題描述：當某一個類別只需要一個物件的時候，該如何撰寫程式\n解決方案：將建構子私有化，並透過靜態方法和靜態變數進行物件生成\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 單例模式算是所有設的計模式當中，最好理解的一個。該模式的目的很明確：就是要確保「一個類別，只會生成一個物件。」那為什麼要確保一個類別只會生成一個物件呢？大多情況下是需要確保一些資料的一致性，像是在一個「資料庫系統」中，如果我們只有一個資料庫的話，可能就會希望這個「操縱資料庫」的物件是唯一的，不然如果發生一些並行的狀況，系統就會需要進行一些併發狀況的程式邏輯（像是事物隔離的邏輯判斷 \u0026hellip;等），使得整個程式變得更加複雜。\n而實現單例模式的方法有很多，大致上可以歸類成 7 種不同的寫法，分別是：「final static variable」「static block initialization」「simple lazy initialization」「mutual exclusion」「double checked locking」「inner static class」和「enumerated type」。其中前 2 種為 Eager Singleton（中文譯做：餓漢式單例模式），中間 4 種為 Lazy intialization Singleton（中文譯做：懶漢式單例模式）。最後 1 種 \u0026hellip;就是 enum。\n先從第 1 種做法講起：final static variable 顧名思義，就是在類別裡面宣告一個常數的、靜態的成員變數，透過存取類別中唯一且無法被更改的變數，來達到單例模式的程式需求。這種寫法可以保證多執行緒下仍然維持單一物件，但缺點是如果該變數本身是屬於比較複雜的物件的話，初始化可能需要花費比較多的時間，並且如果該變數在初始化之後一直都沒有被使用的話，它就會變得有點佔記憶體空間，寫法如下：\n// 1. final static variable class Singleton { private final static Singleton INSTANCE = new Singleton(); private Singleton() {} public static Singleton getInstance() { return INSTANCE; } } 第 2 種方式是利用 Java 類別內的 static 區域，幫靜態成員變數做初始賦值，大致上跟方法 1 有著一模一樣的功能，差別只在於一個初始化的地方是寫在程式的變數後面，另外一個是寫在類別中的 static 區域。餓漢式單例模式的特點在於「會在系統初始化的最一開始，就為變數進行賦值」，因此無論是方法 1 還是方法 2，都有著 \u0026ldquo;系統初始化可能比較花時間\u0026rdquo; \u0026ldquo;可能很佔空間\u0026rdquo; 以及 \u0026ldquo;確保在多執行緒的環境下也能保持單例\u0026rdquo; 的優缺點。\n// 2. static block initialization class Singleton { private static Singleton instance; private Singleton() {} static { instance = new Singleton(); } public static Singleton getInstance() { return instance; } } 第 3 種單例模式的是 simple lazy initialization，應該算是最最直觀、且最最容易被大家想到的程式撰寫方法：在類別裡面的 getInstance() 裡面寫上一個 instance 的 if 判斷，如果它是 null，就為這個靜態成員變數賦值，而如果它不是 null，就回傳這個 instance。這種寫法是 7 種實現方式裡面最為簡單、最為直觀、但也最為不安全的一種程式寫法：雖然在單執行緒的環境下沒有問題，但它無法保證多執行緒下的物件單一性，因此 『非.常.不.推.薦』使用這種寫法：\n// 3. simple lazy initialization class Singleton { private static Singleton instance; private Singleton() {} public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 第 4 種寫法在視覺上算是第 3 種的改良版：既然第 3 種寫法沒有辦法在多執行緒下保證其物件的單一性，那麼 Java 中有沒有什麼關鍵字可以幫助我們達成這件事情呢？答案是 \u0026hellip;有的～可以用 synchronized 對程式區塊『上鎖』，也就是「在多執行緒的環境下，只要有一個執行緒的程式進到 synchronized 所定義的空間內，就將整個空間鎖住，先讓其它想要進來的執行緒拒於門外。」這種技巧嚴格上來說叫做「互斥鎖」，呈現方式如下：\n// 4. mutual exclusion class Singleton { private static Singleton instance; private Singleton() {} public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 但如果把整個方法都定義為「上鎖的空間」的話，在一定程度上會降低程式運行的效率。因此在第 5 種情況下，我們試著改進第 4 種方法，把上鎖的空間稍微給縮小一點：外層的 if 判斷，可以解決「instance 已經被創建之後，訪問 getInstance() 還是會被上鎖」的情況，中間的 synchronized 則跟剛剛一樣，是用來定義上鎖的空間，內部的 if 判斷用來預防「同時有兩個執行緒通過外層的 if 判斷之後，其中一個執行緒已經生成物件」的情況。聽起來有點奇怪？邏輯上比較像是以下的這種感覺：\n執行緒 A 通過外層 if。執行緒 B 通過外層 if。執行緒 A 進到 synchronized 裡面。（執行緒 B 被擋在外面）。執行緒 A 通過內層 if。執行緒 A 利用建構子將物件賦值。執行緒 A 離開 getInstance()。執行緒 B 進到 synchronized 裡面。內層的 if 判斷沒過！為什麼沒過？因為剛剛 A 已經用建構子把物件賦值了。執行緒 B 直接拿 A 的賦值結果離開 synchronized。執行緒 B 離開 getInstance()。\n這種利用兩層 if 加一個 synchronized 加速單例效率的方法叫做「雙重鎖」。不同於 Java 的互斥鎖，其他語言在實現雙重鎖的時候，程式在「視覺上」算是差不多的。但因為在一些比較底層的程式邏輯上，雙重鎖還是有一點點多執行緒上的安全問題（詳情點我），因此在其他語言上不建議使用這種方式實現單例模式。但在 Java 語言上面，我們只需要在 instance 變數的前面加上一個 volatile 關鍵字就可以預防那個「比較底層的問題」了，因此還是可以使用這種方法：\n// 5. double checked locking class Singleton { private volatile static Singleton instance; private Singleton() {} public static Singleton getInstance() { if(instance == null) { synchronized(Singleton.class) { if (instance == null) { instance = new ThreadSafeSingleton(); } } } return instance; } } 第 6 種方法是透過「內部類別」+「final 成員變數」實現物件的單一性。這個方法算是對最前面第 1 種 Eager Singleton 進行的改進：因為第 1 種方法不能預防「初始化物件之後，物件從頭到尾都沒有被人用到」的情形，因此我們如果能想出一個『如果有人要用，我再初始化』的程式寫法，那麼第 1 種方法就可以運行的更有效率了！而很剛好，Java 中的內部類別就有著「一開始不會初始化，只有需要用到的時候才會初始化」的特性，所以我們就可以透過內部類別改良方法 1：\n// 6. inner static class class Singleton { private Singleton() {} private static class InnerSingleton { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return InnerSingleton.INSTANCE; } } 最後一種方法是透過 enum 進行單例模式的生成，同樣是運用了 Java 中的特性（詳情點我）：不同於其他的程式語言，Java 的 enum 在某些程度上，可以視試為一個類別（class）的變體，它跟類別一樣可以宣告變數、可以定義不同的封裝型態、可以建立物件、甚至可以進行方法的呼叫和程式的邏輯運算 \u0026hellip;等。因此，我們可以利用「enum 跟 class 很像」這一個特性，實作出一種很特別的單例模式寫法，就像是下面的這個樣子：\n// 7. enumerated type enum Singleton { INSTANCE; public static void doSomething() { // do something } } 以上，就是 Java 裡面常見的幾種單例模式實現方式。\n"},{"id":36,"href":"/docs/computer_science/cryptography/","title":"密碼學","section":"資工相關","content":"\r密碼學\r#\rChatGPT 的說明 【密碼學】（Cryptography）是一門研究「如何確保訊息能夠安全地進行傳遞」的學科。它涉及到使用不同的數學技術和演算法來加密、解密我們想要保護的訊息，從而確保訊息在傳輸和存儲過程中，不被未經授權的人訪問或修改。在密碼學上，我們會利用密鑰（或稱為金鑰、Key）將原始訊息（通常稱為明文、Plain text、或 Plaintext）進行加密（Encryption）。加密後的原始資料會被稱為密文（Cipher text、或 Ciphertext）。金鑰是加密和解密的過程中至關重要的元素，它確保了加解密演算法的安全性，並且只有授權的用戶才能夠解開密文。在密碼學中，加密演算法可以分為古典加密法與現代加密法，兩者通常是以密文的生成和破譯是否需要經由電腦計算作為區分標準。而現代加密又可以分為對稱式加密（Symmetric Encryption）和非對稱式加密（Asymmetric Encryption）。在對稱式加密中，加密的過程與解密的過程會使用相同的一把鑰匙；但在非對稱式加密中，則使用公鑰和私鑰 2 把不同的鑰匙分別進行加密和解密。\n除了對稱式加密和非對稱式加密外，現代密碼學還涉及其他重要概念，例如雜湊函數（Hash function）、訊息驗證碼（Message Authentication Code）、和數位簽章（Digital Signature）\u0026hellip;等。雜湊函數是可以一種將任意大小的位元資料，轉換成固定位元長度的特殊函數。雜湊函數具、固定輸出長度、快速計算、唯一性、和不可逆性 \u0026hellip;等不同的特點；訊息驗證碼是一種用於驗證數據的完整性（Integrity）和真實性（Authenticity）的密碼學技術。它通常使用雜湊函數、密鑰、以及相關訊息來對訊息生成一個固定長度的驗證碼。這個驗證碼與加密過後的訊息一起傳送給接收方。接收方首先會解密所有的得到的資訊，再使用相同雜湊函數、密鑰、以及相關訊息來重新計算驗證碼，然後與接收到的驗證碼進行比較，以確認數據的完整性和真實性；數位簽章則用來驗證資料的完整性（Integrity）和不可否認性（Non-repudiation），通常與非對稱式加密演算法相互結合，可用於確認資料的真實發送者，以及確認該訊息是否在傳遞的過程中有被修改。\n古典加密法 古典加密法是一種利用簡單的數學原理和手動操作來對訊息進行加解密的方法，通常不需要依賴於電腦、計算機、或其他的電子設備。古典加密法在現代密碼學發展之前被廣泛使用，其基本原理是「透過對原始訊息進行某種轉換或替換。」使得未經授權的人無法輕易理解訊息的內容。最著名的古典加密方法之一是凱撒密碼，也稱為移位密碼。凱撒密碼是一種替換密碼，它透過將字母按照一個固定的偏移量向前或向後移動來加密訊息。另一個常見的加解密方式是替換密碼，其中字母表中的每個字母都被映射到另一個字母或符號（例如培根密碼、維吉尼亞密碼表\u0026hellip;等），它會將單個字母映射到兩個（或多個）不同字母的組合上。解密需要知道替換規則，然後反向應用規則來恢復原始訊息。雖然古典加密法在歷史上被廣泛使用，但隨著現代電腦和密碼學的發展，古典加密法不再被認為是安全的加密方式，取而代之的是更複雜和安全的現代加密演算法，例如 RSA 和 AES \u0026hellip;等。\n凱薩加密法（Caesar Chipher） "},{"id":37,"href":"/_trash/creation/novel/","title":"小說試寫","section":"_Trashes","content":"\r小說試寫\r#\r筆記區\n書籍：45 個人格原型：從神話模型到心理分析，幫助你了解人性，並打造獨一無二的角色與故事 書籍：故事的解剖：跟好萊塢編劇教父學習說故事的技藝，打造獨一無二的內容、結構與風格！ Youtube：0 號手稿 寫作區\n作品練習 "},{"id":38,"href":"/_trash/design_pattern/factory_method_pattern/","title":"工廠方法模式","section":"_Trashes","content":"\r工廠方法模式\r#\rChatGPT 的說明 工廠方法模式（Factory Method Pattern）是一種創建型設計模式，它提供了一種創建物件的介面，但允許子類別決定要實例化的類別。這種模式的核心思想是「將物件的創建過程延遲到子類別中去實現。」從而達到物件的 \u0026ldquo;創建\u0026rdquo; 與 \u0026ldquo;使用\u0026rdquo; 分離，使得系統更加靈活和可擴展。工廠方法模式的主要組成部分包括以下角色：［抽象工廠］（Abstract Factory）：抽象工廠定義了一個抽象的工廠介面，包含一個用於建立產品物件的抽象方法。通常情況下，抽象工廠中可能會包含多個建立產品的方法，每個方法用於建立不同類型的產品。［具體工廠］（Concrete Factory）：具體工廠是實現抽象工廠介面的類別，負責創建具體產品。每個具體工廠對應於一種具體產品（或一組相關的特定產品）。［抽象產品］（Abstract Product）：抽象產品定義一個抽象的產品介面，通常包含了產品的通用方法或通用屬性。［具體產品］（Concrete Product）：具體產品是實現抽象產品介面的具體類別，用以表示不同類型的產品。\n工廠方法模式的關鍵點是「透過將物件的創建委託給子類的具體工廠來實現。」這樣客戶端程式碼不需要直接依賴特定的工廠類型，而只需要依賴抽象工廠和抽象產品介面。這種方式使得系統更容易擴展，可以輕鬆添加新的工廠類型或變體，而無需修改現有的客戶端程式碼。以下是工廠方法模式的一些優點：［可擴充性］：使用工廠方法模式，可以透過建立新的特定工廠類別，來新增新的產品類型，而不影響現有的程式碼。［封裝性］：客戶端程式碼與特定的工廠類別解耦，只依賴抽象工廠和抽象產品接口，隱藏了具體產品的實作細節。［靈活性］：不同的具體工廠可以選擇不同的產品實現方式，以適應不同的需求和不同的環境。\n簡單整理 問題描述：使用唯一的 Factory 可能會使該類別變得龐大\n解決方案：透過建立 AbstractFactory 類別，讓 Factory 變得更加靈活\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 貼心提醒：建議先看過簡單工廠模式會比較好。\n工廠方法模式，算是比簡單工廠模式再更複雜一點的程式。那也因為這個模式跟簡單工廠很類似，所以我們就用同樣的例子繼續做解釋：在簡單工廠模式中，我們假設正在製作一個「資料庫操作程式系統」，並且有著幾個比較重要的類別：分別是代表使用者的 User、代表資料庫的 Database、以及代表工廠的 QueryFactory。User 可以透過 Database 裡面的方法（通常為靜態？），進行像是 INSERT, SELECT ..等不同的資料庫操作，而 Database 在接收到 User 的 query 之後，會再轉手交給 QueryFactory 負責解析，而 factory 則會根據 query 的不同，回傳不同的結果。\nclass User { public QueryResult query(String query) { QueryResult queryResult = Database.getQueryResult(query); return queryResult; } } class Database { public static QueryResult query(String query) { QueryResult queryResult = QueryFactory.parseQuery(query); return queryResult; } } class QueryFactory { private enum QueryOperation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } public static QueryResult parseQuery(String query) { QueryOperation operation = this.parse(query); QueryResult queryResult = null; switch(operation) { case QueryOperation.INSERT: queryResult = new InsertResult(query); break; case QueryOperation.SELECT: queryResult = new SelectResult(query); break; case QueryOperation.DELETE: queryResult = new UpdateResult(query); break; case QueryOperation.DELETE: queryResult = new DeleteResult(query); break; default: throw new OperationIsNotExistException(); } return queryResult; } } abstract class QueryResult(); class InsertResult extends QueryResult {}; class SelectResult extends QueryResult {}; class UpdateResult extends QueryResult {}; class DeleteResult extends QueryResult {}; 接下來我們把情境變得複雜一點：假設我們的這個「系統」因為一些原因（像是上級交代、或者是一些商業規劃之類的？），除了需要能夠針對不同的 query 進行操作之外，它的底層還要兼容不同的資料庫系統（像是 MySQL, MariaDB, MongoDB, Redis, SQLite \u0026hellip;等），那在這樣的情況下，如果我們打算維持使用原本簡單工廠模式的程式邏輯的話，情況可能就會變成下面的這個樣子：\nclass User { // 現在多了一個參數，代表哪種 DBMS public QueryResult query(String db_type, String query) { QueryResult queryResult = Database.getQueryResult(db_type, query); return queryResult; } } class Database { // 同樣多了一個 db_type 的參數 public static QueryResult query(String db_type, String query) { QueryResult queryResult = QueryFactory.parseQuery(db_type, query); return queryResult; } } class QueryFactory { public static QueryResult parseQuery(String db_type, String query) { QueryOperation operation = this.parse(query); QueryResult queryResult = null; // 可怕的 if... else... 程式邏輯出現了 ... switch(operation) { case QueryOperation.INSERT: if(db_type.equals(\u0026#34;MySQL\u0026#34;)) queryResult = new MySQL_InsertQuery(query); else if(db_type.equals(\u0026#34;MariaDB\u0026#34;)) queryResult = new MariaDB_InsertQuery(query); else if(db_type.equals(\u0026#34;MongoDB\u0026#34;)) queryResult = new MongoDB_InsertQuery(query); else if(db_type.equals(\u0026#34;Redis\u0026#34;)) queryResult = new Redis_InsertQuery(query); else if(db_type.equals(\u0026#34;SQLite\u0026#34;)) queryResult = new SQLite_InsertQuery(query); break; case QueryOperation.SELECT: if(db_type.equals(\u0026#34;MySQL\u0026#34;)) queryResult = new MySQL_SelectQuery(query); else if(db_type.equals(\u0026#34;MariaDB\u0026#34;)) queryResult = new MariaDB_SelectQuery(query); // 剩下的一些 switch case, if else } return queryResult; } } 可以很明顯的發現到：這個 QueryFactory 類別的程式已經逐漸往很可怕的地方靠攏了。除了這個現象之外，我們還可以另外觀察到一個關於簡單工廠模式的結構缺陷：該模式並沒有符合開放封閉原則，每當我們需要增加（或修改）QueryFactory 工廠中的某一項產品時，都需要對 QueryFactory 類別中的 parseQuery() 方法重新編輯，這不僅會加大該方法的複雜性，這樣的架構也容易讓之後的程式閱讀、改寫、或重構變得困難。\n因此，為了解決上述的問題，我們可以把原本的程式架構從簡單工廠模式換成工廠方法模式：也就是先利用一個「抽象工廠」類別，組織各「實體工廠」應該要實作的方法集合，後續再由繼承該抽象類別的「實體工廠」進行程式的細節邏輯編織。這種將工廠拆分成抽象的方式，不僅可以讓系統程式變得更具有彈性，還可以讓原本簡單工廠裡高度耦合的程式碼進行拆分、解耦，這便是「工廠方法模式」的核心理念。\n// 系統中的 [使用者] 類別 class User { public QueryResult query(String query) { QueryResult queryResult = Database.getQueryResult(query); return queryResult; } } class Database { public static QueryResult query(String db_type, String query) { // 這邊直接針對 factory 進行賦值，我們假設系統現在使用的是 MySQL 的資料庫 QueryFactory factory = new MySQL_Factory(); QueryResult queryResult = factory.parseQuery(query); return queryResult; } } // 將 [工廠] 抽象化 abstract class QueryFactory { // 定義一系列實例化 [工廠] 所需要實現的抽象方法 public QueryResult InsertQuery(String query); public QueryResult SelectQuery(String query); public QueryResult UpdateQuery(String query); public QueryResult DeleteQuery(String query); } // 實體工廠 \u0026#34;MySQL Query Factory\u0026#34; class MySQL_Query_Factory { @Override public QueryResult InsertQuery(String query) { // 實作 MySQL 中的 insert ... } @Override public QueryResult SelectQuery(String query) { // 實作 MySQL 中的 select ... } @Override public QueryResult UpdateQuery(String query) { // 實作 MySQL 中的 update ... } @Override public QueryResult DeleteQuery(String query) { // 實作 MySQL 中的 delete ... } } // 實體工廠 \u0026#34;MariaDB Query Factory\u0026#34; class MariaDB_Query_Factory { @Override public QueryResult InsertQuery(String query) { // 實作 MariaDB 中的 insert ... } @Override public QueryResult SelectQuery(String query) { // 實作 MariaDB 中的 select ... } @Override public QueryResult UpdateQuery(String query) { // 實作 MariaDB 中的 update ... } @Override public QueryResult DeleteQuery(String query) { // 實作 MariaDB 中的 delete ... } } // 其他的 [實體工廠] 類別 ... // 其他的 [實體工廠] 類別 ... // 其他的 [實體工廠] 類別 ... 透過上面的程式，不難看出工廠方法模式相較於簡單工廠模式有著過高的可讀性和靈活性。透過將工廠從原本的單一實體類別轉變為抽象，讓原本存在於簡單工廠中的「各方法」解耦，工廠方法模式更加適合用在體積較為龐大的產品內容上。從現在的程式碼來看，如果我們想要更換系統的底層資料庫（例如：從 MySQL 換到 MariaDB），我們需要讓 Database 的 QueryFactory 更換成另一個資料庫工廠的實體類別（從 MySQL_Query_Factory 換成 MariaDB_Query_Factory），這個過程雖然還是會稍微調整到原本的程式碼，但相較於簡單工廠的紊亂，這種修改或許是個還可以接受的程度？\n"},{"id":39,"href":"/docs/computer_science/design_pattern/factory_method_pattern/","title":"工廠方法模式","section":"設計模式","content":"\r工廠方法模式\r#\rChatGPT 的說明 工廠方法模式（Factory Method Pattern）是一種創建型設計模式，它提供了一種創建物件的介面，但允許子類別決定要實例化的類別。這種模式的核心思想是「將物件的創建過程延遲到子類別中去實現。」從而達到物件的 \u0026ldquo;創建\u0026rdquo; 與 \u0026ldquo;使用\u0026rdquo; 分離，使得系統更加靈活和可擴展。工廠方法模式的主要組成部分包括以下角色：［抽象工廠］（Abstract Factory）：抽象工廠定義了一個抽象的工廠介面，包含一個用於建立產品物件的抽象方法。通常情況下，抽象工廠中可能會包含多個建立產品的方法，每個方法用於建立不同類型的產品。［具體工廠］（Concrete Factory）：具體工廠是實現抽象工廠介面的類別，負責創建具體產品。每個具體工廠對應於一種具體產品（或一組相關的特定產品）。［抽象產品］（Abstract Product）：抽象產品定義一個抽象的產品介面，通常包含了產品的通用方法或通用屬性。［具體產品］（Concrete Product）：具體產品是實現抽象產品介面的具體類別，用以表示不同類型的產品。\n工廠方法模式的關鍵點是「透過將物件的創建委託給子類的具體工廠來實現。」這樣客戶端程式碼不需要直接依賴特定的工廠類型，而只需要依賴抽象工廠和抽象產品介面。這種方式使得系統更容易擴展，可以輕鬆添加新的工廠類型或變體，而無需修改現有的客戶端程式碼。以下是工廠方法模式的一些優點：［可擴充性］：使用工廠方法模式，可以透過建立新的特定工廠類別，來新增新的產品類型，而不影響現有的程式碼。［封裝性］：客戶端程式碼與特定的工廠類別解耦，只依賴抽象工廠和抽象產品接口，隱藏了具體產品的實作細節。［靈活性］：不同的具體工廠可以選擇不同的產品實現方式，以適應不同的需求和不同的環境。\n簡單整理 問題描述：使用唯一的 Factory 可能會使該類別變得龐大\n解決方案：透過建立 AbstractFactory 類別，讓 Factory 變得更加靈活\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 工廠方法模式，是比[簡單工廠]模式還要再複雜一點點的設計模式。主要的使用情境是「當單的 simple Factory 變得過於龐大」的時候。同樣拿簡單工廠模式中的「傢俱系統」作為例子：假設我們的家俱利統中，除了可以展示各種不同類別的傢俱之外，它可以針對不同的傢俱分類（像是金屬製、實木製、塑膠製 \u0026hellip;等）展示出更加細節的傢俱種類（像是實木桌、橡木桌、組合木桌、大理石桌、塑膠桌 \u0026hellip;等），此外每個傢俱都有自己的材質組合（衣櫃不會有玻璃的、床架只有木頭跟金屬的 \u0026hellip;等），如果我們還是用原本的簡單工廠模式來實作這項功能的話，可能會變成下面這個樣子：\nclass FurnutireFactory { // 靜態的 createFurniture() 方法 // 現在多了一個 [材質] 的參數 public static Furniture createFurniture(String material, String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) { if(material.equals(\u0026#34;Wooden\u0026#34;)) furniture = new WoodenChair(); else if(material.equals(\u0026#34;plastic\u0026#34;)) furniture = new PlasticChair(); else if(material.equals(\u0026#34;metal\u0026#34;)) furniture = new MetalChair(); else throw FurnitureIsNotExistException(); } else if(name.equals(\u0026#34;desk\u0026#34;)) { if(material.equals(\u0026#34;Wooden\u0026#34;)) furniture = new WoodenDesk(); else throw FurnitureIsNotExistException(); } else if(name.equals(\u0026#34;sofa\u0026#34;)) { // 各種不同材質的沙發 } // 其他的 if else ... // 其他的 if else ... return furniture; } } 可以發現到：雖然這樣的程式仍然可以幫我們達成系統的需求，但程式本身已經開始變得有點可怕，createFurniture() 不僅出現了對於龐大類別的高度依賴，這也會對於往後對於系統的維護變得更加困難。因此，相對於使用「簡單工廠模式」來達成需求，一個更好的做法是使用「工廠方法模式」來完成我們所需要的各種功能：透過先定義一個抽象的「工廠」類別，並在工廠裡面定義不同種類的「產品」，再讓客戶根據不同的實際狀況，去依賴不同的「實體工廠」，便是工廠方法模式的核心想法：\n// 抽象類別 [傢俱工廠] abstract class FurnitureFactory { public abstract Furniture createFurniture(String name); } // 繼承 [傢俱工廠] 的 [木製傢俱工廠] class WoodenFurnitureFactory extends FurnitureFactory { @Override public Furniture createFurniture(String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new WoodenChair(); else if(name.equals(\u0026#34;desk\u0026#34;)) furniture = new WoodenDesk(); else if(name.equals(\u0026#34;Bookshelf\u0026#34;)) furniture = new WoodenBookshelf(); else throw new FurnitureIsNotExistException(); return furniture; } } // 繼承 [傢俱工廠] 的 [金屬傢俱工廠] class MetalFurnitureFactory extends FurnitureFactory { @Override public Furniture createFurniture(String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new MetalChair(); else if(name.equals(\u0026#34;table\u0026#34;)) furniture = new MetalTable(); else throw new FurnitureIsNotExistException(); return furniture; } } // 系統中的 [顧客] 類別 class Customer { // 新增一個 [傢俱工廠] private FurnutireFactory factory; private String account; private String password; // 將不同材質的傢俱拆分成不同方法 public Furniture getWoodenFurniture(String name) { this.factory = new WoodenFurnitureFactory(); Furniture furniture = factory.createFurniture(name); return furniture; } public Furniture getMetalFurniture(String name) { this.factory = new MetalFurnitureFactory(); Furniture furniture = factory.createFurniture(name); return furniture; } public Furniture getPlasticFurniture(String name) { this.factory = new PlasticFurnitureFactory(); Furniture furniture = factory.createFurniture(name); return furniture; } public Furniture getMarbleFurniture(String name) { this.factory = new MarbleFurnitureFactory(); Furniture furniture = factory.createFurniture(name); return furniture; } } 透過父類別 FurnitureFactory 中的共同方法，現在我們無論是使用木製傢俱工廠（WoodenFurnitureFactory）、金屬傢俱工廠（MetalFurnitureFactory）、塑膠傢俱工廠（PlasticFurnitureFactory）或者是大理石制傢俱工廠（MarbleFurnitureFactory），都可以透過統一的一個 createFurniture() 方法來完成「獲得傢俱」的功能。此外，如果對於上述的程式感到「各種類型的傢俱還要分開來寫，好麻煩 \u0026hellip;」的話，也可以合在一起寫：\n// 系統中的 [顧客] 類別 class Customer { // 新增一個 [傢俱工廠] private FurnutireFactory factory; private String account; private String password; // 將不同材質的傢俱拆分成不同方法 public Furniture getWoodenFurniture(String material, String name) { if(material.equals(\u0026#34;wooden\u0026#34;)) this.factory = new WoodenFurnitureFactory(); else if(material.equals(\u0026#34;metal\u0026#34;)) this.factory = new MetalFurnitureFactory(); else if(material.equals(\u0026#34;plastic\u0026#34;)) this.factory = new PlasticFurnitureFactory(); else if(material.equals(\u0026#34;marble\u0026#34;)) this.factory = new MarbleFurnitureFactory(); else throw new FactoryNotExistException(); Furniture furniture = factory.createFurniture(name); return furniture; } } 雖然這樣做會稍微違反單一職責原則的想法，意即一個類別應該只負責一組相關的事物（畢竟 Customer 是負責處理「顧客」相關的程式邏輯，getWoodenFurniture() 方法現在還包含了一些「該怎麼創建不同的傢俱工廠」），但設計原則跟設計模式本來就不是得一定遵守的，它們只是提供了一個「便於寫程式」的方法而已，在這個情況下，雖然違反原則，但的確減少了 Customer 的方法數。但嚴格來說哪種方式好？可能就因人而異了。\n"},{"id":40,"href":"/docs/computer_science/design_pattern/abstract_factory_pattern/","title":"抽象工廠模式","section":"設計模式","content":"\r抽象工廠模式\r#\rChatGPT 的說明 抽象工廠模式（AbstractFactoryPattern）是一種創建型設計模式，可以在不需指定的特定實體類別的前提下，將一組相關（或相互依賴）的物件建立組合在一起。在抽象工廠模式中，有以下幾個重要的類別：【抽象工廠（Abstract Factory）】：抽象工廠定義了一系列相關或相互依賴的物件介面，包括多個方法用於建立不同類型的物件，抽象工廠類別可以是抽象類別（Abstract class）或者是介面（Interface）。【具體工廠（Concrete Factory）】：具體工廠實現了抽象工廠中的所有抽象方法或介面，具體工廠的主要工作是負責創建一組相關的物件，每個具體工廠都能創建一組（或多組）特定類型的物件。【抽象產品（Abstract Product）】：類似於抽象工廠，抽象產品定義了一系列相關或相互依賴的物件介面，但並不具體指定物件的類別。【具體產品（ConcreteProduct）】：具體產品是實作了抽象產品介面的具體類，它們是由具體工廠所創建的物件。\n抽象工廠模式的功能包括：【封裝物件的創建過程】：抽象工廠將物件的創建邏輯封裝在工廠中，客戶端程式碼只需要透過抽象工廠介面來創建物件，而不需要關心特定物件的創建過程。【提供一致的介面】：抽象工廠模式提供了一組一致的介面來建立一系列相關的物件，這使得客戶端的程式碼能以一種統一的方式使用這些物件。【支援替換產品族】：由於抽象工廠模式將一組相關物件的建立封裝在一起，因此可以比較容易地替換整個產品族，只需要切換特定工廠即可。【符合開閉原則】：當需要新增一組產品時，可以透過擴展抽象工廠和具體工廠來實現，而不需要修改現有的程式碼，符合開閉原則。\n簡單整理 問題描述：當系統變得愈發龐大，即使將工廠進行抽象，也會導致程式高度耦合\n解決方案：對 Factory 和 Product 同時進行抽象\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 抽象工廠模式，是三個與「工廠」有關的設計模式中（簡單工廠模式、工廠方法模式、和抽象工廠模式），最為複雜的一個模式。也因此，在這三種設計模式當中，抽象工廠模式是使用在最為複雜的情境之中。我們同樣承接前兩個「工廠」中的情境，以一個傢俱系統作為例子：假設現在我們的系統除了需要呈現不同材質的傢俱之外，各種傢俱也有一些更微細項的分類，像是「床」有單人床、雙人床、單人床加大 \u0026hellip;等，書櫃有三層櫃、四層櫃 \u0026hellip;等，桌子也有分無抽屜、一個抽屜、兩個抽屜 \u0026hellip;等，如果同樣用工廠方法來處理的話，可能會變成下面這樣：\n// 抽象類別 [傢俱工廠] abstract class FurnitureFactory { // 在 createProduct() 方法中加入一個 \u0026#34;description\u0026#34; 的參數 public abstract Furniture createFurniture(String name, String description); } // 繼承 [傢俱工廠] 的 [木製傢俱工廠] class WoodenFurnitureFactory extends FurnitureFactory { @Override public Furniture createFurniture(String name, String description) { Furniture furniture = null; if(name.equal(\u0026#34;bed\u0026#34;)) { if(description.equals(\u0026#34;single bed\u0026#34;)) furniture = new SingleBed(); else if(description.equals(\u0026#34;full-size bed\u0026#34;)) furniture = new FullSizeBed(); else if(description.equals(\u0026#34;twin XL bed\u0026#34;)) furniture = new TwinXlBed(); else throw new BedIsNotExistException(); } else if(name.equals(\u0026#34;cabinet\u0026#34;)) { if(description.equals(\u0026#34;three-tier cabinet\u0026#34;)) furniture = new ThreeTierCabinet(); else if(description.equals(\u0026#34;four-tier cabinet\u0026#34;)) furniture = new FourTierCabinet(); else throw new CabinetIsNotExistException(); } else if(name.equals(\u0026#34;table\u0026#34;)) { if(description.equals(\u0026#34;0\u0026#34;)) furniture = new ZeroDrawersTable(); else if(description.equals(\u0026#34;1\u0026#34;)) furniture = new OneDrawerTable(); else if(description.equals(\u0026#34;2\u0026#34;)) furniture = new TwoDrawersTable(); else throw new TableIsNotExistException(); } else { throw new FurnitureIsNotExistException(); } return furniture; } } 可以發現到，跟工廠方法中一開始出現的情況一樣，工廠中的 createFurniture() 方法又變得有點可怕了。因此，我們同樣需要對當前程式稍做修改，而其中一種修改方式，便是使用「抽象工廠模式」進行改寫：抽象工廠模式相對於簡單工廠和工廠方法，除了對於「工廠」類別進行抽象化之外，也同時會對「產品」進行一定程度的抽象化，也就是說，在這個例子裡面，我們除了原本根據傢俱的「材質」進行分類之外，也要把傢俱的「種類」進行分類。除此之外，為了避免單一方法中的 if.else 變得龐大複雜，我們也必須將取得各種不同傢俱的方法（getFurniture()）寫成更加細緻的形式（getTable(), getChair \u0026hellip;等），整體而言，就像是下面這樣：\n// 系統中的 [顧客] 類別 class Customer { // 新增一個 [傢俱工廠] private FurnutireFactory factory; private String account; private String password; // 將不同材質的傢俱拆分成不同方法 // ex1. 木製的桌子 public Furniture getWoodenTable(String description) { this.factory = new WoodenFurnitureFactory(); Furniture furniture = factory.createTable(description); return furniture; } // ex2. 金屬製的床 public Furniture getMetalBed(String description) { this.factory = new MetalFurnitureFactory(); Furniture furniture = factory.createBed(description); return furniture; } // 其他獲得不同材質、傢俱種類、和傢俱細節的方法 ... } // 抽象類別 [傢俱工廠] abstract class FurnitureFactory { // 將不同的傢俱分別寫成不同的方法 public abstract Furniture createBed(String description); public abstract Furniture createCabinet(String description); public abstract Furniture createTable(String description); } // 繼承 [傢俱工廠] 的 [木製傢俱工廠] class WoodenFurnitureFactory extends FurnitureFactory { // 製作不同 [木製床] 的方法 @Override public Furniture createBed(String description) { Furniture bed = null; if(description.equals(\u0026#34;single bed\u0026#34;)) bed = new WoodenSingleBed(); else if(description.equals(\u0026#34;full-size bed\u0026#34;)) bed = new WoodenFullSizeBed(); else if(description.equals(\u0026#34;twin XL bed\u0026#34;)) bed = new WoodenTwinXlBed(); else throw new BedIsNotExistException(); return bed; } // 製作不同 [木製書櫃] 的方法 @Override public Furniture createCabinet(String description) { Furniture cabinet = null; if(description.equals(\u0026#34;three-tier cabinet\u0026#34;)) cabinet = new WoodenThreeTierCabinet(); else if(description.equals(\u0026#34;four-tier cabinet\u0026#34;)) cabinet = new WoodenFourTierCabinet(); else throw new CabinetIsNotExistException(); return bed; } // 其他製作不同木製傢俱的方法 ... } // 其他不同材質的傢俱的類別與方法 ... 像這樣透過抽象工廠模式，對各種不同的產品做拆分，便可以緩解系統中，類別與類別間的高度耦合，這也是該模式所闡述的核心理念之一。總而言之，做個小結論：對於三種不同的工廠模式來說：如果程式架構沒有太過龐大，對工廠或對產品都沒有抽象化的需要，那就可以用簡單工廠模式解決；如果程式的複雜程度大致是在中等，需要對「工廠」或對「產品」的其中一個部分做抽象化的處理，那麼推薦使用工廠方法模式；而對於比較複雜的系統架構來說，如果我們同時需要對「工廠」和「產品」進行抽象化處理，那麼抽象工廠便是不錯的選擇。\n但如果程式又變得更加複雜呢？假設今天我們的「櫃子」類別除了有不同的層數之外，還有不同寬高、不同深度 \u0026hellip;等細節，而「桌子」的類別還可以分得更細，像是橡木桌、桃木桌、組合目的小桌子 \u0026hellip;等，那該怎麼辦？其中一種方法是「繼續拆分」，有幾種不同的變數，就拆分成幾種不同的層級，把工廠變成子工廠、子子工廠，產品變成子產品、子子產品 \u0026hellip;等。另外一種較為推薦的方法是放棄使用「工廠」模式，遵循合成/聚合複用原則，或者是其他不同的創建方式進行物件的生成，會比較合適。\n"},{"id":41,"href":"/docs/life/reading_experience/haikyu_the_dumpster_battle/","title":"排球少年！！垃圾場的決戰","section":"閱讀心得","content":"\r排球少年！！垃圾場的決戰\r#\r心得編寫日期：2024-04-13\n電影超連結：待補\n內文：\n作為一個排球少年的愛好者，在最近看到這部劇場版幾乎是海嘯式的宣傳之後，當然是趁著上映後的第一個假日就手刀去看完囉！以電影的規格來說，算是一個相對短的時長（只有 100 分鐘不到），但以一般動畫的劇場版來說，倒是一個差不多剛剛好的觀賞長度。故事講述烏野高中在春高（春季高中排球全國大賽）裡，在第三輪比賽裡與對手音駒高中的比賽細節。因為烏野高中象徵著「烏鴉」、音駒高中的代表動物是「野貓」，因此這場比賽也被稱為「垃圾場的決戰」。\n先說不喜歡的點好了：電影在前半段大概有 3-4 次比較生硬的切點，就是一個情節結束之後，背景音樂漸弱、畫面變黑、然後過個 1-2 秒之後再下一個情節開始的那種表現方式。而且切割與切割的時間通常沒有經過很久，所以在我的體驗上，每一次的切割都有一中「啊 \u0026hellip;情緒還沒堆疊好就要講下一段故事了啊」的那種感覺。此外，電影前半段採用了大量現實與回憶行進的模式進行，也對這個破壞提供了不小的力道。雖然在原作上的確是使用類似的分鏡與呈現手法，在這點上很忠於原作，但我覺得因為載體的緣故，這種「切割」在電影上就帶給我比較不好的感想了，算是我自己覺得比較可惜的地方（沒有 punch 到我的內心）。\n此外，跟漫畫一樣，這部劇場版同樣也給予了裡面的重要角色很平均的出場時間，包含但不限於音駒的研磨、黑尾、貓又教練、和烏野的眾人。雖然對於客群的擊中率來說，這是一個很好的做法，因為每個人喜歡的角色都會出場，但也因為大家的出場時間相對平均，因此很難感受到「主角是誰」這件事情。雖然有看過排少的人大概都會認定日向是主角沒錯，但他在前半段的出場時間卻沒有明顯的多，從我的角度來看，我會覺得日向、月島、和研磨這三人的上鏡率幾乎是一樣的（有一段時間甚至月島還明顯多於日向）。所以如果是抱持著「想看烏野的小巨人會怎麼表現呢～」的觀眾來說，可能會小失落一點。\n但這不表示我覺得這部電影不是一個好作品。\n我最喜歡的故事段落是在大約比賽行進到第三局的時候，敘事的角度切進研磨和黑尾的童年回憶開始。從那一段開始，電影的敘述開始把重點放在「研磨對於『排球』這件事情到底是怎麼想的？」這件事情上，很難得地一路連貫到了電影的終章，最後研磨第一人稱視角的那一段對我來說真的好好看 \u0026hellip;。也因為中間幾乎沒有被打斷的部分，讓我心裡直到現在都還是有「可能研磨才是這部劇場版的主角吧？」的感覺。或者是說，我私心地認為如果故事打從一開始就用「研磨」這位角色做切入，然後演 100 分鐘他與包含烏野在內的其他人的回憶，那這部電影可能就會變得「更合我的口味」了。（只是這樣的呈現方式，就很不忠於原作就是了）。\n除了研磨之外，故事中對於月島的描述同樣也蠻著墨的。用「原本對排球毫無興趣」作為角色設定，然後在比賽行進的過程中對黑尾說「多虧了學長，我現在偶爾也能感受到排球的樂趣了。」再到後面發自內心的喜歡這門運動，一個完整的起承轉合在這個角色上也同樣是我很喜歡這部電影的另一個原因。或許是我在生活上的態度大概都跟這兩位很類似吧？採取無所謂、沒差、都可以的態度在過大部分的生活，所以更這兩位角色能夠投注更多的情緒在裡面，也真心為這兩個角色的成長感到發自內心的開心與高興。\n整體而言，雖然在我自己的私心上面，這部電影版沒有完全 hit 到我心中的點。但作為一個「給排球少年粉絲的作品」來說，它無庸置疑是一部很好很好的電影，超過 10 名主要角色的性格在短短的 100 分鐘內都明顯地表現了出來，富有起承轉合的故事劇情同樣引人入勝。雖然要我說「很推薦去電影院看」可能有點勉強，但作為排球少年四季之後的新續作，我還是推薦給所有排球少年的粉絲可以找時間去看看，很感謝電影的製作組如此的心力，讓這部作品得以用這樣的結果出現。\n評分\n觀賞難度：★☆☆☆☆（超容易入門！） 推薦指數：★★★☆☆ "},{"id":42,"href":"/_trash/creation/novel/note/story/","title":"故事的解剖","section":"小說試寫","content":"\r故事的解剖\r#\r輔助閱讀\nYoutube: 東默農的編劇實戰教室 重點節錄\n第一章重點 "},{"id":43,"href":"/_trash/pomodoro/202310/20231019/","title":"日常工作紀錄 2023/10/19","section":"_Trashes","content":"\r日常工作紀錄 2023/10/19\r#\rYoutube：《故事的解剖》深度導讀 - 01 Youtube：《故事的解剖》深度導讀 - 01、借閱《故事的解剖》和《45個人格原型》 閱讀《故事的解剖》中的 01（故事面臨的難題：品質、技藝、課題、天賦） 閱讀《故事的解剖》中的 02（故事設計的相關術語：結構、事件） 閱讀《45個人格原型》中的第 1 部，並編寫筆記 閱讀《45個人格原型》中的魅惑繆思、亞馬遜女戰士、父之女、和養育者 閱讀《45個人格原型》中的女族長、神秘客、女救世主、和天真少女 "},{"id":44,"href":"/_trash/pomodoro/202310/20231020/","title":"日常工作紀錄 2023/10/20","section":"_Trashes","content":"\r日常工作紀錄 2023/10/20\r#\r抄寫般若波羅密多心經，Gooaye EP.95 抄寫般若波羅密多心經，Gooaye EP.96 抄寫般若波羅密多心經，Gooaye EP.97 抄寫般若波羅密多心經，Gooaye EP.98（前半） 複習 0 號手稿「照抄妖精的尾巴」的內容，同時重新寫筆記 構思小說女主角的人物、形象 \u0026hellip;等設定 - 1（未完成） 構思小說女主角的人物、形象 \u0026hellip;等設定 - 2（未完成） 構思小說女主角的人物、形象 \u0026hellip;等設定 - 3（未完成） 構思小說女主角、男主角、女配角的性格、形象 \u0026hellip;等設定（未完成） 構思小說女主角、男主角、女配角的性格、形象 \u0026hellip;等設定（未完成） 構思小說第一章的內容（未完成） "},{"id":45,"href":"/_trash/pomodoro/202310/20231022/","title":"日常工作紀錄 2023/10/20","section":"_Trashes","content":"\r日常工作紀錄 2023/10/20\r#\r重構 nccu_project（程式外觀） 重構 nccu_project（程式外觀） 構思小說第一章情節（未完成） 構思小說第一章情節（未完成） 構思小說第一章情節（未完成） "},{"id":46,"href":"/_trash/pomodoro/202310/20231021/","title":"日常工作紀錄 2023/10/21","section":"_Trashes","content":"\r日常工作紀錄 2023/10/21\r#\r重構 nccu_project/index.php（未完成） 重構 nccu_project/index.php（完成） 構思小說第一章的故事主題（未完成） 構思小說第一章的故事主題（未完成） 構思小說第一章的故事主題（初稿完成） 構思小說第一章的故事主題（修改中/未完成） 構思小說第一章的故事主題（完成） "},{"id":47,"href":"/_trash/pomodoro/202310/20231023/","title":"日常工作紀錄 2023/10/23","section":"_Trashes","content":"\r日常工作紀錄 2023/10/23\r#\r抄心經，Gooaye Ep.99 抄心經，Gooaye Ep.100 抄心經，Gooaye Ep.101 重新建構故事第一章（未完成） 重新建構故事第一章（未完成） "},{"id":48,"href":"/_trash/pomodoro/202310/20231024/","title":"日常工作紀錄 2023/10/24","section":"_Trashes","content":"\r日常工作紀錄 2023/10/24\r#\r抄心經，Gooaye Ep.102 抄心經，Gooaye Ep.103 抄心經，Gooaye Ep.104 幫大頭跟彪哥解決網站的問題 "},{"id":49,"href":"/_trash/pomodoro/202310/20231025/","title":"日常工作紀錄 2023/10/25","section":"_Trashes","content":"\r日常工作紀錄 2023/10/25\r#\r抄心經，0 號手稿技術面分析 抄心經，0 號手稿技術面分析 抄心經，0 號手稿技術面分析 幫大頭跟彪哥解決網站的問題 "},{"id":50,"href":"/_trash/pomodoro/202310/20231026/","title":"日常工作紀錄 2023/10/26","section":"_Trashes","content":"\r日常工作紀錄 2023/10/26\r#\r學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 "},{"id":51,"href":"/_trash/pomodoro/202310/20231027/","title":"日常工作紀錄 2023/10/27","section":"_Trashes","content":"\r日常工作紀錄 2023/10/27\r#\r幫大頭解決 apache 連不到 MySQL 的問題 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 思考小說的架構與情節 思考小說的架構與情節 思考小說的架構與情節 "},{"id":52,"href":"/_trash/pomodoro/202310/20231028/","title":"日常工作紀錄 2023/10/28","section":"_Trashes","content":"\r日常工作紀錄 2023/10/28\r#\r學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 教大頭 git command, ocp (Open Close Principle) 教大頭 git command, ocp (Open Close Principle) "},{"id":53,"href":"/_trash/pomodoro/202310/20231029/","title":"日常工作紀錄 2023/10/29","section":"_Trashes","content":"\r日常工作紀錄 2023/10/29\r#\r學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 幫大頭解決 git 的相關問題 幫大頭解決 git 的相關問題 幫大頭解決 git 的相關問題 "},{"id":54,"href":"/_trash/pomodoro/202310/20231030/","title":"日常工作紀錄 2023/10/30","section":"_Trashes","content":"\r日常工作紀錄 2023/10/30\r#\r2502 meeting 2502 meeting 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 "},{"id":55,"href":"/_trash/pomodoro/202310/20231031/","title":"日常工作紀錄 2023/10/31","section":"_Trashes","content":"\r日常工作紀錄 2023/10/31\r#\r陪阿公復健、圖書館借書 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 "},{"id":56,"href":"/_trash/pomodoro/202311/20231101/","title":"日常工作紀錄 2023/11/01","section":"_Trashes","content":"\r日常工作紀錄 2023/11/01\r#\r學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 幫大頭解決 Ubuntu 中， MySQL 無法和 PHP 溝通的問題 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 "},{"id":57,"href":"/_trash/pomodoro/202311/20231103/","title":"日常工作紀錄 2023/11/03","section":"_Trashes","content":"\r日常工作紀錄 2023/11/03\r#\r抄心經，Gooaye Ep.105 抄心經，Gooaye Ep.106 嘗試用 Sprinig boot 做一個 backend api 研究 maven 的用法、嘗試用 Sprinig boot 做一個 backend api 嘗試了解 maven, gradle 的差異 練習 gradle.kts 練習 gradle.kts 練習 gradle.kts "},{"id":58,"href":"/_trash/pomodoro/202311/20231104/","title":"日常工作紀錄 2023/11/04","section":"_Trashes","content":"\r日常工作紀錄 2023/11/04\r#\r練習利用 gradle.kts 生成一個 java application。參考 呈上。撰寫模板方法模式的內容 撰寫模板方法模式的內容（說明、整理） 模板方法模式、gradle、小說內容 了解軟體設計模式，參考資料：YT - 水球軟體學院 了解軟體設計模式，參考資料：YT - 水球軟體學院 了解軟體設計模式，參考資料：YT - 水球軟體學院 抄心經，聽 YT：遊戲微服務計畫 抄心經，聽 YT：遊戲微服務計畫 抄心經，聽 YT：遊戲微服務計畫 "},{"id":59,"href":"/_trash/pomodoro/202311/20231105/","title":"日常工作紀錄 2023/11/05","section":"_Trashes","content":"\r日常工作紀錄 2023/11/05\r#\r研究 gradle 的運作流程，參考：Medium 文章：Gradle 的系列文章，學 jUnit test 5 研究 gradle 的運作流程，參考：Medium 文章：Gradle 的系列文章，學 jUnit test 5 利用 gradle 和 spring boot 建制出一個簡單的本地後端 api。參考：spring boot 教學 利用 gradle 和 spring boot 建制出一個簡單的本地後端 api。參考：spring boot 教學 了解 TDD, BDD, MVC, MVP \u0026hellip;等不同的軟工術語 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 抄心經，聽 YT：在地上滾的工程師 Nic "},{"id":60,"href":"/_trash/pomodoro/202311/20231106/","title":"日常工作紀錄 2023/11/06","section":"_Trashes","content":"\r日常工作紀錄 2023/11/06\r#\r監考，雅芬老師的數位邏輯 監考，慧鳳老師的管理數學 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 編寫閱讀心得：Clean Architecture - 無瑕的程式碼 編寫閱讀心得：Clean Architecture - 無瑕的程式碼 抄心經，聽 Hololive 的直播 抄心經，聽股癌 Ep. 107 抄心經，聽股癌 Ep. 108 "},{"id":61,"href":"/_trash/pomodoro/202311/20231108/","title":"日常工作紀錄 2023/11/08","section":"_Trashes","content":"\r日常工作紀錄 2023/11/08\r#\r帶阿公去樓下復健 去榮總複檢 了解 DDD（Domain-Driven Donain），參考 YT：DDD领域驱动设计 了解 DDD（Domain-Driven Donain），參考 YT：DDD领域驱动设计 了解 DDD（Domain-Driven Donain），參考 YT：DDD领域驱动设计 抄心經，聽 YT：在地上滾的工程師 Nic "},{"id":62,"href":"/_trash/pomodoro/202311/20231109/","title":"日常工作紀錄 2023/11/09","section":"_Trashes","content":"\r日常工作紀錄 2023/11/09\r#\r帶阿公去樓下復健 區公所、加油、打電話叫大頭起床監考 研究 JDBC, JPA, 和 H2 在 spring boot 裡的用途 研究 JDBC, JPA, 和 H2 在 spring boot 裡的用途 研究 JDBC, JPA, 和 H2 在 spring boot 裡的用途 複習 AngulerJS 和 Spring boot RESTful api 的語法跟邏輯 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 "},{"id":63,"href":"/_trash/pomodoro/202311/20231110/","title":"日常工作紀錄 2023/11/10","section":"_Trashes","content":"\r日常工作紀錄 2023/11/10\r#\r帶阿公去樓下復健 了解軟體設計模式，參考資料：YT - 水球軟體學院 了解軟體設計模式，參考資料：YT - 水球軟體學院 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 算命（翻塔羅 + 紫微），收到 50 塊 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":64,"href":"/_trash/pomodoro/202311/20231111/","title":"日常工作紀錄 2023/11/11","section":"_Trashes","content":"\r日常工作紀錄 2023/11/11\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":65,"href":"/_trash/pomodoro/202311/20231112/","title":"日常工作紀錄 2023/11/11","section":"_Trashes","content":"\r日常工作紀錄 2023/11/11\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":66,"href":"/_trash/pomodoro/202311/20231114/","title":"日常工作紀錄 2023/11/14","section":"_Trashes","content":"\r日常工作紀錄 2023/11/14\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 抄心經，聽股癌 Ep. 109 抄心經，聽股癌 Ep. 110 抄心經，聽股癌 Ep. 111 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":67,"href":"/_trash/pomodoro/202311/20231115/","title":"日常工作紀錄 2023/11/15","section":"_Trashes","content":"\r日常工作紀錄 2023/11/15\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 抄心經，隨便聽一些不是很重要的東西 "},{"id":68,"href":"/_trash/pomodoro/202311/20231116/","title":"日常工作紀錄 2023/11/16","section":"_Trashes","content":"\r日常工作紀錄 2023/11/16\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 抄心經，聽股癌 Ep. 112 "},{"id":69,"href":"/_trash/pomodoro/202311/20231125/","title":"日常工作紀錄 2023/11/25","section":"_Trashes","content":"\r日常工作紀錄 2023/11/25\r#\r更新網頁文章：java.util.ConcurrentModificationException 更新網頁文章：java.util.ConcurrentModificationException 更新網頁文章：java.util.ConcurrentModificationException Youtube: DDD 的价值与不足 Youtube: DDD 的价值与不足 Youtube: DDD 的价值与不足 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":70,"href":"/_trash/pomodoro/202311/20231126/","title":"日常工作紀錄 2023/11/26","section":"_Trashes","content":"\r日常工作紀錄 2023/11/26\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 調整座位，重灌 2502 的電腦 調整座位，重灌 2502 的電腦 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":71,"href":"/_trash/pomodoro/202311/20231127/","title":"日常工作紀錄 2023/11/27","section":"_Trashes","content":"\r日常工作紀錄 2023/11/27\r#\r抄心經，Gooaye Ep.117 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 2502 每週 meeting 2502 每週 meeting 2502 每週 meeting 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 算命工作 算命工作 "},{"id":72,"href":"/_trash/pomodoro/202311/20231128/","title":"日常工作紀錄 2023/11/28","section":"_Trashes","content":"\r日常工作紀錄 2023/11/28\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":73,"href":"/_trash/pomodoro/202311/20231129/","title":"日常工作紀錄 2023/11/29","section":"_Trashes","content":"\r日常工作紀錄 2023/11/29\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 調整 git 的提交內容和分支結構 調整 git 的提交內容和分支結構 去圖書館還書、看書、借書 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 重新閱讀 Clean Architecture 重新閱讀 Clean Architecture "},{"id":74,"href":"/_trash/pomodoro/202311/20231130/","title":"日常工作紀錄 2023/11/30","section":"_Trashes","content":"\r日常工作紀錄 2023/11/30\r#\r抄心經，聽股癌 Ep. 118 研究、安裝一些新的 VScdoe 套件 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":75,"href":"/_trash/pomodoro/202312/20231201/","title":"日常工作紀錄 2023/12/01","section":"_Trashes","content":"\r日常工作紀錄 2023/12/01\r#\r抄心經，Gooaye Ep.119 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":76,"href":"/_trash/pomodoro/202312/20231204/","title":"日常工作紀錄 2023/12/04","section":"_Trashes","content":"\r日常工作紀錄 2023/12/04\r#\r2502 meeting（學妹報告） 2502 meeting（學妹報告） 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":77,"href":"/_trash/pomodoro/202312/20231205/","title":"日常工作紀錄 2023/12/05","section":"_Trashes","content":"\r日常工作紀錄 2023/12/05\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":78,"href":"/_trash/pomodoro/202312/20231206/","title":"日常工作紀錄 2023/12/06","section":"_Trashes","content":"\r日常工作紀錄 2023/12/06\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 幫學妹複習報告內容 幫學妹複習報告內容 幫學妹複習報告內容 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":79,"href":"/_trash/pomodoro/202312/20231207/","title":"日常工作紀錄 2023/12/07","section":"_Trashes","content":"\r日常工作紀錄 2023/12/07\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":80,"href":"/_trash/pomodoro/202312/20231208/","title":"日常工作紀錄 2023/12/08","section":"_Trashes","content":"\r日常工作紀錄 2023/12/08\r#\r帶阿公去樓下復健、幫阿嬤拿藥、買午餐 去學校看學弟妹，專題加油 北上的路程（和欣客運） 北上的路程（和欣客運） 北上的路程（和欣客運） 北上的路程（和欣客運） 去呂杰家的路上 去呂杰家的路上 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 2502 台北串燒宵夜 2502 台北串燒宵夜 飯店 check in 飯店 check in "},{"id":81,"href":"/_trash/pomodoro/202312/20231209/","title":"日常工作紀錄 2023/12/09","section":"_Trashes","content":"\r日常工作紀錄 2023/12/09\r#\r證交所考試（適性測驗） 證交所考試（數學 + 邏輯） 證交所考試（資安學科 40 選擇 + 60 手寫） 證交所考試（資安學科 40 選擇 + 60 手寫） 返程 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":82,"href":"/_trash/pomodoro/202312/20231210/","title":"日常工作紀錄 2023/12/10","section":"_Trashes","content":"\r日常工作紀錄 2023/12/10\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 中場休息，接個案子算算紫微跟塔羅牌 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":83,"href":"/_trash/pomodoro/202312/20231211/","title":"日常工作紀錄 2023/12/11","section":"_Trashes","content":"\r日常工作紀錄 2023/12/11\r#\r試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 帶阿公去樓下復健，抄心經，gooaye Ep. 122 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 買晚餐、西瓜汁、陪大頭去印海報 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 試著用 DDD, TDD, gradle, Spring boot, Angular 做出一個富饒之城 "},{"id":84,"href":"/_trash/pomodoro/202403/20240302/","title":"日常工作紀錄 2024/03/02","section":"_Trashes","content":"\r日常工作紀錄 2024/03/02\r#\r把十六病房的朋友們加進 Line 群組 曬衣服、機車加油、幫妹妹買早餐 打掃房間、整理所有衣物、清空黃埔包 撰寫閱讀心得、線上版日記（未完成） "},{"id":85,"href":"/_trash/diary/202401/20240123/","title":"日記","section":"_Trashes","content":"\r日記：2024/01/23\r#\r今天是住院的第 2 天，我打算從今天開始養成寫日記的習慣。\n昨天是軍營表定的複診日期，我們早早就在轉診車前集合，準備去醫院看診。在集合之前同樣可以聽到值星班長大聲的斥喝與責罵，一想到他說的「我們之後會繼續加大力度盯著你們」心裡就湧起了一股噁心、想吐的感覺。在前往醫院的路上，班長發給了我們一人一張初診的基本資料表，我旁邊的鄰兵沒有帶到筆，所以我借了他一支。我們一路上幾乎沒有聊什麼天（他看起來也是比較不想說話的那種類型），所以我後來是一路睡到醫院的，中間沒跟任何人說過任何的話。\n身心科的複診很順利，就結果而言，醫生判斷我有「具有憂鬱傾向的適應障礙症」我不知道那是什麼？但從字面上來看應該就是憂鬱 + 適應不良吧？看完複診期間，醫生說他可以在今天分配了一張院內的床位給我，但他的前提是：「分配床位需要家人的同意」，所以無可避免地，我還是需要打一通電話給我的父親。跟父親的溝通不算順利，基本上可以用「大吵一架」來形容，這應該是我在與家人的經驗當中，第一次那麼用力、那麼強烈、那麼明確地表達、傳遞、和執行自己的想法，但很明顯地，父親那邊還是把他的底線踩得很死（不要住院，再等一個禮拜懇親之後回家慢慢聊、慢慢談），是直到但輔導長後來將電話接手之後，父親才同意了我的住院事宜。雖然不知道他們說了什麼？但我毫不在意。\n在那之後我的情緒逐漸緩和下來，主因是「不用再回到軍營了。」姑姑和妹妹也在我撥通電話給爸爸之後來到醫院這裡找我和關心我（應該是父親打電話給他們的）。那時候大概是跟父親吵架過後的 1-2 小時，我已經變回比較平常的我了，我大概跟她們說了不下 10 次的「對不起」吧？說實話，挺不好受的。此外因為住院的規定是「剛入院的 30 天內都必須要待在醫院裡。」所以過年期間我是不可以回家吃飯的。我應該讓阿公擔心了吧？過年不能回去，不知道他老人家會怎麼想呢？\n出院的時間預計在 2 月底 3 月初左右，等回去之後再看看要怎麼辦吧？病院裡大家的人都很好，雖然不乏有比較難以相處的，但也在這裡結識了 3-5 個年紀相仿的朋友（幾乎都是軍人）。老實說，還是有點焦慮，但如同士官長在第一天說的：剛換環境總比較容易焦慮。這樣的狀況再之後會好上許多吧？希望在這裡可以讓我的心情和心態慢慢地倒回原來的正軌。\n今天妹妹送來了水壺、書籍、和一些其他的生活用品。妹妹帶來的是勸學齋主的《紫微初階》、《傅佩榮解讀易經》、CEH 相關書籍、和一本我沒看過的小說——《祈念之樹》，從書本外殼的介紹來看，我猜應該是姑姑借給我的（因為我們家的人沒有人會看東野圭吾的書）。現在的我真的覺得好幸福，真的很感激他們為我所做的這一切，也很抱歉昨天失控的情緒給他們帶來了不少的麻煩。\n也因為今天是第二天入院，加上昨天晚上入院的時間有點太晚了（大概在 5:10 左右？）。所以住院例行的也做了 X 光和心電圖檢查被調整到了今天才做，從跟這邊的病友聊天的過程可以得知：我們軍人待在這裡主要是需要完成一份「評估診斷」，然後再把這份評估讓院方和軍方決定我的況狀（是免役？還是停役？又或是重回軍營 \u0026hellip;等），診斷的第一步驟是需要完成一份心裡測驗（簡稱心測），那個測驗過幾天就會來了吧？不知道會有什麼樣的內容？\n"},{"id":86,"href":"/_trash/diary/202401/20240124/","title":"日記","section":"_Trashes","content":"\r日記：2024/01/24\r#\r今天是住院的第 3 天。\n昨天晚上在寫完日記之後發生了一個意外的小插曲：有 2 個病友\r\\(_{[1]}\\)\r（A 和 B）差點打了起來。起因是因為 A 在看電視的時候一直在自言自語，B 覺得 A 有點吵，就請他安靜。但 A 覺得 B 的這一行為像是在攻擊他，所以就出言挑釁了一番。接著場面就火爆起來，一度還差點變成雙方互毆的局面，是護理站的護理人員即時近來調解，才將事情壓制下來的。\n總之，因為這件事情，昨天睡前的心情大概只有 30~40 左右。然後焦慮的分數有 90+ 就是了，這邊三不五時就會有這樣的問題嗎？還是我之後都把自己關在房間裡面好了。今天晚上也看到我爸跟我媽了，雖然不能面對面地聊天（好像是非會客時間？），但還是可以看出他們臉上不安和焦躁的心情。沒想到當兵之後的第一次見面居然是以這樣的方式，雖然比預期的時間還要早（原本會面是在懇親的時候），但這樣想想也覺得挺可笑的（在精神病院裡面）。他們帶了一些吃的、喝的、和其他保暖衣物給我。已經記不清楚這是我入院之後，第幾次收到他們的關心了，心情真的舒坦了很多。\n除此之外，今天也發生了幾個比較重要的事：首先是營長和輔導長有來會客。這輩子大概只有這一次可以跟營長坐同一桌聊天了吧？感覺真奇妙。其次是我在病院裡面換床位了。從原本的 48 床換到了現在的 22 床。換原因是因為這裡發生了類似流感的傳染疾病，醫院為了預防（和隔絕）病毒，所以就把 45~56 的床位都留給得到流感的那些人（目前大約 4-5 個，但因為是傳染初期，所以人數之後可能還會更多）。\n第三個是我今天做了一次社工師的家庭訪問，過程大概花了 25 分鐘左右。雖然不是正式的心測，但這好像也是流程的一環？社工師問了一些家裡的情況、家庭成員、相處氣氛 \u0026hellip;等，她也幫我歸因了一些我會憂鬱 + 焦慮的因素，然後建議我在出院之後要怎麼面對、處理、和應對。最後，我今天也看了一本東野圭吾的《祈念之樹》，怎麼說呢 \u0026hellip;，一個頂尖的小說家真的好厲害 \u0026hellip;，能以清晰精練的文字描繪豐富的人物、事件、和場景 \u0026hellip;，這就是我最最追求的其中一條道路的盡頭吧？雖然好遠好遠。但又讓人好嚮往、好期待。\n——生活正在慢慢回到正軌，無論是身體、還是心裡。但還不能鬆懈，要好好注意，好好維持。\n1：柏豪跟秉霖\r#\r"},{"id":87,"href":"/_trash/diary/202401/20240125/","title":"日記","section":"_Trashes","content":"\r日記：2024/01/25\r#\r今天是住院的第 4 天。\n今天早上做完心測了！跟昨天社工師的家訪類似，心理師問了很多跟家庭相關、工作相關、和壓力相關的問題。不知道這 2 次的會談有沒有什麼關聯？因為從心理師的問題來看，感覺她事先沒有和社工師有對我的狀況進行過交流。但心理師問的問題和社工師明顯不同：社工師問的是「我」與「家人」之間的相處情況與氛圍；但心理師著重的則是「我」與「環境」的相處，以及這些環境帶給我的「心裡看法」。\n除此之外，就像昨天所說的：今天的隔離人數相較昨天又更多了，大約有 \\(\\frac{1}{4} \\sim \\frac{1}{3}\\)\r的病友都被送進隔離區。而且我在剛剛才知道，他們得的其實不是流感，而是 covid，所以接下來我們每天都要做一次確診的快篩。同時，也因為待在外面的人數變少了，所以自己與自己獨處的時間就多了起來：今天曬了大約半小時的太陽，或許是錯覺？但吸收陽光之後心情有感覺比較「正面」一點。然後，我自己也花時間重看了一遍《紫微初階》這本書，目前進入到「格局」的部分。雖然不能說沒有收穫，但畢竟大多都還是以前就學過的東西，所以整體而言還是複習成分居多。\n稍晚應該會回想一下前兩天家訪跟心測的內容吧？無論是我、家庭裡的大家，真的各自都有辛苦的地方呢 \u0026hellip;。「搬出去真的是個好決定嗎？」老實說社工師的說法有稍微說服到我原本的決定。今天跟心測的姊姊聊了一下之後，她也同樣再提醒了一件在入伍之前，整骨的哥哥就有提到的事：我一部份的個性其實跟「我很不喜歡的個性」重疊了。這當然不是件好事，也得好好思考與模擬要怎麼改善才行？\n等等晚上要打 2 通電話：1 通是固定 19:40 的回家報平安，另外一通是跟輔導長說「我的心測已經完成」的事。根據大家以往的經驗，一般心測完 2~3 週後結果就會下來了。但我因為過年的原因（放了大約一個禮拜的年假），所以我可能還會再多一陣子，也因此 \u0026hellip;我還要再等 30-35 天左右吧？這樣算下來，大約 2/28 前後可以完成。但真的能夠那麼順利嗎？結果真的不會是「重回軍營」嗎？天知道～總之只能先等待了。\n"},{"id":88,"href":"/_trash/diary/202401/20240126/","title":"日記","section":"_Trashes","content":"\r日記：2024/01/26\r#\r入院的第 5 天，目前一切安好。\n今天沒什麼特別的事情，加上已經習慣裡面的生活了，所以今天讀書的時間特別多。大概在下午 3 點左右，我《紫微初階》看完了——準確來說，是把「格局」和「五行局」這兩個章節仔細的讀完了。我得收回昨天說過的話（整體而言還是複習居多～），老實說 \u0026hellip;看完之後的收穫是挺多的。原以為大部分都是早就知道的內容，但還是從中挖到了一些學問：像五行局的命名邏輯、格局的細緻分析 \u0026hellip;等。尤其五行局的部分：利用宮位的納音進行吉凶的論斷算是一個很有趣的技巧，也有點飛星的味道在裡面，沒意外之後應該會用這種方式論命看看（總覺得離我原本學的飛星越來越遠了 \u0026hellip;）。\n也因為《紫微初階》已經閱畢，加上目前手中僅有的 4 本書裡面，《祈念之樹》已經在前天看完了，《紫微初階》在剛剛也結束了，CEH 的內容需要實際操作才可以達到書本的需求（但裡面用不了電腦）；所以終於要進到《易經》的解讀和分析了 \u0026hellip;。可以很自信地說，我對於解釋爻辭的易經占卜幾乎是完全沒有涉獵（我比較擅長的是京房易的占卜邏輯）。但毫無疑問，傅教授的《解讀易經》一定是一本好書，目前計畫分 32 天把所有的內容看完（易經共有 64 卦，以一天 2 卦的進度來算）。理論上按照這樣的進度來執行，出院之前就可以完成。但內容能不能看懂、看透徹就又是另一回事了。希望可以跟最剛開始紫微一樣，有個雖然辛苦、但跟充實又很快樂的過程。\n"},{"id":89,"href":"/_trash/diary/202401/20240127/","title":"日記","section":"_Trashes","content":"\r日記：2024/01/27\r#\r今天是入院的第 6 天，用軍營的時程表來看的話，今天是部隊的懇親日。\n要說我不羨慕嘛 \u0026hellip;多少還是有一點，畢竟入院的生活是沒有放假的，就連年假也不例外——誠如23 號的日記所言：除非你在過年之前就已經先在裡面待滿至少 30 天，才有出外的機會，不然剛進來的 30 是不可以離開醫院的。但比起「羨慕」，我更多的心情其實是「舒坦」。入院算是在我衡量了 2 邊的利弊之後，\u0026ldquo;選擇\u0026rdquo; 過後的結果：用我當兵裡面 1~2 個月的所有假期，去交換早日離開新訓的環境，直到現在我仍不後悔。\n即使在這裡同樣會被固定作息；即使這裡除了廁所之外，其他地方都有 24 小時全方位無死角的監視器；即使這裡不會給你任何（哪怕是 1 秒）的手機時間、3 C 用品完全禁止使用：即使三不五時身邊就會有人突然發狂、當機、或表現出怪異的舉止。但我仍為我的選擇不感到後悔（包含複診那天跟醫生說出我的真實想法、甚至跟爸爸在電話裡大吵一架）就像裕宏班長說的：「好好思考自己的未來要選擇什麼？要拿著什麼？要丟掉什麼？」我思考了，也選擇了，現在只是在這裡面對、享受、和承受選擇過後的結果而已。\n除此之外，今天比較重要的事情有 2 個：第一個是《易經》真的、真的、真的好難讀 \u0026hellip;，看了一整天才勉強看了大約 7 個爻辭和概述。第二個則是明儒跟我說他要把我培養成他在這裡的下一個接班人（就是最熟悉院內所有軍隊流程的軍籍病友），所以他在之後會開始丟一些院內相關的課題給我。但老實說我對於「成為接班人」的意願並不是很高，我也還沒準備好要面對這件事，也不知道該從何開始？但換個方式想：在入院之前，我也早就懶散地度過很多年了，巳宮祿存天府無煞的大運讓我過得太～舒服了，或宇也是因為這個原因，才讓我現在沒辦法適應軍中的生活吧？無論如何，從現在開始練習繃緊神經也好，不要像是當兵那樣一下子把壓力 all in 到身上的角度，而是慢慢地、慢慢地累積壓力、扛著壓力往前走，或許才是比較適合我的方式吧？畢竟如果連這都想不練習、也沒有練習的意願的話，那麼我下一步「月同遇煞」的大運又該怎麼過呢？\n"},{"id":90,"href":"/_trash/diary/202401/20240128/","title":"日記","section":"_Trashes","content":"\r日記：2024/01/28\r#\r今天是入院的第 7 天，如果用我現在在寫日記的這個時間（18:55）來算，我入院的時數已經超過我待在軍營裡的時數了。直到現在還是有點難以感覺到這個時間上的變化，這就是「緊繃」跟「鬆懈」之後的時間差距嗎？時間真的過得好快啊 \u0026hellip;，不知道營區的大家現在過得怎麼樣呢？如果是放 3 天的懇親假倒還好，但如果懇親只有放六日的話 \u0026hellip;，希望不要有人逾假未歸，不然難以想像他們會面對到怎麼樣的麻煩。\n今天有發生幾件有趣的事情：首先是我進行了第一次的會客，來的人是我媽和我妹 2 人。雖然會客的時間只有 15 分鐘，但還是聊了不少的事情。她們也趁著這次來會客帶了很～多很多的書本過來，其中有 2 本跟紫微有關的書籍（《紫微進階》和《紫微高階 1》），這兩本配合《易經》會是我之後幾天的閱讀主力，可以感覺到在這裡的閱讀量應該能夠累積不少起來，畢竟包含院內本身提供的書籍在內，才過不到一個禮拜，我就已經看完 3-4 本書了。\n其次是明儒快篩呈陰性，所以他從隔離的區域出來了。他也趁著這個解隔離的機會跟我說了完整的院內流程：包含社工家訪、心測、心理師撰寫心測報告、心理師把報告寄件給精神科主治醫師，主治醫師撰寫病人的病情診斷、然後將診斷結果寄回原軍營，讓原軍營做最後裁定（回營、驗退、或因病停訓）。算是一個挺正常，但看起來又有一點點長的行政流程（難怪他們會說需要大約一個月左右的時間）。\n最後是今天又認識了一個新的朋友——冠至（外號叫蔡蔡）。他是 186 梯次的二兵（我是 191 梯），在入院之前一直都待在精北。有重度憂鬱的病史、跟超過一次的自殘與自殺未遂的紀錄。從跟他的對話中我又再一次的感受到了「重度憂鬱不一定是從外表就能夠看出來的。」的這件事。除此之外，名儒也跟我說：從今晚（或明天）開始，要來整理一下環境資訊了——包含記得護理師、保全、與病友的人名、個性、習慣。還有記得其他東西（例如遊樂器材借閱時間、麻將借閱時間、曬衣場跟熱水的開放時間 \u0026hellip;等）的相關細節。就像之前跟自己說的：也要開始練習把手邊的事情、未來的事情好好地整理和規劃一番了。入院歸入院，該鞭策自己的還是要鞭策，不然就只是在懶散度日而已，對自己不會有正向幫助的。\n"},{"id":91,"href":"/_trash/diary/202401/20240129/","title":"日記","section":"_Trashes","content":"\r日記：2024/01/29\r#\r（1/30 10:20 補寫）\r#\r昨天忘記寫日記了！趁著現在早上還有一點記憶趕快補寫一下。\n昨天基本上沒有發生什麼太大的事。沒有紛爭、沒人吵架、也沒有發生鬥毆，算是相對少見的和平一天。前兩天認識了冠至，昨天則多記了兩個朋友的名字——分別是秉霖跟仲敏。他們都是昨晚 \u0026ldquo;算命大集合\u0026rdquo; 的時候我趁機記起來的。我們昨晚在我的房間開了一個小小的 party，起因是因為我窩在床上看我的《紫微進階》，然後明儒看到之後就問我會不會算命（因為看到我一直在看那種類型的書）。我說會，也幫他算了一下，他覺得挺準的，就把其他人給拉過來了。整體而言， party 的氛圍滿好的，如果之後能夠維持昨晚的熱情和心態認識更多的人就更好了！\n此外，昨天早上也被保全給小唸了一下，原因是我洗澡的時間太早了：因為以前的固定生活，我習慣在 5:40 ~ 5:50 之間起床，然後洗澡（順便刷牙）。但因為這裡表訂的開燈時間（也就是起床時間）是 6:35，加上浴室緊鄰著其他人的寢室，可能因為這樣就被人給投訴了吧？看來之後還是得把洗澡的時間調整成下午或晚上才可以了（但不考慮睡前的 60-30 分鐘，因為那時候搶浴室的情況會最嚴重）。最後一間值得分享的事情是：我把《紫微進階》給全部看完了！準確來說是 \u0026ldquo;星耀篇\u0026rdquo;、\u0026ldquo;四化篇\u0026rdquo; 這兩個篇章。最前面的 \u0026ldquo;快速排盤\u0026rdquo; 對我沒有太大幫助所以我就直接跳過了；然後最後面的 \u0026ldquo;名人盤例\u0026rdquo; 因為我對那裡面大多數的人都不熟，加上沒有比較細節的大事年表，所以目前的參考價值不大也同樣跳過了。再來就剩下《高階 1》跟《易經》了，加油！\n"},{"id":92,"href":"/_trash/diary/202401/20240130/","title":"日記","section":"_Trashes","content":"\r日記：2024/01/30\r#\r第 9 天，今天的太陽依舊從東邊升起。\n仲敏今天下午離開了，算是毫無徵兆的那種，早上起床量血壓的時候，護理站的姊姊突然跟他說他今天可以出院，要離開，然後他就去整理行李了。明儒之前也有說過：「志願役的離院時間算是比較不穩定和突然的。」我想這又是其中的一個例子吧？總得有點尷尬，我還來不及跟他說「那天晚上幫他排的命盤是錯的。」他就走了 \u0026hellip;看來這就是緣分吧？或許我不該在這件事情上面太過執著（雖然對我來說有點難）。\n今天同樣也做了幾件比較重要的事：首先是我確定了「我在過年的期間（小年夜 ~ 大年初五），連 4 個小時的『暫時外出』都不可以。」這也意味著今年會是我從小到大以來，第一次在小年夜的晚上沒有待在家裡吃飯，不知道他們會怎麼想呢 \u0026hellip;。有點小好奇？之後得再多加把勁，讓第二次的機會降到很低很低（甚至是 0）才行。其次是過年期間的會客仍然開放，所以他們還是可以來這裡看我 15 分鐘，這對他們來說應該是個好消息。\n然後我今天問到家訪的社工師的名字了！會問社工師的名字是因為我爸媽有點在意社工師對我這個狀況的看法？聽我爸說社工師好像有特別打電話給他，問他我之前說的那些東西是不是真的？雖然沒有問到確切的聯絡方式，但有了社工師的名字之後，他們應該就好聯繫許多了吧。不知道他們會問她什麼問題？希望不要一直黏著她問東問西，造成別人的困擾才好 \u0026hellip;。\n再來，算命的「行程」在今天仍然持續。自從名如他們發現到我會算命之後，我一直都會保持 1~2 天幫 1~2 個人算命的節奏（而作為算命的交換，他們要把當天的夜點給我）。今天的客戶是冠至和金城：冠至的沒什麼特別的地方？是命宮紫府在寅的格局，雖然煞星（包含陰煞、截空）的位置不是很好，但他重度憂鬱的狀況倒沒有很明顯地看出來？可能是我漏看、也可能是功力不夠、再不然的話 \u0026hellip;就是業力引爆在他自己身上了吧；再來是金城的命盤，金城的盤是命宮天梁在亥，三方四正基本上還滿漂亮的，一些懂得紫微斗數的老前輩們圍著那張盤聊了很久，大家基本上都沒什麼負評。至於為什麼他會進來住院嘛 \u0026hellip;推測是因為他剛好連續走了幾年很爛的流年 + 大運才導致的。\n"},{"id":93,"href":"/_trash/diary/202401/20240131/","title":"日記","section":"_Trashes","content":"\r日記：2024/01/31\r#\r1 月的最後一天，也是來到這裡的第 10 天。\n扣掉時不時就會有人互罵然後嘗試打起來（或者真的打起來）這點，習慣這裡的生活之後，就開始有點養老院的感覺飄出來了。這 2~3 天陸陸續續出院了很多人，明儒在今天下午也出院了。同時因為接近過年的關係（現在進來的病友會跟我們一樣不可以放年假，要在裡面過年）自從程育進來之後（他 23 入院，我 22 入院），院內就再也沒有新人了。現在的人數相比第一天我進來的時候少了約莫 10 左右，這也算是繼 \u0026ldquo;確診事件\u0026rdquo; 之後，第 2 次感受到院內的冷清。\n程育今天去做了心測，所以從今天算起，最慢 30-35 天他就可以出院了，但他的狀況時好時壞，總有些讓人摸不著頭緒？希望他能順利度過院內剩下的時間。今天也發現了新的休閒活動 （其實是之前下午都關在房間看書，沒有注意到）。在下午短短 3~4 個小時裡面也跟大家打了麻將、下西洋棋、象棋、暗棋、和五子棋。這些活動算是這邊少數的休閒之一（其餘的應該只有看電視跟自主運動了？）\n至於閱讀的進度 \u0026hellip;老實說不是很理想：《高階》目前只看完紫微星系的部分（前面 6 個章節），晚一點打算補看天府、太陰、和貪狼（7-9 章）的內容，預計後天或大後天要把這本書給看完，而《易經》則是完全沒有進度（半放棄狀態）。但與之相對，這幾天我起盤的速度快了許多，除了原本的紫殺之外，現在的我也能背出紫破和紫微獨坐的盤型了，5 組的暗合星耀則是已經記起來了，出院之前沒意外的話，能夠把這些東西完全記熟。\n最後是小小的自我檢討：今天中午打了一通電話給我妹，有試著想要隨便聊點什麼，稍微練習一下自己的口條。但可能是真的沒有什麼話題吧？也可能是因為我太久沒有跟別人聊天的經驗了。我妹接起來之後我完全不知道要說什麼。再加上她的語調聽起來挺累的，我也不想要一直吵她，所以我只是匆忙說個幾句就把電話給掛掉了，超級爛的，哈哈哈！以後得多多練習跟人說話才行！\n"},{"id":94,"href":"/_trash/diary/202402/20240201/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/01\r#\r終於來到了 2 月的第 1 天～\n或許是待在這邊太無聊的關係吧？「韓國瑜當上立法院長」這件事竟然可以引起我的興趣！？先不論我是高興還是難過，但有點難以想像我竟然會因為政治的事情而有這麼明顯的情緒起伏。畢竟在住院期間，每天不是躺床，就是走路、看書，偶爾看看電視，看看籃球，然後晚上打打牌就睡覺。唯一能夠接收到外界訊息的管道就只有 3 餐時間的新聞台、以及時有時無的每日報紙（完全無 3C、無電子的生活）。但也多虧這樣的生活，讓我慢慢養成了「閱讀」的好習慣。不只是「書籍」的閱讀，我也開始比之前更加用心、更加仔細地「閱讀」身邊的一些人事物了！（病友的心理狀況拉、對話內容啦、或者是觀察鳥、觀察花、觀察草\u0026hellip;之類的）不知道在這之後能不能「讀」出什麼有趣的東西呢？真是令人期待。\n此外，今天輔導長又來看我了。他說今天會過來的主要原因，是把我們連上的另外一個人給帶來 803（我猜是 17 號？）所以就順便過來看看我，問我過得如何？有沒有需要幫忙的部份這樣。雖然這些對話也許只是輔導長的例行公事？但這多少也讓我對他們的印象變得更加和緩一點。其實我自己心裡也很清楚不論是輔導長，還是班長、士官長、和連長 \u0026hellip;等都是好人。只是我真的無法適應那裡的生活，所以現在才會待在這裡。\n然後是紫微斗數的部分：原本預計明天（或慢一點後天）會看完的《紫微高階 1》在今天全部看完了。昨天後來沒有持續看下去（因為後來太累了，在寫完日記之後只去廣場散個步、吃個藥、就直接回去躺床了），但今天一口氣把包含輔星在內的後續章節全部都給讀完了（7-32 章）。《高階 1》的感想跟前 2 本差不多：雖然大部分的內容都已經知道了，但同樣還是有從中學到一點新的東西：像是南派裡 6 線（活動線、成就線、行動線、桃花線、享受線、和光明線）的名稱由來和相關作用、同干同氣的細節說法、以及以六親立太極的新詮釋 \u0026hellip;等，都是之前沒有自細發現過的東西。\n最後是最重要的事䞍：之前我妹他們來會客的時候，幫我買的 2 張電話卡消失了！不知道是消失在護理站裡面，還是她們本來就沒有把電話卡交給護理站的姊姊們？如果這件事是發生在一個月前，我可能會以「就這樣算了吧～」來為這起事件劃上句點。但此刻的我應該會找時間跟我爸媽抱怨一下，表達一下自己覺得比較不滿意或疑惑的情緒。畢竟偶爾讓人覺得「我有時候也有點麻煩」好像也不是什麼壞事？\n"},{"id":95,"href":"/_trash/diary/202402/20240202/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/02\r#\r程育今天被帶進保護室了。\n保護室顧名思義，就是會被醫生和護士們重點「保護」的一個區域，通常要在院內做出比較明顯、比較重大的危險行為（像是暴力、自殘、或其他容易對他人產生潛在危害的行徑）才會被關進去。但程育的狀況有點特別 \u0026hellip;別說是暴力了。在他入院的這些日子以來，我甚至年他一次把手高舉過肩膀都沒看過。他會被「保護」的原因主要是由於它身體內蛋白質、脂質、碳水化合物及微量元素的不足，導致身體無法維持正常的細胞結構和功能，引發體內多種生物化學過程的不平衡，使得機能組織、器官或整體系統的異常功能，影響人體的運作——簡單來說就是營養不良。\n包含今天在內，他好像已經在院內昏倒過 4 次了：第一次是在複診的診間、第二次是在入院之前的會客室安檢、第三次是心測的測驗途中、第四次（也就是最後一次）則是今天中午服藥之後。他因為早上的血壓數值比較低，所以妹護理站的姊姊要求中午吃完飯之後再去量一次血壓（大概是 12:30 左右去），那時候我沒有在第一現場，因為 12:00 ~ 13:30 一般是我的午休時間，所以那時候我正睡得香甜。\n從事後其他人的說法來看，程育是在 12:30 量完血壓之後，一出護理站的門，就直接暈倒在門口了（頭好像還有稍微撞到地板？）。我有點擔心他，多少也對這件事情有點自責（他的班長曾託付我要好好照顧他，因為我是他唯一年紀相仿的同房室友）。但就像阿政和顏勤說的一樣：他其實沒有很努力地在改變他自己，所以我們做得越多，反倒愈加冗余。\n另外昨天的「電話卡事件」大致已經落幕了。最後我們是以「我家人在會客室的時候，以為有把電話卡轉交給護理人員，但其實他們沒有轉交」作為事件的偵查結果（爻辭：天水訟、九二）。爸爸也在今天直接買了 3 張新的電話卡過來，並跟我一起當面點交，確定卡片有被收進我的位置之後才離開。此外，因為昨天已經看完《紫微高階》的原因，今天也開始著手翻閱我一直都很不想面對的《易經》了。我現在已經放棄在出院前把全書看懂了，只求能夠把他先大致掃過、看完一輪。但即使如此，進度同樣非常緩慢，只進行到了\r\\(\\frac{13}{64}\\)\r的地方，不知道什麼時候才能「看」完。\n"},{"id":96,"href":"/_trash/diary/202402/20240203/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/03\r#\r今天也是平凡的一天，所以我們來聊聊別的東西：「夢」。\n來這裡也快兩個禮拜了（第 13 天），如果把午覺也一起算上去的話，在這邊睡著的次數大概也已經超過 20 次了吧？但很意外地，在這超過 20 次的夢境裡面，大約只有不超過 5 次的好夢的印象。剩下的夢境除了今天早上的內容之外（阿嬤找我求救，我在趕到之前聽到碗盤摔到地上的聲音，然後驚醒），其餘的夢境無一例外，全部都是當兵那短短 6 天裡面發生的事情，或者是相同的人（我、鄰兵、班長與其他幹部們）因為類似的事情，產生類似的結果。\n說得簡單一點：在那些「惡夢」裡面，基本上我不是在被罵、就是在準備被罵的路上。被罵的原因各種各樣：但凡是早起、集合、內務、行軍、吃飯、拿東西、唱歌、司令台點名 \u0026hellip;等，甚至還有幾次是睡到一半被嚇醒，睡回去之後繼續被罵的經驗。現在（寫日記的當下）想想：會不會我真的對那個禮拜的生活，累積了很多很多的壓力跟負面想法啊？至少我的潛意識應該是這麼認為的。\n即使現在的生活大致都很放鬆，也還是不能撫平那時候隨時繃緊的神經跟意識嗎？或者是我還需要再多一點的時間呢？我也不確定。但在我理智上線的此時此刻，如果你問我「要不要回去軍中繼續受訓」，我還是會回答同樣的那一句話：「除非有人能跟我解釋我所有ㄉㄚ動作裡面，背後的所有動機與原因，不然我寧願現在找一個方法逃兵，或者是捐光我身上所有的錢，然後去死一死。」\n在當兵以前，我是一個相信「凡事都會雨過天晴」的那種人，但捏許正事因為這樣的想法，神明（或某種佛祖上帝之類的人）才會讓我體驗了一次「我無法單以『凡事都會雨過天晴』的心態來面對跟處理的狀況。」在當兵之後，我的態度很明顯地改變了，現在的我是這麼認為的：「不果你不喜歡某件事情，那你就要直接拒絕；如果你拒絕不了，那就要想辦法改變；如果你改變不了，那請盡可能地逃走；但如果你連『逃走』這件事情都做不到，那就去死一死吧。」\n"},{"id":97,"href":"/_trash/diary/202402/20240204/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/04\r#\r今天我入院以後的第 14 天。也是我入院之後第 2 次會客的日子——這次來的人是我妹、和我的二表哥。\n很意外地，他們帶來的東西跟我之前打電話報平安時跟他們說的東西一模一樣，沒有少任何一樣，而且也沒有多出任何一樣。這滿少見的？不知道他們的心態是不是有發生了什麼變化？有點令人好奇。此外，從我妹的談話裡，可以感受到從我住院以後，家裡的氛圍一直都很低迷（甚至有緩慢下降的情況），這同樣也不是件好事，等等 19:40 打電話的時候再跟他們多聊幾句好了。\n今天我把《易經》看完了。用「看」這個詞有點不精確，精確一點應該是「掃視」完才對。至於心得 \u0026hellip;，以我這幾天翻閱易經的經驗來看，我覺得要把那本書讀熟、讀懂，認真來說是有可能辦到的，但我覺得它的機會成很有點太高了——如果要把目標定成「在出院前讀懂《易經》」的話，那就會花上大量我平常自主運動、跟別人互動、聊天、下棋、和深度對談的時間。所以我的策略改成了「先掃視一次，大致了解每一個卦象所代表的背景和意涵，等之後有空再慢慢把它讀懂」上面。\n然後是之後的讀書時間，這次會客他們帶來的書本共有 4 本，分別是《紫微高階 2》《紫微高階 3》《紫微高階 4》和《Linux 鳥窠的私房菜 - 第 2 版》，相對於全力沈潛在《易經》的學海裡面，我會則傾向把今天帶來的這幾本書分別讀完，效益應該會比較好。\n最後是今天的另一項 \u0026hellip;軼事？聽表哥說，我媽好像一直以來對於我病情的理解都是「在大部分的時候面無表情，沒有正常的回話能力，基本上只會『嗯』『嗯』『嗯』的回答而已。」痾 \u0026hellip;我覺得這個等等打電話應該也可以好好澄清一下，我平常打電話的回應應該超級正常的吧？還是只有我這麼認為？其他人都覺得我變得很沒有回話能力了。\n"},{"id":98,"href":"/_trash/diary/202402/20240205/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/05\r#\r入院第 15 天，因為院內來了 3 個新的病友\r\\(_{[1]}\\)\r，其中 2 個和我一樣是義務役的軍人，另外一個則是睡在我隔壁的一個阿伯。還沒認識這 3 個人，所以今天還沒有辦法寫太多關於他們的事情，之後再花時間慢慢瞭解吧！今天開始讀第 2 本紫微高階的書籍，雖然只是閱讀的第一天而已，但已經看完了大約\r\\(\\frac{1}{3}\\)\r左右，預計順利的話，明天就可以把這本看完了。\n或許是時隔多年才出版的原因吧？這本書（《紫微高階 2》）相較於前面 3 本紫微斗數的書籍，哲學跟說教的比重佔了很多。但這也不是說它的價值就變得很低，目前看下來還是有可以學習跟注意的東西。今天也聽冠至說了很多他在入院和入伍之前的事情，從他的內容來看，可以感受到我們兩個平常的生活圈真的差很多（他算是在外面一個蠻有地位的 8+9）。也因為這個原因，我打算在這裡跟至少 10 個左右的病友進行比較深層、比較內心的聊天或談話，冠至就當作這個計畫的第 0.5 個吧！可以的話，接下來的 9.5 個人中也希望有一些比較中年或比較年長的病友（雖然他們幾乎都只說台語，然後我台語超級爛就是了 \u0026hellip;）。\n另外，因為放完年假的關係， OT(Occupational Therapy) 的姊姊們久違地出現了！今天早上 10 點第一次體驗了採買的活動，還滿有趣的，在不超過 400 元的前提下，盡可能買到最多自己想要的東西，唯一比較可惜的地方是：或許是我已經離之前的「普通」生活有點距離了？在的我對於零食完全沒有興趣、飲品也只有水、波蜜果菜汁、和麥香奶茶（裡面不能喝）有興趣而已，所以我在這次的採買裡沒有買到任何東西，只是看著他們買著想要的東西而已，哈哈哈！\n1：嘉祐、翔之、跟永清阿伯\r#\r"},{"id":99,"href":"/_trash/diary/202402/20240206/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/06\r#\r過年的前 4 天。\n今天院內離開了大約 10 人左右？包含阿政、顏勤、秉霖、耿顯 \u0026hellip;等，除了顏勤是放年假（過年後會回來）之外，其他人都是出院，幾乎所有在這邊認識的人都走了呢 \u0026hellip;。也因為院內空了很多很多的位置，所以院方就把平常安置在 2 樓的其他病友們全部轉來 1 樓了（為了方便管理）。用總數來看的話， 1 樓的總人數（相對昨天）反而是比較多的，這也代表了平常 2 樓也有至少 10 位以上的病友在居住。此外，因為 2 樓的病友相對於 1 樓來說，基本都是比較慢性、或比較嚴重的精神病患，所以這裡也變得更像大家世俗中所想像的 \u0026ldquo;精神病院\u0026rdquo; 了，哈哈哈！\n今天國軍也為還留在院內的所有軍籍病友發放了一人 1000 元的過年紅包，是以 \u0026ldquo;住院慰問金\u0026rdquo; 的名義發送的，但紅包無論是何種軍階都是固定 1000 緣就是了，所以對於金城來說應該算是比較小的損失（他是上尉）。今天也見到在軍中同連的 17 號了！原來他之前都住在 2 樓嗎！看來他真的過得比較辛苦呢 \u0026hellip;。雖然還沒跟他搭話，但從遠處觀察的結果來看，他焦慮、活動力低下、跟憂鬱的氛圍還是挺明顯的，希望他成早日擺脫這種壓力所帶來的痛苦，慢慢讓自己放開一點。\n說到放開，程育今天從保護室裡放出來了！自從他出來跟我打招呼之後，他感覺就像是變了一個人似的？從原本一天說不到幾個字的狀態，到現在看到人就打招呼，順便聊個 2-3 句，管他認不認識眼前的那個人。他之前應該真的是營養不良吧？然後現在比較像是營養補太多 \u0026hellip;。現在的他真變得超級熱情，老實說我有一點招架不住（哈哈 \u0026hellip;），但也不能否認：因為他那自來熟的個性（加上一定要把我拉在他身邊的個性），我也因此順勢認識了 2~3 個平常只會點個頭、說早安晚安的人。到今天為止，大概也過完在這裡近一半的天數了（一般的義務役軍人會抓 30-35 左右的天數）老實說這樣的日子也過得滿快的，有點擔心我想讀的書會不會讀不完？我看之後的幾天還是多加一點讀書的時間，拼拼進度好了！\n"},{"id":100,"href":"/_trash/diary/202402/20240207/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/07\r#\r冠至今天也出院了。\n昨天的 OT 活動時間廖醫師有來找我（廖醫師就是我的主治醫師，那個當初決定讓我入院的醫師），來做一些例行性的問診。我跟他說「心情方面目前沒有什麼問題，但生活上有個地方倒是挺困擾我的——睡在我左邊跟右邊的兩個阿伯打呼都超大聲的，讓我晚上很難入眠。」所以在經過一些跟廖醫生的討論之後，他從今天晚上會幫我加重肌肉鬆弛劑的藥效，並多補半顆輕型的安眠藥給我，希望會有效。\n早上程育在聽到我跟廖醫師的談話之後，也在 OT 結束之後給了我一個耳塞讓我用，中午午睡的時候試用了一下，隔音效果的確滿好的，真感謝他。程育今天同樣也呈現一個很活潑、很好動的狀態，不過因為下午陸陸續續下了幾場大小不等的雨，所以我們能活動的空間就縮小了很多，也因為下雨的關係，院內的溫度低了許多，大部分的人都會在這時候選擇把自己關在自己的房間內，所以他不再能像之前一樣隨便走、隨便看到人、隨便打招呼了。\n另外，因為今天是禮拜 3，所以今天早上的服藥時間（9:00）也會順便幫所有的病友紀錄體重。記得我入伍之前最後一次量是 70.2，然後 6 天後入院的量的體重是 63.6，到了今天（入院的第 17 天）體重已經慢慢回到 66.9 了！從復原的角度來看，應該還算可以～但從 BMI 的角度來看嘛 \u0026hellip;，好像快要超過標準的 18~24 了，可以的話希望出院之前不要再變胖更多（或胖的健康一點）不然之後健身就會很辛苦、很辛苦 \u0026hellip;。\n最後！今天的 OT 活動是過年前的最後一次，是為期 1.5 小時（10:00 ~ 11:30）的卡拉 ok 歡唱。只能說這裡不愧是 \u0026ldquo;高齡化社會\u0026rdquo; 特別明顯的地方，幾乎所有他們唱的歌我都沒聽過（扣掉一首大家應該都比較熟的海波浪），我也跟金城和小 OT 炫耀證明我的歌喉，點了一首永邦的每次都想呼喊你的名字，只能說 \u0026hellip;久違的唱歌真的好爽（可以只唱 1, 2 首就聽別人唱歌更爽），希望以後多一點這樣的唱歌活動！\n"},{"id":101,"href":"/_trash/diary/202402/20240208/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/08\r#\r來到這裡的第 18 天。\n你天天氣明顯轉涼了，早上出房門之後，皮膚的體感溫度大概只有 19 度上下吧？（昨天至少有 23, 24）如果把風的因素加上來的話，體感大概可以再扣個 3~5 度左右。不知道是因為加藥的關係？還是我的身體一下子轉太涼了？今天一整天感覺都懶懶的，所以早上刷牙漱口之後，就決定給自己放半天的假——吃完藥（8:10）之後，就回被窩睡到中餐（11:30）再起來。算是打破了之前跟自己說「早上起床後，在中午吃飯之前都不可以回去休息」的規定，所以為了找個合理的藉口理由說服自己，我的說法就是：「都連續工作這麼久了，讓自己放個半天假應該不過分吧？」算是小小的醜 1，可以的話，希望之後自己可以盡力拉長發生醜 2 醜 3 的時間不要太快（或甚至不要有～）。\n今天午睡（13:30）過後，護理站也辦了一個健走活動——就是把全體病友從被窩中拉出來，大家一起繞著廣場走 30 分鐘。這個類似 ant mill 的活動也讓我了解到「我真的是一個走路走得超•級•慢的人。」就連 50-60 歲左右的阿伯、阿公走路都比我還快 xD！看來我抽到陸軍是比較不適合的，我應該比較適合空軍才對（空軍行軍走路速度超慢）。在健走活動結束之後，護理站的姊姊們有給我們每個有參加活動的人一人一瓶波蜜果菜汁（雖然沒有麥香或阿薩姆奶茶，但還是超幸福！！），也意外發現波蜜上面寫的是 100% 的濃縮原汁，所以這是代表它比較健康的意思嗎？如果是的話以後改喝波蜜當習慣好了。\n"},{"id":102,"href":"/_trash/diary/202402/20240209/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/09\r#\r今天是入院的第 19 天，也是農曆的除夕。\n按照往常「過年會放鞭炮」的慣例習俗，大概可以預見睡不著的晚上了，希望程育給的耳塞除了可以抵禦左右兩邊的打呼聲之外，也可以抵擋今天晚上的鞭炮攻勢。今天早上幫漢哲算了一次命，過程中意外被護理站的姊姊給發現了。等漢哲的算命結束之後 1-2 分鐘，姊姊就偷偷跑過來問我有沒有空？然後就把我帶進護理站幫他們算命了（哈哈）！前前後後看了 4-6 張命盤，得到的感想是——命盤的基本格局真的有差。\n在院內的病友們，無論是明儒、秉霖、仲敏、漢哲、或其他人 \u0026hellip;等，大致上都是在排完盤之後，3-5 秒內可以馬上看出某個（或某些）宮位特別不好的（但金城不算，他是在大運不好的時候，又剛好連續走了 2,3 年爛到炸開的流年運）。但姊姊們（或他們的小孩們）就很難有這種「馬上看到不好的地方」的現象，所以他們的盤相對於住在院內的病友來說，論命的 \u0026ldquo;驚奇感\u0026rdquo; 相對就沒有那麼強烈了，對自己而言算是小小的可惜（但對他們而言這是很好的事情～）。\n然後我今天也看完勸學齋主的《紫微高階 3》了，而《高階 4》目前只看完引言和目錄，同樣也可以感覺到它們都是還不錯的書～真是期待，哈哈！除此之外，今天也有年前的加菜：分別是午餐餐後的紅豆豆花、跟晚上的超～大雞腿便當。該怎麼說呢 \u0026hellip;，好難想像不到一個月前的我，每天都還需要很認真很用力地跟自己說 \u0026ldquo;要活下來！\u0026rdquo; 才可以撐下去，但現在的我真的感覺好幸福、好幸福 \u0026hellip;。\n"},{"id":103,"href":"/_trash/diary/202402/20240210/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/10\r#\r今天是入伍的第 25 天、入院的第 20 天，也是農曆甲辰年的第 1 天。\n昨天除夕的晚餐時間跟阿公通過電話了！聽起來還蠻順利的，阿公的心情似乎還算不錯，不知道他們的年夜菜吃了什麼？應該也跟往年一樣是從外面買來的吧。除此之外，昨天也打給了工具人大頭，主要需要麻煩她幫我拿晉安的聯絡方式，還有 BOSS 年末捐款的一些活動細節。她們年末應該會有類似的募款活動吧？有的話我可不想缺席～畢竟捐錢一直都是我很熱衷的一項活動！哈哈哈！（雖然有時候會被人騙錢就是了（哭））。\n昨天也照常 21:00 吃完藥之後就直接躺床睡覺，就像昨天日記說的：原本以為晚上 11, 12 點左右會被過年的鞭炮聲給吵醒，但意外地並沒有！反倒是 1 點多快 2 點多的時後有稍微醒一下，起來上廁所。看來廖醫生跟程育耳塞的組棉 combo 效果非常有效呢！昨天也是在我有記憶以來，第 1 次除夕晚上不是在家裡面吃飯，老實說我在當兵之前的確有想過「乾脆入伍之後的 4 個月都不要回家，連過年之類的也在軍中過就好了。」但我壓根也沒有想到我最後會是在精神病院吃除夕的年夜飯就是了～說實在還算蠻新鮮的，雖然感覺很不真實，但它的確真實發生了。\n另外，關於閱讀的部分：《高階 4》目前看到「天同」那章的一半（第 5 章的一半），預計明天（最慢最慢後天）會把整本書本看完（共 17 章）。也因為《高階 4》是我手邊最後一本關於紫微的書籍的（《高階 5》和其他的書我都還沒買），所以預計在下次會客的時候，我會麻煩家人帶古占（古典占星）、現代占星、或者是一些藏傳佛教的書籍。這 3 個大方向目前是以 \u0026ldquo;藏傳佛教\u0026rdquo; 的興趣最大：畢竟之前準提佛母有跟我說「我算是個跟藏傳佛教蠻有緣的人，有機會的話可以多多了解。」但我從那之後到現在過了 2~3 年才開始起步，是不是有點太晚了啊 xDD.\n"},{"id":104,"href":"/_trash/diary/202402/20240211/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/11\r#\r（2/12 10:05 補寫）\r#\r今天永清阿伯被送進保護室了。\n永清阿伯就是過年前新進來，睡在我隔壁的 23 床病友（詳見 2/5 的日記內容）。永清阿伯從外人來看的話，會覺得他一直都有自言自語的習慣。他平常人很好、很有活力、遇到人會打招呼、也可以正常地聊上幾句話。只不過永青阿伯有一個小小地問題——就是他會跟一位只有他才看得到的「朋友」聊天。我們先暫時把祂稱作 A 好了～從阿伯的行為（和我自己的感受與觀察）來看，A 應該是隨時隨地都跟在阿伯身邊，A 不會傷害他，但在日常生活上很常跟阿伯持相反的意見。\n很常聽見阿伯說出類似「就跟你說不要這樣擺嘛」「好啦好啦明天開始聽祢的」之類的內容。但 A 感覺起來並不是阿伯的親人或朋友之類的熟人？我有嘗試過問阿伯說 A 是誰？阿伯那時候就只會說「就站在那邊的那個啦」，然後如果追問其他細節（像男女、年紀、外貌 \u0026hellip;之類的）他同樣也只會說「阿反正就那邊那個啦」。護理站的姊姊們有因為想要 \u0026hellip;讓 A 消失(?)特別開給阿伯一些比較額外的藥，但阿伯每次只要看到那個藥就會很抗拒去吃它。\n這次阿伯會被關進保護室的原因也是跟這個有關：案發當時我正在洗澡，所以沒有目擊到第一現場，但根據程育所說（程育 24 床），那時候是吃完晚餐飯後藥的自由時間（18:00 後），他跟阿伯歐在房間睡覺，接著突然進來了至少 4 個左右全副武裝的保全大哥，說他們在餐廳的某個角落找到阿伯偷偷吐掉的藥，所以要阿伯重新把藥吃掉。但阿伯抵死不從，所以就這樣被關進保護室了（事後回想有點無釐頭，也有點搞笑），總之，這就是今天的日記內容了。\n"},{"id":105,"href":"/_trash/diary/202402/20240212/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/12\r#\r（2/13 07:45 補寫）\r#\r連續 2 天忘記寫日記，有夠懶惰 XD.\n今天久違地跑了一次體能訓練，會這麼做的主要原因有 2 個：第 1 個是自從我入伍之後，就一直有比較嚴重的便秘問題，這幾天跟護理師的姐們討論過後，她們說之前在軍營裡可能是因為壓力太大，在這裡則可能是運動量變小的關係（加上這裡不提供類似早餐店大冰奶之類的飲料），所以建議我可以增加運動量看看；另一個原因則是因為家裡帶來的書籍我昨天晚上全部都看完了，所以自己的時間也變多了（一天大概多了至少 3 小時有）。因此，綜合上述兩點：今天的我就把這些多出來的時間拿來跑體能了。\n今天因為是久違地運動（入院之後的第一次），所以只先暖身跑了 2 組遇線折返（一組來回一次，所以總共是來回 6 次），兩組中間跟做完之後會再做一次的「手忙腳亂」當短休息。整體而言的心得是：雖然只過了大概 1 個月，但體能很明顯地下降了很多。看來之後得多做幾次，把之前的體能給拉回來才行！此外～今天也有一個值得紀錄的事情：那就是我的體前彎可以在膝蓋不彎曲的前提下碰到地板了！（入院之後每天都有在練習。）如果用以前「25 公分 = 剛好碰到地板」的標準來看的話，我的進步幅度大概就是從 8~9 左右進步到 24.8 ~ 25.1 之間。對我來說算是蠻高興的一件事情，再來的目標就是 30，然後 35，再到 40。\n最後，今天下午 13:30 也有會客（這次來的是我爸跟我妹），誠如之前我說的，他們幫我帶來的約莫 6~8 本左右與藏傳佛教有關的書。它們是我之前一個國中朋友，在開始吃齋念佛之後所閱讀的一些書籍。準確來說：是那個協會（或那個佛堂？）免費發送給有緣人的一些書籍。雖然基本上都是一本一本拿，但那時候的我很厚臉皮第一次拿走了一整套（約莫 20 本書），然後就擺在我的書櫃當裝飾了 XD，希望這次拿過來之後，它們可以派上用場，讓我多學到一點關於藏傳佛教的理念、知識、和相關的活動與習俗！\n"},{"id":106,"href":"/_trash/diary/202402/20240213/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/13\r#\r入院的第 23 天。\n雖然賴床的狀況有點惡化（從原定的 5:45 被我拖到快 6:00 才起來），但今天早上在簡單的盥洗之後，還是以 3 組遇線折返、3 組 50 下開合與 10 下伏地挺身、和 20 圈的廣場繞跑為美好的早晨拉開精力充沛的序幕。可以感受到在過程之中，身體幾乎維持在 95% 極限的狀態，如果全部再多加一組的話（也就是多一趟折返、50 次開合跳、10 伏地挺身、跟 5 圈廣場）就會是我 102~105% 的極限了。\n之前讀碩士的時候，一直有「一天到底要怎樣才可以喝到 2000cc 的水啊」的疑問，但我現在找到解答了！原來這麼簡單：就只是因為我上大學之後運動量一直沒有像現在這麼多而已（以前只有簡單的每天跑 3000）。今天光是早上的「第一次」訓練，就喝掉了 1500+ 的量，配上早上服藥後的「第二次」和中午睡醒後的「第三次」，我今天大概喝了 4000~5000 有吧？身體目前沒有什麼太大的問題，唯一比較擔心的事情是我第三次最後的收操沒有收得很好，所以小腿腳踝那邊到現在都還是有一點點酸酸的，有點期待明天、後天 \u0026hellip;之後的運動時間。\n另外，今天還有 2 間可以分享的事情：第 1 件事情是賴桑在下一次的會客（2/17, 13:30）會來看我，不知道他那時候會帶什麼東西來？真是期待；另一件事情是——佛教相關的書有點 \u0026hellip;\u0026ldquo;難讀\u0026rdquo;。不知道是不是剛好都挑到我比較不擅長的書的原因？扣掉任何跟算命有關的書。我比較喜歡那框架感很薄、思考空間很廣泛（像是傳記類、哲學類、）或者是框架感很重，但相對基礎同樣也很牢實（像數理化）的書。但這次他們帶來的書剛好是那種「框架感很重，但基底很不明確、無法證明、甚至幾乎沒有，或底層根據本身就互相矛盾」的那種書。看來我下次還是麻煩我家人帶占星類型的書好了。\n"},{"id":107,"href":"/_trash/diary/202402/20240214/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/14\r#\r今天是農曆連假的最後一天（大年初五）。\n從今天開始來寫日記。\n回顧整個過年期間，今年應該是我過最輕鬆的過年連假了吧？沒有整天塞車的家族旅遊、沒有三間五間的廟宇參拜、也沒有人擠人的吵鬧氣氛 \u0026hellip;。現在仔細回想，我好像真的有一點點人群上的密集恐懼症。雖然在這裡同樣是團體生活、我又睡在兩個打呼超大聲的阿伯中間（永清跟柏豪）、我們 40 個人共用 6 間公共浴室和 4 間廁所、有時候也還有一些比較嚴重的病友會大吼大叫，或自言自語地高談闊論、而且這裡能夠活動的空間小到連我家隔壁學校操場的\r\\(\\frac{1}{4}\\)\r都不到。但這邊的大家基本上都很保持距離，不會任意踩進你的個人空間、也幾乎沒有（或完全沒有）必須應付的人際關係、也不會被生活上的突發事件打擾。這種「做任何事都不需要考慮到任何人的感受」的情緒真的很讓我感到放鬆，出院之後也盡量幫自己營造一個這樣的生活空間好了？大約花個 2~3 年的時間。\n今天同樣做了一些的體繩訓練，一次是剛睡醒的早晨、另一次則是中午吃飯前的空閑時間。稍微思考和計算了一下，如果要很認真、很用力地運動的話，一天 4 次的體能訓練應該就是極限了（無論是時間，或者是體力）：剛睡醒（5:45~6:30）是一次、早上 OT 之前的自由時間（8:50~09:50）是第二次、下午睡醒之後（13:30~14:30）是第三次、最後一次則報完平安之後的那段時間（19:50~20:50）。剩下的自由時間分別放在三餐、OT 活動、下午打麻將（15:30~17:00）、跟其他零零碎碎的瑣事 \u0026hellip;應該就把一天的所有時間都填滿已經過完了。\n此外，這邊因為有進食管制的關係，所以不能夠做飲食控制（所以體重就很難調整到自己所希望的數字上）。因此在體重的問題上，現在的戰術就是盡可能地多操體能、多運動，先把身體多餘的脂肪先換成肌肉，等出院之後再控制吃的東西⋯⋯降低熱量、同時維持（或提高）在院內的體能強度，但事訓練的時數要再縮地更少一點（畢竟之後還要工作，所以沒那麼多時間）把體重慢慢變成自己喜歡的樣子。\n最後是一點小確幸的紀錄：今天的體前彎同樣也可以碰到地板，但跟之前一樣，雙腳的膝蓋那邊還是需要稍微的彎曲才行。前幾天為了想讓自己可以再壓低一點，所以找了一個比較有高低差的位置。今天實測過後發現不太能用（因為重心會歪掉，不能長時間站在那裡），明天貨後天再來找幾個地方看看，看看自己在出院之年能不能努力拼到 30~40！\n"},{"id":108,"href":"/_trash/diary/202402/20240215/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/15\r#\r（2/16 17:20 補寫）\r#\r大年初六開工。\n可以感受到無論是我們的主治醫生、還是原本就在這邊工作的護理師們都開始忙碌了起來。原本從 2 樓下來 1 樓的病友們也重新回到 2 樓的住所了。今天父親來到護理站，把我的健保卡交給了我的主治醫生（因為我心測的評估結果已經出來了，他們需要把評估的結果 key 到我的健保卡裡，但我當初入院的時候沒有把健保卡交給護理師她們）。而他們除了要把報告記錄在我的健保卡裡面外，嘉義的部隊也會需要備份一份我心測的資料。所以早上護理站的姊姊也跟我說「等等中午吃完飯可以打個電話聯絡一下部隊，請他們這 2 天找個時間來取件。」但部隊那邊的效率比我想像的還要高出許多，大概只過了 2 個小時不到吧？部隊那邊就直接派人來護理站取件了（甚至還不到中午的吃飯時間）。所以根據之前的經驗來看：接下來的 1 個禮拜，廖醫師（也就是我的主治醫師）會根據心測的結果寫出一份診斷報告，然後會再把診斷報告寄送到我的連隊中（過程大概也是 1 個禮拜），連隊收到我的診斷報告之後就可以把我的停役令發下來，我就可以出院了。\n除此之外，今天也是我第 1 刺在這邊上洗衣服、曬衣服、和收衣服。在這之前我的衣物都是在會客的時候跟家裡的人交換的（穿過的包一包給他們、洗完的包一包拿給我）。會想要自己洗衣服的原因主要有 2 個：一方面是想要減輕他們過來的負擔（這樣就不用再帶大包小包的衣服過來會客了）；另一方面也是為了之後自己搬出去而做準備——說起來有點慚愧，但我其實是個滿嬌生慣養的人，一直以來都沒有自己洗衣服過。雖然「在 26 歲第一次洗自己的衣服」代表我還是個生活白痴（因為連這點簡單的事都還不會），但換個角度思考：這同樣也可以代表我距離「非生活白癡」的標籤又更近一步了！果然還是這種相對的正向思考，才是我比較擅長的思考模式。\n另外，我這幾天也得了稍微有點嚴重的（大）感冒，症狀大約是在 14 號中午午覺前後出現的。主要比較明顯的狀況有鼻塞、喉嚨痛、跟吞口水的時候超級不舒服。雖然跟確診的狀況非常相似，但早上護理站的姊姊們幫我快篩之後是 1 條線，所以應該只是普通的重感冒（或流感？）而已，而這也是為什麼我今天的寫日記是補✍️的原——因為我昨天的身體狀況實在是太差了。意識清晰可以給到 1 分、說話沙啞只能給大約 0.5、喉嚨毫無懸念最多只能打 0.1、其他的五官功能（聽覺、視覺、味覺、體溫狀況 \u0026hellip;等）加起來大概也只能給到 0.7~0.8。總共 6 項（眼耳鼻舌身意）的評分依據，僅僅拿了 2.4 分，距離滿分 600 可以說是差得超級無敵遠。\n昨天在沒躺床的時候，還勉強自己做了 2 次的完整訓練（1 次的完整訓練 = 6 次來回遇線折返 + 3 次來回側併步遇線折返 + 10 圈廣場慢跑 + 150 下開合跳 + 30 下伏地挺身）。阿祐還警告提醒我「在這樣做下去身體只會變得更差哦，躺床休息會好得比較快。」所以今天（跟之後幾天）的訓練就都被我給取消掉了，還是乖乖躺床好好養病比較好，哈哈哈！\n最後，我爸今天早上除了帶健保卡來護理站以外，他還額外帶了 3 本從圖書館借來的書給我：分別是《陌生人經濟學》《奧格威的行銷創意與傳奇人生》與《八字決戰一生：先天易數白話專解》。總的來說 \u0026hellip;無論是哪一本，都有點「微妙」的氛圍在裡面。但這 3 本書並沒有全部都交到我手上，因為八字的那本書名有「決戰」二字，安檢的保全覺得它有一點點地暴力影射，所以就把它退件了 XD 真是有趣的判定標準。\n"},{"id":109,"href":"/_trash/diary/202402/20240216/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/16\r#\r從 14 號開始算起的話？今天是重感冒第 3 天。\n狀況相對於昨天算是好上了許多。用分數來量化的話 \u0026hellip;大概已經提升到 31~33 之間了吧？大概就是 \\(\\frac{1}{3}\\)\r的 100% 健康再少那麼一點點這樣。希望明天可以提升到\r\\(\\frac{1}{3}\\)\r，甚至是更高（同時也希望今天的變好只是假象，明天不又繼續讓狀況變得更加不好 \u0026hellip;）。此外今天參考了阿祐的建議，扣掉三餐時間、上廁所、洗澡、和吃藥之外，其他 9 成 9 的時間保持在戴著口罩、躺在床上的狀態。也因為今天幾乎都躺在床上，所以面紙的用量相對於昨天的 4 包來說節省了很多（今天 0.8~0.9）。\n但今天躺在床上也不是整天睡覺、什麼事都沒做。主要還是有做幾件事情：第一件事情是「冥想」（沒錯～躺著也能做哦！）主要就是自己跟自己對話啦，對話的場景有很多（像我自己就至少有長椅、黑房間、跟芒草原三種），內容在這邊就不細聊了；除了冥想之外，我也會思考一些比較現實層面的事情，今天思考的內種要圍繞在「斗數命盤」「社會化」跟「抄經念佛」這三件事情上。\n先從「斗數命盤」說起好了？因為它最簡單描寫——簡而言之，就是默背紫微星在 12 宮中時，所有主星的坐宮會在哪裡，算是加速自己排盤的一個練習，也是一個有點燒腦又很好殺時間的活動（至少對我來說啦）；至於「社會化」跟「抄經念佛」\u0026hellip;先講後者好了：因為我自己是一個迷信（或稱之為 \u0026ldquo;宗教狂熱\u0026rdquo; 或 \u0026ldquo;信仰狂熱\u0026rdquo;）的人，所以這次的重感冒讓我稍微有點認真地想，是不是前幾天開了吃素跟放生的玩笑才會像面再這樣重感冒的（13 號的日記最後面有隱晦地寫到一點點），我有因為這樣而 \u0026hellip;反省(?)了一下，出院之後如果還記得的話，也會認真研究放生跟吃素的相關學問、原理、細節、方式、和功夫。\n最後是「社會化」的問題：我其實從住院之後，時不時就會思考「我是不是要為了『社會化』而做一點改變」這點。因為從核心來說，我是一個很固執、很自私、也很活在自己的框架上的人。但也因為這個性格，間接（或直接？）導致了「我必須要離開軍營，住進精神病院裡面，才能夠讓自己的狀態好轉」這件事情的發生。除此之外，我也在思考「為什麼我會需要為別人的行為而承擔責任」這件事情？聽起來很荒謬對吧？也許對一部分的人來說，這問題就像是「為什麼 1+1=2」一樣直觀又愚蠢，但直到現在我還是沒有辦法給出一個能夠完美說服我自己的理由。\n「因為我們是一個 Team」嗎？但那又怎麼樣？為什麼我們是一個 Team，就要一起分擔所有的壞事；「因為不這樣做的話無法督促整個團隊」嗎？我覺得從這方面解釋只是間接暗示負責領導的人無法做好他該做的工作而已；「因為我有收錢，所以拿了錢就要辦事，接受規則」嗎？那我可不可以把錢退掉？必竟 \u0026ldquo;收錢\u0026rdquo; 這項行為不是我自己主動要求的。總而言之——我並不覺得「連坐」這種懲罰方式會對一個團隊帶來正面的幫助。更為深入地說：我並不覺得「在我完成我份內的工作之後，因為別人並沒有完成他份內的工作，所以我原有工作的報酬就會一被起剝奪」這個行為很合理。\n但不知怎的？我總感覺這個社會、這個世界對於這樣的狀態好像感到習以為常？好像這件事本該就得這麼做才對？就像我對身邊某人抗議了這件事情之後，他給了我一句「但你不覺得你這樣想，就是在逃避問題嗎？」的回覆。直到現在我還是不知道這個回答跟我的問題本身有什麼關聯。也許這就是我現在會被關在精神病院裡面的原因吧？因為我 \u0026ldquo;並不正常\u0026rdquo;。但把話說回來，我其實還蠻喜歡這個議題的，所以沒有意外的話，我可能會一直找人聊天，持續尋找能夠令我滿意的答案。\n"},{"id":110,"href":"/_trash/diary/202402/20240217/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/17\r#\r今天院內又多來了 2~3 個人，包含這些在內，院內自從過完年之後，已經陸續進來莫約 12~15 位的新病友，其中軍人跟民眾的比例大概各佔一半，同時新來的病友中，又有 8~9 成是那種身上至少有半甲刺青的患者。也因為這幾天一次進來了這麼多人，加上我(重?)感冒的狀況時好時壞，所以明如當初給我的其中一向功課（認識包含護理師在內的院內所有人）應該是沒辦法完成了：因為扣掉這些新來的人，舊的病患們我也大概才只記得\r\\(\\frac{1}{2}\\)\r的人，護理是是只記得大約5 人左右——也就是說，我覺得「要在剩下的 14 天內，跟至少 40 位從未接觸的人聊天上幾句。」已經是不可能的事情了。這還是不算上在這 14 天中，又新進來或剛認識就出去的那種人。\n除此之外，今天也有幾個值得紀錄的事情：首先是(重?)感冒的狀況和緩了許多，目前的症狀只剩下流鼻水而已，之前的頭暈、發熱、四肢無力 \u0026hellip;等帳撞幾乎都已經消退（或者完全消失）了。看來廖醫師雖然是精神科的主治醫師，但他對於一般的感冒也是挺有心得的（還是這對一般的醫生來說就像是小學加法一樣簡單 \u0026hellip;？）希望明天（最慢後天）症狀可以完全消除，就可以重新回歸體能訓練了。\n其次是今天又有一次的會客時間。這次的組合挺特別的，是我媽和好久不見的賴桑。賴桑原本說要帶冰淇淋紅茶或者是麥香奶茶之類的飲料過來，但因為我跟他說「這邊任何與紅茶、綠茶、咖啡有關的飲品因為含有咖啡因的成分都不能帶。」所以他最後選了兩罐的小柳橙美粒果給我當慰問品。我們沒有聊很多，主要的話題圍繞在「為什麼我會住進精神病院」這件事情上。也因為我已經被問過很多次了，所以幾乎是機械式、流水線式地回答了這個問題，包含像是團體空間、內物櫃、牙刷、洗澡、偷喝飲料、脫衣服抽菸 \u0026hellip;等事情上。（還有那個不停被找出去索島指的進度落後）。而或許是已經說了很多次，所以潛意識多少也開始對這些事情加以分析的緣故吧？在跟賴桑聊天的過程中我更確定了「其實我自己真的有強迫症」這件事情上面，不知道這算是好事還是壞事？\n其次是因為會客室可以偷偷用手機，所以我也在那時候稍微修改了一些像是 Line, IG \u0026hellip;等社群媒體的個人近況，算是一種另類的跟大家報平安（畢竟如果以軍中正常的作息來看，我已經是一個從入伍第 6 天第一次放手機之後，到現在入伍第 31 天都完全沒有跟外界聯絡過的 3C 原始人了）。然後不得不稍微抱怨一下：不知道是我不懂他的操作方式還是怎樣的？國軍的 MDM 用起來真的好麻煩 \u0026hellip;。\n然後是閱讀的進度：今天他們帶來的書與原先預期的「藏傳佛教系列」無關（可能他們沒有找到？畢竟我放得蠻不直觀的）。是《占星相位研究》《占星 12 宮位研究》《當代古典占星研究》和《簡少年說紫微》這幾本書。扣掉最後紫微的那本（那是要送給漢哲的），我又有 3 本書可以看了！雖然從現代占星的系列來看，他們帶來的是第 2 集（相位）和第 3 集（宮位）。第 1 集（占星概述）還放在家。但直接從 2,3 開始看應該也沒有太大的關係（因為第一本我以前也看完 7-8 成左右了）。稍微翻了幾頁 2,3 集的內容，跟第 1 集類似，都是資訊密度很高的書籍，所以應該也能夠學到很多東西才對～\n最後是停役流程跟停役進度的事：今天鈞祐有跟我小聊了一下，他說他的心測報告最慢下禮拜 1 會出來（今天是禮拜 6），然後部隊最慢下禮拜二（也就是他報告出來的隔一天）會來這裡拿心測結果。所以他的 \u0026ldquo;最後的 14 天\u0026rdquo; 可以從下禮拜 2 開始算起。也因為他跟我是同一位輔導長所照顧的對象，就方便性來說的話，部隊應該會把我們的出院時間安排在同一天才對（這樣就不用跑兩趟），所以這樣算起來 \u0026hellip;，我的出院時間應該會是在 3/4 左右（正負誤差 2 個工作天吧？）。如果是 3/4 出院的話，對比同梯的新訓期間（1/16 ~ 3/20）也是早了至少 2 個禮拜，算是個蠻好的消息。\n最後，因為我待過精神病院的緣故，我猜之後健保卡上面應該會有類似「社會功能減損」之類的標籤被貼在上面吧？雖然這代表以後的工作可能更難找了，但如果你問我「如果時間可以重來，你會為了撕掉這個標籤而把軍事役期給當完嗎？」我想我還是會回覆同樣的那 3 句話——我不要、我不要、和我不要。如果你要我重新回去新訓的那段生活，我寧願認真地找方法去死一死。\n"},{"id":111,"href":"/_trash/diary/202402/20240218/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/18\r#\r住院後的第 28 天，同事也是感冒之後的第 5 天。\n今天的感冒體感而言 \u0026hellip;有再不好一點，嚴重程度大概介於前 2 天的中間，比預期的「一路好轉」還要走偏一點點（變成了「又變差了」）。算比較令人沮喪的情況吧？（雖然我沒有因為這件事情真的沮喪起來就是了。）病情的部分 \u0026hellip;簡單來說就是鼻水一直流、不停流、瘋狂流、木橋流水流啊流。有趁著早上量血壓的後跟負責我的護理師說過了，但護理姊姊說今天的值班醫師（王醫師）不是我的主治醫師（廖醫師）。所以她們現在能幫我做的只有持續原本的藥，調整藥量（包含新增、減少、或者是加重、或減輕）都不是她們的職權。所以經過討論之後，姊姊決定再多開 3 天原本的藥量給我，只能說也真的是辛苦她們了。\n此外，除了這件比較過的事情以外，今天也有一些值得紀錄的好事情：首先是阿祐他今天試了一次我原本的訓練菜單（詳細內容可以回頭喵一下13 號的日記）。他做完之後給我的回饋是「比想像中的和眼裡看到的感覺還要累太多太多了。」這聽起來還蠻讓人高興的，並不是因為「我在做完那個訓練之後，沒有他那麼累，所以我比他厲害。」這種無意義的想法。而是「這組訓練經過別人的實作之後，同樣也有『讓人感到很精實』」的這個回饋——也就代表如果我城持續進行這項運中，那它就可以讓我持續地 \u0026ldquo;進步\u0026rdquo;、而非 \u0026ldquo;踏步\u0026rdquo; 或甚至 \u0026ldquo;退步\u0026rdquo;。\n第 2 件令人振奮的事情則是我的體前彎可以輕鬆碰地了！在不彎曲膝蓋的情況下。目前在往「單節指節碰地」或「握拳碰地」的路上前進；第 3 件事情則是今天久違地玩了一次燒腦的德國麻將——拉密。主要參與者有我、金城、燦瑋、跟翔之。心得的話 \u0026hellip;能夠持續思考真的好舒服，雖然我們只玩了 4,5 場左右，但感覺我的腦袋還可以再應付另外的 4,5 場。此外也因為很投入的關係，總共 2.5 小時的遊玩時間對我的體感來說大約只有 25~35 分鐘上下而已。雃且也因為這個拉密的活動，更加認識燦瑋和翔之這兩個人了，超讚！\n最後是一些無關於日常活動的冥想問答：今天同樣也有在看占星相關的書（《占星 12 宮位研究》）。從宮序（也就是宮位的排列順序）可以明顯地感受到西洋的 12 宮大致都是以 \u0026ldquo;人\u0026rdquo; 為本位，當做宮位的描述核心：像是我隱藏（12 玄秘）、我展現（1 本命）、我擁有（2 財帛）、我所見（3 兄弟）、我感受（4 田宅）\u0026hellip;等，都和「我自己」有關係。但相對而言，紫微的邏輯則是以 \u0026ldquo;整體\u0026rdquo; 為宮序的核心：像是長輩或前輩（12 父母）、我自己（1 本命）、平輩或親密友人（2 兄弟）、另一半（3 夫妻）、晚輩, 子女, 或下屬（4 子女）\u0026hellip;等。\n可以感受到 \u0026ldquo;團體\u0026rdquo; 或 \u0026ldquo;家族\u0026rdquo; 的味道相對濃厚。而宮位間的吉凶判定，西洋占星和東方紫微的判定邏輯也有點不一樣：占星的四分相和對分相大致都認定為凶象，但紫微的四正宮位如果產生交流的話，則不一定是凶象，還得看是祿科 or 權忌；還有 \u0026hellip;占星對「與 1 宮無法產生托勒密相位的宮位（也就是 2,6,8,12 宮）」的描述基本都以凶宮來論，但紫微上面 \u0026hellip;至少從北派相關的斷法來說，非～常非常注重一六共宗的關係（6 宮的重要程度只輸 1 宮一點點））。而至於是什麼原因？導致這兩者之間有著這麼大的不同，可能就還要再研究一下了～\n"},{"id":112,"href":"/_trash/diary/202402/20240219/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/19\r#\r（2/20 12:10 補寫）\r#\r感冒的第 6 天。\n今天的症狀明顯好了 8 成以上。廖醫師的專護（郁柔姊姊）今天有幫我澄清一個觀念，她說：「相對於鼻塞，一直流鼻水其實會是一個比較好的情況。因為這代表鼻子不再塞住了，鼻腔沒有像之前那樣一直腫著。」所以我的狀況真的是「一路好轉」沒有錯！跟昨天心裡想的「又變差了」完全相反。預期再過個 2-3 天，感冒的狀況就能完全消失了。\n相對於先前的 29 天來說，雖然今天也是時不時就有人大吼大叫、咆哮、或者是差點打起來，但這幾乎 3-5 就會發生一次，所以也算是比較平凡的一天。早上的 OT 活動是每 2 個禮拜會有一次的「零食採購」，但跟上次不同的地方是：因為庫存(?)的關係，這次沒有美粒果可以買、波蜜果菜汁和其他一些零食的數量也相對比較有限，不能像上次一樣盡情地買（上次有個人把他的 400 元全花在波蜜上，送來了至少 20-30 罐）。此外，這次負責記帳的「記帳士」也從原本「金城、顏勤、我」的組合改成了一些新來的軍籍病友們。因為我們幾個預計再過 1-2 個禮拜就要離開了，所以 OT 姊姊們打算趁現在培養一些新的記帳士，為之後的採購做準備。\n另外，今天也幫了 2 個朋友算命：分別是專精室內設計的燦瑋、和信奉伊斯蘭教的繼允。先說說燦瑋的盤好了，因為他的比較簡單：命宮天相在丑、對宮紫破擎羊鈴星，整體而言是個普普通通的格局。遷移宮的紫破擎羊讓他有著一張只要不笑別人就會覺得他在氣的兇惡面孔，官祿空宮，但有陀螺天馬，所以是個有點吹毛求疵、鑽牛角尖、或追究細節的人，無論是在工作或平常與人的相處上應該都有這種性質。此外，也因為他命宮（丁丑）忌入本命兄弟（巨門獨坐的子位），所以跟母親的相處應該蠻常有口角或吵架的 \u0026hellip;（這點也有被他證實）。\n簡而言之，雖然在家庭關係上有一點比較明顯也比較不好修復的問題，但他無疑是個轉且盡責的好人。他對日本也挺有相當的研究，很常聽他分享一些 2D, 3D、分鏡、色彩、感受、描繪這個描繪那個 \u0026hellip;之類的專業術語。真的很難不讓人用仰望的眼神去看著他——我對於能夠在某種專業上，可以很有自信、很大方地分享那些知識的人一直都很無法抗拒（簡單來說就是崇拜啦）。\n至於繼允的盤 \u0026hellip;，老實說直到現在我還是不確定到底準確還不準確？他算是我自從入院以來，唯一一個無法說服自己「我有說中」的人。跟挺宇命盤的準確度差不多，但兩者不準的原因又完全不一樣——因為繼允在某部分上跟我很相似，都是在一些地方上極度虔誠（或宗教狂熱？）同時說話方式跟說話內容又有點哲學的人（他很有點「空」、有點「禪」）。所以很難從一些比較常見的切入角度（跟爸媽的關係、男女相處、自己藏起來的內在性格、或與他人常見的互動方式 \u0026hellip;等）。但雖然算的不準，繼允確是我到目前為止最最感興趣的人沒有之一，之後有機會再來聊聊～\n"},{"id":113,"href":"/_trash/diary/202402/20240220/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/20\r#\r入院的第 30 天！今天早上廖醫師帶來了一個好消息：「他說醫院這的作業流程（包含社工家訪、個案心測、心測結果評估、和將評估撰寫成診斷報告）已經全數完成了。」廖醫師預計今天或明天就會把這些文件全部轉送到軍方，然後他也說他在寄出後，也會幫我催軍方那邊的進度，預計在 2/29（含）之前把我送出院！所以待在這裡的日子只剩下不到時間了（預計啦）。有種既開心又有點不捨的感覺呢 \u0026hellip;\n今天同樣也發生了幾件值得紀錄的事情：首現是今天的我開始恢復訓練了！在早上起床的時候做了 3 組的遇線折返（2 組跑步 + 1 組側併步）和 5 圈的廣場跑步。但因為身體還是有一點點小感冒的感覺，所以原訂 9:00 和在那之後的所有訓練都被暫時取消了。看看明天狀況如何？如果還是維持原樣（或者是康復明顯）的話，我那就會變回不停訓練的狀態了。\n今天的 OT 活動是看電影——國際市場：半世紀的諾言，但因為我對電影的內容沒什麼興趣，所以就跟小 OT 聊了一下算命的話題，這大概也是我身上唯一一個可能會讓女生引起興趣的話題了，哈哈！我目前的目標是讓我的算命客戶 +1，期間金城也幫我做了一個小小的助攻，說我算命其實算的很準，只不過可以感覺出小 OT 雖然有意願，但還很小很小，所以客戶還沒有成功 +1，之後再看看怎麼辦吧？至少明天也同樣是看電影的環節（今天只看完了電影的一半），所以明天還有機會再 \u0026ldquo;招募\u0026rdquo; 一次。\n另外，今天整個院內也做了一次安全檢查——檢查所有病人的私人物品、公共區域的一些可用空間，看有沒有私藏違禁品之類的情形。來做檢查的人看起來是一些 科大的 \u0026hellip;實習學妹吧？看著她們在檢查的背影，我心裡浮現了一種「原來我已經到了那種，看著大三大四的學生的時候，會覺得『她們好年輕喔』的年紀了嗎 \u0026hellip;」有點時代的眼淚的感覺？雖然我對於自己的年紀並不是那麼在意就是了。\n最後還有幾件事情可以記錄：第一件事情是今天是幫翔之算命了～。他的命宮日月在丑。基本上思考活躍、2 面性格的味道很重，會把心事藏得很沉很沉，幾乎不會跟任何人說。與家人的相處不差，但蠻容易有思想上的隔閡或代溝 \u0026hellip;等，同樣是一個突出的地方沒有特別突出，同時輸人的地方又再比其他人輸一點點的那種命盤（這裡大部分的人都這樣——包含我自己）。第 2 件事情是柏園因為挑釁別人所以被對方爆打了一頓，他被整個打到頭部大流血，直接抬出精神病院，左轉隔壁的急診室。第 2 件事情是我從繼允的身上得到了一些可以深入了解伊斯蘭教的文本、資訊、和相關知識 \u0026hellip;等，超開心的！終於可以認真了解這個宗教了！\n"},{"id":114,"href":"/_trash/diary/202402/20240221/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/21\r#\r今天是住院的倒數（10）天。雖然昨天有說「如果身體狀況維持原樣或比較好的話，就進行訓練。」但早上的狀況感覺上又稍微變差了一點，所以後來也沒有起床晨練了。早上 9:00 量血壓的時候，玟君姊姊偷偷塞了一包喉糖給我，真的是幫了我很大很大的忙！超級感謝她的（哭）。除了早上之外，中午玟君姊姊也稍微問我關於資工系的事情，他的兒子現在也在讀資工）。我也跟她大概分享了一些科系裡面的學科、未來發展 \u0026hellip;等。可以感覺得出來玟君姊姊同樣也是一個很為她孩子操心的母親呢～\n今天的算命客戶輪到了顏勤～在他說出他生日的時候我有稍微嚇了一跳，有點難想像他已經超過 30 歲了，他外表看起來大概也才 \u0026hellip;25, 26 左右吧（或甚至再低一點）。這就是每天都有在體能訓練跟飲食控制的差距嗎 \u0026hellip;。他的命宮太陰在辰，沒有很差的六內宮（命、財、官、疾、福、田）。算是病友裡面少數還不錯的命盤（好壞等級大概跟金城的差不多）。但他的問題也跟金城的問題很類似——這幾年的大運流年走得很差。不難從命盤上難出他這幾年過得辛懷疑、迷茫、還有辛苦。而且他剛好又是太陰在辰戌的人，所以命遷兩宮會是一個太陽一個太陰，日月就喜照不喜坐嘛 \u0026hellip;一直把別人的事情丟到自己的肩膀上扛，很容易累倒的。真的是辛苦他了。\n另外，誠如昨天所說：今天的 OT 活動同樣也是看電影。而今天 OT 活動的重點同樣不是在「看電影」這件事，而是要問出小 OT 的出生時間。今天除了金城之外，也同時拉了上一段才剛提過的顏勤幫我 \u0026ldquo;洗腦\u0026rdquo; 小 OT，也終於成功拿到姊姊的時辰了！但因為還沒排盤，所以還不知道內容長什麼樣子？有點好奇最後排出來的格局會是什麼樣子？如果要我猜的話 \u0026hellip;，同梁寅申、同巨丑未應該會是我的主要方向。我覺得純粹殺破狼的機率應該比較小，紫微也不太是。柔星的機率挺高的，然後不是會太陽或太陰坐命（雖然太陽本身也不算柔星就是了）。此外輔星很多的機率也不低，至於命財官的凶星\u0026hellip;空劫或陀羅吧，火鈴的感覺不高。\n最後，今天下午午覺之後，聽了阿祐他們跑一次團，他們跑的不是 DnD（Dungeons \u0026amp; Dragons）系列，而是 CoC（Call of Cthulhu）的世界觀。只能說嘉祐說故事的能力真的很好，情緒和語調的詮釋也很投入。我只聽大概 2~3 分鐘就完全陷進他所創造的情境裡面了。完全能夠感受到他對於 CoC 的熱忱與活力，除此之外，跑團的另外 3 人（翔之、燦瑋、和翊紘）也很認真在嘉祐設計的克蘇魯世界中遊玩。有那麼一瞬間我還小小後悔之前沒有和他們一起創角、一起跑團了（哭）。但相對的～在他們跑團的期間我也多看 3 本書了！不知道出院之前我還能在看完幾本呢？希望能在拼個 1~2 本呢。\n"},{"id":115,"href":"/_trash/diary/202402/20240222/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/22\r#\r（2/23 20:15 補寫）\r#\r嘉祐在今天出院了。因為他走的是 \u0026ldquo;驗退\u0026rdquo; 流程，和我們大部分義務役的 \u0026ldquo;因病停訓\u0026rdquo; 不一樣，所以他必須要在入伍以內的 30 天之內完成所有的作業流程。也因為他是在 1/24 入伍的（從 24 算第一天），所以最慢最慢就是今天要完成。承襲昨天的活動，他今天在走之前跟翔之、燦瑋、和翊紘一起把克蘇魯的劇本跑完了。接著說了一些感性的話、最後再把一些他這 30 天珍藏的零食給了我們之後，就離開了。\n也因為他給的是 \u0026ldquo;我們\u0026rdquo; 而非跑團的 \u0026ldquo;他們 3 人\u0026rdquo;，所以我也有拿到嘉祐給的餞別禮——個人勢台 V 雀羽困（すずはね こまる）的親簽海報。同為一個 VT 豚，我完全可以理解這份禮物到底有多麼貴重，大概就是某個超級球星的簽名球衣、或者是某個韓國偶像的親筆簽名的那種等級。我一定會好好珍惜的｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡\n此外，今天下午的 OT 是上 2 樓的閱讀時間。我們因為昨天拿到時辰了，所以今天就按照排出來的結果做了一次定盤。但在那之前，先解答一下昨天的猜測：結果是命宮廉貞在申，三方四正的吉星有左輔、右弼、跟文昌（命遷還有再輔一點點的紅鸞跟天喜），煞星則是有鈴星。所以稍微對一下答案的話：\n命遷同梁或同巨（錯） 命宮不是純粹的殺破狼、也沒有紫微（對） 柔星坐命（錯） 不是太陽或太陰坐命（對） 命財官遷輔星很多（對） 命財官遷的凶星有空劫陀、沒火鈴（錯） 從我對自己的標準來看，大概可以給到 35-40 分。3 對 3 錯有點可惜，明明有往人緣跟交際的方向去猜，但怎麼就沒有想到廉貪呢 \u0026hellip;，只往善於社交微笑的同巨或同梁去猜，我真爛。除此之外，今天的排盤論命也是繼允之後，第二次的算不準事件。搞砸了呢 \u0026hellip;，本來以為會很順利地客戶 +1 的，但沒有想到失誤的狀況大概跟第一次看繼允命盤的時候一樣（甚至還更歪一點），老實說挺難過的。直到現在都還無法釋懷心裡面這種不舒服的自責感。\n如果要細究這份心情的話，難過的原因主要是由以下幾點組成：首先是最單純的「算不準」，我沒有師傅那種對於命盤的理解能力和自信，所以對於客戶回饋「算不準」的時候，我一率都會往「對，真的是我沒算準」的方向去想，所以就會糾結、在意、跟難過。其次是姊姊又算是一個比較特別的狀況——在她昨天給我她的生日之前，姊姊的年齡一直都是院內的一大謎團（說得上是那種「只要誰能真正知道姊姊的年紀，那他絕對會在院內被大家奉為老大、超人、或神明」的那種隱秘程度）。是我一直去話術姊姊，她才願意給我的。但我覺得我辜負了她的期待 \u0026hellip;\n從下午 2 點之後到晚上睡覺之前，我一直都沈浸在自責、懊惱、後悔、不甘、和想要改善的情緒中度過，也有想過能不能買點吃的或者什麼其他的東西送給姊姊作為辜負她的期待、浪費她的時間的一點補償。但我把這個想法跟大頭說之後，她覺得我的反應有點太 over 了。所以直到現在我都還是不知道該怎麼辦才好？我想 \u0026hellip;這可能也是我要學著面對的課題之一吧？如果我之後持續執業論命的話，就一定會一直發生像繼允或者是姊姊的種情況。所以我得學著面對失敗——面對一個幾乎無法改善狀況，只能無力地看著它逐漸死去的那種失敗。\n老實說，雖然這樣的情況在我現在算命的經驗上已經可以降在 5%（甚至是 3%）以內了，但每次只要碰到這 5%, 3% 的時候，我們心就還是會好難受、好難受 \u0026hellip;。「看著別人逐漸失望、逐漸失去期待和熱情的眼神」真的是一件好煎熬的過程。我還要再讓多少人感受到這種痛苦，才可以成為一個能夠讓人撥雲見日、展開笑容、豁然開朗的神棍呢？我想 \u0026hellip;可能還有一段路要走吧。\n"},{"id":116,"href":"/_trash/diary/202402/20240223/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/23\r#\r雖然我不確定我還會在這邊住院幾天？但看到了今天早上的情況之後，我幾乎可以確定一件事情——那就是我應該不會在這裡再遇到像凌晨一樣嚴重的暴力事件了。事情得從昨天晚上說起：昨天有兩個患有躁鬱症的病友（姑且就叫 A, B 吧）在晚餐後的泡麵時間差點打起來。事發前的情形不清楚，那時候我正打電話在跟大頭抱怨「OT 姊姊算不準事件」，但在那時，我的後方傳來了一聲很 \u0026ldquo;認真\u0026rdquo; 的「幹你娘」。轉過頭後，就看到 A 把一碗剛加滿 99 度熱水的泡麵直接潑到 B 的臉上。幾乎是下一個瞬間，我直接丟掉手上的聽筒往 A 的身上衝去，而在我衝過去的路上，A 的反應也證實了我心裡面的猜想——他想要跟 B 來一場男人之間的浪漫對決。\n這件事雖然後來以「我、一些其他人、和保安把 A 架開，並把 A 關進保護室 3 小時」做為事件的結尾，但你以為故事到這邊就結束了嗎？必須得說，這還僅僅是前戲而已。距離「潑泡麵事件」大概只過去 9 個小時，時間來到今天凌晨 5:40 左右。B 趁著「大家在 6:30 之前都幾乎在熟睡」和「寢室的門絕對不會被鎖上」這兩個既定印象，大搖大擺地走進了 B 的房間，然後耗子尾汁、不講武德，騎在了 A 的身上，用他昨天沒用上的超派鐵拳就是對 A 的臉上一頓招呼、不停招呼、瘋狂招呼、除了招呼還是招呼。\n後面的細節就不贅述了，總之 A 被關進了保護室，並在半天之後，經由至少 3 位法警的戒護下，走出保護室、整理完房間的行李、直接強制出院、坐上警備車、去了大家大概都知道的那些地方。至於 B 嘛，從他的頭部只看得到紅色看不到皮膚色的情況、和整間房間的牆壁就像是恐怖遊戲的那種感覺來看 \u0026hellip;也挺不樂觀的。我算是少數例外，但幾乎所有的軍籍病友都被這起事件嚇得不輕，所以早上的大家氛圍很明顯地超級壓抑。而它也被我稱為「223 事件」。\n除此之外，今天的其餘日常仍然照舊進行。\n今天早上的 OT 活動是久違地卡拉 OK 歡唱時間。這次應該也是入院之後的最後一次唱歌了？畢竟按照頻率來看的話，這個活動是兩個禮拜才有一次（所以下一次就會是 3 月之後了）。因為上次的唱歌（可以參考7 號的日記），所以這次是在我主動說「想要唱」之前，就被拱上去了。這次唱了王傑的我是真的愛上妳。唱這首主要有幾個原因：首先是它是我最最拿手的一首歌（沒有之一，就真的是最拿手）；其次是因為這次是 \u0026ldquo;最後一次\u0026rdquo; 唱歌了，我覺得如果沒在這邊唱這首歌會有點 \u0026ldquo;虧待\u0026rdquo; 在這邊一起生活的朋友們（沒錯！我用了「虧待」這個詞來炫耀強調我對歌唱的信心）；最後是我想要用這首歌跟 OT 姊姊證明我還是有 \u0026ldquo;價值\u0026rdquo; 的——我「會」唱歌。並不只是一個滿口胡言，騙說我會算命，但其實啥都不會的破爛神棍。\n我還是對於「算不準」這件事情很介意。今天的歡唱時間我也有在唱歌之餘，再問纏了一次 OT 姊姊算命的事情，但被她婉拒了。那我想 \u0026hellip;，應該就只能這樣了吧？再 \u0026ldquo;問\u0026rdquo; 下去就超過了，會重蹈覆徹，變成之前那個死纏爛打的、不好的我。失敗的感覺真的好糟好糟，無能為力的感覺也好差好差，我想這就是我一直不想要在算命上明定價格的原因之一吧？我還沒有足夠的實力可以再壓低失誤率，也沒有足夠的能力可以去修正（甚至是反駁）那些質疑的聲音與問題，看來我還有很長的一條路需要走呢 \u0026hellip;。\n下午還跟繼允做了一個類辯論的哲學思考，主要的內容是「為什麼東方的文化傳統是以家庭、族群為社會重心；但西方的文化可以將『以自身、自我為主』的觀念作為他們的底層意識？」繼允真的是一個超～～級無敵轟炸有魅力的人！我覺得他做 TYuber（或者是其它面向那種類型的工作）一定會很有特色。整場辯論大概持續了 1 個小時左右？我先後用了戰亂、文化交流與融合、與黑死病 \u0026hellip;等論點來嘗試奠基這個命題。但可以感覺到無論是哪種觀點，他都沒有很滿意我的答覆（雖然有些論點我自己也覺得有點站不住腳就是了）。所以在最後我就問他「那你覺得呢？你覺得問題是什麼？」然後他說「我還是不知道，我想這就是我們需要用一生都去思考的問題吧？」\u0026hellip; かっこいい！\n辯論之後是久違地日麻時間！由我、翔之、繼允、和一個我還沒把名字記起來的朋友\r\\(_{[1]}\\)\r所組成。第一次打實體的日麻感覺好熟悉又好陌生，熟悉的原因是因為它就是我知道的那個斷幺、七對子、國士無雙的日麻，但陌生的原因則是 \u0026ldquo;視野\u0026rdquo; 相較於看著電腦螢幕差好多：因為電腦是完全俯瞰的關係，所以你很容易去判斷和分析哪一個人現在想要做什麼？他們理牌、整牌、和等牌的進度大概到哪邊？但因為現在是實體的麻將，所以望向棄牌堆的角度就會接從原本的 90 度的鉛直，往下拉到約 30 度左右的位置上，所以你在觀察的時候要不斷抬頭低頭、上看下看，才夠完成原本單純盯著電腦螢幕就可以做到的判斷。佔這不會影響到我玩日麻的樂趣啦！只是脖子比較累而已～\n1：不能吃牛的易辰\r#\r"},{"id":117,"href":"/_trash/diary/202402/20240224/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/24\r#\r（2/25 05:20 補寫）\r#\r入院的第 34 天，今天我成功一覺到天亮了！這應該是從 1/16 入伍之後的第一次，說真的有點感動（哭）。從入伍後，幾乎（或者可以說是完全沒有）睡好的經驗——不是躺了很久才睡著，就是會在睡覺的過程中醒來好幾次（超過 10-20 分鐘的那種醒來）。大部分的晚上都是在焦慮中失眠、焦慮中睡著、再從焦慮中醒來。整晚沒睡的經驗大概也有個 1,2 次。這種情況在入院之後有明顯的改善：除了焦慮的時常大幅降低以外（可能跟用藥有關），基本上我在躺床 5-10 分鐘左右，就可以完全睡著。但還是蠻容易在中間醒來個 1,2 次的，原因不明。\n早上跟繼允和燦瑋聊了一些香水、精油、跟線香之類的話題，基本上在他們的聊天過程中，我是一句話都插不上邊的——因為我完•全•不•懂那些東西。但我還是有從中稍微了解到一些精油線香的相關知識（精油要用燒的、不建議用水氧機；線香有機會把讓房間天花板變色；燦瑋超級喜歡 Aesop 的護手霜和其他商品 \u0026hellip;等），也有記錄到一些香水(?)的名稱，像是 Aesop 的浪船\r\\(_{[1]}\\)\r、MMM 圖書館的低語者、還有迪奧的曠野之息 \u0026hellip;等。\n在聽他們聊天的過程中，我也稍微思考了一下關於「生活型態」的問題：因為一直以來我都是個比較極簡的人，同樣的衣服、同樣的褲子、同樣的穿搭、同樣的生活作息 \u0026hellip;等。但有沒有一種可能，就是其實我的極簡只是一種「邋遢」呢？只是懶得想、懶得動、懶得在這邊思考而已。又或者，我的這種「單調」生活其實也可以單調的很有所謂的質感？不再穿自己喜歡，但別人覺得很怪的衣服、不要再做自己覺得很普通，但別人覺得很困擾的行為、不要再用著自己的「框架」，來面對面對這一整個「社會」。可以再思考一下，或許可以從中發現什麼也說不定？\n此外，今天也有久違的 15 分鐘會客，來的是我妹跟晉安。基本上沒有做什麼安檢，因為他們只帶了兩本書、一個透明 L 夾、和一個用來裝衣服的垃圾袋。其他像是多的衣服、吃的喝的 \u0026hellip;等全都沒有，所以聊天的時間還蠻充裕的。同樣是稍微的關心，基本問題同樣環繞在「我為什麼會住院」「精神病院裡面環境怎麼樣」和「大概多久會出院」這 3 個話題上面。除此之外，晉安現在也有一份穩定的工作了！他年前在拼考四大研，但失敗了（哭）。是個很普通但也很懷念的閒聊。\n最後是思考時間！因為今天是給自己的「放假日」（就是什麼都不做，大部分時間都躺在自己床上的一個日子），所以也同樣思考了很多事情：但主要的問題基本上還是環繞在我這幾天芥蒂的事情上—— OT 姊姊命算不準事件。直到今天、直到現在，我還是對於「算不準」這件事情耿耿於懷，一方面是我本身就很好奇「我算不準的地方是哪裡？」是以「知道了之後，就可以再進步」的心態的好奇；另一方面是在目前 \u0026ldquo;失手\u0026rdquo; 的兩個客戶中（繼允、小 OT），我大致上已經解決了「繼允的命為什麼算不準」這件事情，所以我變成只需要 focus 在小 OT 的盤上就好。\n但不管怎麼說，我覺得最最重要的事情也許跟命盤無關，因為問題的核心應該是「我很不擅於面對和解決『別人對我在意的事情感到失望』這種情緒。」以往我的做法會是盡可能地證明自己、表現自己、和解釋自己（簡稱死纏爛打），在感情上尤為如此（對之前被我這樣騷擾過的所有女生感到相當抱歉\u0026hellip;）。現在的我 \u0026ldquo;自認\u0026rdquo; 有稍微好一點，因為我有意識到，且願意去撰寫下來，進而去面對、改善這個問題。但還是不知道具體應該要怎麼做就是了啦～不過之後一定會有辦法的。\n1：不知道是不是這個\r#\r"},{"id":118,"href":"/_trash/diary/202402/20240225/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/25\r#\r入院的第 35 天。按照原定廖醫師的預期（和我自己的期待），今天應該是在院內的最後一個星期日了。也許是天氣的關係？（今天一整天都沒有太陽），包含翊竑、易辰 \u0026hellip;等大部分的人，在今天都顯得有點無精打采，甚至可以說是 emo emo 的。連我也不例外，所以我繼續去煩了金城、顏勤、繼允、和燦瑋 \u0026hellip;等沒有把自己關在房間裡面的人。我問了他們「如果你把一個你充滿信心、充滿成就感的某個東西（可以是身材、作品、技藝、或其他東西 \u0026hellip;等等）展顯給一個你覺得很重要的人之後，對方給了你一個失望（或者是你預期以外）的反應時，你會怎麼調適那種心情？」\n簡單來說就是我還卡在 OT 姊姊的 emo 裡面啦，我還沒把「命算不準」這件事情給放下，雖然相對於第一天來說已經好很多了。而他們回給我的答覆老實說也都很有參考跟深入思考的價值，像是「也許只是她自己不承認而已」、「搞不好這個『問題』本身就不是一個問題」、「比起失敗的作品，或許你可以更注重在那些『成功』的作品上」或者是「或許她還沒意識到其實她有這個現象」\u0026hellip;等等。\n此外，今天的主要活動大部分都集中在下午上（早上在問問題跟躺床思考）。第一個值得紀錄的事情是我把《當代古典占星研究》給看完了。這本書大致說明了「古占」和「現占」的一些分歧與差異——古典占星重視的是我與周遭、我與自然環境會有怎麼樣的交互作用？會有怎麼樣的事情發生；現代占星則是「我」是由何構成？「我」又應該如何激發、喚醒、提升自己內在身心靈的一些 \u0026ldquo;能量\u0026rdquo;。從「我想研究紫微斗數，所以我才開始學占星」這一個出發點來看的話，往古典占星鑽研應該才是一個正確的選擇（但我買的書大多都是現代的 rrr（哭））。\n畢竟從紫微斗數的視角往外看，我們在聊的不外乎就是預測、預測、跟預測。幾乎沒有算命先生會把命盤的重點放在身心靈、自我提升、能量激發與覺醒上面。而對於大眾的心理預期來說，他們來找我們算命應該期待聽到的也是預測、預測、和預測吧？如果你（妳）期待一個算八字或算紫微斗數的算命先生一拿到你的出生時間之後，就開始跟你（妳）說「凡事都要相信自己啊」「怎麼會覺得自己做不到呢」「去試試看吧！人有無限的可能啊」，那在大多數的情況下，一定是有什麼地方出了問題 \u0026hellip;很大、很大、很大的問題。\n然後，今天除了每天預定的體能訓練之外，也第一次完整地體驗了晚餐過後為期一小時的金城操（燦瑋命名的）。金城大概在我入院的前 \u0026hellip;5 天吧？就有問過我有沒有興趣跟著他們一起 go run go run 了。但我那時候可能還在適應環境吧？所以就拒絕掉了。現在想想，真的是超～～級後悔的！金城操做完之後，我也教了燦瑋合繼允遇線折返的跑法（這邊有個有畫線的羽毛球場）。體前彎的部分 \u0026hellip;目前大概在 28 或 29（可以輕鬆膝蓋不彎，指尖就碰到地板的程度），希望出院之前可以再多拼一點數字上來！\n"},{"id":119,"href":"/_trash/diary/202402/20240226/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/26\r#\r入院的第 36 天，也是出院的前 (4) 天。\n今天的早餐是我入院以後，少數會選擇不知的蘿蔔糕，所以我直接在床上睡到了 8:30。並且在那之後在床上寫了約 10 份的 \u0026ldquo;名片\u0026rdquo;（就是一小張名字 + 電話 + line + IG 的紙），然後把它們分給了我在這裡最好的朋友們（鈞祐、瑋鴻、程育、繼允、金城、翔之、顏勤、燦瑋、易辰~~、跟時間上還沒來的泓梠~~）。上次一次交到那麼多朋友是在我大一的時候，再再上次的話 \u0026hellip;，應該就是國中的時候了吧？所以這次應該稱得上是我人生中第 3 次交朋友的 \u0026ldquo;高光時刻\u0026rdquo; 了！。\n早上今天的 OT 活動是上禮拜五的卡拉 OK 歡唱（沒錯～連兩天唱歌），直接打臉我在 23 號說的「應該是入院之後的最後一次唱歌了。」我點了一首張宇的趁早，一方面回應大家希望我唱歌的期待、另一方面也稍微抒發一下想要回家的心情。雖然嘴上還是說著「沒關係」「我不在意」之類的話語，但不可否認的是：開始想回家的感覺確實越來越重了。想念家、想念 2502、想念院外的所有一切。即使從軍友的的角度來看，我已經算是待在這裡數一數二久的人了，但我有時候還是能感覺到一點點不真實（或者是說違和？）的感覺，但又說不出來是哪裡。不知道還要多久才可以出院呢？還有多久才可以重新回到我所熟悉的地方呢～希望 3/1 之前就可以走了\u0026hellip; 不對！用吸引力法則的話來說應該是「我得在 3/1 之前離開了」！\n最後是思考時間（沒錯，今天就是沒有力氣到啥都沒做，直接鬼轉躺床亂想）：今天的思考內容是「逃避。」會定這個標題的主要原因是——我昨天又被當兵中夢境給驚醒了。內容大概是大家瘋狂遲到，然後瘋狂被罵 \u0026hellip;等等。我想要思考的問題有以下幾個：首先是「『逃避』本身是不好的行為嗎？」如果是，那我們「人」為什麼會有「逃避」這種情緒產生呢；又如果不是，那為什麼我們不可以選擇逃避呢？先說說我的看法好了：首先我不覺得「逃避」本身不是一件不好的行為。原因在於大多數的人，在大多數的情況下，都擁有「選擇」的權利。在此基礎之上，如果參雜了「人」的因素進來，當一些人看到你選了他們不希望你挑的選項之後，就會使用「逃避」這個字眼來表示你在「違反他們的期待」。\n所以我認為，「逃避」這個詞在一定的程度上，更有「選錯選項」的味道在裡面。那這樣就引申出第二個問題了：什麼叫做「選錯選項」？一個學校的學生，受到同儕排擠疏遠。他選擇將這件事鬧大，讓校方不得不處理這件事情。那這樣他算「逃避」被排擠的環境嗎？一位職場的勞工，為了生計被迫簽署一份不平等的合約。他選擇將這件事情公告於眾，那這位勞工是在「逃避」受到壓榨的處境嗎？一位百經沙場的戰士，在面對一群無法抵禦的敵人來襲時，選擇命令撤退，甚至是逃跑，這樣他算是在「逃避」他即將遭遇到的困境嗎？\n也許有點滑坡了，但我想要表達的事情是：對我來說，我只是利用我身上所的擁有的「條件」去「選擇」了我想要的「選項」而已，我並不覺得這樣做就算是在逃避。同時相反地，如果這樣就是逃避的話，那我覺得與我擁有相同「條件」的人，如果違背了他的自身意志，去「選擇」大眾所期待他挑選的「選項」，那麼我應該也可以評價他為「一個不知變通的人」吧？（超級符合守序邪惡的想法 XD）但，也許正是因為這種想法，我才會被關進精神病院裡面吧？因為從他們的視角而言，我「有病」。就像是 Nathaniel Lee 所說的一段話：「他們說我瘋了，我說他們瘋了，可該死的，他們人數比我多。」\n"},{"id":120,"href":"/_trash/diary/202402/20240227/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/27\r#\r入院的第 37 天。\n焦慮的情緒日益漸增，主要的原因是在「不確定哪時候可以出院？」這件事情上面。稍微回頭看了一下過去寫的日記：院方（廖醫師）在 20 號的時候就把我的資料給送出去了，理論上來說，寄出之後 2-3 個工作天軍方那邊就會收到才對？但中午致電給輔導長時，他說「他那邊還沒有收到醫院送過來的文件。」這有點奇怪？因為包含今天在內的話，今天已經是第 6 個工作天了（20, 21, 22, 23, 26, 27），有點安心文件是不是在路上出了什麼問題？畢竟一份軍方的文件，從軍方有在台中配合的醫院裡，送到嘉義的軍營裡面，應該不會花到 6 天的時間吧？這種「和我有關，但我完全無法靠自己控制」的事情真的是最能夠讓我焦慮的事情了（這也是我在軍營裡面爆掉的大主因）。\n中午浩洋和柏豪差點在廣場打起來（準確來說是浩洋想要重現「223事件」）老樣子，雖然浩洋口中說著「不要攔我，在攔我的話我會連你也一起打。」但我還是自願充當那個在護理師趕來之前，把他纏住的那個人（哈哈）。感想有兩個：分別是「幹他的力氣好像有點大欸」跟「幹他力氣那麼大，我居然能拖得住他欸 XD。」看來每天的體能訓練和晚上的金城操真的幫助我在物理上精實了不少。也挺感謝燦瑋在第一時間就把柏豪拉得遠遠的，還有其他人馬上去叫護理師過來。\n印象中那時候有個人叫我別拉了（不是浩洋），聽到之後我下意識地回了「沒關係，打我至少比打在他身上還好（年輕人身體硬朗 rr）。」中二一點來說，想要記錄這段情節主要原因是「我的英雄學院」裡面一直有一段台詞我很喜歡、也很嚮往——在頭腦開始思考之前，身體就已經先動起來了。雖然事後想想有點危險，但我內心是真的很高興我無論是這次、上次、上上次，亦或者是數不清楚的那幾次，我都是那個可以「在思考之前，先讓身體行動」的那個人。感受到自己逐漸擁有自己所嚮往的特質真的好令人高興～\n最後做個從昨天尾段拉過來的首尾呼應：、無論我待在這裡的這段時間到底是不是在「逃避」，我仍然不後悔我做出來的這個「選擇」。它至少讓我更加認識了自己、更加認識了「護理師」「職能治療師」這些職業、讓我更明白精神病患有種類和嚴重程度、也在這裡學到了一些原本待在軍隊裡面也許遇不到的事情。但話雖如此，我還是希望自己可以儘早離開這裡，或至少解答目前最讓我焦慮那個問題——我的那份文件現在到底在哪裡？\n"},{"id":121,"href":"/_trash/diary/202402/20240228/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/28\r#\r繼允發現我這幾天焦慮的情緒了，在我什麼都沒說，他也還看到我近期的「憂鬱日記」的時候。他說他是觀察出來的。如果我有他的觀察力的話，我的算命功力至少可以提昇 100 倍吧？甚至遠遠超過 100 \u0026hellip;。今天早上大家同樣處在一個相對壓抑的氛圍之下，主要的原因有兩個，分別是新來的軍友 A 和民眾 B（和 223 事件 的 A, B 是不同的 2 人）。A 是一個有過動傾向的人，按照他人的說法我自己的感覺來看，他很容易讓周遭的人（包括我）處在一個很躁的情境之下。\n「欸我什麼時候可以出院」「欸我下禮拜可以出院嗎」「欸他今天走了，等等下午會換我嗎」「欸醫生哪時候會來啊？我要問他我哪時候可以出院」。即便你已經回答他了，他還是會再問一樣的問題，或類似的問題，加上他真的很喜歡往我們這邊靠攏，所以所以我們都有點招架不來，有時候甚至得被迫放棄一些平常時間的聚會聊天（因為只要他一走過來，我們無論是誰，都會什麼話都聊不下去）。\n另外一個民眾 B 是新來的病友，大概才來 2-3 天而已。B 老老的，看起來至少有 80。因為他前幾天最常做的事情是在某個角落大吼大叫、趴在地上假裝自己跌倒、偷走別人三餐的配料（甚至是整份餐點） \u0026hellip;等，所以醫護人員最後真的無計可施，只能先把 B 安置在相對單人的空間裡。但他時不時還是會在裡面肆意地咆哮、用手邊或空間裡的物品大敲大鬧，所以多少還是會影響到我們。\n他倆讓我們很不開心（準確一點的說法是：開心不起來。）今天早上剛好 A 去做了心理測驗（不安因素 -1），所以大家難得聚在了一起，不過因為公共空間只剩下距離 B 房門最近的那張桌子沒有人去（我想也是\u0026hellip;），所以我們只能在那邊聊天。大家都到齊之後， B 老樣子在門口不停地大吼大叫，但我在過程中有發現到一個規律——那就是只要有人站在門口看著他，他就會看著門口的人，然後回去躺床（間隔大概 15 分鐘）。所以自從我發現這件事情之後，就直接把自己的位置改到了 B 的房門門口，結果也正如我所預期的那樣——不安因素全數消除。\n繼允聊了一些他在這幾天觀察下來，覺得我們每個人可能可以「嘗試變好」的一些方向——也就是點出他認為我們自己會生病的核心問題。其他人的部分我忘記了，我只記得其他人的他都說得很多、也很詳細，但我這邊他只說了一句話：「不要太強迫自己。」然後補充「你的焦慮基本都是自己給自己的。」我還沒深入的剖析這兩句話，但我覺得基本上他都說到點上了，所以我該思考跟嘗試進步的地方不在於「理解話語本身」，而在「改變話語」這件事情上面。\n下午 13:30 有一次 15 分鐘的會客，理論上來說應該會是最後一次了。這次來的人只有我爸，我們很少見地聊了很多，起初他好奇的問了一句「啊表哥的女兒大概怎麼樣？」然後聽我大概說完之後，他給了我很多很多我論命上的建議。這些建議跟前幾天我在檢討「算不準小 OT 事件」得到的結論有點類似、具有共時性、或者是說得簡單一點：巧合——我太常用武斷或直接的詞語來描述一個人、或者是一件事情了。但這件事要深入聊的話會講很久，所以就在這邊先打住吧！\n總而言之，從這次的談話中，我再一次感受到了「智慧的高低和學歷的高低本來就不成正比」這件事。我的父親只有高中肄業。之後先後嘗試過各種粗活（水電、油漆、搬磚、冷氣維修 \u0026hellip;等），最後是定在一家麵包店，裡面當 20 幾年的烘焙師傅。從世俗的觀點（學業與成就）來看，他絕對不是一個「很好」的父親，但他善長的並不是那些東西，而是韌性、交際、與說話方式。他跟我分享了很多「就算你想要保持現在的風格，也可以嘗試改變的說話技巧。」這無疑給了我一個巨大的啟發。我想，我之後應該會認真試試看他所說的那些方法來論命了。\n最後是一些思考時間：承接昨天的話題（我的英雄學院那個），今天繼允說過的話讓我有點想要重新思考我所「嚮往」的到底是怎麼樣的一種人格特質。準確一點來說：一直以來，我都有「我要變成能說出那句話的那種英雄！」的這個目標。但細節一點思考，我定義的「英雄」是哪種英雄呢？或者是說得白話一點：我要讓自己在哪些地方上面，變成「英雄」的身份呢？如果答案是「所有方面」，那結果就會導致類似於「當兵之後被送進精神病院」的結果。\n正如繼允所說。因為我一直都想要當那個「英雄」，所以我會一直跟自己說「在別人開始行動之前，我就可以開始行動了。」這無形之中就會把壓力累積在自己身上，強迫自己在任何事情上都盡善盡美，最後就會惡化成「為什麼我連這種事情都做不好？」當兵前這個狀況可能還比較不明顯，但至少在入伍的那 6 天，以及入院後的這段時間裡我都是這樣度過的。雖然這樣會讓其他人感到舒適（因為他們被我這個「英雄」給「保護起來」了），但緊接而來的就會是我的憂鬱、焦慮 \u0026hellip;等比較嚴重的負面情緒。\n雖然從大家的回饋來看，即使之後會帶有一些負面，但我確實能夠從中獲得一些快樂與成就感。但在那之後呢？我並不想當「被軟土深掘」的那一方（雖然我知道現在的朋友都不會這樣對我）。而在這個問題點上，我英並沒有「教」我如何去處理（畢竟本質還是王道漫，王道漫沒人三不五時就在跟你聊這個的）。所以也許除了現在的個性之外，我也需要試著學習當一個懂得 \u0026ldquo;袖手旁觀\u0026rdquo; 的人吧？\n"},{"id":122,"href":"/_trash/diary/202402/20240229/","title":"日記","section":"_Trashes","content":"\r日記：2024/02/29\r#\r2 月的最後一天，同時也是 4 年內難得一見的 2/29 號。今天是給自己的休息日，所以早上的主要活動就是躺在床上思考、放空、或者睡覺。廖醫師大概在 10:40 左右進來查房，我跟他說了目前的文件狀況（軍方那邊說他還沒收到我的文件），廖醫師挺訝異的，並跟我要了部隊的聯絡方式，我猜他之後應該會加大力度幫我盯進度吧？看來效率可以提高不少，根據 25 號的預言，只剩下明天（3/1）有時間可以實現了（因為假日基本上無論是院方、或者是軍方，他們對軍病友這邊都不會有新的行政進度，所以軍人幾乎不會在假日離開），好期待明天的結果。\n早上基本沒發生什麼事（除了聽說餐廳那邊有糾紛，造成顏勤心情有點不好之外），所以就用一句話草草帶過。下午我原本也想要繼續睡覺的。但大概 2:20 左右繼允跑來叫醒我，他跟我說「等等 2:30 有 2 樓的閱讀時間，問我要不要去？」我看了一眼 \u0026ldquo;被詛咒的占星書\u0026rdquo; 之後就點頭答應了，也順便把翔之和燦瑋叫起了來。我這次上樓的目的是想要看那本被詛咒的占星書，繼允是想要找 \u0026ldquo;他堂哥\u0026rdquo; 聊天，燦瑋是讀沙丘。\n一開始的氣氛很和諧，和諧到大 OT 説「這是她這幾次以來，開辦過最有成就感的『閱讀』了。」因為大家都真的在閱讀，沒有人已閱讀之名，行他事之實。燦瑋在之後的某一刻有轉頭和坐在後面的 OT 姊姊聊起沙丘，我不知道他們是怎麼開始話題的？沒有特別注意到。而繼允後來也因為 \u0026ldquo;他堂哥\u0026rdquo; 今天沒出現，所以就在他倆旁默默聆聽、觀察，以及醞釀等等的超級大場面 \u0026hellip;。原本的氣氛一路和諧，和諧到他們的談話完全無法影響到我閱讀，直到姊姊開口問了一句「那繼允你覺得呢？你有什麼看法？」我就不能再專心讀書了。\n——有趣的東西要來了\r#\r沒有要被掰彎的意思，但我真的好～愛好愛繼允。他的行爲、他的說話方式、還有他的觀察力無一令我歎為觀止。「那要看我們現在是以什麼樣的身份來對話，我才能決定我要怎麼說我的看法。」這是他丟出來的第一個回答，十分銳利。姊姊沒有意識到他接下來想要說什麼？所以同樣是以 \u0026ldquo;太極拳\u0026rdquo; 的教科書回答作為答覆。然後就得到了「對！就像這樣！這個回答讓我覺得現在我們應該是醫生跟病患的關係，所以我想要直接回答我最真實的看法。」——我覺得剛剛你們的那段對話很幾乎沒有什麼太大的意義。\n接著繼允就是一連串的強勢進攻：「我覺得妳只是因為需要工作，所以才在跟燦瑋的『聊天』。」「我覺得在剛剛的對話中，你完全沒有投入任何的情感進去，所有的答話都像是教科書般的回復與應對。」「我覺得以一個精神科的醫生來說，你可以說是把這份工作做到了『近乎完美』程度。」「妳把妳的情緒隱藏地超級好的，無論是現在、還是在一樓的餐廳、或者是其他『病友能看到妳』的時候。」而我射從旁輔助：「妳可以跟我們分享一下妳是怎麼把情緒掩飾到這種程度的嗎？」「職能治療師有相關的面部表情和言語談話的教學嗎？」\n一連串尖銳地問題，很明顯地讓姊姊卡住了，從繼允事後的說法來看，他說在問第二個問題之後，姊姊明顯從「工作用」情緒一瞬間切到了「防禦用」的情緒。（他的判斷依據是姊姊的手從放在桌上、變成摸指甲、最後到插進口袋。）總而言之，在之後的 20-30 分鐘裡。我們不停地對小 OT 進行試探、攻擊；然後退一步、試探、攻擊；再稍微往前一步、試探、攻擊 \u0026hellip;。一來一往的交談當中，幾乎姊姊每一次的回話，都可以讓繼允從中獲取更多可以往前（或往後）的訊息。除此之外，坐在旁邊的大 OT 也很清楚繼允現在正在做的事情，但她絲毫沒有要幫忙小 OT 的意思（因為在這過程中，我有補問一句「那老師的看法是 \u0026hellip;」，然後大 OT 回答了「我現在什麼都沒有聽到哦～」）。雖然姊姊的太極拳至少有 99 分的水準，但還是可以感受到她在那時候的不知所措中，也有丟出幾分的真話出來（雖然我分辨不出來，但繼允應該可以）。我敢肯定：姊姊以後一定會超～級討厭我跟繼允同時存在的場合。\n最後是一個小小的有趣紀錄：我們在今天晚上進行了一次 803 院內的值星交接儀式。晚上做完金城操之後，我們所有人在連集合場集合（其實就是廣場中間的涼亭啦）。原本的氣氛只是單純地「有趣」，直到值星官（金城）把他的值星帶拿出來之後，氣氛直接從有趣進化到了「爆笑的失控」。也是到了那時候我才明白：原來我一直以來，都不是「國軍臺中 803 總醫院，精神科十六病房的 22 床病友」而是「國軍 803 旅、重症營、重症一連的 022 號二兵」。必須得說：整個值星交接的過程中，我完全沒有辦法立正站好，全程都是蹲在地上笑到無法出聲的狀態。\n"},{"id":123,"href":"/_trash/diary/202403/20240301/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/01\r#\r身為一個神棍，我想，偶爾相信一些像是「吸引力法則」這種在大眾眼裡偏向怪力亂神的東西應該也很正常吧。為什麼會這麼說呢？因為我在 25 號的日記 \u0026ldquo;許願\u0026rdquo; 了「希望那一天是我在院內的最後一個星期日。」並且在昨天又 \u0026ldquo;提醒\u0026rdquo; 了一次這個願望。然後就在今天，也就是能夠實現願望的最後一天，我成功的接收到願望了——也就是說我今天就可以出院了。\n出院的通知是鈞祐跟我說的，不是護理師。\n他說今天早上在量血壓的時候，護理師隨口問了一句「欸你今天要出院，阿你的行李整理好了嗎？」才知道要出院。他第一時間就跑來找我確認消息，但我那時候並不知道「他要出院」以及「我可能也要跟著出院」這件事，所以去了一趟護理站確認「我們兩個是不是今天都要出院」這個訊息，接著回到肯定的回覆：下午離開。到此為止，為期 40 天（準確來說是 38 天又 19 個小時）的住院就要結束了。（第一天是晚上來的，最後一天今天是下午走的，這兩天沒辦法奏出一個完整的 24 小時，所以時數上會比 39 天再少一點點）\n出院的時間點定在大約 13:30 左右，所以在 9:00 量完血壓之後，我大概還剩下 4.5 個小時。因為原先就有預期「近期內可能會出院了」，所以東西打包的過程並沒有花上太多時間，大概 5-10 分鐘就結束了（這就是極簡主義的優勢 rrr）。之後就是所有菌友出院之前的老環節——傳承身上的東西。因為我本身不吃零食，所以我能夠傳承的大多是是日用品居多（像是臉盆、洗髮精、沐浴乳、濕紙巾 \u0026hellip;等）。很順利把所有能傳承的東西都給了其他人。\n接著 10:00 的 OT 是我從一入院之後，就一直都沒有參加過的「烹煮」活動。（我對料理不熟，加上不知道為什麼？總對那項活動有著莫名的排斥。）因為上禮拜六才剛過完元宵的關係，所以今天做的是湯圓。整個活動同樣也是用「和諧」跟「愉快」來形容（扣掉中間某一 part 我跟繼允跑去找小 OT，然後他看到我們的第一瞬間直接面露驚恐、後退兩步。）我在過程中也有稍微幫忙（洗餐具），大家最後做出來的成品也很好吃。好吃到我認真想學「料理」這道才藝了。\n然後就是中餐，以及出院前的等待。在中間的涼亭跟大家稍微聊了一下。基本沒什麼內容，主要的活動是「猜小 OT 的年紀」。攻擊方是繼允，防守方是我。遊戲規則很簡單：無論他問了什麼（ex. 23 歲嗎？24 歲嗎？25 歲嗎？），我都回答「不是。」然後他從我的所有「不是」中，挑出他所認為的最後答案。他前前後後改了幾次的答案，但在我遊戲的最後他應該是鎖定在了 27~30 這個範圍之間（尤其是 27 或 30）。至於他有沒有答對呢？這可能就只能請他去問小 OT 了～（根據算命的客戶保密協定，我不會跟任何非客戶或客戶允許的人，透露出任何論命過程中的相關資訊。）\n接著就是出院。軍隊那邊是連長來接我們的，家裡則是姑姑來接我們。連長在送我們離開之前告知了一些相關資訊：包含在今天的 23:59 之前，我們都還是屬於受連長管轄範圍內的軍人，所以可以的話，回家之後就盡可能不出門會比較好。其次是後續的追蹤需要半年，追蹤的方式是需要回到原醫院（也就是 803 這邊）找當初的主治醫師（我是廖醫師）進行回診。最後再跟我們做一點短暫的道別之後，我就在之後的一個小時內，回到了我離開了 46 天的家中。\n回到家的第一件事情，當然就是跟家人的報備了。因為阿公阿嬤本來就在家，所以回去的第一時間（在看到房間之前）就有先做了：可以看得出來他們挺擔心的（廢話！），不知道爸爸或姑姑跟阿公說了什麼？從他們的認知來看，我是「因為長期就讀資工系的關係，導致早已養成了 11,12 點睡覺的習慣，以至於當兵之後 9 點睡覺感到極度的不適應，產生了大量的夢話、甚至是夢遊的情形，讓鄰兵與班長不得不把我安置在醫院。」的這種說法。\u0026hellip; \u0026hellip;，嗯好我之後會再調查一下是誰想出這種說法的，有點有趣！\n剛回到房間，簡直可以用「一團亂」來形容——床上跟桌上放置著這段時間爸爸睡在我房間的一些用品、隨意擺在地上的黃埔包，以及他們翻找黃埔包之後散落一地的物件、衣櫃區多了大約 5-10 件新衣服、書籍放的東搞西歪，有的在書櫃有的則放在書桌或椅子上（這他們有先跟我說過）。簡而言之，當下除了「哇\u0026hellip;」跟「災難」以外，我完全找不出其他的形容詞可以描述我當下的房間環境。不太確定他們到底是怎麼把房間放滿那麼多東西了？看來之後有得整理了（捲起衣袖）\n在整理的過程中，輔導長也有傳 Line 問我「出院之後怎麼樣？」「狀況還 ok 嗎？」「有沒有身體比較不能適應的狀況？」雖然我不知道這是不是例行性的問話？但即使是，我還是可以從那些字句裡面感受到一些溫度。只是比較糗的地方是，我把回話打成了「還ok，謝謝連•長的關心。」超糗的 rrrr！然後就被輔導長傳了一個蓋布袋的貼圖（哭）。下次我會再注意一點的 \u0026hellip;\n最後的最後，今天久違地跟阿公阿嬤吃了一頓晚餐。整個吃飯的過程很慢（相對於軍隊和院內的速度來說），但這也是我最最習慣的速度，所以也吃得挺開心的。阿公跟我說了很多他以前當兵的事情，也跟我說了一些其他的事情（有些模糊，有點忘了），感覺今晚應該是他難得話這麼多的一個晚上。不知道他在我離開家裡的這 46 天過得如何呢？有沒有吃飽、睡好、把身體照顧好呢？希望有才好。\n總而言之，我回家了。\r#\r"},{"id":124,"href":"/_trash/diary/202403/20240302/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/02\r#\r因為早睡的關係，今天洞五四五（05:45）就起床了，還嚇了我爸一跳，他上次看到我這麼早起大概是我還在上高中的時候了吧？哈哈！今天早上同樣在進行整理房間的工作。主要分成書櫃區、衣服區、書桌區、以及軍用品區三大區塊。書櫃的部分基本上是最簡單的：只要先把全部的書拿出來、再把全部的書給放回去就可以了；衣服區是其次比較好整理的地方：因為在軍隊和住院的過程中，那些曾經被我穿過又帶回來的衣服、都疊在同一個地方，所以我只需要把它們分類再重新放回去就可以了。這兩個地方總共花了 20-30 分鐘左右，算是相對比較好整理的兩個地方。\n至於書桌跟軍用品區（就是黃埔包裡面的所有東西）\u0026hellip;，老實說有點令人頭疼：我一開始的想法是要把所有黃埔包的東西放在桌上，然後再從桌子整理。但到後來我發現桌子有點太小了（或者說黃埔包裡面的東西有點太多、又有點太大了。）所以最後只能全部重新放回黃埔包（含原本放在書桌上的東西），然後一件、一件、一件地把東西給拿出來，然後擺放到相應位置（小小強迫症）。最後整理完的時候，大概也已經 8 點左右了？\n早上的工作除了把房間整理完之外，還要負責洗衣服跟整理家裡的環境（在吃完早餐之後）：因為媽媽這幾天在外出差的緣故，所以這段時間的家務事都要交由我們三個人（我、我妹、我爸）來做。今天我負責「曬衣服、收衣服、幫機車加油」這三件工作。吃過早餐之後，就馬上著手進行。早起做家事真的有一種「重新動起來了！」的感覺。前前後後又忙了一點時間，大概在 10:20 左右才把所有事情弄好。雖然還是有點累，但一想到以前待在軍隊裡面的日子，就覺得現在做這些東西完～全感覺不到辛苦呢。\n整理完家裡的事情之後，接下來是個人的事情：因為我有先跟翊紘他們說「我出院之後會辦一個『和姊姊一起南下養虱目魚』的病友群組」所以早上的剩餘時間就是拿來找到名簿上的所有人，再把所有人的加進群組裡面。也因為從目前的時間點來看，出院的人只有我、嘉祐、跟鈞祐 3 個人，所以一開始的聊天內容就只圍繞在我們 幾個能聊的話題上，我也跟嘉祐說我追蹤雀羽困（すずはね こまる）的 Youtube 了～\n中午睡了個午覺。\n下午重新開了電腦，並開始了出院之後的工作：首先是「撰寫閱讀心得」。原本以為在當兵和入院的時候可以發現幾本有趣的書的。但整個 46 天的軍旅生活以來，我覺得只有《祈念之樹》這本書值得紀錄，也就只有把它的心得給完成；其次是「日記電子化」，就是現在看到的這些全部東西。因為我覺得紙本的東西終究有消逝的疑慮（相對於電子來說），加上我個人比較擅長用電腦紀錄跟撰寫東西（資工系的習慣），所以就這樣做了（但還未完成，因為文字量很大）。\n此外，在電子化過程中，嘉祐有偷偷私訊我說能不能幫身邊的親戚朋友算命？我當然是毫不猶豫地點頭啦（有錢賺嘛！貪財神棍～）。不過因為行程的關係（今天下午原本的計畫，就是要卯起來把日記電子化的。）所以我暫時把論命的時間移到了明天的下午或晚上左右（自己預計大概 6-7 點吃完飯那邊？），希望明天可以得到一個他高興、我也喜歡的雙贏結果（畢竟如果不準的話我就又要哭哭了）。\n今天晚上同樣是跟阿公吃飯，今天吃飯的人相對於昨天（我、阿公、阿嬤）來講，又多了兩名成員——我爸和我姑姑。我吃飯的時候，下意識地把腰桿打直，還被爸爸說了一下「哦那個坐姿是真的有當過兵欸！」讓大家稍微開心了一下。很顯然地，阿公想聊的東西昨天還沒有聊完，甚至昨天講的根本不到一半。今天我跟阿公大概吃了 30-40 分鐘左右的晚餐（通常 20 分鐘就算長了），久到姑姑原本要等我們聊完再整理廚房，但後來她覺得「先整理可能比較好」，所以就從我們聊到一半開始整理，也真的在她整理完的時候，我們都還沒有聊完！能感覺阿公的心情真的很好。\n最後，晚上因為有點疲乏了（打了大概 5, 6 小時的日記），所以臨時接了一個女生朋友 A 的塔羅算命。問她跟某一個男生的感情發展。從她的回饋原文來說：「我覺得，除了『顯意識』跟『淺意識』那邊對他的描述比較不一樣以外」「其他都準到靠北」「妳的功力真的是，很厲害\u0026hellip;」——這種成就感就是我想要當一個神棍的原因啊啊啊啊啊！也從朋友身上騙收到了一點點隨喜的錢錢，明天的早餐又有著落囉～\n最後，打到這裡的同時，時間已經來到 3/3 的 00:30才睡，雖然晚睡了 3 個小時左右，但還是希望明天同樣可以跟今天一樣早起，如果精神真的撐不住的話，明天中午再補睡一下就好（因為要做的東西有點多，所以我打算先養成早起的習慣，等事情少了再慢慢早睡。）祝我自己今天晚上能有一場好夢。\n"},{"id":125,"href":"/_trash/diary/202403/20240303/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/03\r#\r早上睡過頭了 \u0026hellip;，果然我昨天不該那麼晚睡的，大概賴床到快 7 點才起床，早上直接少掉快 1.5 小時的寶貴時間。但嘆息歸嘆息，早上要做的事情還是得做：首先一起床直接去幫我妹買了一份早餐。她吃起司抓餅，備註是「不要醬油、胡椒粉多。」但店員最後做出來的抓餅不知道為什麼還是加了醬油，害得我妹早上的心情被小小的扣一分。也讓我對那間早餐店的評分扣了一分（滿分 100 分）。\n今天在整理家裡的時候，意外阿現還有一些當兵跟入院時的衣服還沒有洗 \u0026hellip;難怪我昨天在點衣服的時候覺得大概有少了幾件？我還以為是我又記錯數量了。畢竟以我這個記憶力，忘記「自己身上有多少衣服」也是很正常的事情吧？哈哈哈 \u0026hellip;。今天也稍微整理了一下洗衣機和陽台的環境。雖然還沒有到要定期清理的時間，但因為我連續兩天都在那邊用，又看周圍有點不順眼，索性就開始打掃了，感想只有一個——果然好髒 \u0026hellip;上一次打掃的人一定沒有打掃好。\n此外，日記電子化的工作在今天也持續著。因為預計還要寫一段時間，所以之後除非有特別的東西，不然就不會再強調了。今天的工作除了這個之外，還有一件相對意外的事情需要處理——那就是「修馬桶」。我們家的馬桶有點特別，可能是相對老舊的關係？它的沖水量如果不保持在一個「正確的 range」就會發生問題——如果水量太少，那它沖第一次水什麼事都不會做，第二次則會把水吃掉很多，讓馬桶的水位就會變得比較低，第三次沖水就會把馬桶的水全部吃光。但如果水量太多，水箱出水閥的蓋子會蓋不起來，讓馬桶一直漏水。\n修理花了我很多的時間（至少 1 小時有）：我一開始以為是浮球的原因，但轉了幾次之後發現不管是哪個長度，都沒有辦法調整到最原本的那個「正確 range」。所以我後來把注意力放在控制出水閥的鏈條上——因為它有被調過的痕跡，（猜是我爸之前對它動了什麼手腳。）只是我不管怎麼試，都一直調整不到原本的正常長度，用不同長度的鏈條配不同長度的浮球都調不好，看來只能等晚上我爸回來再麻煩他了 \u0026hellip;。\n今天中午同樣在樓下跟阿公阿嬤吃飯。姑姑煮的，煮了一大鍋的芋頭粥。老實說我超～不喜歡吃芋頭粥的 \u0026hellip;，我是「火鍋不加芋頭」的那個流派。基本上任何跟芋頭有關的東西我都是保持著「好啦吃配料可以，但你要我把湯裡那塊芋頭嗑掉我做不到。」的那種心態。但畢竟我真～的真的，好～久好久沒有跟阿公一起吃飯了，所以我還是把碗裡的東西全部都吃光了，包含了 3 顆小小的芋頭（哭）。然後還是老樣子，阿公看到我吃光光的碗盤同樣覺得很開心。\n下午開始著手其他的工作了，首先完成預計晚上要算的紫微斗數。堂妹的排出來還蠻好的，把個性跟運程打成白話文給她檢查之後，得到了「張兄，此卦真準！」「至少有 9 成！」的回覆（炫耀），那就基本沒錯了。命宮太陰獨坐在卯，命財官雙祿巡逢、又有化科，且不見空劫忌破。是一個可以從 85-90 左右開始往上打分的格局。不喜歡冒險、喜歡按部就班算是她的一大優勢，雖然從我的角度來看，我會覺得她缺了一點野心跟冒險的動力有點可惜（畢竟我是廉破），但從擊樂瞳樑的角度來看，這個盤算是如果要剖腹的話，我會稍微挑起來的一張命盤。（順帶一提，報酬是之後 4 月的一頓晚餐，賺爛！）\n最後，值得紀錄的事情還有兩件：第一件事也是「阿公在吃飯的時候跟我聊了好多好多。」感覺他的心情真是不錯！第二件事情是我在睡前久違地上了一次 Discord 跟朋友們聊了一下我的近況、和他們的近況。沒想到才短短 50 天左右的時間（從我 1/16 入伍到今天），大家就有很多可以聊、可以分享的東西了。無論是開心的、有趣的、嚴肅的、難過的、爆笑的、懷念的事情 \u0026hellip;等。最後又稍稍超時。現在（10 點快半）才準備睡覺（遲到了 1.5 hr），同樣也在這邊立了一個 flag: 希望明天的我同樣可以早起！\n"},{"id":126,"href":"/_trash/diary/202403/20240304/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/04\r#\r早上同樣睡過頭了。\n今天早餐原本也要自己去買的，但因為是禮拜一（我爸跟我妹 7:30 就會出門、我 8:00 才起來），所以我爸已經幫我買了一個早餐——一份原味蛋餅，跟一個看起來類似美而美的小小漢堡，但漢堡裡只有一個小肉排跟一個小小的蛋而已（迷你版漢堡！）。也因為今天是出院之後的第一個「平民平日」（禮拜五出院的那天我的身份還是軍人），所以今天才開始進行一些像是繳回溢領的薪餉、申請住院實支實付的保險、把一些軍中用品和生活用品還給朋友、順便跟他們聊天吃飯 \u0026hellip;等。\n但考慮到今天一出們就事一整天，加上早上抵擋不住「賴在電腦前面吧～」的誘惑。所以還是花了大概 2-3 個小時把《葬送的芙利蓮》全部看完了。只能說超級好看的啊 \u0026hellip;，雖然直到今天為止，進度才演到一級魔法使篇中，第二次考試的後段而已，但相較於當兵之前（第一次考試前段），也有蠻多的進度可以補的。只能說芙利蓮的動畫組真的把魔法戰鬥的打戲呈現得好好看，文戲也都演繹得好精彩，完全能感受到製作公司對於這部動畫的用心。\n看完芙利蓮後才開始認真工作。原本的預期是從近到遠——先理頭髮、然後還給國家多領的薪水、去申請保險、最後再去學校把東西還給朋友順便吃飯。但在我理完頭髮之後（大概 10:20 左右吧？），接到了我爸打來的緊急電話：他說「沒有今天一定要做的事情的話，那就回家。」（我爸講話都沒講重點的）也看到了家裡的 2 通未接來電。那時候才心想「可能家裡出了點問題吧？」結果回去之後才發現那「一點」問題可大了——阿公暈倒送上救護車了。\n詳細的暈倒地點是在他房間的浴室，那時候他應該正在上廁所？阿嬤看阿公好久都沒有從浴室走出來，想說進去看一下，結果發現阿公好像是便秘用力過度、腿軟了站不起來，所以想要去扶阿公。這不扶還好、一扶之後才發現阿公直接在廁所失去意識，她隨即 call 了我、我爸、和我姑姑 3 個人的手機。我爸因為那時候也在家，所以是第一個到現場的人，他做了點判斷之後，就打給救護車了。\n救護車把阿公送去距離我們家最近的大醫院——慈濟。但因為阿公之前的就診紀錄都是在台中榮總，所以我們一到慈濟就改叫民用救護車轉院到台中榮總。 From 慈濟 to 榮總的這段救護車是我陪阿公的，也是我第一次坐救護車的副駕。第一次坐在車子裡面聽到鳴笛、看到讓路、闖紅燈、各種救護車的極限操作真的是讓我再一次睇感受到了護理人員的辛苦。雖然整趟路程從 map 上面看大概需要 18-20 分鐘的時間才會到，但在救護車的特權下，我們只經過 10 分鐘就到中榮了。\n到中榮之後大部分的作業都是我跑的（畢竟只有我待在那邊），流程是先掛號、然後看診、再來抽血、驗尿、照 X 光、待在急診室等急診裡面的病床、最後抽血完過 1.5 hr 之後回去看診的診間了解抽血報告。阿公其實在叫完祐護車之後就恢復意識了，只是為了保險起見，我們還是送醫檢查了一次。也因為整趟阿公都是意識清醒的，所以也久違地跟阿公聊了幾句（但大部分都是在類似尬聊就是了，因為前幾天也聊了很多）。也意外從看診的時候發現到阿公是個藥罐子（一天大概會有 15 顆左右的藥要吃）。\nX 光跟抽血報告的結果基本上沒有大問題。X 光上有看到阿公的肺不太好（相較於一般人來說），但因為他曾經是個老菸槍，加上他之前來榮總照 X 光的時候都差不多是這個樣子，所以在這樣的情況下，他的 X 光算是比較「正常」的類型（就是沒問題的意思）；至於抽血 \u0026hellip;除了腎功能有些下降以外，其餘也是一切正常。所以醫生最後給出的診斷是「阿公的心跳本身就比較慢，加上大便的時候憋氣讓血液一時沒有辦法上去腦袋，導致頭那裡供養不足才暈倒的。」簡單來說，可以用一句話做總結——因為大便太用力、閉氣太久所以昏倒了。\n我們最後大約在 7:20 點左右辦好出院手續，在這過程之中也見到了好久沒見的叔叔，但因為叔叔來的時間是下班之後（大概快 6:30 那附近），那時候已經確定阿公基本上沒問題了，所以叔叔一來之後就在辦出院相關的事宜，也因此沒有聊上幾句。最後我們在 8:50 左右回到家，到目前為止，時間已經已經 21:23 了。等我打完這份日記之後就要去洗澡睡覺，準時兩兩洞洞（22:00）關燈躺床～\n"},{"id":127,"href":"/_trash/diary/202403/20240305/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/05\r#\r今天早上 5:50 完美早起啦。算是睽違 2 天之後的完美早起。早上基本的工作都圍繞在「衣服」上面。前前後後用了 2-3 次洗衣機 + 一整天的太陽把所有的衣服全部洗完，算是幫早上的工作起了一個好頭。除了衣服的家務之外，也趁著洗一機在工作的空白時間（每次大約 1-2 小時）抽空幫阿公去拿藥、幫阿嬤買立可白、幫他倆老人家買午餐 \u0026hellip;等，也做了一點昨天預計要完成的，可以在家裡附近就做好的事情：像是「到郵局把多領的薪水繳回去」之類的。等到家裡附近都「沒事可做」之後，就開始了今天的忙碌行程：\n首先，昨天忘了說：出院之後要先去區公所變更一次兵役的體位，所以第一站是北屯區公所。公所的大哥看到我的時候嚇了一跳，然後調侃了一句：「欸又是你哦？怎麼又有事情了，哈哈哈！」坐在櫃檯的替代役學長也笑了一下。仔細想想這段時間（從去年 9 月左右到現在）真的是麻煩他們了。下一次（預計也是最後一次）因為當兵的事情跑區公所大概就是半年檢查完之後了吧？（大概是 8, 9 月那邊）\n區公所的行程結束之後，下一站是南山人壽的理賠申請。看了蘋果地圖、google map、和問住在周邊的人，前前後後總共跑了 3 個不同的地點才找到了現在（2024/03/05）南山人壽的所在位置——在北屯路大買家旁邊，帝國大樓（北屯路 360 號）的 5 樓。因為是第一次自己申請理賠，加上其實不太清楚自己可以申請什麼項目（聽說是實支實付？）所以一開始在確認身份（跟確認理賠項目）的時候花了點時間，幸好櫃檯的姊姊還蠻有耐心的！也很願意跟什麼都不懂的我說明那些東西大概要怎麼查？怎麼寫 \u0026hellip;。最後總算是在經歷一番折騰之後，完成了理賠的申請。\n今天沒有去學校附近還東西。所以大約 15:30 點左右就回到家了。在收完今天可以收的衣服、和把明天要收的一稍微一個位置之後，我就倒頭睡在床上，一路死到 17:30 被姑姑叫起來吃飯了。所以今天的我大概有 2 小時的午休 (?) 時間。吃完飯後是晚上的工作。今天預計打算把 ep002（混血吸血鬼）的 podcast 全部聽完。這算是第一次認真聽我們剪接完之後的結果，整體而言蠻多可以細節說的。\n首先是聲音的問題：因為我們兩個的位置本身就坐得比較近，所以無論是我的 mic 還是大頭的 mic 都會吃到對方的聲音，所以在經過討論之後，我們打算多買一個防噴罩跟 2 個麥克風照測試隔音效果，同時把錄音的座位拉得遠一點（這個應該最有效果？）。此外我重聽之後有發現到「我的講話很平淡」這件事情。應該說那就是平常的我，但我沒想到從 3C 產出來的結果會讓人這麼催眠，看來我得好好練習一下「情緒」的部分了。\n此外，無論是我還是大頭，我們的說故事能力都要加強——我們都有很好的故事，但我們的表達都沒有辦法很完美地重現那個故事最有趣的地方。像我自己的話 \u0026hellip;，語氣平淡、容易忽略重點直接講結果、還有一直「然後」「後來」「就是」就很容易打斷那個沈浸的節奏。但扣掉這些部分來說，畢竟這是我們兩個第一次的長錄音（也是第一次回聽我們的結果），所以就「初次上場」而言，我覺得還是可以給到 70 左右的分數？但大頭對我們的組合就比較嚴苛了，可以看得出來他對 podcast 的熱忱遠遠大過我很多，所以從她給我們的評價看來，我猜她應該會打 20-30 吧？雖然我覺得不至於那麼低就是了。\n最後。日記打到現在也已經 20:40 40 了。我預計 21:00 關電腦。然後花一個小時抄 2 份般若波羅蜜多心經，最後再洗個澡、拖一拖、摸一摸，然後跟昨天一樣 22:00 完美就寢。至於有沒有辦法完成呢？只能指望等等的我不會不小心點開一個很好看的 youtube，然後就不小心超時了，哈哈哈（Flag 立超大）！簡而言之，今天是個雖然忙碌但很充實的一天。\n"},{"id":128,"href":"/_trash/diary/202403/20240306/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/06\r#\r昨天的 flag 很好的被拔掉了。今天早上同樣洞五五洞（05:50）完美早起，但也完美的再起來 10 分鐘後繼續賴床，直到大約 7 點左右？因為要跟姑姑一起陪阿公回榮總複診，才睡眼惺忪地第二次起床。今天主要複診的目的是確定前天（也就是 4 號）暈倒的後續狀況，看看有沒有什麼需要留意的？或者是之前漏掉但在這 2 天才又發現新的問題 \u0026hellip;等。但從複診的結果來看，應該沒有什麼特別需要提的問題，所以只是單純的看看報告、說明報告細節，然後就走了（大概 9:40 到家）。\n回家之後，我則繼續處理日記電子化的工作，這大概是我目前最最龐大的工作（沒有之一）了。雖然現在已經 6 號了，但電子化的進度大概只維持在 2/19, 2/20 左右而已。會這麼慢的原因主要有兩個：第一個是我在寫日記的時候是抱持著「等之後電子化之後就要寫得詳細一點」的心態在寫的，所以基本上紙本上的文字都是經過壓縮後的文字（微文言文？），加上我自己會要求「紙本上的日記一定要寫滿。」所以假設一張紙大約有 400, 500 左右的字數，搬到電子日記上之後，就很容易「解壓縮」到 600, 700, 甚至是 800+ 個字元。\n然後是中午/下午的行程：\n中午同樣在樓下跟阿公阿嬤吃中餐（現在都會直接在樓下跟他們吃飯，順便聊聊天）。吃完飯之後我把房間的東西整理整理，去了一趟學校，把最後在住院的時候打算要做的事情做完——也就是把當兵前跟朋友借的東西還回去。因為借的東西有點多，加上我有點想要偷渡一些「在家不好丟」的東西拿去學校丟（像軍靴 \u0026hellip;完全不知道要怎麼處理），所以我索性直接把所有要帶東西塞進黃埔包裡，扛著那個大包包去了學校。\n去久違地學校見到了嘉彥跟大頭。在一邊整理我自己的座位(?) 的同時也跟他們聊了一些我在當兵跟住院的事情。雖然大頭大部分都聽過了，但因為我真的好～久沒有跟他們說話了，所以她就被迫再全部重新聽一遍我的所有故事（超難過，哈哈）。此外，因為在當兵之前我有用她的學生證在學校的圖書館借了幾本書，所以今天來學校的次要目的是把那些書還回去（順便借一些我這幾天心想看的書）。\n下午同樣久違跟大頭吃了一頓晚餐，我們去吃學校附近的傻瓜麵。他對我新養成的一些習慣（像是三不五時就會瞄一次手錶）感到非常地不適應，但我自己則是抱持著「反正不會影響到別人，所以應該不會改」的心態在面對 XD。另外今天到學校之前也去 7-11 領了當兵前跟朋友訂的手工手鏈，但可能是當兵瘦了一頓的關係吧？（從 70+ 一路跌到 66 附近），可以明顯看出送來的成品已經變 over size 了。所以原本打算在吃完飯之後去一中街裡面的市集調整長度，但後來忘了（哭）。\n除此之外，今天到 2502 後也發現實驗室裡面新來了一個新的學妹，但沒聊上幾句。聽嘉彥說是鈞淯老師 9 月份的碩一生（所以學妹現在是大四，算一算跟我差了大約 3 歲）。然後今天也久違地在研究室後面的床上睡了一下。只能說——一中街真的好吵 rrrrr。已經習慣戴耳塞睡覺的我，在入睡的前 10 分鐘都超級痛苦的。不過後來還是順利睡著了，接著就被一個好消息給吵醒——程育也從院內出關了～好棒！\n最後，下午（大概 6, 7 點那邊）稍微跟大頭聊了一下後續的 podcast 方針，主要是針對昨天看到的問題做討論和研究，討論完之後我就回家了。回到家之後發現桌上擺了麥當勞宵夜（4 塊雞塊 + 1 杯中杯的檸檬紅茶），是妹妹買的（好感動嗚嗚嗚）。吃完之後打了這篇日記，等等同樣也是關電腦、洗澡、有時間的話再抄一份經，最後就是睡覺了。\n"},{"id":129,"href":"/_trash/diary/202403/20240307/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/07\r#\r今天早上同樣完美起床。\n昨晚最後沒有抄經，所以從今天早上開始要維持「每日 2+ 抄」的習慣（補當兵那段時間沒有寫到的部分）。抄完經之後，因為今天的洗衣服不是我負責（變相來說，我今天早上沒有家務要忙），所以早上同樣在做日記電子化的工作。早上拼了一點，把進度趕到大約 3/3, 3/4 那邊，預計明天就可以把所有想要寫的東西全部都電子化了～此外，對於日記和個人網站的部分，我也稍微做了一點變更（把工作日誌的頁面刪掉、改成日記，同時把 2/13（含）以前的內容拿掉）。\n中午去同樣在家吃飯，今天吃的是家裡附近的古月食堂，看到這店名我就想到好久沒有跟古月聊天了，不知道他現在過得怎麼樣？（上一次更新他的消息還停在特戰每天要全副武裝跑 5000 兩三次），但算算時間應該是退伍了，所以現在應該已經在家瑋老師那邊工作了吧？等等（或這幾天）有空的話再跟他聯絡一下好了～\n下午同樣去了學校（今天禮拜四有 meeting!!），昨天因為有麻煩大頭申請一份機車證給我，所以今天終於可以光明正大地停進學校的停車塲了！呦呼～！Meeting 開始之前雅芬老師關心了一下我的身體狀況（她知道我住院的事情），然後再問了我一次「有沒有打算讀博士？」的問題，我想我該認真思考讀博士的可能性了，就算今年不要，那明年或者是更以後呢？這個「博士」對我來說有沒有價值？是時候思分析一下了。\n這禮拜的 meeting 是聽了佳彥的會議論文書報，同樣是攻擊型的文章（也就是針對現有方案提出安全疑慮的論文內容），很雅芬老師的風格。被攻擊的文章好像原本有聽過？但沒有很深的印象，隱隱約約只記得「這篇文章有問題」而已。但嘉彥的 ppt 做得蠻不錯的！進入到 security analysis 之後馬上就勾起我以前對這篇文章的回憶了，他真的是一個好厲害的學弟 XD。此外，在 meeting 中間的閒聊環節，學姊也給了我們一些中華電信的職缺機會，有助於我們現在（或畢業之後）可以馬上銜接職場，同樣也是一個人超好的學姊（哭）。\nMeeting 結束後同樣待在學校，然後晚餐同樣也吃了幾天前才剛吃的傻瓜麵。跟預期的不同（聽完 meeting 就回家），我在學校待了一個晚上，主要是在 meeting 結束之後我們（我跟大頭）聽鳳鳴說了很多她現在的工作狀況，前前後後聊了大概至少 1 個小時有？但因為聊的不是我自己的事情，所以我就不寫在這邊了。總而言之！也是辛苦她了！鳳鳴的 part 結束後我前到了幾天去申請理賠的南山人壽打電話過來：說要補件交「護理紀錄」才可以申請理賠（預計三月底之前會會進來我的帳戶），所以明天得記得補件才行！不然我的錢錢就要飛走了！\n"},{"id":130,"href":"/_trash/diary/202403/20240308/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/08\r#\r今天同樣完美起床，但今天沒吃早餐，也沒抄經（哭）\n早上忙著在做最後的家裡打掃，因為今天是媽回來的日子。起床之後先是把妹妹洗好的衣服拿去曬，然後是丟進最後一份要洗的衣服，再來是把所有眼睛看得到的地方跟看不到的地方都擦了個遍、接著吸地板、清理樓梯的垃圾、整理家裡的環境、然後把剛剛丟進洗衣機的衣服再拿去曬，就完成了簡單的「準備」。然後是「考試」：大約 10 點左右媽就回來了，從第一眼望去，他對於家裡的環境沒有特別大的怨言，看來「基本分」已經握在手裡了。後面的「考題」就不會變難。「監考」的力度也不會被拉高，算是一件對我來說還蠻可喜的事情。\n除了打掃家裡之外，早上預期的工作是「安排之後要做的事情。」日記電子化雖然只差一步就要完成，但這幾天拼下來老實說有點疲乏了。打開電腦的第一件事情不是寫日記就是寫日記，我覺得偶爾換換風格，做點別的事情也不錯，所以就打算趁著現在好好歸納跟整理一下現在有的東西。但才坐上書桌沒多久，就被媽媽 call 過去了。稍微紀錄了一下 10-12 點間被叫出去的時間點：10:01、10:13、10:25、10:43、10:47、11:03、11:32、和 11:51。次數算是有點多，老實說也沒有很完整地安排之後要做的事情，但這麼頻繁的次數應該是第一天回家的關係，下午或明天沒意外就會降低很多了。\n中午跟媽吃了 15 顆水餃（今天因為是媽回來的第一天，加上入伍之後第一次跟她有吃飯的機會，所以就把午餐時間挪給我媽這邊了）。稍微聊了一點未來的規劃，目前沒意外的話應該還是打算往國外的工程師發展吧？畢竟工作時間彈性（遠端工作 + 沒有固定上下班的打卡時間）、薪水又不錯（比國內的工程師行情價多了至少 10k 有），也從我媽那邊聽到了幾個不錯的工作機會，明天或之後可能會稍微研究一下？\n中午直接睡 4 個小時，所以基本上下午都沒在做事。\n醒來大概是 16:10 左右，趁著最後這段「晚餐前的時間」把「日記電子化」給完成了！也算是稍微放下了一個心中的大石頭。之後如果有什麼想要回顧的事情，直接翻一翻我的日記就可以看了，想想就覺得很新奇（哈哈！）沒想到當初在當兵那段時間無意培養起來的興趣，居然可以一路維持到現在，我想這就是累積的力量吧？無論是這種普通的習慣，抑或是住院時光的體能訓練、體前彎，還有一直以來都有在練習的定期定額、紫微解盤、經文抄寫 \u0026hellip;。\n所有的東西都是經由「累積」而來的，很少有能夠一蹴而就的機會（至少我自己從沒有過）。雖然每天看都只是進步一點點，但某個時間點（例如今天）往回看之後，就會發現其實在這段時間也做了好多、好多的事情～一想到這邊，就覺得還能生活在這個世界上真的太好了。也再一次地認知到了《小丑》裡面的一段話：「只需要一個糟糕的一天，最理性的人也能成為瘋子。」即便現在的我是這麼正向、這麼樂觀，但在不久之前，我可是差點能成為小丑的那個人。\nBTW 今天最後還有兩個值得紀錄的 bonus：\n我妹今天晚上要去日本玩了～ 翔之也出院了！咱「南下養虱目魚」的主人公出關啦！ "},{"id":131,"href":"/_trash/diary/202403/20240309/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/09\r#\r今天是表定的休息日，所以睡到了 9:40。\n早上起來之後，吃了爸買的早餐——一份美而美的漢堡，加上一杯大冰奶。然後待在電腦前面看了一整個早上的 Hololive 烤肉。除了坐在電腦前面耍廢之外，早上值得紀錄的事情還有 3 件事情：首先是今天有抽出約 1 個小時的時間幫媽媽驗算她這次出國期間的所有花費（公費 and 私人借閱）。從那些被帶回來的 Receipt 可以看得出來他們出差的這幾天真的是超級忙碌的 \u0026hellip;，途中還遇到了一次德國的罷工導致他們最後需要「逃」到奧地利才可以回台灣，好辛苦 \u0026hellip;。\n第 2 件事情是「我被我媽催說要找工作了。」它（指這件事）其實有在我的預期之內，只是我沒有想到會來得這麼快（原本以為大概會有至少 3-5 天的緩沖之類的？），從以前的經驗來看，我再來大概只剩下一個禮拜左右的時間。在那之前沒有給她一個滿意的答覆的話，她就會開始幫我找工作了 \u0026hellip;（就像是之前妹妹那樣）所以原本預計「休假」的計劃現在只能先放在旁邊，最慢下禮拜一（11 號）就要聯絡二表哥了。（二表哥那邊有個不錯的工作機會，就是昨天說的國外的工程師）\n最後一件事情最重要：Hololive 的梅露（夜空メル）被解約了！什麼情況？哭啊 1/16 的新聞我居然現在才看到！也太慘了吧？我超喜歡的桃鈴家大姊 (;´༎ຶД༎ຶ`)。從官方發的公告來看，看起來是是因為洩漏公司機密而被解僱的。到目前為止（03/09）沒有什麼特別的消息，看來應該會比露西亞的狀況還要再好一些吧？但就只是一些而已 \u0026hellip;，還 4 難過 rrr。\n中午吃了一份放在冰箱 3 天左右的炒飯，它是我三天前（也就是 6 號）的宵夜。但因為我現在已經戒掉(?)吃宵夜的習慣了，所以那份炒飯就一直靜靜地躺在我們家的冰箱裡，直到大概 11:30 左右才被我媽拿出來微波。吃到了好久沒有吃到的「微波炒飯」，有種「懷念但又不懷念」的微妙感覺？（自我檢討一下：形容詞可以再豐富一點，不然日記都會寫得很無趣。）然後在吃飯期間也翻到幾張妹妹到了日本後，拍的廟宇的照片給我，超級好看！！\n今天中午吃完飯之後沒有午睡，出門去樂成宮附近，久違地找賴桑聊了一下。賴桑是唯二在我住院期間有來看我的朋友之一，另一個是晉安。（來探訪的人這麼少的原因有兩個：一方面是我朋友本來就不多，另一方面是其他人都湊不出時間來這裡，所以才會只有他倆來。）在他家玩了一下好久沒有打開來的 LoL。也跟他爸媽大致交代一些當兵之間的事情（大部分說明的還是失眠的問題）。然後也去了 lalaport 逛了一下，最後還吃掉了他們家的一個哈根達斯！賺！賺爛！\n離開賴桑家大約是在 16:00。按照計畫，原本晚上要待在 2502 跟大頭做點 podcast 的雜活（不算工作，就是說一點「之後要聊什麼內容」之類的話題），但大頭今天身體不舒服，所以她下午好像去了一趟小診所？直到 18:15 才來學校。但因為她的身體狀況真的不是很好（至少從外表上，你不會覺得她現在很有精神能跟人聊天），所以最後也告吹了 podcast 的閒聊，我也提早在 19:50 左右就回家了。\n最後，今天同樣完美早睡（21:00）。\n"},{"id":132,"href":"/_trash/diary/202403/20240310/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/10\r#\r（3/16 10:50 補寫）\r#\r今天阿公又暈倒了。\n早上基本沒什麼需要重點記錄的事情：原本預計今天晚上要約賴桑和晉安吃飯，吃晚上 19:00 的拾七石頭火鍋，但因為阿公中午又暈倒了一次，所以毫無懸念地取消了。這次的暈倒是在 3 樓的客廳，事發經過大概是早上 09:30 ~ 10:30 左右，在事發前一小時到半小時，到阿公有去廁所大便一次（因為有 4 號的經驗，現在只要是我們有空的時段，阿公想要上廁所我們都會稍微在旁邊看一下），那時候在場的有我、姑姑、和阿公三人。\n在確定那時候阿公「想上但沒上出來」後，我們就把阿公扶回客廳的座位上（那時候還到了一杯水給他喝，確定有意識）。到 11:20 左右(?) 因為是阿公阿嬤的午餐時間，所以阿嬤想要問阿公「想要吃什麼？」但阿嬤叫阿公，阿公都沒有回應，所以阿嬤 call 了姑姑下來，接著姑姑發現阿公又暈倒了，所以廣播到樓上給我。之後的流程就是固定的「叫救護車、打電話給爸爸、準備要去醫院」，最後上救護車。\n這次上救護車的也是我，我們原本要跟上次一樣先去慈濟，再轉院到台中榮總。但救護車開到半路的時候接到通知說「慈濟滿床了」（好像是那附近有一個蠻多人受傷的車禍，所以一時排不出新的床位給其他人），所以我們就改到中國醫去（有通知其他家人）。這次阿公恢復意識的時間比較晚？相較於 4 號的情況，阿公是直到中國醫之後重新恢復意識的（但呼吸跟心跳一直都有就是了，所以不排除是睡著？嗎？（應該不是 \u0026hellip;））。然後跟 4 好的情況一樣，因為基本病歷資料都在中榮那邊，所以在中國醫的時間也不長，進急診之後直接做了轉診到台中榮總。\n到台中榮總之後，首先也是做跟 4 號一樣的流程：先進急診掛號、然後等看診、再來是抽血、驗尿、照 X 光，最後在急診裡面待一個病床，等抽血之後的 1.5 hr 回原本的診間找急診醫生看抽血報告。但不同於 4 號的事情是，因為已經是這禮拜第 2 次暈倒了，所以家裡決定要讓阿公在這邊住上幾天，做個比較完整、比較詳細的全身檢查，看是不是有什麼大問題？確定都沒問題才會放阿公回家。也因此，在做完所有的檢查之後，我們最後把阿公帶到了台中榮總急診大樓五樓的 35 病房住院。最後是大約在 7, 8 點左右跟爸爸交班，9 點回到家，洗澡之後大概 10 點，好累，晚安。\n"},{"id":133,"href":"/_trash/diary/202403/20240311/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/11\r#\r（3/16 12:45 補寫）\r#\r今天同樣是洞五五洞（05:50）部隊起床。早上因為要回診 803 的關係，所以一早起來之後就在準備要帶去的文件。大概在 7:20 左右(?) 爸爸先在 35 病房跟叔叔交班完回來家裡了，所以我們按照原定計畫，在 9:00 的時候從家裡出發到 803 回診廖醫師的身心科。7:20 ~ 9:00 的時間是抄經的時間，我有點自我檢討(?) 是不是這幾天偷懶了幾天沒有抄，才導致阿公會生暈倒住院的。但後來想一項檢討這個其實有點接近「迷信」的範疇了，就類似「阿我一定是對那個那個神明還是誰的不敬，所以我現在才會這麼雖啦」這種無法證明也無法重複驗證的一刀切，所以後來就沒那樣想了。\n到 803 大概 9 點快半，從準備停車的路上，就可以看到裡面已經有一些準備要復檢的役男在排隊跟集合。還是有點難以想像我在大概 40-50 天前也是他們之中的一份子，但現在已經恢復成民眾的身份了，心裡只有一個想法——當兵真的好辛苦 \u0026hellip;，真是辛苦他們了。也在看診之前小小的憂鬱了一下：為什麼世界上要有戰爭呢？是因為有打仗的可能，所以我們才會需要當兵的吧？如果世界上沒有戰爭的話，是不是就不需要有「兵役」這份義務了呢？如果沒有兵役的話，我現在應該也不用花半年的時間每個月回診一次身心科吧？\n在身心科的診間前面等了大約 10 分鐘左右就輪到我了（我前面大概只有 2, 3 個人，而且都看很快）。見到了熟悉的廖醫師，也稍微跟廖醫師報告了這幾天的狀況：心理上大致沒什麼問題，身體倒有點累累的就是了。也跟廖醫師提出了想要減藥的看法：原本三餐飯後有 1 顆 Erispan-S，睡前有 1 顆 Erispan-S, Leeyo 和半顆的 KINAX（如果真的睡不著的話，我還有備用的 Dormicum）。但因為我自己覺得出院之後的生活還行，所以就打算停掉 SleepA 以外的所有藥物。廖醫師在評估之後也同意了！算是一個皆大歡喜（我跟我爸）的結果，也順便約了下一次的回診時間（4/10 的晚上）。\n結束身心科的回診之後，同樣照原定計畫要去學校，只不過在去學校之前被我爸小小的 gank 了一次：就是要幫阿嬤買他喜歡吃的牛肉麵當午餐。但也因為這一次的 gank 才讓我發現到那家牛肉麵店已經改位置了？原本在自助洗衣店的對面，現在直接再往後移個 \u0026hellip;2000 公尺吧？變成在沙灘排球場那邊了。總之！買完午餐之後去了學校，大概是 12:40 左右到學校的，也久違在學校的圖書管稍微逛了一下，可是沒有什麼特別有興趣的、想坐在那邊看的書，也沒有借書證可以把稍微有興趣的書給借回來，所以就回 2502 繼續看我的紫微探源。然後在 2502 後面午睡了 1-2 小時。等到大概 5 點左右才起床？起床之後跟大頭稍微說明了「之後大概一個禮拜都會在醫院陪阿公哦～」，然後趕在 19:00 前把要補錄的 podcast 給錄完回家了。\n從明天開始，就是陪阿公的住院生活了。\n"},{"id":134,"href":"/_trash/diary/202403/20240312/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/12\r#\r（3/17 15:55 補寫）\r#\r今天是陪阿公住院的第一天。\n早上 05:50 準時起床。原本打算先抄經的，但因為早起的過程中有點拖拖拉拉，所以最後能夠抄經的時間就全部被我磨掉了（真難過\u0026hellip;）。我們（我跟姑姑）預計 6:45 從家裡出發，姑姑載我到醫院之後會直接去上班，所以我一個人上去跟叔叔交接。交接的過程沒有什麼太大的問題，因為第一天進來病房的時候我有大致看過環境跟一些器具用品的分布位置，所以很順利。唯一比較小遺憾(?) 的地方是阿公沒有看到我跟叔叔的交接過程（那時候他還在睡覺），所以他一早醒來發現旁邊坐著我的時候以為叔叔只是稍微離開之類的？花了一點時間跟他解釋。\n今天在院內做了兩個比較重要的檢查：第一個是根據這兩天（和上次 4 號）的檢查來看，阿公的腎功能指數都處在偏低的位置。所以我們首先去照了一次肚子的超音波（坐輪椅去的），應該是確定要腎本身有沒有什麼問題？（如果沒問題，那數值偏低就是因為阿公這幾天吃得比較少的關係。）結果明天會出來；第二個是今天做了一個 30 分鐘的腦波檢測，也因為是 30 分鐘的檢查（有點久），考慮到阿公的年紀和身體狀況，所以我們最後決定推床過去。但說實話，我不太確定這個腦波檢查是用來檢查什麼的？但也是明天可以看到結果～\n此外，早餐因為要照超音波的原因，所以阿公沒有吃（應該說病房原本就沒有訂），但因為阿公本來就不喜歡吃病房的三餐，所以應該算是一件好事(?)。超音波結束之後我有問阿公要不要吃東西，但說他不要，看來如果明天腎確定沒有問題的話，腎功能指數可能還是會再低一陣子了（苦笑）；至於中餐跟晚餐的部分病房則是有幫忙訂，只不過阿公真～的很不喜歡這些餐點。所以他想要停掉吃的，自己去買（但我們沒照做就是了，哈哈）。此外，今天有稍微做一個出院的日期占卜，從結果來看的話，應該是禮拜六出院（最慢最慢禮拜天一定出去），但禮拜五可能會有點小小變數？只是不知道那個變數是什麼，只能等禮拜五再看了。\n然後在下午的 5, 6 點左右（應該是 17:55 - 18:05 那邊），爸爸下班來交接了。我大致跟他說一些要注意的事情，然後就收拾東西下樓去找姑姑了。今天晚上跟明天晚上原本都有約吃飯，也有先跟姑姑說過，所以坐上姑姑的車之後，就直接往聚餐的地點開了。今天約的是國中的飯局，加上我總共有 5 個人，我們挑的是一間五常路的燒肉店。飯局的過程蠻開心的，聊了很多我當兵的事情，也說了一些之後的想法跟規劃（工作之類的），可以感覺這個久違(?) 聚餐大家都很開心。\n吃完燒肉之後，我們打算到泡沫紅茶店繼續聊～老實說我沒有想到有這 part，但也因為我們約的地方還蠻好叫車回家的，所以就跟上了！我們原本約是精武路的翁記，但那天不知道為什麼沒有開？所以後來改去崇德路上的歐吉開趴。原本我希望 21:50 就要走的，但沒辦法，聊天的時間真的是太難得了，所以最後我們還是在那邊聊到了 11 點左右才慢慢回去。回去的時候叫了一台計程車，付了 250 左右的前前平安到家！\n好累 \u0026hellip;\n希望明天我能成功跟自己說「時間到就走。」\n"},{"id":135,"href":"/_trash/diary/202403/20240313/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/13\r#\r（3/17 16:45 補寫）\r#\r今天早上 06:20 起床，06:45 出門去找阿公。\n早上幾乎爬不起來 \u0026hellip;，不知道是心理因素還是我已經習慣 7-8 hr 的睡眠時間，睡覺明明只少一個小時，但我還是覺得少睡了大概 5, 6 個小時有。早上準備要出門之前爸爸就先回來了（那時候大概 06:40）。他說「因為阿公現在在睡覺，所以就先回來了。」我覺得不算是個太好的理由，但總之我們還是準時在 06:45 出門，然後我在 07:15 左右順利到了病房裡面。看到阿公還在睡覺，鬆了一口氣。幸好沒有什麼問題～也因為昨天睡不好的關係，加上我爸整理位子的功力真的是有待加強 \u0026hellip;加深了我「好不想面對」的厭世情緒，所以我到了病房之後只是簡單把背包收進櫃子，就躺在旁邊的看護床上睡覺了。\n我們一起睡到了大概 8:40 左右(?) 才起床。中間阿公有偷偷轉過來看我（應該是想確定我跟我爸交班了沒？），我們也不小心睡過了一個社工師的訪談環節。是直到 9 點左右，住院醫生定期查房我們兩個才起來的～醫生查房是早上的定期環節：會說明前幾天的檢查有沒有什麼異狀？明天或之後又要做哪些檢查 \u0026hellip;等。今天的內容大概是「腦波檢測沒有問題」「等等會裝一個可攜式 24 小時心電圖機，用來檢查有沒有心律不整的問題」跟「腎本身沒有問題」這三點。所以從這邊可以推估阿公腎功能指數掉下來的原因，很大部份是因為進食量跟喝水量減少的關係，醫生也提醒阿公了這件事。\n查房結束之後，我們兩個就繼續睡覺（沒錯，今天的主要內容就是睡覺！）接著就是 11:20 的中餐時間，今天的餐點內容阿公同樣不喜歡，但因為早上有聽到醫生的說法（這邊的飯要多吃），所以他很少見地全部吃完了！醫生的話真有用（哈哈）。至於我嘛 \u0026hellip;，因為病房這邊沒有提供我的午餐，所以我下去樓下的 711 買了麵包來充饑。我中午不想要吃太多，因為晚上還要跟阿志他們一起吃飯。此外，我也趁著午餐的閒暇時光和大頭聊了一點住院的事情，她也跟我說了一點最近學校啊、家裡啊、生活發生的瑣事 \u0026hellip;之類的，簡單來說就是閒聊。\n吃完飯的行程是午睡，我們大約在 12:00 結束用膳，然後兩個人一路睡到了 13:10 被醫生叫醒裝心電圖機。裝心電圖的地方在急診大樓以外，同時因為阿公剛睡醒沒有什麼體力，所以我們最後決定直接把床推過去安裝室，讓那邊的姊姊幫忙安裝。心電圖機的安裝有點花時間，負責姊姊交代了一些比較重要的幾件事情：像是這台機器不可以碰水，所以到明天拆掉之前都先不要洗澡（但下半身不影響）；然後它心跳紀錄只要 22 小時的長度資訊就夠了，所以不一定要明天的 13:45 以後才可以拆掉，可以再稍微早一點點（像明天 13:00 之類的）就可以麻煩住院那邊的姊姊拆掉了；最後是機器拆掉之後，心臟科的醫生會快速做一個診斷，如果有什麼大問題的話明天下班前（17:00）會來跟我們說。\n整體而言，今天在病房的狀態是睡得多、做事的少。醫生比較擔心的部分是阿公的進食量跟喝水量，但從我中午跟晚上的觀察來看，阿公有在慢慢調整這兩個部分了（就是有多吃飯跟多喝水）。然後是腦補的部分：因為昨天蠻忙的（可能是前幾天檢查比較多的關係），加上我昨天有帶筆電（預期很閒），此外從紫微斗數上來看，流月的化忌象又很濃厚（代表不順心），因此我昨天其實有給自己一個「我就是帶了筆電過去，才會很忙」的心理暗示。也因為那個心理暗示，我今天在出門的時候就故意反向操作。不帶筆電、不帶書，只帶小包包跟錢包，讓自己在表現上顯得「感覺今天會很忙」，所以化忌的能量就讓我今天的狀況「反過來」（也就是變很閒）。這應該算是一種吸引力法則吧？我果然是神棍（笑死）\n再來是 17:05 姑姑準時來交班，早上的工作就結束了。\n工作結束後，今天的聚餐是跟大頭、阿志、金魚 \u0026hellip;等朋朋在中台灣最強中餐廳——黎明福利餐廳吃飯。相較於昨天的聚會，今天這一桌大概有 11, 12 個人左右？我除了 3, 4 個能叫出名字的人以外，其他的人就完全不熟了。但不知道是大家都很 E 的關係？還是這次吃飯的主講人（就是主要說故事的人）是我。整個吃飯的過程我都沒有特別感到不自在，或者是「我好想先離開」的那種感覺，也久違遇見了鉦烽。同時，因為昨天的「睡太少事件」，我很順利在 8:30 左右結束飯局就直接回家了。雖然沒有跟他們多聊覺得有點可惜，但為了明天的工作，我覺得這點 trade off 還算值得！\n"},{"id":136,"href":"/_trash/diary/202403/20240314/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/14\r#\r（3/18 10:40 補寫）\r#\r早上睡過頭ㄌ \u0026hellip; 06:40 才起床，拖了一點出門時間。\n今天同樣也沒有帶任何東西過去（暗示自己忙，所以反過來會閒）。早上跟姑姑交班的時候阿公還在睡覺，所以同樣也是到了那邊之後先小睡了一陣。直到 8:00 左右的早餐時間才被護理站的姊姊叫起來吃東西。阿公今天早上同樣也把所有餐點吃光了（超棒！）吃完早餐稍微休息一下，我就問阿公「要不要用助行器去外面走走？」他說「好」，所以我們就稍微出去晃一晃～（其實我昨天也有問，但那時候阿公說他腳還是有點無力，所以後來就作罷了。）早上只簡單的在病房外的走廊隨便晃晃，沒有去到其他太遠的地方，可以看出阿公的體力有點下降，因為即使是這樣的短路程，他同樣有點喘的感覺。\n此外，今天早上值得紀錄的事情還有幾件事，第一件事情是「X 光烏龍事件」：因為阿公身上還帶著心電圖機，所以原訂 10:00 要做的 X 光檢測被調到下午了。但不知道是護理站的疏忽？還是什麼其他原因，10:00 的時候還是有人來跟我們說「要去照 X 光囉～」，但就 \u0026hellip;不能照，所以還是改成下午了；第二件事情是在走路完之後，阿公有嘗試去排便，但可能是小腸還是沒什麼力氣？所以以失敗告終，同時護理站的姊姊那時候剛好在病房內，所以我就順便跟她說明了這個情況，姊姊就說「好那之後會加開一些軟便劑給阿公。」\n接著就是中餐時間：同樣地，阿公還是不喜歡吃這邊的食物，但因為醫生的建議，所以他還是全部吃完了（超棒 XD）。我也第一次開始跟著阿公一起隨餐吃這邊護理站的食物（昨天晚上姑姑好像有跟護理站的人說「從明天開始，麻煩餐點多附一份」所以我才有得吃）。只能說我對食物真的變得更不挑了？雖然可以明顯感覺到「餐點應該沒有當初在 16 病房那邊好吃。」但我還是可以給到大約 70 左右的食物評分，也有全部吃完（我現在除了茄子以外的東西大致都不挑）。然後就是熟悉的飯後午睡時間ㄌ \u0026hellip;\n下午第一次刻意地想休息（昨天是累到沒時間想東想西），因為有「思考」跟「決定」這兩個動作，所以化忌就可以開始工作了：中午我被打斷睡眠的次數大概有 3, 4 次吧？中間不外乎是復健師跑過來問事情、護理站的姊姊來幫阿公量血壓、住院醫生來拿住院診斷、和護理站姊姊按照預定時間（13:00）來拆心電圖機、X 光比預期得還要早，所以我們提早去量 X 光 \u0026hellip;等。每次的睡眠大概都只介於 15~20 分鐘，完全不能用「有睡好」來形容這個中午/下午的時間。\n下午照完 X 光回到房間大概是 13:25 左右，我趁著這個阿公很醒的時候順便問了一次「下午要不要再出去走走」得到了肯定的答覆。然後就帶著助行器陪阿公走出病房了。這次的復健走了好～長一段時間（現在算下來大概有 1 個小時或以上？）那公先是花了 20 分鐘走出整個住院的空間，然後又花了點時間走到了一個有大片玻璃的地方，他站在那裡，望著外面看了好～久好久（期間有原地踏步一下），不知道他那時候在想什麼？有在想要不要問但後來還是作罷了。\n然後時間快轉到交班前，今天的交班是爸爸。因為爸爸這幾天工作比較忙（又有神明生日了），所以原訂 18:00 交班先是被拖到了 18:30、18:45 \u0026hellip;最後在將近七點才過來（也真的是辛苦了）。也因為今天爸爸來的時候是坐姑姑車來的，加上我今天晚上沒有任何的行程，所以我就直接坐著姑姑的車回家了。最後最後是回到家。除了例行的洗澡跟家務外，我也花時間抄了一點經（大概 2-3 份吧？）希望阿公可以趕快好起來，好好保重身體，早日康復。\n"},{"id":137,"href":"/_trash/diary/202403/20240315/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/15\r#\r（3/18 12:05 補寫）\r#\r5:40 醒來、5:50 賴床、6:00 起床。\n今天同樣是 6:45 從家裡出門，7:15 到中榮的 35 病房。但跟以往不一樣的是：今天到病房的時候阿公已經起床了（他還很熱情的跟我打一聲招呼，精神看起來蠻好的）。早餐同樣雖然不喜歡，但還是吃得一乾二凈。大概在 8:05 左右，昨天開始給的軟便劑發揮功效了。第二次在院內排便看起來一切正常，所以回報給家人的群組之後，姑姑就問說「今天可不可以出院了？」——原來這就是禮拜二的占卜解答嗎？小小伏筆回收。另外今天也幫阿公申請了一天的電視使用，真的是太晚有發現這個功能了 \u0026hellip;之前都只能坐在床上發呆放空，有了電視之後時間變得超好殺的 XD\n除此之外，早上同樣也有幾個值得紀錄的事情：首先是阿公在院內第 2 次（或第 3 次）的量體重：74.2，比入院的 71 還要胖了不少。從醫生給的回饋來看，這應該是個好現象（類似體力回復之類的）；其次是今天早上也有走路復健，同樣也走了大約一小時再多一點點。走路時間的尾端復健師剛好要來看阿公，所以就順便做了一點復健的評分跟測量，其中一個是測量握力。因為同樣也是可以給我測試的東西，所以我就順便測試了——左手 39、右手 34，慣用手（右手）比男生的平均值（38）還要來得少一點，不知道是為什麼？也因為是第一次全力地壓握力計，所以再次感受到了 52 kg 的天使真的好猛 \u0026hellip;；\n最後是關於「出院」的事宜：雖然早上就有在問能不能出院？但因為主治醫生 10:00 才來查房，他說一般院內會在 12:00 前把所有要出院病人的流程都跑完（包含簽名、繳費 \u0026hellip;之類了），回報給姑姑之後，姑姑說「那這樣太趕了，還是明天出院吧。」所以我們就決定把出院的時間定在明天早上了。再來的中午跟下午基本上都在看電視、復健、睡覺、跟發呆殺時間這 4 件事情上度過。直到大約 19:00 爸爸來交班，這一個禮拜的看護工作就結束了。\n晚上回到家後，最重要的事情就是「收了第二個紫微斗數的學生——珽宇。」決定要教他紫微斗數也是好久之前就決定好的事情了，只是這陣子拖來拖去，最後才定在今天晚上開始第一堂課：我跟他大致介紹了紫瑋書的中要三元素（宮、星、四化），然後講了一點南派北派的差異（我自己是 15% 南 85% 北），最後再給他一個十干四化表讓他回去背，第一堂課就結束了。對我來說收穫蠻大的，因為珽宇是很熟的人所以他也蠻直接的給了我他跟不上的 part，我自己反思之後，也覺得有些內容可以再講得、詮釋得更好一點，算是個很棒的教學相長吧？\n總而言之\n終於結束看護的工作了（癱）\n"},{"id":138,"href":"/_trash/diary/202403/20240316/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/16\r#\r（3/18 12:35 補寫）\r#\r今天沒有起床去載阿公。\n早上洞六洞洞（06:00）賴床，但因為自己的懶惰病發作了，所以我一路睡到了洞六五洞（06:50）才起床。起床之後同樣是先做內務（折棉被、刷牙洗臉、整理房間），然後整理了這禮拜一直沒有時間處理的書桌，因為照顧阿公、加上早出晚歸的關係，雖然昨天跟前天晚上沒有晚餐的約，但考慮到醫院那邊可能隨時需要什麼備品之類的？所以書桌一個禮拜就堆積了不少東西。基本上今天直到出門前都在整理那些東西，整理完之後抄了一份心經、洗了一次澡，然後就出門離開家了。\n離開家的時間大概是 9:30，，這是預計好的。我們禮拜二國中晚餐燒肉聚的時候他沒來，那時候我有拿到紫瑩想轉交給他的伴手禮（超高濃度巧克力！），所以昨天我有先聯絡鄭，問他今天大概 10 點左右有沒有待在家（從我家到他家大概 25 分鐘的路程）。把伴手禮拿給他之後的下一個目的地是學校，途中經過了一個好久沒吃到的蛋餅早餐店，所以就順手買了一份早餐（起司幾塊蛋餅 + 大冰奶），好ㄘ！\n今天的工作大部分都是在補寫日記、剪接 podcast、跟編排紫微斗數的教學進度與內容。整天都懶懶的，所以進度一直很延宕，還跑去睡了 2 次覺（11 點的時候跟 1 點半的時候）。大頭大概在 3, 4 點的時候出現，所以我趁那時候把我的成品給他看，也順便跟她聊了一下之後的方案、跟工作職務分配。然後就回去各自做各自的事情了，我的部分的話：日記到這時候大概還有 3-5 天的進度沒補，我打算一天補個 1,2 篇（厭世zz）；podcast 基本上剪好了，但因為大頭對這個比較要求，所以可能還有一些小細節需要調整；紫微課綱的安排倒是蠻順利的？可能是之前有先試教過的原因。\n最後，同樣在大約 7 點左右結束學校的工作，回到了家。今天晚上是幫自己安排的休息時間（雖然從早上開始就一直偷跑「休息」這件事情了）稍微看了一下 youtube, Hololive, 芙利蓮 \u0026hellip;等等。然後抄了第 2 份心經、在睡覺之前又跑去客廳打了一場 LoL 的 ARAM。現在想想今天真的是夠混的，打完 LoL 的時候，時間已經來到 23:40 了，那天想要手刀去洗澡拼 12 點前睡覺也沒達成。希望這麼混的心態下次不要再出現了（哈哈）\n"},{"id":139,"href":"/_trash/diary/202403/20240317/","title":"日記","section":"_Trashes","content":"\r日記：2024/03/17\r#\r（3/18 13:20 補寫）\r#\r今天 6 點起來。比預期的 5:50 還要再晚一點點。\n早上發生的第一件大事是——我的耳塞不見了。那是我睡覺的時候固定會戴的。雖然心裡有個底說「今天一定會找到」（吸引力法則的運用），但早上嘗試找了 5-10 分鐘左右都無果，所以就暫時不管它了。在整理好內務之後，我坐在書桌上抄了 2 份心經。期間爸媽有來敲我的房門（他們知道我醒了），問我「要不要跟他們去鎮瀾宮拜拜？」但我拒絕了～我想多留點時間給自己，如果跟他們出門的話大概會花上 4-5 個小時以上吧？所以就推掉了。\n家裡的事情做完之後，同樣也是去學校幹活。今天到學校的時間大概也是在 10 點左右。然後「累累病」同樣也在今天復發了（昨天真的不該說「希望這是最後一點懶惰的日子」之類的話 \u0026hellip;），同樣是日記電子化、podcast 細節修剪、跟紫微斗數的課綱撰寫。效率同樣很低，中間同樣也有睡了幾次覺。大概到 1 點左右吧？真的撐不住了，果斷直接放棄，給了自己第一個連續假期（昨天跟今天）然後就開始去滑 youtube 聽歌、找有興趣的歌、跟看一些我有興趣的 ig 短影音。\n在休息期間找到了幾首還不錯的音樂，基本上都是彩虹社 Enna的作品或 cover。到這裡不得不提一下：Enna 的唱功真的超鬼的 \u0026hellip;，就是有這樣的人存在，所以我才會覺得我唱歌跟一坨大便一樣（稱讚對方的意味）。昨天基本都在聽他的原創跟翻唱，期間有找到一個 1.5 小時的尼爾演唱會——超～級～好～聽！但有注意到這部影片的倒讚蠻多的？順藤摸瓜找到了 Selen 被解約的消息！？看起來事情挺大條的，同時我自己原本也有訂閱 Selen，對於彩虹社決定這樣做也蠻讓人難過的，希望這件事情可以有個好的落幕。\n大頭同樣在大約 3-4 點左右來，但因為 podcast 的東西大致都差不多了，所以昨天的互動基本上都是在說下一次的錄音（預計是 18 號晚上，也就是明天晚上）要聊哪些東西？詳細內容就不透露了，不然會爆雷 XD。此外也跟她請教了關於載具的使用方法——從今天開始我也是不用傳統發票的載具超人拉！我快不是大家說的「科技原始人」了（哼）！此外，在大頭教我用過程中載具的過程中，翊紘也有用公共電話打給我小聊一下～他說他最慢後天會離開病房，聽起來真是個好消息！但聽說繼允現在已經 \u0026hellip;壞掉了？還是讓人有點擔心。\n今天晚上因為有點事情，所以 5 點左右就離開學校了。5:45 有一頓我爸媽要請賴桑跟晉安吃飯的晚餐局～跟 [10 號]的內容一樣，我們約在拾七吃火鍋。晉安在「當兵」的話題上跟我爸蠻有話聊的，所以他倆聊得很開心。我、賴桑、和我媽則大部分都在討論我們家廁所的問題——我媽想要重新裝潢我房間旁邊的廁所，剛好賴桑是做裝潢的，所以就順便跟他請教了一點問題，聽點報價、內容、還有材質、技術 \u0026hellip;之類的事情。飯局基本上很順利地結束。晚上送賴桑回家的時候我重新開通了跟他的 visa 網路借刷服務。之後又可以繼續累積 Line point 囉～\n晚上 21:00 完美就寢。\n"},{"id":140,"href":"/docs/life/diary/2024/03/18/","title":"日記","section":"每日小記","content":"\r日記：2024/03/18\r#\r（03/19 00:40 補寫）\r#\r有點不確定這樣算不算補寫？畢竟我還沒睡。\n把出院之後的所有事情都完成了，包含跟家人吃飯、整理房間、去區公所變更體位、請住院實支實付的保險、回診拿藥調藥、跟好久不見的朋友吃飯、去學校找老師報平安、還當兵之前借的生活用品、還有日記電子化 \u0026hellip;等。仔細想想，雖然出院已經 18 天了，但今天才把所有的事情做完，也算是有點慢吧？雖然中間卡到大約一個禮拜的阿公住院，但我不覺得這能算是我做事緩慢的理由，所以「拖延」這個壞習慣還是得再想辦法改改才行。\n早上去了學校之後，把日記電子化的工作全部完成了，雖然中間同樣有睡了大概一個小時，但整體而言不算有拖到進度，所以還在算可以接受的範圍。日記電子化大概在下午 1 點左右完成。完成之後我稍微修改了一下個人網頁的某些版面：主要是新增了占卜的區塊（用來放以後紫微斗數、塔羅牌、或其他算命相關的資訊）、移除了原本的創作區塊（創作版有點亂，所以我先全部撤下來，等之後再看看要怎麼擺回去）、以及調整資工區塊的一些內容（像是密碼學的介紹 \u0026hellip;等）。目前的想法是「應該還有更好的改進方法，但我現在還沒想到，所以就先這樣吧。」\n今天晚餐時間跟大頭去吃了一中街的飯飯，大頭說上次跟珽宇有來吃過，覺得還不錯，所以就帶我來吃了。只能說真不愧是大頭跟珽宇，他們挑的店都好讚（哈哈），一碗 130 的唐揚雞腿飯給了滿滿的雞塊（大概 5, 6 塊吧？）好難想像在一中街裡面只要付出這點錢就可以吃到那麼好吃的東西 \u0026hellip;，而且在用餐的過程中，老闆一直在做燒肉飯（110），看得我都想要預約下一次的吃飯時間嚐嚐了（大頭說他上次就是吃燒肉飯，同樣也很推）。我還跟她說「跟八兩比起來，我只要再多付 10 塊錢，就可以吃到這麼好吃的東西，感覺好不真實ㄛ～」現在想想，真的是有點後悔沒有早點發現這家店面的存在，如果早點知道的話，我可能就不會一直吃八兩當我的正餐了吧。\n晚餐過後我們錄了一次 podcast。\n聊天的內容主要是我當兵跟住院的故事。整體而言算是蠻辛苦的：一開始想用 Adobe Audition 錄音，但不知道為什麼聲音跟監聽會有超過 0.1 秒的誤差（聽起來就像是回音），所以在試了約 1 小時候以放棄告終，改回用 Garage Band。回到熟悉的 Garage Band 之後又花了大概 25 分鐘暖身（我覺得我講得不好，所以大概在 25 分種喊停重錄）。重錄一次之後，中間又因為一些原因導致大頭忘記開錄音。最後我們錄完 2 小時左右的長度已經 22:30 左右了。心得是「我的聊天功力退步的好嚴重」還有「現在講到當兵的事情還是會有一點情緒」（覺得不太好，我希望可以早點放下那段時間的事情）。\n然後是 11 點離開學校的時候，跟大頭聊天聊了快一個小時，主要的內容基本上環繞在聊天方式、星座、跟個性上面。她不能理解我為什麼凡事都以其他人、以家人為重？我則是不能理解她為什麼每次都可以把其他人的想法擺在自己的想法後面。算是蠻衝突的兩種個性（這也是我們一開始想要做 podcast 的原因，因為我們個性夠衝突、所以容易在不同的事情上產生分歧的看法，就能造就話題）。\n最後是回家時間，老實說我今天真的沒想到到了現在（01:10）我還坐在電腦前面打著這篇日記？今天以前的我在這個時候早就睡死了，我原本也預期自己應該要已經睡死的，但計畫總是趕不上變化。晚上錄 podcast 真的遇到太多難關了，離開學校之前的「橋下談心」也很合我的胃口，所以就大聊特聊了一陣子。我想我明天可能會睡得很晚很晚吧？希望從明天開始，我可以回復到原本 9 點就寢的狀態。\n（語無倫次 \u0026hellip;）\n"},{"id":141,"href":"/docs/life/diary/2024/03/19/","title":"日記","section":"每日小記","content":"\r日記：2024/03/19\r#\r（03/20 00:30 補寫）\r#\r連續兩天過 00:00 才睡，有點不好。\n早上睡到了 9:15 才起來，精神不是很好。把家裡早上該做的事全部做完之後已經 11:40 了，所以今天基本上的重要活動都發生在中午跟下午。中午同樣去到了學校，第一件擺在眼前的事情是「準備紫微斗數的 ig 貼文。」我還沒想清楚新的身份要以什麼樣的名字出道，應該不會再用『紅茶拿鐵』這個名字了。之前的貼文是請我朋友幫忙畫的，自己稍微檢討(?) 了一下，我覺得我朋友畫的畫很好看（真心），但如果要密集且持續地經營的話，我自己負責貼文的視覺呈現應該會是更好的選擇，所以前前後後用了 canva, coolors, 和 Mac 的內建 ppt(Keynote) 做了一個大致的貼文視覺，像是下面的這個樣子：\n大致參考了 3-5 個我比較喜歡的簡約的貼文風格，最後做出了上面的這個作品。中間的內容是中文的 Lorem ipsum，反正就是大概說明一下把字貼上去之後會長什麼樣子。沒有意外的話之後就會延續這樣的風格一直用下去了（背景、框框的位置、跟框框 border 的類型預計都不會改動，最多就是調整一下它們的顏色而已）。希望這次的我可以把「在 IG 經營紫微斗數」這件事情做好，或至少堅持到今年年底，讓我在寫年底回顧的時候可以因為這件事情多寫個一行、或一個段落。\n除了準備 ig 貼文的視覺，我也稍微整理了一下禮拜五要跟珽宇講的一些紫微斗數內容：主要還是打算先說過一遍宮、星、四化這三個東西。以大量的實際命盤做舉例，放棄掉原本一顆星耀一顆星要按照順序的講法，我覺得從 1 對 1 教學的角度上會比較好（因為比較靈活），目前準備了 3 張盤，分別是我的、大頭的、跟他朋友的 3 張（他自己的盤我一直都定不準，超級崩潰 \u0026hellip;）。禮拜五再看看效果怎麼樣？不好的話就調回來最枯燥穩健的步驟，效果好的話就繼續維持。\n此外，今天最重要的事情果然還是下午大頭來之後，一起錄的 podcast 了。今天的主題是「星座 and MBTI」。相對於昨天比較失敗的「當兵抱怨集合」，今天的主題算是一個大眾比較能夠接受，也比較容易講得有趣的話題。我們䲡言後聊了至少 2 個小時有。稍微說明了一些星座的看法（上升、太陽、月亮 \u0026hellip;等），也因為我跟大頭的個性差超多（我偏感性，她超理性），所以我們能夠製造的「衝突」自然多了很多；除此之外，MBTI 的環節同樣也很有趣，因為我是 INFJ 的人，她是 ISTP 的類型。扣掉最前面的 I，我們兩個又是完全的極端。而且她的 I/E 算是比較 50%, 50% 的類型，所以她很有可能是 ESTP 的人，只是這次剛好 I 多了一點點而已，這樣就是完全的相反了，超級「衝突」，話題性很足。\n最後的最後是閒聊環節：錄完 podcast 之後大概是 8:20 左右？原本我打算直接回家的，但剛好遇上了鳳鳴跟鉦烽來串門子，所以就直接放棄「10:00 前睡覺」的計畫，跟他們在 2502 大聊特聊了一下。同樣也是在聽鳳鳴和鉦烽說他們最近的生活，也稍微聽了一些在日記上不好明說的東西～感想只有一個——好有趣！我覺得適時地跟除了大頭以外的人聊天，在無形中應該可以增進我的雜談功力。所以之後也打算跟新來的學妹稍微聊一下，希望到時候他不要覺得我是一個很煩的學長才好～但應該很難，因為我大概已經被貼上「怪人」的標籤了（笑）。\n"},{"id":142,"href":"/docs/life/diary/2024/03/20/","title":"日記","section":"每日小記","content":"\r日記：2024/03/20\r#\r稍微遲了一下，今天 08:00 起床。\n今天早上沒有抄經，取而代之的，是一早就直接到 2502 工作的行程。到學校做的第一件事情是「把履歷更新，然後交給忠全。」上次寫履歷是大約一年前了？那時候忘記因為什麼原因（好像是其他人想看我會怎麼寫履歷的樣子）寫了一份，今天的第一項工作就是要把那份履歷找出來，然後把它改寫成現在的版本。我一開始以為我把履歷放在 CakeResume 上面，但找了一下發現沒有，後來又依序看了 1111, google drive, OneDrive 跟 Dropbox。最後才在 104 上面找到——也是，之前家教都是在 104 上面找的，怎麼就沒想到要找 104 呢。\n改履歷的過程沒有很複雜，基本上就是把兵役狀況從「待役」改成「已服役」、預期的薪資寫一寫（4 萬或以上）、希望職缺填上去（後端工程師、演算法工程師、或其他資訊相關職缺）、跟補上這一年正在做的幾個 side projects 內容：第一個是卜卦程式，完成度沒有很高，大概才 3 成(?) 左右，預計是做成網頁版的，然後可以支援京房易的解卦方法跟爻辭的解法兩種。第二個是算命的 App，用 flutter 做的。目前的進度在「紫微 + 八字的前端已經完成」上，大概也是 30% 左右的完成度（但程式的行數 \u0026hellip;卜卦前端完全不能比就是了）。最後一個是富饒之城，這個就做得比較多了，後端大該完成 80%+ 的進度，算是我目前最能秀出來的專案之一了，但壞消息是——它的前端進度根本是 0。\n履歷完成之後，我同樣去後面的折疊床睡了一下（大概 1 到 1.5 小時）。起來之後則是第二份工作——把法扶姊姊今天早上給我的法律文件拿到郵局寄出去。其實我原本是想要明天再做這件事情的（因為懶 XD），那時候只是跟自己說「如果今天流日有驛馬的話，那就動起來好了。」然後看了一下農曆（2/11），再稍微掐指一算：笑死，流日遷移真的有驛馬，\r\\(\\frac{4}{12}\\)\r的機率還真的被我給撞到了。只好遵守自己跟自己的約定，動起來囉～送件的流程基本不難，就是把文件蓋上自己的姓名章，然後拿到郵局寄出去而已。但因為我身上沒有印章，所以我前前後後先是去了印章店刻一個新的（噓～），然後走去郵局，然後發現印章根本沒有印泥，所以又跑回附近的光南買了一個印泥，再回去郵局把信件寄一寄，最後再回學校——真的很驛馬，整趟下來走了快 2 小時的路，累死。\n回到 2502 之後做的最後一項工作是「決定紫微 IG 第一篇文章的內容」。我打算跟之前的做法一樣：先稍微介紹一下紫微斗數，然後再分別介紹宮、星、四化這三項元素最後再進到事件的論斷跟吉凶的判別。文章一開始想先介紹一下紫微的起源，只不過不小心研究得太深入了。原本只是想要簡單說明南派跟北派的差異，但不小心就鑽到續道藏的紫微、七政四餘、跟一點南印度占星術 \u0026hellip;等不同的命理內容。回過神來已經快 7 點了，距離跟表哥吃飯只剩下 30 分鐘的時間，只好放下手邊的工作，離開學校，騎去表哥待的旅店。\n今天是表哥跟表哥老婆（是叫 \u0026hellip;嫂嫂嗎？）上台中的第一天，他們應該只會在這邊待今明兩天而已？畢竟他們 24 號就要回菲律賓工作了，回去之前還要把他們的女兒交給嫂嫂的媽媽顧（在南部）。他們這次上來的主要目的是給外婆（表哥的奶奶）看一下她的玄孫女（就是孫子的女兒），還有給我媽看一下她的侄孫女（就是他哥的孫女）。（親戚稱呼好難（癱））。她有一個很好聽的名字——妍恩，聽起來超像韓國人的 XD，以後應該也會像那些韓國藝人一樣漂亮吧～！\n最後！今天終於沒有隔日寫日記了，但現在也 22:20 了。\n趕快收一收，洗澡睡覺去。\n"},{"id":143,"href":"/docs/life/diary/2024/03/22/","title":"日記","section":"每日小記","content":"\r日記：2024/03/22\r#\r（03/23 01:25 補寫）\r#\r久違(?) 的晚睡時間。\n今天早上 09:00 才起來，自從上禮拜開始偷懶的情況就越來越重了，可以的話希望能在這一個禮拜把這個壞習慣改回來。今天上午的行程是抄經，因為昨天跟前天都沒有抄（偷懶 \u0026hellip;），所以包含今天的份，早上總共抄了 6 份經文。養成這個（幾乎）每天抄經的習慣也大概 3-4 年了，老實說最有感的變化，還是剛開始抄的那段時間：從原本動不動就心浮氣躁，變成現在大概都能平心靜氣；從原本的執著跟在意，到現在可以把大部分的事情拋諸腦後 \u0026hellip;等。還蠻慶幸自己之前有把這個習慣養成起來的，它無形中讓我這個人沈穩了很多，對於很多事情也能夠以比較冷靜、比較符合自己本新的方式去處理與面對。\n在抄經的過程還有 2 件值得紀錄的事情：第一件事情是我把保險理賠下來的錢捐走 \\(\\frac{1}{10}\\)\r了。老實說還是有一點點「放不下」的情緒在裡面，畢竟是個不小的金額（理賠了 8 萬下來）。要把錢捐走這件事算是自己跟自己的約定：類似於基督教的什一奉獻，我自己也希望可以至少捐出十分之一的財產給有需要的人，但因為以前一直都還沒開始工作，所以這份任務就沒有很認真地實施。只是現在會跟自己說：「也當完兵了，那在某種程度就不再是男孩了，那就要開始扛責任了。」所以當完兵之後的每一份收入我都會捐走至少 \\(\\frac{1}{10}\\)\r出去，當作回饋給社會的一點心力。\n第二件事情是阿公今天在客廳的廁所跌倒(?) 了。詳細的發生情況我不清楚，只是聽到阿嬤的電話之後，用最快的速度趕到阿公身邊而已。從我的角度來看：我會覺得阿公應該是類似於在廁所腿軟、然後攤坐到地上的過程頭撞到牆壁。但從後續的狀況來看，阿公應該沒有什麼太大的問題？當下是有清楚意識的，也能夠馬上起來（雖然還是需要我攙扶），可以自己回位子、自己吃飯、喝水、對話 \u0026hellip;等。\n現在想想也挺幸運的，要不是我今天抄了 6 份經文（代表在家裡待了很久很久），阿嬤應該也沒辦法第一時間把我叫過去幫忙。我想 \u0026hellip;這或許也是抄經的一個好處吧？默默地累積所謂的福報，然後在需要的時候「剛好」就可以有很合適的人能夠來解決事情，像上次阿嬤在客廳跌倒也是一樣，很剛好在我準備要出門的那一瞬間才跌倒，我只要早個 2 分鐘（或晚個 2 分鐘）出門就不會撞到這件事。看來除了可以「改善自己的內心」之外，抄經也能夠帶來其他的好處與幫助呢～\n結束早上的行程之後，我去了一趟好久沒去的整脊，上次去喬骨頭是 1 月的事情了，是入伍的前一天（也就是 1/15）。隔了 2 個多月不見，郭師傅看起來瘦了很多，身體也面得有點精實。一問之下才知道原來她最近在嘗試 168 斷食 + 生酮飲食，然後花了大概 3 個多禮拜的時間瘦了 11 公斤！聽起來超級吸引人的吧？瘦下來的部分。但聽到他說這幾個禮拜幾乎沒吃澱粉就讓我覺得「哇～好難 \u0026hellip;」，因為我是個沒有飯就很難覺得有在「吃飯」的人，果然不管是減肥還是做什麼其他事情都是要付出代價的嗎，天下真的沒有白吃的午餐啊 \u0026hellip;。\n結束郭師傅的行程之後，是回學校的 2502 時間，我在那裡稍微做了一些預定的工作（把 podcast 的帳號顧好、構思紫微斗數的貼文、準備工作要用的履歷跟 side projects \u0026hellip;等）。原本表定 20:00 ~ 20:30 要教珽宇紫微斗數，但他這幾天的眼睛有點不好（應該試過敏 + 用眼過度），所以今天的課就暫停了一次，改成了閒聊時間～。珽宇稍微跟我說了他公司的一些情況，聽下來還蠻有興趣的？但「找工作」是表訂明後天要完成的事情，所以只是暫時先記錄下來。目前預計的工作有新博弈、券商 x2、品諭工作、車商工作、跟珽宇工作 6 份。我打算花上假日的時間研究好這些全部的優劣跟優先順序，然後在下禮拜投履歷，希望快一點的話下禮拜或下下禮拜就可以開始上工了。\n最後是 23:00 回到家之後的 Discord 時間，今天預計要開直播玩揀愛這個遊戲，原本以為它會是一個「教導直男如何跟女生相處或聊天」的一個 \u0026hellip;類教學型遊戲？但玩下來才發現它不是戀愛模擬遊戲，而是一個推理解謎的遊戲。也因為這個錯誤的期待，讓我在最一開始給了這份遊戲「不好玩」的評價。但現在回過頭來想想：如果我一開始就是以「推理解謎」的心態來玩它的話，我應該會給到至少 92/100 的分數——無論是音樂、劇情、文字、還是畫面的呈現 \u0026hellip;等，都很引人入勝，也很讓人感到舒服與放鬆。真要說的話，我會推薦這款遊戲給其他人玩，但還是會跟他們說「它不是一個訓練直男如何讀懂女生的新的遊戲，而是一個包著『戀愛』元素的解謎遊戲哦～」\n"},{"id":144,"href":"/docs/life/diary/2024/03/24/","title":"日記","section":"每日小記","content":"\r日記：2024/03/24\r#\r（03/25 03:10 補寫）\r#\r失眠了 \u0026hellip;爬起來寫日記。\n不知道是睡不著的關係？還是這幾天天氣比較不穩定的關係？現在的心情狀況挺不好的，用分數量化的話 \u0026hellip;大概是介於 40-45 之間吧？滿分是 100 分。大概在幾個小時前嘗試一次睡覺，但有點太熱了 \u0026hellip;，加上我又不想要早早開冷氣，也不想要多吃一些助眠藥跟肌肉鬆弛劑（我覺得藥能戒就戒，除非真的很必要，不然我現在都是維持兩天吃半顆的劑量，算是超少超少的了）。結果就是從 21:20 一路翻來覆去到現在，直到忍不住爬起來寫了今天這篇日記。一方面是補一下這兩天沒有寫的進度，一方面也想順便記錄一下現在的狀況跟心情。\n這個假日基本上沒有做太多的事情：搞定了 spotify podcast 跟 apple podcast 的帳號、試著上傳了一支影片、第一份精華突破 1000 點閱、辦了新的算命帳號、發了一篇算命的文章、找回原本消失的小帳（專門追蹤繪師跟一些 anime 的）、多記了幾本以後要看的書、看完了葬送的芙利蓮、跟爸媽吃了一頓北澤的晚餐、決定好工作要往非台中的地方找，明天要跟珽宇細聊 \u0026hellip;，看起來事情做得很多吧？但我現在滿腦子思考的都是那些「我沒完成」的部分：youtube 帳號還沒創、還沒想好 IG 工作帳要叫什麼名字、這兩天浪費了大概 4-5 個小時沒有工作進度、連續兩天都沒抄經、宜宸的流年還沒寫、妍恩的本命盤也還沒寫給小表哥、還有家人每天一直問, 一直問, 一直問, 一直問, 一直問, 一直問的工作找了沒 \u0026hellip;\n我覺得我在「有症狀」的時候，比較常見的狀況會是「不停專注在那些我還沒有完成的事情。」即使我的心理還蠻肯定這樣做是不對的，但還是會不由自主的往那些地方去想（但相對以前來說，現在應該算好很多了？以前是會一直去想，不會讓自己刻意暫停、或練習中斷思考）。失落、焦慮、不安、難過 \u0026hellip;這類的負面情緒倒是還好，但疲憊感卻很濃就是了，有很明顯地「雖然我頭腦知道只要花 xxx 的時間就可以完成，但身體卻一點想動的慾望都沒有」的這種情緒跟感受，不知道其他人有沒有也有類似這樣的症狀？\n還是稍微總結一下這兩天吧。\n就像前面講的：這兩天把 podcast 的帳號都辦完了，雖然過程還是被大頭稍微唸了幾句，但如果只看結果的話，還算蠻不錯的，兩支影片都有 1000 多的觀看，以出道來說應該還算可以吧？雖然現在的粉絲大多都是 3F（fridnes, family, and fools）就是了；辦了新的算命帳號，這算是我從出院之後就一直想要做的事情，只是一直拖延到了這兩天才用好。辦帳號的同一天順面上傳了第一支影片，之後預計週更，希望能順利；找回了原本追一些台灣 / 日本繪師的 ig 帳號算是一個小小的意外，今天在看 ig 可以登入的帳號的時候意外發現到的，忘記密碼點了之後也發現它連的是我有在用的 mail，所以就重新把它撈起來了，這樣以後就有一個可以專門看繪圖的小帳了，開心～；多記了幾本書，大部分是跟成功學、正能量有關，我在有症狀的時候蠻喜歡看那些東西的，算是幫自己打氣之類的；最後是北澤吃晚餐，明明是壽喜燒專賣但我們還是硬生生只點火鍋，真的超有趣 XD\n打到這邊突然想到原本想說什麼了：這幾天看到一個 tiktok 的 shorts，主要是在說傳統的 asian parents 的一些負面情況，像是「即使婚姻已經一團糟了，還是不願意離婚，繼續維持著這種惡性的關係」這類的，也分享了一些他們家裡面平常會發生的 \u0026hellip;憾事？稍微看了一下，聽了一下。嘛 \u0026hellip;必須得老實說這跟我家的狀況蠻像的（哭），只是他爸媽可能再瘋一點而已，但也有可能是只有我這麼覺得，搞不好其他人覺得我們家更瘋也說不定？\n下面有個回覆我蠻喜歡的，這間就直接抄下來了，來自 @user-ml8vb9iv8v 的留言：「根據個人經驗，爸爸之所以能夠忍受媽媽發瘋，有可能是因為爸爸也生病了，只是爸爸生病的方向和媽媽相反。媽媽有病態的強迫傾向和控制慾，而爸爸則是會抽離自己、放棄自我思想，被動接受外在環境的變動，只求穩定和諧。媽媽強硬的迫使一家人的生活規律且受控，爸爸就可以置身事外享受媽媽幫他鞏固的和諧。如果孩子和媽媽起爭執，爸爸會軟性勸說比較弱勢的那方妥協，意圖消滅衝突回歸和諧的狀態，成為媽媽的幫兇」這句話我自己挺有感的，只是主角要稍微換一下——不是爸爸，是我。\n我沒有要很深入的寫一些心裡的想法，因為這是公眾向的日記，我只是想記錄一下我大概在哪一天是怎樣的狀態而已，而且這東西如果寫得很細節的話，會很沈重跟難看。但不可否認的是：我還是需要思考一下這病症帶給我的一些麻煩與困擾，以及需要思考該怎麼做才可以逐漸的 \u0026hellip;治癒它？對於跟「家人」有關的東西，我一直都是很容易被情緒勒索的，大概在最近我也逐漸發現到這樣的性格，長久下來可能也不是一個很好的現象，至於要怎麼解決嘛 \u0026hellip;，我可能還是要再想想，現在能想到最簡單的方法就是往外地走了，其餘更進階的方法，我還需要一些適應跟心理建設。\n"},{"id":145,"href":"/docs/life/diary/2024/03/27/","title":"日記","section":"每日小記","content":"\r日記：2024/03/27\r#\r（03/29 00:35 補寫）\r#\r好久沒有寫日記了。\n原本打算日更的，但後來發現不一定每天都有什麼有趣的事情，所以在經過思考之後，除非某天有什麼有趣的東西，那就會在那一天動筆寫日記，不然就是稍微累積一定的量（大概 3-5 天）再一次總結這幾天的進度。所以今天這一篇會簡單地總結我 25-27 號這三天的小小歷程。如果要先簡單扼要的破題的話 \u0026hellip;這禮拜的事情大部分都會跟「找工作」有關，然後參雜一點算命跟玩桌遊的事件。\n25 號珽宇重新打了一通電話給我，跟我說有關於工作的事情：公司的業務基本上是幫不同的硬體設備做資安的檢測，大部分都是用程式去跑，偶爾會需要跟不同的 \u0026hellip;窗口(?) 要檢測所需要的資料與內容。從珽宇的角度來看，我應該最慢 3-5 天就可以熟悉整個工作流程，算是對我的一個小小肯定吧？挺開心的。然後我們重新約了一次面試的時間——預計在 29 號禮拜五的早上 10:00，線上面試，由他的主管負責，預計 1 小時以內會結束面試，需要準備的東西有畢業證書、碩士論文、跟履歷表。\n26 號我見到了傳說中的鳳鳴朋友——鮭魚腳腳。她比我想像中的還要再安靜跟靦腆一點，我猜有很大很大的機率是因為我們還不熟，所以在聊天的內容上就有點小尷尬。除了鮭魚腳腳以外，我、嘉彥、鳳鳴、跟學妹淑芬也玩了一個晚上的桌遊，先是兩把的拉密，然後是兩把的富饒之城。學妹淑芬就跟印象中的差不多，在打桌遊的時候，我故意玩的比較針對一些，想要試試看她的反應，整體而言還蠻有趣的，尤其是心裡的想法會直接寫在臉上這個部分 XD，總而言之跟一開始的印象差不多，學妹淑芬是一個相對外向的人。\n除此之外，26 號也有幫 2501 的金毛學弟算一次紫微斗數：命宮七殺獨坐在丙辰，命財官雙祿巡逢但被財帛的貪狼生年忌給破局。是一個很有自己的想法、不喜歡被人拘束、不喜歡過著他人定義的生活的人。脾氣有點衝，家裡有一個話很多又愛東管西管的媽媽，算是個中間中間的殺破狼。在感情上，夫妻宮忌入兄弟沖交友會是他感情上比較需要留意的部分——也就是另一半會希望他多把心思放在她身上，而不是他朋友；工作則是這步大運和下步大運要往外走才會比較好。\n然後是今天，珽宇跟我改了面試的時間，改到星期六的下午 13:30。他說他們公司的老闆決定要面試我，所以錄取率可能會比單純給主管面試的通過率還要再低一些。我稍微看了一下流日的命盤：流日命宮在本命子女，是我 12 宮裡面最爛的位置沒有之一。遷移宮雙祿三權，但流日財帛（同時也是流年 + 流月的官祿）巨日三化忌。沒意外的話應該會死得透心涼。但先做好可能會被慘電的心理準備了，所以基本上沒有太大的擔心的地方。\n除此之外，今天也跟大頭重新討論了 podcast 的事情：可以感覺到不管是我還是她，都對這件「錄製 / 經營頻道」這件事產生的初步的強烈排斥。我覺得現在「工作上的我跟她」有點陷到以前「感情上的我跟佳琦」的狀態裡了。在我們討論的過程中，我得到的大部分是否定的情緒、負面的情緒、不被肯定的情緒、對我失望的情緒 \u0026hellip;等。作為一個感受性比較強的人來講，老實說挺難受的。但這就是所謂的「成長」吧？不停睇面對挫折，再不停地解決這些挫折。等回過神來才發現自己已經走好長一段路了 \u0026hellip;，真想趕快跳過這些過程，直接走到終點啊。\n總的來說，這幾天是比較枯燥、低迷、和比較沒動力的日子。\n"},{"id":146,"href":"/docs/life/diary/2024/03/28/","title":"日記","section":"每日小記","content":"\r日記：2024/03/28\r#\r（03/29 01:15 補寫）\r#\r今天的生活，從一早的 6 通未接來電開始。\n起來的時間大概是 10 點左右（準確來說是 09:45）。姑姑從電話那頭說「阿公身體有一點問題，可以的話能下去看一下嗎？」然後我就完全醒了。阿公昨天晚上睡得有點不好：一整晚的徹夜咳嗽，加上維持在 37~38 左右的體溫，早上除了趕緊給他吃一顆普拿疼之外，剩下的就是化痰劑跟止咳藥水了。阿公的身體正以肉眼可見的速度衰弱，雖然做好心理準備了，但在情緒上還是會有一點點受到影響，希望能夠增到明年過年吧？至少包一次紅包給阿公，但農曆 4, 10 月都有點危就是了，除了抄經念佛之外，我完全想不到其他可以幫助阿公延壽的方法，可能這幾天再找一下吧？\n再來是工作上的事情，這邊的工作分成幾個部分：分別是 podcast、珽宇公司、品諭公司、C++ 教學、博士、家人催工作的壓力、還有我自己想要做的其他東西 5 項。先從 podcast 說起，原本打算今天要休息不去學校的，但因為昨天最後的共識有點模糊，加上我跟大頭都想要趁我還沒有正職之前多錄一點，所以最後還是打算在今天下午錄音了，老實說早上要出門之前真的挺 emo 的，emo 到我在電腦前面從 11 點左右一路坐到快 4 點才從我家出門。\n至於珽宇公司，珽宇又改一次面試時間了，從原本 29 號的 13:30 延後一小時到 14:30。我心裡的打算是如果這兩天再收到改時間的通知，我就考慮不上台北面試了。但原因比較不是「因為一直改時間，所以我有點不爽。」比較像是我現在越來越不想接觸任何跟「找工作」有關的事情了，所以如果再給我一次重新選擇的機會（對我來說，改面試時間就是重新選擇），我這次就會把它拒絕掉。找工作真的讓我太～過 emo 了，繼續留著這個情緒會很不好，加上品諭的面試基本上成功機率很大，所以我打算直接「快速解決」這個問題。\n然後是品諭公司：面試的時間同樣是在明天 29 號的下午 13:30，我投了公司裡面的兩份職缺，分別是「遊戲數值設計師」和「遊戲伺服器程式設計師」這兩個，用白話文講的話：前者是跟數學比較有關的機率工程師，後者則比較偏向普通的後端工程師。因為產業的緣故，所以起薪通常會比一般的前後端還要再高一點。我打算開 47k 的薪水，希望這個數字到時候可以真的被採納。\n再來是 C++ 教學：這其實算是個小小的意外插曲？這幾天 Line 上面突然跳出了一個姊姊的訊息，說是想多學一個新的技能，所以找我來學 C++。雖然我有試圖用很隱晦的方式把這份工作給拒絕掉，但可能是我真的說得太隱晦了 XD，所以後來還是決定要在線上教姊姊寫 C++。目前預計的授課內容是基本程式設計 / 資料結構 / 演算法 / 跟一點點前後端的相關知識，可以把這個課綱理解成大學資工的 C++ 速成教學。費用的話我打算以堂數收，每堂 1.5 hr / 400 元（沒錯，又是打破行情的價格哈哈），希望可以在今年把這個 C++ 給上完。\n然後是博士。主要是雅芬老師有在問「我有沒有想要讀博？」老實說 \u0026hellip;，我現在還沒有辦法確定「要」還是「不要」。但真要選的話，「不要」的比重比較大——因為我的事情現在有點多，再多一個讀博的話，可能會把時間壓縮得更加緊繃。今天早上的 emo 情緒一部分也是因為這個，因為早上照顧阿公有點小小厭世，看到爸媽的面試提醒有點厭世，剛好這時候大頭又跟我說「老師想要找我聊聊。」只能說是挑了一個很不好的時間來問我了～所以我很少見地用「不行，我今天不太能聊讀博士的事情，我有點 emo」直接拒絕了老師的會談。下禮拜一會再跟老師見到一次面（要吃飯），如果明天面試順利的話，我打算在禮拜一推掉讀博的邀約。\n接下來是家人催工作的壓力。這個也算是我們家的 \u0026hellip;問題(?) 吧。跟我自己的個性也有關，我一直不希望把事情鬧得很僵，所以一直以來在家人的事情上面我都是盡可能地「以和為貴」，但從 24 號我看到了那個 shorts 之後，我開始很認真地思考「要怎麼在面對家裡的事情的時候，把自己的態度踩死」這個問題——我知道對於一部分人來說，把態度踩死這種事情就像是呼吸一樣簡單：「蛤？就直接拒絕掉就好了啊」「這不是直接說『不要吵我』就可以的嗎」。但因為一些以前的生活經驗，導致我現在不太能夠這麼的 \u0026hellip;坦率？自然？總而言之，「直接說出來」對我來說是個很需要勇氣、很需要心理建設、跟很需要不停在心中練習的一件事情，希望過一陣子之後，我在面對這類的問題時，可以處理的好一點。\n最後是我自己想要做的事情：因為最近自己過得有點渾渾噩噩、虛擲光陰，所以我早上除了坐在電腦前面 emo 發呆，也有花少少的一點時間整理了一些我想要在今年完成的事情，分別是算命帳號發 35+ 的貼文、程式的 youtube 頻道要有 15+ 的影片、存完 200,000 的緊急備用金、重新當回家教老師賺點外快、搬出去住、養一隻貓咪、飲食控制和重訓健身、經營好半杯珍奶的 podcast、閱讀至少 20 本書並撰寫心得、以及在部落格裡面擁有至少 50 篇的文章（不含日記 and 閱讀心得）——現在知道為什麼我今年工作超忙了吧～有很大一部分是自已搞自己的 XDD\n總之，工作大概就是上面這些東西。\n下午去了一趟學校，遇到了雅芬老師～老師還是稍微提起了跟讀博有關的事情。今天去學校的主要目的是錄第四集的 podcast，主要內容是「平常無聊的時候都在幹嘛？」算是個蠻好發揮的話題。前半段大致是在講淑芬的殺時間秘笈（社群網站廢人），後半段則是我殺時間的方法（思考廢人）。整個 podcast 錄了大概 2~2.5 小時，氛圍相對於昨天可以說是天差地別（今天氣氛超好的），除了「我們已經錄過很多次，所以多少開始抓到一點訣竅」以外，我覺得很大一部分原因是昨天把所有嚴肅的東西都說開了，所以今天基本上就是不抱著任何的芥蒂在聊天的。\n整體而言，晚上的 podcast 是今天少見的開心時光。\n希望明天（跟往後）的日子也可以再輕鬆、再愜意一點。\n"},{"id":147,"href":"/docs/life/diary/2024/03/29/","title":"日記","section":"每日小記","content":"\r日記：2024/03/29\r#\r（03/30 12:40 補寫）\r#\r品諭的公司面試上了，算是解決了一件重要的事。\n原本以為我不會緊張的，結果前一天晚上還是失眠到 4 點左右才睡著：印象中最後一次看時間是 04:05，之後過了半小時左右就睡著了，然後早上 9 點快半起來，所以昨晚的睡眠時間是 5.5 個小時，比平常的 7-8 小時還要短上許多 \u0026hellip;，雖然很想要繼續倒頭就睡，但因為 13:30 就要面試了，加上我還有一些東西沒有準備好（對，我就是這麼的臨時抱佛腳），所以醒來之後只花了不到 10 秒做一點內心的掙扎，就老老實實地爬起來準備了。主要要完成試穿西裝、準備碩士論文紙本、列印履歷、跟找到公司地址這 4 項。\n試穿西裝沒什麼特別的，就是把以前大學面試跟碩士面試的那套衣服拿出來重穿，除了有點皺皺的之外，其他的地方基本沒什麼問題。身材一直都沒變胖也沒變瘦，某種程度上來講也算好事吧；碩士的紙本論文要去大頭家拿，她昨天有先幫我拿到她家（這樣會稍微順路一點），沒什麼特別的，就騎過去～；列印履歷我原本打算先找到公司再印，但想到可能會花很多時間在找公司上，就還是先去了路上順路的一家 7-11 用 ibon 搞定了；最後是找公司，老實說我完～全沒有想到那間公司會在那種超高級辦公大樓的地方。該說是真不愧是地址在市政府附近的公司嗎？總之裡面富麗堂皇的程度是真的讓我嚇了一跳 \u0026hellip;。\n面試的過程基本分成兩個階段：第一階段是筆試，總共有兩份考卷。其中一份考卷是類似於 MBTI 的人格測驗，總共有 20 題，跟大部分的人格測驗一樣，選出選項裡面最符合你的敘述就可以了；另外一份是比較重要的考試卷，因為應徵的職位裡，除了程式之外，還會用到一些高中大學才教的數學關念，像是矩陣、線性代數、排列組合、機率、數值分析、統計 \u0026hellip;等，所以 10 題的比重裡，光是數學的部分就佔了 6 題，剩下的則是程式跟一些開放式問答，像是：「請寫出目前開發過最大的專案中，你遇到過哪些問題，並如何解決這些問題？程式的或者是與人溝通交流的都可以。」\n第二階段是口試，由兩位考官負責，一個是我之後的主管 Riam、另一位則是 Riam 的主管 Peter。在經過簡單的自我介紹之後，他們主要的問題都圍繞在一開始的自我介紹上面做提問，像是「你做過哪些專案」「說明一下你寫過的兩篇論文大概在研究什麼」「你對 python 熟悉嗎？我看你的專案大部分都是用 java 做的」「你有一份 side project 是 App，是用什麼語言寫的啊？為什麼要用那個語言」還有比較生活化的問題，像是「你有什麼其他的興趣嗎？我看你履歷上沒寫到興趣的事情」「你家教的學生大部分都怎麼找的」「你對算命很有興趣嗎，我看你的 side project 上有類似的東西」「你有沒有想過你在 3-5 年之後想要做什麼」 \u0026hellip;等。整體而言氣氛很輕鬆，感覺不到太大的壓力。\n最後面試在 15:20 左右結束，而錄取通知則是在 17:15 收到。\n錄取通知還有一個蠻值得紀錄的：公司需要我提供一個英文名字，作為公司內部的系統帳號、mail 地址、和在公司裡面的稱呼。我身上目前有兩個名字，分別是 Patrick 和 Fonu，前者是家人取的，後者是自己的遊戲名。考慮到在算命的觀點上，「名字等同於這個人的運勢。」所以我想要稍微細心一點挑揀稱呼，先看看名字都有哪些意涵，再決定自己要叫什麼。首先 Fonu 就不考慮了，因為是我隨便從亂打的 ajsdhauasjfsemq 挑出來的隨機字母，沒有寓意；Patrick 一開始有在考慮的範圍內，但老實說我不太喜歡這個名字（唸起來有點咬舌），加上它的寓意我自己沒有很喜歡，後來也跳過了。\n最後我挑了 \u0026ldquo;Arvin\u0026rdquo; 作為我的新名字，一方面它唸起來比 Patrick 還要順、一方面我有先問過，大致不會遇到撞名的問題、最最重要的是：我喜歡他的 meaning ——以平等之心待人者。相對於「出身高貴的；貴族」的 Patrick 來說，我更喜歡這種比較低調、比較和緩的寓意。其實除了 Arvin 之外，我還看到了幾個比較喜歡的名字（像「修道士」Lemoine、「心中的光亭」Hobart、「流浪者」Wendell、「信仰很忠誠的人」Truman、或「和平，平安」Solomon \u0026hellip;等）但這些名字對我來說多少都還有些缺點，不是音節太長、饒口，就是太常見、或已經有著名的人了。\n最後是吃晚餐的時候，有跟爸媽提了這件事情（找到工作囉～）。大概從今天開始，他們就不會再催我找工作了吧？算是一件好事，無論對我或者是對他們來說都是。在吃飯上也稍微跟他們說了「我之後要搬出去住，因為要養貓。」從反應跟回覆看來，他們應該沒有太強烈的反對情緒。倒是我爸在聊天的過程中有拋出了一句「那你們之後孝親費打算拿多少回家」有點讓我愣了一下，我還以為他們對孝親費一直都是保持「有再給就好」的態度 \u0026hellip;，雖然我現在是沒打算給啦，畢竟他們都還有工作，應該還不需要我跟我妹在金錢上的幫忙，但為了以後打算，我之後可能會稍微問問其他人是怎麼給的吧？\n沒意外的話，一兩個禮拜後的日記，就會是工作相關的內容了。123\n"},{"id":148,"href":"/docs/life/diary/2024/04/02/","title":"日記","section":"每日小記","content":"\r日記：2024/04/02\r#\r四月的第二天。\n從上一次寫日記到現在過了 4 天，大部分的時間都是在忙之後的東西。首先是分配每個月的預算：因為錄取信裡面有寫上我工作之後的起薪，所以就用了那個數字做了一點資金分配。原本是打算用 3/3/3 的分法的（\r\\(\\frac{1}{3}\\)\r房租水電、\r\\(\\frac{1}{3}\\)\r存起來、\r\\(\\frac{1}{3}\\)\r做其他花費）。但如果按照這樣分的話，房租會有點太多(?)、加上最後的 \\(\\frac{1}{3}\\)\r會有點吃緊、我自己又想要抓一些扣打做小小的 Buffer（5k ~ 10k）、存錢的 % 恕我想抓多一點、還有憨憨的錢要分出來 \u0026hellip;。所以最後加加減減、把一些東西拿掉，再把一些東西放進去，就變成下面這個樣子：\n飯錢一天我抓 200~250，每個月 1500 的治裝（應該不會全部花完？）、住的全部壓在 12k 以內、交通的 1500 我稍微抓的比較多（平常應該 1000 以內就可以解決）、書跟健身房 \u0026hellip;也會花到那麼多(?)、憨憨的 4000 不能少、剩下來的就是 buffer，還有全部存起來的部分了。基本上，除了治裝費以外，裡面的每一項我都抓得比較寬裕，所以實際上的花費應該不會這麼多～但房租的部分我就不確定夠不夠了？希望能在 12k 以內完成。\n除此之外，這幾天也去了一趟郵局，把網銀的帳密重設一次（因為一直以來都沒有用過那個戶頭領錢，所以帳密就忘記了）。然後跑了一趟青島路的後輩指揮部，把健保轉出的程序辦一辦（新的工作會幫我辦新的健保）；然後偷偷地把不會穿到的衣服褲子丟掉一些，跑了 2-3 趟篤行路附近的舊衣回收箱，希望它們之後可以找到好主人，發揮服飾的真正價值；然後是找房子 \u0026hellip;好難，一直遇到騙訂閱的房仲，開一個很甜的價格，再跟我說那間沒有了，你要哪間新的我幫你找（哭）；然後試用了一次麻布，透掉台股淨值看不到這個小缺點以外，大致都蠻好用的；也練習了一下 Lina pay 跟載具的用法，這就是科技的力量嗎 \u0026hellip;也太方面了。（生活白癡的發言）\n至於副業的部分 \u0026hellip;前幾天跟大頭錄了新的一集 podcast，這次是我剪，預計明天開始，最慢後天要剪完；算命這兩天又多接了 2 單，一個是表哥的（跟他女兒有關）、一個是泡麵跟他朋友的 case（問工作）；IG 貼文 \u0026hellip;明天會補上；Notion 的週進度和月進度也是預計明天完成；最後家教的部分，C++ 這禮拜六會開始上課、珽宇的紫微斗數可能就要看他哪時候有空了？然後這兩份家教我都希望今年可以結束，這樣明年的我就會再稍微輕鬆一點了～\n"},{"id":149,"href":"/docs/life/diary/2024/04/05/","title":"日記","section":"每日小記","content":"\r日記：2024/04/05\r#\r（04/06 11:25 補寫）\r#\r上工前倒數 3 天。\n稍微記錄一下這幾天發生的事情：首先是 4/3 早上 08:00 左右花蓮發生了規模 7.2 的淺層地震。氣象局說是自 921 以來台灣碰到的最大地震。基本上各地的震度都有到 4 級或 5 級，最大的也有到 6 弱或 6 強。沒意外的話應該之後會變成一個防災演練的主題 \u0026hellip;吧？然後這個地震目前被取名為「403 強震」。地震當時我在睡覺，算是被震醒的。五樓的情況 \u0026hellip;除了客廳有一張相框碎掉、儲藏室的鐵架歪掉（但沒斷掉，也沒掉東西）之外，基本沒有什麼問題。阿公阿嬤看起來也沒有太大的狀況，但早上陸陸續續還有 20+ 的餘震，為了安全起見，我還是在三樓待到中午姑姑回來才出去。\n3 號下午原本打算去五權路的咖啡店工作，但去到那邊之後才發現他們禮拜三公休 \u0026hellip;，所以後來轉往大頭家做事。工作主要整理了一些之後上工後會用到的東西：像是 Microsoft office、python 套件、還有 google calendar \u0026hellip;等。也趁著那段時間在算命的 ig 上面多發了一篇破軍星的文章。原本想要按著主星順序（紫微、天機、太陽、\u0026hellip;、破軍）發的，但後來想想把順序打亂好像也挺有趣的？就決定按照封神榜的故事依序介紹了。\n再來是 4 號：4 號基本上承接 3 號的行程，去了咖啡店工作，重新整理資料夾、剪聲音的原始檔、剪精華、規劃了一些之後要做的東西，重新辦了自己的 Notion 帳號、找房子（但還沒找到）、準備之後家教要用的東西 \u0026hellip;等等。晚上跟爸媽吃了一頓晚餐，整體而言算是充實但幾乎忘記工作細節的一天，四號晚上也接了一份泡麵朋友的算命單，只是到現在（6 號的 11:50）我都還沒動筆就是了 \u0026hellip;有點慚愧，等等會把她的問題處理好，哈哈哈哈。\n再來是昨天 5 號，昨天中午同樣跟爸媽還有我妹去吃大墩十一街的昭日堂燒肉，我們四個人點三人份的套餐 + 我輩的生日優惠有點稍微吃不消。整體份量很足，食材也很有口感跟味道，可以感受到跟一般的平價燒肉處在不同的等級，然後可爾必思好好喝！不知道它算不算是相對健康的飲料？如果是的話，以後就多喝可爾必斯代替麥香奶茶好了 XD；此外，昨天下午爸媽也去了一趟苗栗通宵拜拜，詳細地點不明。但因為我不想去那麼遠的地方，加上下午有買衣服的行程，所以中午就回家睡覺了。下午去了一趟 UNIQLO 買之後工作要穿的衣服，總共 3 件衣服 + 2 件褲子，以後就輪著穿～\n5 號晚上還久違地教珽宇算命。目前的進度是在各主星的基本關鍵字上，同時也跟珽宇聊了一些他最近的生活，他說他前陣子去了一趟天文館，然後看了 Netflix 上的三體，劇情聽起來真的滿吸引我的，沒有意外的話之後就會去補了，只是聽說總共有 8+ hr \u0026hellip;，不知道之後有沒有那麼多時間把它們全部看完？最後，昨天晚上稍微找了一些 Notion 的 template，但整體而言都沒有以前自己做的喜歡，所以打算在接下來的兩天回去 review 一下薑餅資的影片，把她的模板給載下來，再整理成我之前自己調整的那個樣子。\n"},{"id":150,"href":"/docs/life/diary/2024/04/08/","title":"日記","section":"每日小記","content":"\r日記：2024/04/08\r#\r（04/09 01:10 補寫）\r#\r第一天上班。\n早上起了個大早，大概在 5:55 左右就起床了，印象中上次這麼早起床已經是畢業之前的事情了吧（扣掉當兵不算的話）。例行性的抄經、洗澡、整理房間 \u0026hellip;，大概在 8:00 左右就出門上班了。到公司大概是 8:50 左右？一樓的對講機壞掉了，所以一開始有一點小遲到（如果用規定第一天 ９ 點就要進公司的話）。第一個代辦事項是簽合約：人資的 Zora 姊姊先給了我一份大概 30 頁的資料，大多是勞動契約、保險的基本資料、跟一些工作須知，雖然 30 頁的文件密密麻麻的寫了很多，但直到寫日記的當下，還記得的內容大概就只剩下「每個月 5 號發薪水」了 XD.\n後來稍微做了自我介紹，發現大家好像都不太會念 Arvin 這個名字？所以常用的暱稱就索性直接寫「沛時」了（笑）。新來的第一天公司大概辦了 7-10 組帳號給我？但不知道是資料還沒更新好，還是什麼其他的問題？剛到公司的前 2-3 個小時幾乎所有的帳密都是無法使用的狀態 XD，是直到午休過後，大概 1:30-2:00 才可以順利登入。今天最主要的工作有兩個：第一個是熟悉公司業務。畢竟本質上還是遊戲公司，所以幾乎所有下午的時間都在試玩所有的遊戲，前前後後大概 20-30 款吧？雖然每一個遊戲的外觀都不一樣，但把 UI 的部分抹掉的話，底層應該都是類似的業務邏輯。\n另一份重要的工作是算數學。因為職位是機率工程師，因此我最主要的工作就是「確保企劃組那邊設計出來的遊戲，期望值能夠符合在某一個固定的 range 上。」傍晚的時候稍微瞭解了遊戲的邏輯跟期望值的計算方式之後，上司就放我一個人去練習算數學了。這也是今天我對自己最不滿意的地方：原本以為只是簡單的數學，大概 20-30 分鐘左右就可以搞定的，但前前後後算了 1.5 個小時，還是沒有算出正確的結果。連品諭都跟我說「你已經過下班時間很久了，趕快回家！」我才匆匆地收拾東西回去。這點我對自己蠻失望的，總覺得辜負了大家對我的一些期待與想法（雖然我完全不知道他們有沒有期待我就是了）。\n回家之後先是吃個飯，洗個澡，然後花點時間剪了 podcast 的精華、再補一些算命客戶的定盤資料，轉眼間時間就來到 22:30 了，總覺得時間過得好快 \u0026hellip;，感覺今天什麼事情都沒有做到，然後就這麼過去了。應該是還在適應的關係，總感覺自己的時間變得好少好少。原本 Notion 上預計要做的 3-5 件事情也幾乎都做不了。我真的能夠達成自己在年初寫的那些目標嗎？總感覺還要再更努力地生活，才可以免強跟上我自己幫自己訂下來的標準呢～\n雖然感覺大家人都很好，但我還是有點小小焦慮，可能我真的把自己的標準、跟別人的期待看得太重了吧？十點半躺床之後完全沒有放鬆的感覺，輾轉了一陣子之後，還是決定爬起來寫這篇日記。不知道明天的工作會進行得怎麼樣呢？明天最主要的兩件事就是請教上司期望值的正確算法、跟麻煩公司幫我把 Office 灌好了吧？早上明明還能打開 Excel 的，但不知道為什麼過了午休把電腦關機再開機之後 office 就跑不起來了 \u0026hellip;\n"},{"id":151,"href":"/docs/life/diary/2024/04/10/","title":"日記","section":"每日小記","content":"\r日記：2024/04/10\r#\r工作的第 3 天，想辭職的心情同樣還是 50+ %\n首先記錄一下時間效率：我發現我幾乎沒有什麼休息時間，這邊除了指心態上的持續緊繃外，給自己 20-30 分鐘看個 Youtube 或打 LoL 的那種放鬆更是我想講的。會有這樣的狀況一方面是我把自己的工作排太滿的關係，幾乎每天都會有 2-3 個需要 1 小時以上的 tasks 需要我處理。這算是我自找的，因為觀路的雙化忌會讓我在工作上容易忙東忙西，然後我又不想要再工作上忙東忙西，所以就排了超多事情讓自己幾乎是忙到炸開；另一方面也跟通勤有關係。在實測上從我家到公司單程至少需要 30-40 分鐘，這個數字甚至是全程都有一點點超速的狀況下（大概穩定 70-80 km/hr 的那種）才能達成。所以 \u0026hellip;沒意外的話，「找房子」會是我這禮拜放假最主要的 tasks 之一。當然離公司近很好！但不行的話，走路 30 分鐘以內的路程我都能接受，畢竟既然都要花上 1-1.5 小時了，與其坐在坐墊上，不如多站起來走走，還能身體健康。\n再來記錄一下工作：這幾天的工作內容大部分（或者說全部）都是在算期望值。主要跑了 2 個遊戲，一個是單線類的 line game，另一個則是不特定線訪的 Way game。整體而言難度沒有很高（應該說抓到訣竅後，就還蠻容易上手的），大致上跟前天的想法類似：只是不習慣而已，多給自己一點時間應該就能適應。但直到目前為止，大概還只是全部工作的 \\(\\frac{1}{5} \\sim \\frac{1}{4}\\)\r而已，從品諭跟 Riam 平常在聊的內容來看，工作除了「設計遊戲，並計算期望值」之外，還有一些是需要跨部門合作的（跟後端對接，跟平台廠商接洽遊戲的上架或流程 \u0026hellip;等等），有點小雜，但如果循序漸進就應該還行。目前預計只做兩年，在明年有 2700 萬後 \u0026hellip;如果那時候還是很不喜歡「工作」的話，就會認真想要離開，提早過上自由人生（笑）。\n然後是心情：昨天跟前天的狀況比較不好（尤其是前天，大概逼近臨死的那種低分），今天稍微好一點，或者說 \u0026hellip;好很多？可能是漸漸習慣工作沒有想像中的備感壓力（但還是有不小壓力），也有可能是昨天有吃藥的關係。我有在想還是就不要把藥戒掉比較好？我原本的思考邏輯是「慢慢把藥停掉、慢慢讓自己不要依賴、慢慢讓自己變得『正常』 \u0026hellip;」之類的，但昨天晚上偶然滑到一個 Youtube 影片，然後自己又是「偶然就代表神明想要跟你說話」那一派的信徒，所以就在想還是就繼續吃著算了？反正也不會有什麼嚴重的副作用，也不會對其他人造成太大的困擾。\n其實我一直有在想，到底是「因為我有病，所以我本身就很容易焦慮」還是「因為我被寵壞了、日子安逸太久了，不願意面對這個社會，所以才假裝自己有病。焦慮則是『安逸太久』的副作用」。目前還沒有想出結果，但心裡的想法其實是比較偏向後者的。我爸那句「你不覺得你現在這樣做就是在逃避嗎？」蠻意外有被我記起來的？那就代表它一定是一句很重要的話，無論是「就是要點醒我，才借我爸的口對我說的」還是「好好想想這句話，找出那個盲點，怪怪的地方在哪裡，然後詮釋它、證偽它、突破它」都能夠對我有不小的幫助。就像股癌說的那個 yes man 一樣：無論答案是正面還是反面，對你來說都是成長。\n所以 \u0026hellip;雖然我還是很不想工作，但就試著轉念吧？「工作」就是我的「Yes man tasks」\n"},{"id":152,"href":"/docs/life/diary/2024/04/13/","title":"日記","section":"每日小記","content":"\r日記：2024/04/13\r#\r工作後的第 1 天休息日，想辭職的心情大概 49+ %。\n禮拜三晚上才寫完 10 號的日記，隔天 11 號禮拜四晚上，心情又重新 down 到跟禮拜一左右的谷底了（甚至是更低）。大概從 10 點左右開始翻來覆去，最後一次有印象看時間大概是在 3:50 左右，不想工作的情緒真的是只要在晚上不小心黏上來，就整個晚上都揮之不去。某種程度上來說，還算是挺麻煩的 \u0026hellip;。老實說我有點歸納不出為什麼我不喜歡現在的工作。與其說是「不喜歡」，我更覺得我的內心比較像是「一想到要工作就好累，所以只要工作我就不喜歡」的這種感覺，所以在 10 號晚上崩潰大失眠的期間，我有用「我被寵壞了」的說法來形容自己，雖然才過 3 天，但現在回頭看感覺算挺貼切的？\n原本打算 12 號（禮拜五）就遞出辭呈，也開始在思考「辭職之後想要幹什麼」了，但跟品諭說了這件事情之後，她還是打過來跟我聊了大概 30-40 分鐘，主要是在挽留，也跟我說了「雖然薪水相對其他博弈來說少了一點點，但相對來說，工作真的很輕鬆跟很自由。」我挺同意她的論點，而且從我的角度來看，這份薪水說低其實也不低，至少在對讀書的我來說，那時候訂下「畢業之後的工作至少要有 4 萬」的目標已經達成了，說實在的，除了我表哥突然跟我說「我們公司這邊又缺人了～」之外，很難保證現在的我還能找到有同樣薪水位階、但愜意程度跟現在比起來也是不相上下的工作。\n從塔羅的翻牌來看也是，比起「討厭這份工作」，我覺得我更加抗拒的是「工作」本身。所以雖然大頭在這件事情上持的是相反的意見（她覺得我只要覺得不適合就先跑再說，不要讓自己待在那邊讓病情更惡化），但經過考慮之後，我還是覺得要再逼自己一點點，不可以讓自己太放鬆、太放肆，目前訂下的目標是做滿一年。除非中樂透或有其他的大理由，不然我還是會在這邊生存看看，試著融入這個社會，而不是把自己關在自己的圈圈裡面，不願意面對這個社會，拒絕與人交流、拒絕讓自己成長。\n此外，12 號晚上也跟 Riam 和 Peter 聊了一下第一個禮拜的工作心得：說實在的，我覺得我講話還是太不經大腦了。印象中我那時候的說法是「嘛 \u0026hellip;就是工作，沒什麼特別的。」如果我是 Riam 或 Peter 的話，應該會考慮把我辭退掉吧：）。算期望值的工作最慢會在禮拜一結束，照 Riam 的說法，之後就會開始讓我接觸跟程式有關的環節了，沒意外的話，應該會是期望值跟一些數字上的試算或驗算（畢竟是機率工程師），老實說挺期待的，感覺這個部分應該是我會更有興趣的工作內容才對？而且寫的還是 python，剛好可以補一補我 python 相對不熟的這個弱項～\n最後是今天 13 號。主要發生 2 個值得紀錄的事情：第一件事情是去看了排球少年的劇場版——垃圾場的對決，詳細心得可以參考我在觀影心得裡面寫的那一些，這邊就不重新贅述了，基本上劇情穩紮穩打，除了最後面之外，我覺得沒有特別亮眼但也沒有特別出戲或不好看的地方。除了這個之外，第二件事情是我打算去找鉦烽看房子了！今天一早起床就有看到他貼了徵室友的文章，原本還幫他轉發到我的 ig 上（雖然應該不太會有人看我的 ig？），但後來想想還是自己應徵看看好了，明天下午 15:00 看房，照他的說法是房租一個月 7000，有沒有含水電還不清楚。但從目前的數字來看，比我預期的花費少了 5000 左右，算是很吸引我的一個物件，至於要不要真的簽下去嘛～就明天再看看囉！\n"},{"id":153,"href":"/_trash/design_pattern/least_knowledge_principle/","title":"最少知識原則","section":"_Trashes","content":"\r最少知識原則\r#\rChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 \u0026ldquo;朋友\u0026rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 \u0026ldquo;封裝\u0026rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。\n此外在物件導向程式設計中，一個物件的 \u0026ldquo;朋友\u0026rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 \u0026ldquo;朋友\u0026rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 \u0026ldquo;朋友\u0026rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 \u0026ldquo;朋友\u0026rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 \u0026ldquo;朋友\u0026rdquo;。 需要注意的是，儘管可以與這些 \u0026ldquo;朋友\u0026rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。\n簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。\n程式碼範例 迪米特法則的核心是「盡量保持鬆耦合」的設計思想：當一個物件（或一個方法）需要透過很 \u0026ldquo;遠\u0026rdquo; 的呼叫，才可以完成某項功能時，就代表該物件對於呼叫中的所有東西都保持著依賴關係，那這時候，只要這一條依賴關係的任一截點出現問題，就都有可能導致功能的毀損，進而影響整個程式的運作。舉個例子：我們假設在一間上市公司中，從公司最大的「老闆」一路到最基層的「員工」有以下的這幾個階層：老闆（Boss）\u0026gt; 各部門的部處長（DepartmentDirector）\u0026gt; 專案經理（ProjectManager）\u0026gt; 員工（Staff）。然後今天老闆想要讓自己的公司網頁新增一項功能，他將這件事情告訴了 IT 部門的部處長，處長為此成立了一個「網站專案團隊」，並指派一位資深員工為專案經理讓他挑選幾位處理該專案的員工（Staff）來完成老闆所需的工作。如果在這樣的情況下，老闆想要追蹤一下這個網頁功能的更新，那可能會發生這樣的問題：\nLog websiteInfo = boss.getDepartmentDirector(\u0026#34;IT\u0026#34;).getProjectManager(\u0026#34;web\u0026#34;).getStaff().getTaskLog(); 我們可以看到：光是 Boss 想要拿到一條「網站的更新紀錄」，就需要經過至少 3 ~ 4 個人的手，除了在實務的情況下，這麼做的效率可能有點低下之外，對於程式的撰寫來說，這種寫法也是挺有風險的，畢竟我們沒有辦法保證「呼叫上的所有方法即使產生了細節上的改變，程式也能完整運行」（例如 getProjectManager() 突然不用 \u0026ldquo;專案名稱\u0026rdquo; 做為參數，改用 \u0026ldquo;專案代號\u0026rdquo; 之類的），因此，迪米特法則告訴了我們「不要跟這麼多人講話」，也就是不要依賴過多的 \u0026ldquo;陌生人\u0026rdquo;。盡可能只透過，跟身邊的「朋友」聊天，就能拿到必要的資訊。降低方法間的相互調用，也就降低了「依賴於 \u0026lsquo;方法\u0026rsquo; 的一致性」，進而提升程式整體的品質，就是迪米特法則想要告訴我們的事情。\nLog websiteInfo = boss.getInfo(\u0026#34;WebsiteUpdate\u0026#34;); 朋友 知道了法則想要傳遞的訊息之後，接下來就可以往下一步走了：哪些人、哪些東西、哪些物件、哪些方法才是所謂的「朋友」？一般來說，常見對於「朋友」的定義有以下四種：「類別本身的成員變數」「類別本身的方法」「父類別的所有成員與方法」「傳入方法中的所有參數」以及「在方法中建立的任何物件」。可以發現到朋友的類型可以根據是類別還是方法有所不同，這也是該原則比較特別的一個地方：不僅適用於類別的角度，也適用於方法的角度。\n類別本身的成員變數 這個應該滿好理解的？畢竟是「自己本身就有的東西」。「類別本身的成員變數」可以視為是一個自己的親近朋友，無論是 \u0026ldquo;基本資料型態\u0026rdquo;（像是 int, float, long, double \u0026hellip;等），或者是 \u0026ldquo;參考資料型態\u0026rdquo;（各種類別：諸如 Object, System, Boss, Staff, Library \u0026hellip;等），只要是類別自己有的東西，都可以視為自己的朋友，這點也包含所有的父類別、父父類別、父父父類別 \u0026hellip;等。\n此外，成員變數如果是參考資料型態的話，那麼它的方法也算是「朋友」。但這些方法僅限於可訪問的那些（也就是帶有 public 關鍵字的那些），如果成員變數的方法全部都是用 private 或 pritected\n類別本身的方法 同理於 1.，類別本身的方法也算是「自己本身就有的東西」，所以類別裡面的所有方法無論是哪一種封裝等級（public, pritected, private）無論是哪一種回傳型態（int, String, Object, Book \u0026hellip;等），無論該方法需不需要參數 \u0026hellip;等，它們都可以視為是自己的朋友。因此在進行這類的呼叫時上不用太過擔心，雖說不上是肆無忌憚，但大體而言，還是可以放心使用。\n傳入方法中的所有參數 接下來從方法的角度去做切入，在方法的程式細節中，除了可以利用到上述的兩種朋友（所屬類別的成員變數、所屬類別的其他方法）之外，還可以將「傳入方法中的所有參數」都視為是自己的朋友，也跟 1 同理，無論是 int, float \u0026hellip;等基本資料型態，還是 Object, String \u0026hellip;等參考資料型態，只要是傳進來的參數，都可以視為是方法本身的「朋友」，此外，同樣也跟 1 一樣，傳入方法的參數如果是某一個物件的話，該物件的方法也可以被視為「朋友」。\n在方法中建立的任何物件 這算是對於類別或方法來說，最為彈性的一個「朋友」。建立物件的方式有兩種：第一種是透過最簡單的 new 關鍵字建立，像是使用 Staff staff = new Staff(\u0026quot;小明\u0026quot;) 這類的語句來生成新物件。另一種方式是透過方法的回傳所建立：像是利用類別裡，成員變數的方法、類別本身的方法、或者是當作參數傳入方法中的物件的方法 \u0026hellip;等，透過這些方式所獲得的物件同樣也算是「朋友」，就像這樣： DepartmentDirector dd = boss.getDD(\u0026quot;IT\u0026quot;) 讓 Boss 透過自己本身的 getDD() 來獲得 IT 部門的部處長。\n還有一個很容易搞混的問題：鏈式呼叫\n"},{"id":154,"href":"/docs/computer_science/design_pattern/least_knowledge_principle/","title":"最少知識原則","section":"設計模式","content":"\r最少知識原則\r#\rChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 \u0026ldquo;朋友\u0026rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 \u0026ldquo;封裝\u0026rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。\n此外在物件導向程式設計中，一個物件的 \u0026ldquo;朋友\u0026rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 \u0026ldquo;朋友\u0026rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 \u0026ldquo;朋友\u0026rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 \u0026ldquo;朋友\u0026rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 \u0026ldquo;朋友\u0026rdquo;。 需要注意的是，儘管可以與這些 \u0026ldquo;朋友\u0026rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。\n簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。\n程式碼範例 「最少知識原則」又稱作「迪米特法則」（後面統一用『迪米特法則』稱呼～），該原則的核心思想是「盡可能地減少需要依賴的類別和方法」，它透過定義「朋友」與「非朋友」這兩種不同的關係，將類別與類別、方法與方法、或類別與方法之間的調用加以分類，進而減少對於過量類別和過量方法的嚴重依賴。我們一個簡單的例子來做說明：假設我們正在製作一個「資料庫管理系統」，裡面的其中一項功能是「Customer 可以修改 x 資料庫中， y 資料表的內容」簡單來說就是一個 UPDATE 方法，程式的實作方式如下：\n// [使用者] 類別 class User { // 私有變數 system, 用來獲取 \u0026#39;資料庫系統\u0026#39; private DatabaseManagementSystem system; // update 方法，用來更新資料庫中的資料 public State update(String db_name, String table_name, String query) { // 首先利用 connectToSystem() 與資料庫系統建立連線 this.system.connectToSystem(this); // 接著利用 getDatabase() 來取得想要操作的資料庫 // 然後利用 getPermission() 取得資料庫得操作權限 // 再來利用 getTable() 獲取想要操作的資料表 // 最後利用 setQuery() 進行資料上的修改 return this.system.getDatabase(db_name).getPermission(this).getTable(table_name).putQuery(query); } } 我們可以看到：雖然只是一個簡單的 User.update() 方法，裡面卻至少依賴了 4-5 種不同的物件方法（像是 getDatabase(), getPermission(), getTable(), setQuery() \u0026hellip;等）。在這樣的程式邏輯下，應該不難想像：如果這一串呼叫中的其中一個環節出了狀況（例如 getTable() 這個方法突然壞掉了？），那麼整個 User.update() 就沒有無法正確地回應預期的結果。這就是沒有使用到「迪米特原則」可能會對程式帶來的潛在風險。\n朋友 知道了違反原則可能會造成的問題之後，接下來就可以來說明迪米特原則的程式風格了。但在直接進入到程式範例之前，我們要先來解決另外一個問題：因為迪米特原則的核心是「應該只與你自己的『朋友』建立依賴」，所以我們要先解釋所謂的「朋友」到底是什麼？一般來說，常見對於「朋友」的定義有以下四種：「類別本身的成員變數」「類別本身的方法」「父類別的所有成員與方法」「傳入方法中的所有參數」以及「在方法中建立的任何物件」。可以發現到朋友的類型能夠根據是類別還是方法有所不同，這也是該原則比較特別的一個地方：不僅適用於類別的角度，也適用於方法的角度。\n類別本身的成員變數 這個應該滿好理解的？畢竟是「自己本身就有的東西」。「類別本身的成員變數」可以視為是一個自己的親近朋友，無論是 \u0026ldquo;基本資料型態\u0026rdquo;（像是 int, float, long, double \u0026hellip;等），或者是 \u0026ldquo;參考資料型態\u0026rdquo;（各種類別：諸如 Object, System, Database, Table \u0026hellip;等），只要是自己持有的成員變數，都可以視為自己的朋友，這點也包含類別本身的父類別、父父類別、父父父類別 \u0026hellip;等。此外，成員變數如果是 \u0026ldquo;參考資料型態\u0026rdquo; 的話，那麼它封裝成 public 的方法也可以算是「朋友」。\n類別本身的方法 同理於 1.，類別本身的方法也算是「自己本身就有的東西」，所以類別裡面的所有方法無論是哪一種封裝等級（public, pritected, private）無論是哪一種回傳型態（int, String, Object, Book \u0026hellip;等），無論該方法需不需要參數 \u0026hellip;等，它們都可以視為是自己的朋友。因此在進行這類的呼叫時上不用太過擔心，雖說不上是肆無忌憚，但大體而言，還是可以放心使用。\n傳入方法中的所有參數 接下來從方法的角度去做切入：在 \u0026ldquo;方法\u0026rdquo; 的程式細節中，除了可以利用到上述的兩種朋友（所屬類別的成員變數、所屬類別的其他方法）之外，還可以將「傳入方法中的所有參數」都視為是自己的朋友，也跟 1 同理，無論是 int, float \u0026hellip;等基本資料型態，還是 Object, String \u0026hellip;等參考資料型態，只要是傳進來的參數，都可以視為是方法本身的「朋友」，此外，邏輯同樣也跟 1 一樣，傳入方法的參數如果是某一個物件的話，該物件封裝成 public 的方法也可以被視為「朋友」。\n在方法中建立的任何物件 這算是對於類別或方法來說，最為彈性的一個「朋友」。建立物件的方式有兩種：第一種是透過最簡單的 new 關鍵字建立，像是在方法內直接使用 Database db = new Database() 這類的語句來生成新物件。另一種方式是透過回傳值建立起來的物件：可以透過類別本身建立物件、透過成員變數建立物件、或者是物件參數建立物件 \u0026hellip;等，透過這些方式所獲得的物件，同樣可以也算是方法的「朋友」。\n綜上所述，程式的更新可以改寫成以下的樣子：\n// [使用者] 類別 class User { private DatabaseManagementSystem system; public State update(String db_name, String query) { this.system.connectToSystem(this); State State = this.system.update(db_name, query); return State; } // 其他 User 中的方法 ... // 其他 User 中的方法 ... // 其他 User 中的方法 ... } // [資料庫系統] 類別 class DatabaseManagementSystem { private Map\u0026lt;String, Database\u0026gt; databases; public void connectToSystem(User user) { // 一些連接資料庫的程式 ... } public State update(String db_name, String query) { Database db = this.getDatabase(db_name); State state = db.putQuery(query); return state; } private Database getDatabase(String db_name) { // 一些取得資料庫的程式 ... } // 其他 DatabaseManagementSystem 中的方法 ... // 其他 DatabaseManagementSystem 中的方法 ... // 其他 DatabaseManagementSystem 中的方法 ... } // [資料庫] 類別 class Database { public State putQuery(String query) { // 一些執行 query 的操作 } // 其他 Database 中的方法 ... // 其他 Database 中的方法 ... // 其他 Database 中的方法 ... } 現在， User 的 update 方法只跟 system 這個變數，以及 system.update() 這個方法保持依賴，如果程式中的其他部分（例：Database.putQuery()）發生問題，雖然就結果而言，還是會使得 User.update() 無法順利運行，但是因為現在 User 已經沒有再依賴 Database 的相關方法了，因此即便 putQuery() 有需要修改細節上的程式內容、或者是修改傳入的參數 \u0026hellip;等，都不會對 User.update() 方法造成影響。這就是「降低方法依賴」所帶來的好處，也是迪米特原則倡導的一個程式撰寫方法。\n鏈式呼叫 最後，還有一個在該原則上很容易搞混的問題：鏈式呼叫。雖然在大部分的情況下，當我們想要看 Java 內的程式是否符合迪米特原則時，對直觀的方法會是「數一行程式上存在著多少個 .」，但不是所有「超過 1 個 . 的程式」就是需要修改、不符合迪米特法則的程式。一個最常見的例子是：System.out.println()，雖然程式裡面包含了兩個 .，但這句話本質上就是一個單純的輸出指令，不需要做任何的修改。\n還有一種常見情況是 return this 的時候，例如當一個 Database 需要創建一個新的 Table 時，他會不停地對某一個 Table 物件做修改和操作，雖然在視覺上，這個 Database 呼叫了很多不同種類的方法，但追根結底，對於這個 Database 來說，它所依賴的物件易始至終並沒有發生任何的變化，那這樣得情況下，即使呼叫了很多不同種類的方法，也還是可以視為一個「與朋友溝通」的操作，就像是下面這樣：\nclass Database { // 一些 Database 的成員變數 // 一些 Database 的成員變數 public createTable() { Table table = new Table(\u0026#34;Student\u0026#34;); table.charSet(\u0026#34;UTF-8\u0026#34;) .addColumn(\u0026#34;id\u0026#34;, Integer.getClass()); .setUnique(\u0026#34;id\u0026#34;); .setAutoIncrement(\u0026#34;id\u0026#34;); .addColumn(\u0026#34;name\u0026#34;, String.getClass()); .addColumn(\u0026#34;age\u0026#34;, Integer.getClass()); .addColumn(\u0026#34;sex\u0026#34;, String.getClass()); .addColumn(\u0026#34;teacher\u0026#34;, Teacher.getClass()); .addColumn(\u0026#34;parents\u0026#34;, Person.getClass()); .addColumn(\u0026#34;contact\u0026#34;, String.getClass()); } } 對於 createTable() 這個方法來說，雖然在方法裡面出現了「一行程式裡面出現多個 .」的情況，但自始至終，這些方法在執行和操作的過程，都只會影響到最一開始那個被建立的 table 物件，而 table 物件是「方法中被建立的物件」，也就是法則裡面所定義的「朋友」，因此，即便這行程式裡面出現了許多方法間的呼叫，但就本質上而言，這個 createTable() 仍是沒有違反迪米特法則的。\n"},{"id":155,"href":"/docs/computer_science/design_pattern/template_pattern/","title":"模板方法模式","section":"設計模式","content":"\r模板方法模式\r#\rChatGPT 的說明 模板方法模式（Template Method Pattern）又稱作模板模式（Template Pattern）是一種行為型設計模式，該模式定義了一種演算法的骨架，並允許將特定步驟的程式細節延遲到子類別中實現。這個模式使得程式可以在不改變演算法結構的情況下，對演算法的某些步驟進行重新定義。模板方法模式在許多程式語言和框架中廣泛應用，它可以用於創建框架或函式庫，以便子類別可以自訂某些演算法的行為，同時保持整個演算法的一致性。\n以下是模板方法模式的關鍵要素和工作原理：［抽象模板］（Abstract Template）：抽象模板是一個抽象類別或接口，它用於定義演算法的骨架，通常包含一個（或多個）不同的模板方法，這些模板方法是演算法的關鍵步驟。通常，抽象模板中的模板方法會呼叫一些抽象的（或可擴展的）方法，以便在子類別中具體實現。［具體模板］（Concrete Template）：具體模板是抽象模板的子類別，它用於實作抽象模板中的抽象方法，以定義演算法的具體行為。具體模板通常的功能在於實作抽象方法，而不需要改變演算法的整體結構。［模板方法］（Template Method）：模板方法是抽象模板中所定義的方法，它描述了演算法的步驟和順序。這些步驟可以包括一些已經實現的操作和一些需要在特定子類別中實現的操作。模板方法透過呼叫抽象方法來完成演算法的不同部分。［鉤子方法］（Hook Method）：鉤子方法是在抽象模板中定義的可選方法，子類別可以選擇性地覆寫它們來影響演算法的行為。這允許子類別在不改變整體演算法結構的情況下，對演算法進行擴展或自訂。\n模板方法模式的優點包括以下 3 點：「透過提供特定的演算法的骨架，使得程式碼可以重複使用，減少了不同類別間的重複程式碼。」「允許在不改變整個演算法結構的情況下，讓使用者自訂特定步驟中的具體行為。」以及「提供了一種易於維護和擴展的程式設計方式。」\n簡單整理 問題描述：相似的類別會有著相似的方法、內容、或呼叫順序\n解決方案：透過建立一個通用的模板，讓不同類別可以使用相同模板，進而減少程式冗餘\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 (To be continue \u0026hellip;)\n"},{"id":156,"href":"/docs/computer_science/probability_theory/probability_distribution/","title":"機率分布","section":"機率論","content":"\r機率分布（Probability distribution）\r#\rChatGPT的說明 機率分布（Probability distribution）是描述隨機變數可能取得每個值的機率的數學模型。它是機率論的核心概念之一，用來表示隨機現象的結果在不同取值之間的機率分配情況。在機率分布裡，分布的方式總共可以分成「離散隨機變量機率分布」與「連續隨機變量機率分布」兩種：【離散隨機變量機率分布】：對於離散隨機變量，其機率分布可以由機率質量函數（Probability Mass Function，PMF）來描述。PMF 給出了每個可能值的取德機率，通常用符號 \\(P(X) = x\\)\r來表示，其中 \\(X\\)\r表示隨機變量， \\(x\\)\r表示某個具體的值。 PMF 需要滿足兩個條件：分別是「所有可能的取值的機率都在 0 到 1 之間」與「所有可能取值的機率總和等於 1」。\n【連續隨機變量的機率分布】：對於連續隨機變量，其機率分布由機率密度函數（Probability Density Function，PDF）來描述。機率密度函數通常表示為 \\(f(x)\\)\r，表示在某個區間內取得某個值的機率密度。PDF 沒有直接的機率值，僅僅能表示位於該值附近的機率密度。對於連續隨機變量，「『機率』落在某個區間內的機率」等於「該區間內的機率密度函數的積分」。\n離散機率分布的常見例子包括伯努利分布、二項式分布、卜瓦松分布 \u0026hellip;等，這些分布通常用於描述離散型隨機變量（例如描述試驗結果的成功或失敗次數）。連續機率分布的常見例子則包括正態分布、指數分布、連續行均勻分布 \u0026hellip;等，這些分布通常用於描述連續型隨機變量（如測量結果的時間、距離、或數值等）。\n離散隨機變量機率分布\n離散型均勻分布 "},{"id":157,"href":"/docs/computer_science/probability_theory/","title":"機率論","section":"資工相關","content":"\r機率論\r#\rChatGPT 的說明 機率論（Probability Theory）是數學的一個分支，主要研究隨機現象的數學模型和規律。它探討的是不確定性事件的可能性和結果發生的機率。以下是對機率論裡，對各名詞更加詳細的解釋：【隨機現象】：隨機現象指的是無法確定其具體結果的事件，例如擲骰子、抽取彩球等。【樣本空間和事件】：在機率論中，由「所有可能的結果」所組成的集合被稱為樣本空間（sample space）。而事件則是樣本空間的子集，表示某些特定結果的集合。【機率】：機率是描述事件發生可能性的數量化指標，通常以介於 0 到 1 之間的數字表示。【隨機變量】：隨機變量是用來描述隨機現象中結果的數學變量。它可以是離散的（例如擲一枚骰子得到的點數）；也可以是連續的（例如測量某個事件發生的時間長度）。【機率分布】：機率分布描述了隨機變量可能取得每個值的機率。【期望值和變異數】：期望值（expected value）是隨機變量的平均值，表示事件發生的平均結果。變異數（variance）衡量隨機變量數據的分散程度，即事件結果與其期望值之間的差異的平方的平均值。\n"},{"id":158,"href":"/docs/life/diary/","title":"每日小記","section":"生活相關","content":"\r每日小記\r#\r2024/03\r...\r2024/03/18 2024/03/19 2024/03/20 2024/03/21 2024/03/22 2024/03/23 2024/03/24 2024/03/25 2024/03/26 2024/03/27 2024/03/28 2024/03/29 2024/03/30 2024/03/31 2024/04\r...\r2024/04/01 2024/04/02 2024/04/03 2024/04/04 2024/04/05 2024/04/06 2024/04/07 2024/04/08 2024/04/09 2024/04/10 2024/04/11 2024/04/12 2024/04/13 "},{"id":159,"href":"/docs/life/reading_experience/head_first_design_patterns/","title":"深入淺出設計模式","section":"閱讀心得","content":"\r深入淺出設計模式\r#\r心得編寫日期：2023-07-07\n書籍超連結\n內文：\n一直以來，我都對「設計模式」這個東西抱著若有似無的認知。具象一點說明的話，大概就是「知道『設計模式』是一種可以讓程式寫得更加漂亮、更有彈性的觀念和方法，但實際上這些觀念是什麼（我不知道），那些方法又該如和撰寫（我也不知道）」的狀況。然後在今年 5 月底左右吧？因為第二篇論文出現了一點卡關的狀況（文章的內容一直沒辦法寫成老師期望的那種感覺），也因為患有一點研究生症候群，就開始找手邊一些「一直以來都有興趣，但又找不到合適的時間去了解」的東西進行研究了。而這之中，【研究設計模式】剛好是其中之一。\n這邊的 \u0026ldquo;研究設計模式\u0026rdquo; 是指「閱讀和設計模式相關的書籍」。這邊我挑的是《深入淺出設計模式》並不是閱讀比較主流的《Design Patterns: Elements of Reusable》也就是四人幫撰寫的那本）。會選擇那本書的其中一個原因是：剛開始的我，並不知道這本設計模式的聖經本，另一個原因則是它是我最快速能找到的相關書籍，所以就\u0026hellip; 這樣開始了。\n雖然在四人幫的著作中，共列舉了 23 種常見的設計模式，但本書並沒有包含這麼多的內容。書中的 13 個章節裡，扣掉最後一個章節在介紹 MVC 架構（Model, View, Controller），以及倒數第 2 章在介紹不同模式的合併用法之外，其餘的 11 個章節依序僅介紹了 Strategy（策略模式）、observer（觀察者）、decorator（裝飾器）、factory（工廠模式，包含簡單工廠、工廠方法、和抽象工廠）、singleton（單例模式）、Command（命令模式）、Adapter（配適器）、Facade（外觀）、Template method（模板方法）、Iterator（迭代器）、Composite（組合模式）、State（狀態模式）、Proxy pattern（代理）\u0026hellip; 等。剩餘的模式則僅於書中的附錄稍作提及。但這並不代表這本書不是一本良好的教學素材。相反地，因為本書的撰寫方式有別於市面上大多數的教學書籍，採用了極大量的圖片、角色對話、與情境式的描述，為各種模式的優缺點、應用情境、特徵、使用方法做大量的說明，同時也附上了許多的觀念思考、練習題、與程式範本，因此在閱讀上，並不會出現常見的倦怠、疲憊、或單調的感覺。\n整體而言，這本書帶給我很多新的啟發，無論是程式的撰寫方式，例如「多用組合、少用繼承」「單一類別、單一職責」「依賴通用接口，不要依賴特定類別」\u0026hellip; 等，或者是各種不同模式的應用與架構「工廠模式可以讓物件的實例化延後至子類別中實現」「模板方法只關心演算法的骨幹，因此可以在不改變演算法結構的前提下，重新定義某些方法的執行細節」「單例模式可以讓類別只生成單一物件，以確保某些資源的分配不會遇到問題或錯誤」\u0026hellip; 等，抑或是程式的語法觀念，像是「C++ 的物件繼承，菱形繼承的問題與解決」「虛函數, 純虛函數」\u0026hellip; 等，都是在閱讀本書之後才有了一個更加明確與更加清晰的認識。雖然是在一個比較非主動的動機下，才開始閱讀本書，但整體而言，能夠「閱讀本書，並從書本當中學到了更多的知識」對我來說實在是一件很高興又很喜歡的事情。\n評分\n閱讀難度：★★★☆☆（需要有基本的物件導向程式觀念） 推薦指數：★★★★☆ "},{"id":160,"href":"/_trash/creation/novel/note/0_hand_paper/copy_fairy_tail/","title":"照抄妖精的尾巴","section":"0 號手稿的筆記","content":"\r照抄妖精的尾巴\r#\r序場（開頭定調）\n暗示主角即將遭遇巨大的危險 預告故事的未知比觀眾想像的還要未知 由一群地位很高（或實力很強）的人來鋪墊主角群 王道情節：「成長」的故事\n「厲害的人」可以是好人或壞人\n主角可以是好人、麻煩的人、或（暫時的）壞人\n舉例：用序場墊高主角的做法\n一群壞魔法師， 他們最想解決的不是魔法協會 而是小小的魔法組織 因為他們有預感 這個小團體才是未來最大的威脅 \u0026hellip; 魔法監獄要處死魔法界的大惡人 麼法協會會長第一次親自來到行刑現場 因為要處死的人當中有主角 而會長打算赦免主角 \u0026hellip; 墊高之後需要顧及的兩件事情\n幫角色添加反差 序場是故事的定調 幫角色做反差\n可以讓會長/主角當作純粹的好/壞人 可以在好壞上面做反差（大家以為他很好，但其實他很壞） 可以拿來做反差的東西：性格、背景、招式、外貌 用登場方式幫角色做反差： 墊高角色之後，先往下拉，展現出角色的弱 看上主角什麼能力，就先讓主角在那個能力上翻車 用配角呼應主角\n讓配角的登場方式與主角相互關聯 烏斯懷亞怕水 vs. 西米來到港口找護船人 主/配角因某事而相遇 在某個事件（困境）裡，其中一方受到另一方的幫助 因此產生交集 補充：困境最好跟故事/主題本身有關 磨合段落\n角色沒有主要行動 行為、地點、要素的限制較少 可以不用先想，自由度高 最後面的情節\n配角「被騙」，遭遇某個困境 困境如果可以呼應主角的「弱」會更好 主角出面解決問題 在這邊反轉「主角很弱」這個印象 結尾接回序場 做主角的二次墊高（因為他們，使得xx得以安分） 拋出伏筆（因為他們擁有某種 \u0026ldquo;力量\u0026rdquo;） "},{"id":161,"href":"/docs/life/reading_experience/the_camphorwood_custodian/","title":"祈念之樹","section":"閱讀心得","content":"\r祈念之樹\r#\r心得編寫日期：2024-03-02\n書籍超連結\n內文：\n這是我在十六病房裡閱讀的第一本書，甚至比我那一系列勸學齋主的紫微斗數還要早看。講述的是一個平凡的日本少年，在一次的因緣際會下，繼承了家族代代相傳的一份重要工作——樟樹的守護人，並以此為故事的核心，一步一步地挖掘、探索這份工作的內容、意涵、與重要性。整體來說，故事懸疑和解謎的成分很大，但沒有恐怖、血腥、或驚悚的氛圍在裡面，算是一個普遍級的優秀作品。然後隨口說一下，相對於《祈念之樹》，我其實更喜歡原日文《クスノキの番人》也就是《樟樹的守護者》這個名稱。\n「衷心期望樟樹可以接收到你的心願。」\r#\r整部小說採用封閉式劇情的書寫方法。大概在小說的前 20 頁裡，就把故事所有「前因」（世界觀、主角的背景、和主角的目標）都說完了，很高效地把幾乎所有的篇幅都放在故事的「後果」之上。為什麼素未謀面的律師要替主角解圍？為什麼神秘人委託了律師這份工作？為什麼神秘人讓他接任一個看似毫不等價（甚至可以說是輕鬆過頭）的工作？所謂「樟樹守護人」的重要性到底在哪裡？白天的祈念和夜晚的祈念又有何差異？也為什麼一定要使用「祈念」這個詞，而非「祈願」「許願」、或其他等類似的字語？又為什麼會有人想要虧探那些祈念者的祈念過程？ \u0026hellip;諸如此類的問題會在故事的各個地方浮現，當你解決一項問題之後，另一項問題又會接踵而至，可以說是完全沒有鬆散篇幅的緊湊作品。\n此外，除了一點點「神秘力量」的架空設定，以及關於「記憶」「回憶」的描述以外，這部小說對「親情」（準確來說是「家人」）的描寫占了很～大很大的比重，幾乎可以說是完全在探討關於家人的一部作品。在本作中，無論是主角、女主角、重要的幾個配角、亦或是其他在小說中出現的所有角色，無一例外都在探討關於「家人」這份情感的意義與價值。除了世俗意義上父親母親、兄弟姐妹 \u0026hellip;的那種家人外，裡面也有聊到類似「一定要有血緣關係，才是所謂的『家人』嗎？」「如果我有一群相信我的部署和上司，那他們也能算是我的『家人』嗎？\u0026hellip;等較為廣泛的層面與議題。\n老實說，因為從小的生活習慣，我很不擅於處理這種面向的問題（或者可以說是刻意避開思考這類型的問題），但也因為如此，我才能很沈浸在故事所建構的氛圍之中（主角在小說的設定上，也是一個幾乎沒有和任何家人有過深度交流的人物）。我猜，因為這本小說的內容與調性（神秘學、親情、慢節奏），這也是我的家人選擇在我入院之後，第一次送書時就給我這本小說的原因（我那時候除了麻煩他們送來我想看的書籍以外，就只有這本書是「額外」的）。就結果而言，它的確帶給了我一些啟發。總的來說，如果你是一位不排斥接觸這類議題，又喜歡閱讀小說的人，我很誠摯地推薦這部作品。\n評分\n閱讀難度：★☆☆☆☆ 推薦指數：★★★★★ "},{"id":162,"href":"/_trash/creation/coding/","title":"程式專題","section":"_Trashes","content":"\r程式專題\r#\r"},{"id":163,"href":"/_trash/creation/novel/note/story/ch01/","title":"第一章重點","section":"故事的解剖","content":"\r第一章重點\r#\r善良的背面一定是邪惡嗎？\n英雄就是要摧毀邪惡？還是號召善良？\n聖人是什麼？\n用某一個片刻來呈現角色過往的一切\n"},{"id":164,"href":"/_trash/design_pattern/simple_factory_pattern_1/","title":"簡單工廠模式","section":"_Trashes","content":"\r簡單工廠模式\r#\rChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。\n簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。\n簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 \u0026hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。\n簡單整理 問題描述：Client 對於 Product 有著高度的依賴\n解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在常見的設計模式裡面，跟「工廠」有關的設計模式共有三種，分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過一個工廠，來簡單地改寫程式碼的一種設計模式。讓我們來想像一種情境：假設我們正在製作一個「繪製不同圖型」的程式，裡面有一個一個用來繪製圖形的畫布 Canvas，以及一些預設的可繪製圖形 Circle, Square, Rectangle, Triangle, 和 Polygon \u0026hellip;等。我們首先假設所有的圖形都繼承於 Shape 類別，我們也假設只要呼叫 Canvas 裡面的 addShape() 方法，並透過傳入的 String 參數，該方法就會幫我們繪製圖形，如下所示：\n// 抽象父類別 [形狀] abstract class Shape {} // 各種繼承 [形狀] 的子類別們 class Circle extends Shape {} class Square extends Shape {} class Rectangle extends Shape {} class Triangle extends Shape {} class Polygon extends Shape {} // 繪圖類別 `Canvas` class Canvas { public void addShape(String shape) { // 建立圖形變數 \u0026#39;shape\u0026#39; Shape shape = null; // 把 \u0026#39;shape\u0026#39; 變成我們預設的其中一種形狀 if(shape.equals(\u0026#34;Circle\u0026#34;)) { shape = new Circle(); } else if(shape.equals(\u0026#34;Square\u0026#34;)) { shape = new Square(); } else if(shape.equals(\u0026#34;Rectangle\u0026#34;)) { shape = new Rectangle(); } else if(shape.equals(\u0026#34;Triangle\u0026#34;)) { shape = new Triangle(); } else if(shape.equals(\u0026#34;Polygon\u0026#34;)) { shape = new Polygon(); } // 檢查 shape 是否為 null ? if(shape == null) { throw new ShapeIsNotExistException(); } // 畫圖 this.draw(shape); } private void draw(Shape shape) { // 繪製圓形的方法 } // 其他 Canvas 中的方法 ... // 其他 Canvas 中的方法 ... // 其他 Canvas 中的方法 ... } 從執行的角度來說，這支本身並沒有問題，基本上我們只要給定正確的參數（像是 canvas.addShape(\u0026quot;Circle\u0026quot;) 之類的），該繪製軟體就會正確地幫我們把圖形呈現在畫布上面。但從「設計原則」的角度來說，它其實已經違反單一職責原則了：因為現在 Canvas 類別不僅要管理「繪圖時的相關資訊」（像是設定繪圖板大小、長寬、設定各種背景參數 \u0026hellip;等），它同時也需要管理「如何生成各種不同的圖形」（圓形怎麼畫？正方形多大？長方形要什麼顏色 \u0026hellip;等）。\n因此，一個比較好的改寫方式是：先透過一個「形狀工廠」（ShapeFactory）來生產不同的形狀，並設定不同形狀的參數、顏色 \u0026hellip;等。再將 ShapeFactory 製作好的形狀回傳給Canvas，讓 Canvas 透過類別裡面的 draw() 方法，直接將該工廠所生產的圖形放到使用者的畫布上面。這樣一來，就可以完成「ShapeFactory 負責生產圖形」「Canvas 類別負責設定畫布的相關資訊」的分工：\n// [圖形] 類別，和剛剛一樣 abstract class Shape {} class Circle extends Shape {} class Square extends Shape {} class Rectangle extends Shape {} class Triangle extends Shape {} class Polygon extends Shape {} // [圖形工廠] 類別，用來生產不同的形狀 class ShapeFactory { public Shape createShape(String shape) { Shape shape = null; if(shape.equals(\u0026#34;Circle\u0026#34;)) { shape = new Circle(); } else if(shape.equals(\u0026#34;Square\u0026#34;)) { shape = new Square(); } else if(shape.equals(\u0026#34;Rectangle\u0026#34;)) { shape = new Rectangle(); } else if(shape.equals(\u0026#34;Triangle\u0026#34;)) { shape = new Triangle(); } else if(shape.equals(\u0026#34;Polygon\u0026#34;)) { shape = new Polygon(); } if(shape == null) { throw new ShapeIsNotExistException(); } return shape; } } // [畫布] 類別，用來管理跟 \u0026#34;畫布\u0026#34; 有關的各種資訊 class Canvas { private ShapeFactory shapeFactory; public Shape addShape(String shape) { Shape shape = shapeFactory.createShape(shape); this.draw(shape); } } 透過簡單工廠模式，將不同類型的工作分離，進而讓程式達到單一職責原則的規範，就是簡單工廠模式最常見的使用情境。另外，因為簡單工廠模式通常都不會有什麼太過複雜的內容，因此相對於在不同的類別裡生成不同的 SimpleFactory 物件，如果是對於程式效率很注重的人，會將工廠裡面的方法直接加上一個 static 關鍵字，讓整個方法變成一個靜態方法，如下所示：\nclass ShapeFactory { public static Shape createShape(String shape) { // 生成圖型的程式細節 ... } } class Canvas { public Shape addShape(String shape) { // 不需要生成 factory 物件 // 直接通過類別呼叫方法 // 可以節省一些 `Canvas` 所需的記憶體空間 Shape shape = ShapeFactory.createShape(shape); this.draw(shape); } } 透過將方法宣告成 static，使得其餘程式在調用 createShape() 方法時，不需要先創建一個 ShapeFactory 的物件，以節省更多的記憶體空間，就是這類作法的其中一個原因。而這種「透過工廠中的靜態方法，生成工廠中的產品」的程式撰寫方式，也可以被稱作「靜態工廠」。但需要注意的事情是：靜態工廠只是一種工廠模式的「優化方法」，而不是一種「設計模式」，工廠類型的設計模式只有簡單工廠、工廠方法、和抽象工廠三種。\n"},{"id":165,"href":"/_trash/design_pattern/simple_factory_pattern_2/","title":"簡單工廠模式","section":"_Trashes","content":"\r簡單工廠模式\r#\rChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。\n簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。\n簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 \u0026hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。\n簡單整理 問題描述：Client 對於 Product 有著高度的依賴\n解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在常見的設計模式裡，跟「工廠」有關的設計模式共有三種。它們從簡單到複雜分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過生成一個「簡單的」工廠，來分離不同職責的程式碼，讓程式可以達到更好的靈活性、可讀性，和良好的封裝性。讓我們用一個簡單的例子來做說明：假設我們現在正在撰寫一個「資料庫操作程式系統」，該系統需要包含一些使用者對於資料庫的簡單操作，像是 SELECT, UPDATE\u0026hellip;等，在不使用簡單工廠模式的情況下，程式可能會寫成像是下面的這個樣子：\n// 資料庫系統中的 [使用者] 類別 class User { private Database database; private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } public QueryResult query(Database.operation operation, String query) { this.database = this.connectToSystem(this.account, this.password); QueryResult queryResult = null; switch(operation) { case Database.operation.INSERT: queryResult = database.insertQuery(query); // C - create break; case Database.operation.SELECT: queryResult = database.selectQuery(query); // R - read break; case Database.operation.UPDATE: queryResult = database.updateQuery(query); // U - update break; case Database.operation.DELETE: queryResult = database.deleteQuery(query); // D - delete break; default: throw new OperationIsNotExistException(); break; } return queryResult; } // 其他 [使用者] 的方法 ... // 其他 [使用者] 的方法 ... } 透過不同的 operation 區別不同的 query 指令，並透過 queryResult 接收 database 的各種回傳。在這樣的情況下 User.query() 方法是可以正常運行的。但話雖如此，這個 query() 方法還是有著可以優化的空間：User 類別的主要職責應該是「管理所有跟 User 相關的事物」，例如修改密碼、查看使用者基本資料、或者是一些其他主體為「使用者」的操作 \u0026hellip;等。但這個 query() 的程式細節明顯是跟「如何對資料庫進行查詢」有關，不是 User 的工作。違反了設計原則中的單一職責原則，因此，我們可以針對這一項缺失，進行一點調整：\n// 資料庫系統中的 [使用者] 類別 class User { private Database database; private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } public QueryResult query(String query) { this.database = this.connectToSystem(this.account, this.password); // 封裝『如何對資料庫進行查詢』這件事情 // 現在 User 可以不用關心 query 的程式細節 // 只要知道『這樣就可以得到資料』就行 QueryResult queryResult = database.getQueryResult(query); return queryResult; } // 其他 [使用者] 的方法 ... // 其他 [使用者] 的方法 ... } // 資料庫系統中的 [資料庫] 類別 class Database { private enum Operation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } // 將『如何對資料庫進行查詢』寫在類別 `Database` 裡面 public QueryResult getQueryResult(String query) { Operation operation = this.getOperation(query); QueryResult queryResult = null; switch(operation) { case operation.INSERT: queryResult = database.insertQuery(query); // C - create break; case operation.SELECT: queryResult = database.selectQuery(query); // R - read break; case operation.UPDATE: queryResult = database.updateQuery(query); // U - update break; case operation.DELETE: queryResult = database.deleteQuery(query); // D - delete break; default: throw new OperationIsNotExistException(); } return queryResult; } // 其他 [資料庫] 的方法 ... // 其他 [資料庫] 的方法 ... } 像這樣區隔不同職責的程式碼，就是一種「簡單工廠模式」的撰寫邏輯。此外，值得一提的是：在某些工廠類型的方法中（不是只有「簡單工廠」），為了一些程式效率（或其他）的需求，我們可以把「工廠」中的方法定義成靜態的，這樣在進行呼叫的時候，就可以不用先創建一個 Factory 物件，再透過該物件去呼叫我們想要使用的方法了——直接將方法宣告成靜態的，並透過類別直接呼叫即可。而這種透過靜態的方式，呼叫工廠中的方法的行為，就叫做「靜態工廠」方法：\n// 資料庫系統中的 [使用者] 類別 class User { private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } public QueryResult query(String query) { // 現在 `User` 不需要依賴一個 `Database` 的物件 // 只需要利用 `Database` 的靜態方法 // 同樣可以達到 `User` 預期想要做到的事情 QueryResult queryResult = Database.getQueryResult(query); return queryResult; } // 其他 [使用者] 的方法 ... // 其他 [使用者] 的方法 ... } class Database { // 一些 [資料庫] 中的成員變數 // 一些 [資料庫] 中的成員變數 // 將 getQueryResult() 宣告成靜態的 // 這樣就可以免去其餘類別需要「先創物件、在調方法」的過程 // 一方面可以簡化程式碼 // 另一方面也可以減少其餘類別本身的依賴與負擔 public static QueryResult getQueryResult(String query) { Operation operation = this.getOperation(query); QueryResult queryResult = null; switch(operation) { case operation.INSERT: queryResult = database.insertQuery(query); // C - create break; case operation.SELECT: queryResult = database.selectQuery(query); // R - read break; case operation.UPDATE: queryResult = database.updateQuery(query); // U - update break; case operation.DELETE: queryResult = database.deleteQuery(query); // D - delete break; default: throw new OperationIsNotExistException(); } return queryResult; } // 其他 [資料庫] 的方法 ... // 其他 [資料庫] 的方法 ... } 最後，簡單工廠還有一個東西可以說：在剛剛的例子下，我們無論是在 User 的方法內進行資料庫查詢，還是在工廠（也就是 Database）內進行資料庫查詢，都是讓它們回傳一個真正的 Data 物件，這樣做可能還是有點看不出「簡單工廠」的有趣之處，而也這個 Database 與其說是「工廠」，更像是一個真正的資料庫類別。因此，我們可以再～對這個程式進行一點改寫，沒有麼特別的原因，只是想要單純的改寫它：\n// 資料庫系統中的 [使用者] 類別 class User { private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } // 透過直接呼叫 Database 中的靜態方法 getQueryResult() // 可以省去一點建立 User 所需要的記憶體空間 public QueryResult query(String query) { QueryResult queryResult = Database.getQueryResult(query); return queryResult; } // 其他 [使用者] 的方法 ... // 其他 [使用者] 的方法 ... } // 資料庫系統中的 [資料庫] 類別 class Database { // 一個 \u0026#34;工廠\u0026#34; 物件 private QueryFactory factory; // 靜態方法 getQueryResult public static QueryResult query(String query) { // 呼叫一個 factory 的方法 QueryResult queryResult = factory.parseQuery(query); return queryResult; } } // 資料庫系統中的 [Query 工廠] 類別 class QueryFactory { private enum QueryOperation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } public QueryResult parseQuery(String query) { QueryOperation operation = this.parse(query); QueryResult queryResult = null; switch(operation) { case QueryOperation.INSERT: queryResult = new InsertQuery(query); break; case QueryOperation.SELECT: queryResult = new SelectQuery(query); break; case QueryOperation.DELETE: queryResult = new UpdateQuery(query); break; case QueryOperation.DELETE: queryResult = new DeleteQuery(query); break; default: throw new OperationIsNotExistException(); } return queryResult; } } // 資料庫系統中的 [Query] 類別們 abstract class QueryResult(); class InsertQuery extends QueryResult {}; class SelectQuery extends QueryResult {}; class UpdateQuery extends QueryResult {}; class DeleteQuery extends QueryResult {}; 透過讓 User 和 Database 都只依賴一個共同的「產品」父類別 Data，並且在「工廠」類別（QueryFactory）中根據不同的情況，創建出不同種類的產品子類別（例：InsertResult, SelectResult, UpdateResult, DeleteResult \u0026hellip;等），也是簡單工廠模式建議的程式撰寫方式：畢竟如果只是回傳同樣資料型態的物件，那麼就跟「單純把程式碼換地方擺」沒有兩樣了～\n"},{"id":166,"href":"/_trash/design_pattern/simple_factory_pattern_3/","title":"簡單工廠模式","section":"_Trashes","content":"\r簡單工廠模式\r#\rChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。\n簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。\n簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 \u0026hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。\n簡單整理 問題描述：Client 對於 Product 有著高度的依賴\n解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在常見的設計模式當中，跟「工廠」有關的設計模式共有三種，它們從簡單到複雜分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過一個結構「簡單」的工廠，來將程式碼拆分，以提高程式系統的可讀性、靈活性、和可擴展性。讓我們以一個簡單的例子來做說明：假設我們現在需要製作一個「網站架設系統」，該系統需要包含一些關於前後端的程式內容，而其中一項功能的描述如下：「使用者可以透過輸入不同的 SQL 語句，來取得不同的資料庫內容。」用程式來呈現的話，可能會像這個樣子：\n// 架站系統中的 [客戶端] 類別 class Client { private String account; private String password; public Object getDatabaseData(String query) { Database database = this.getDatabaseConnection(account, password); Object data = null; Database.Operation operation = database.getOperation(query); switch(operation) { case Database.Operation.INSERT: data = database.insertQuery(query); break; case Database.Operation.SELECT: data = database.selectQuery(query); break; case Database.Operation.UPDATE: data = database.updateQuery(query); break; case Database.Operation.DELETE: data = database.deleteQuery(query); break; default: throw new QueryUndefinedException(); } return data; } } class Database { public enum Operation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } public Object insertQuery(String query) { // 一些 insert 的程式細節 } public Object selectQuery(String query) { // 一些 select 的程式細節 } public Object updateQuery(String query) { // 一些 update 的程式細節 } public Object deleteQuery(String query) { // 一些 delete 的程式細節 } } 透過上面的程式架構，客戶端如果想要進行一些 SQL 的操作，只要使用到 Client.getDatabaseData() 就可以完成需求了。看起來挺正常的，程式沒什麼問題，功能上也完全正確，但這樣的程式的確還有改善的空間，其中一個問題是它違反了單一職責原則：根據單一職責原則的說法，一個類別應該只處理一組相似的工作，而在類別 Client 中，它所負責的應該是一些「與客戶端有關的程式邏輯」才對，像是基本資料設定、修改密碼、或者是一些與客戶端相關的功能。\n但 getDatabaseData() 方法很明顯地就是在「調用資料庫、對資料庫進行操作、並返回結果。」這個方法從頭到尾都不與「客戶」有關，應該與「資料庫」更甚至是「SQL 操作」有關才對吧？因此，針對這一個問題，我們可以對上述的程式進行修改：把 Client.getDatabaseData() 的程式細節從 Client 中搬走，改放到 Database 的類別之中，以保證單一職責原則，提高程式的可讀性與靈活性。\n此外，為了預防「把程式全部往 Database 裡面塞之後，Database 會變得非常龐大」的狀況，我們新增了一個 Query 的抽象類別，並額外創建了 InsertQuery, SelectQuery, UpdateQuery, 和 DeleteQuery 等四個繼承自 Query 的子類別，用來分工不同的 SQL 工作內容，進而減少 Database 中的方法數量，讓分工變得更為明確。簡單來說，程式可以被我們改寫成下面的這個樣子。\n// 架站系統中的 [客戶端] 類別 class Client { private String account; private String password; public Object getDatabaseData(String query) { Database database = this.getDatabaseConnection(account, password); Object data = database.getResult(query); return data; } } // 架站系統中的 [資料庫] 類別 class Database { private enum Operation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } public Object getResult(String query) { Query queryObj = null; Operation operation = this.getOperation(query); switch(operation) { case Operation.INSERT: queryObj = new InsertQuery(); break; case Operation.SELECT: queryObj = new SelectQuery(); break; case Operation.UPDATE: queryObj = new UpdateQuery(); break; case Operation.DELETE: queryObj = new DeleteQuery(); break; default: throw new QueryUndefinedException(); } Object result = queryObj.getResult(query); return result; } } // 新增的 Query 抽象類別 // 裡面宣告了一個需要實作的 getResult 抽象方法 abstract class Query { public abstract Object getResult(String query); } // 繼承 Query 的所有子類別 class InsertQuery { @Override public Object getResult (String query) { // 一些 insert 的程式細節 } } class SelectQuery { @Override public Object getResult (String query) { // 一些 select 的程式細節 } } class UpdateQuery { @Override public Object getResult (String query) { // 一些 update 的程式細節 } } class DeleteQuery { @Override public Object getResult (String query) { // 一些 delete 的程式細節 } } 這就是透過「簡單工廠模式」的一種實現了。透過 Database 中的 getResult() 方法，讓原本寫在 Client 中的程式，得以拆分出來。現在對於 Client 來說，它不再需要知道關於 query 相關的程式細節（像是要 new 哪一種類型的 Query 物件？之後又要調用哪些分法？ \u0026hellip;等）， Client 只要知道「調用 getResult()，我就可以拿到 Database 裡面的程式」就可以了，這便是一種簡單工廠模式的程式範例。\n"},{"id":167,"href":"/docs/computer_science/design_pattern/simple_factory_pattern/","title":"簡單工廠模式","section":"設計模式","content":"\r簡單工廠模式\r#\rChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。\n簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。\n簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 \u0026hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。\n簡單整理 問題描述：Client 對於 Product 有著高度的依賴\n解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在常見的設計模式當中，與「工廠」有關的設計模式共有三種，它們由間單到複雜依序是簡單工廠模式、工廠方法模式、以及抽象工廠模式。簡單工廠模式顧名思義，就是透過一個「工廠」類別，將比較「簡單的」程次區域給獨立出來，通常會配合單一職責原則進行程式碼的檢查，如果某一段程式不符合單一職責原則的話，就可以考慮用簡單工廠將程式給區分出來。讓我們用一個簡單的範例來做說明：假設我們正在開發一個「線上傢俱閱覽系統」，使用者可以根據不同的需要來瀏覽、比較、或購買傢俱，程式片段大致如下所述：\n// 系統中的 [顧客] 類別 class Customer { private String account; private String password; // 透過不同的關鍵字，取得不同傢俱 public Furniture getFurniture(String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new Chair(); else if(name.equals(\u0026#34;desk\u0026#34;)) furniture = new Desk(); else if(name.equals(\u0026#34;sofa\u0026#34;)) furniture = new Sofa(); else if(name.equals(\u0026#34;bed\u0026#34;)) furniture = new Bed(); else if(name.equals(\u0026#34;television\u0026#34;)) furniture = new Television(); else throw new FurnitureIsNotExistException(); return furniture; } } 上圖的程式邏輯本身沒什麼問題，透過 getFurniture() 方法，我們的確可以讓顧客在系統中正確地看到他們想要留懶的不同傢俱。但從設計原則上，這樣的寫法就有可以改進的空間了，因為這支程式並不符合單一職責原則。白話文的來說： Customer 類別所負責的職責，應該僅限於跟「顧客」有關的東西才對，像是修改密碼、檢視帳戶資料、升級成 VIP 會員、儲值、訂閱相關資訊或取消訂閱 \u0026hellip;等。但這個 getFurniture() 方法很明顯是在「創建一個傢俱，並回傳給使用者。」比起顧客，更像是「傢俱」類別的工作，因此針對這個部分，我們可以利用簡單工廠模式對程式進行改寫：\n// 系統中的 [顧客] 類別 class Customer { // 新增一個 [傢俱工廠] private FurnutireFactory factory; private String account; private String password; public Furniture getFurniture(String name) { // 將「獲得傢俱」的程式封裝起來 Furniture furniture = factory.createFurniture(name); return furniture; } } // 系統中的 [傢俱工廠] 類別 class FurnutireFactory { public Furniture createFurniture(String name) { Furniture furniture = null; // 把「獲得傢俱」的程式邏輯擺放在 [傢俱工廠] 裡面 if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new Chair(); else if(name.equals(\u0026#34;desk\u0026#34;)) furniture = new Desk(); else if(name.equals(\u0026#34;sofa\u0026#34;)) furniture = new Sofa(); else if(name.equals(\u0026#34;bed\u0026#34;)) furniture = new Bed(); else if(name.equals(\u0026#34;television\u0026#34;)) furniture = new Television(); else throw new FurnitureIsNotExistException(); return furniture; } } // 系統中的 [傢俱] 類別（抽象的） abstract class Furnutire { protected String name; public Furnutire(String name) { this.name = name; } } // 其他繼承了 [傢俱] 的不同真實傢俱 class Chair { public Chair(String name) { super(name); } } class Table { public Table(String name) { super(name); } } class Lamp { public Lamp(String name) { super(name); } } class Computer { public Computer(String name) { super(name); } } 這就是簡單工廠的具體範例了。\n執得一提的是，因為簡單工廠真的很簡單，因此在一些程式設計上，我們更傾向於把簡單工廠的方法（或方法們）宣告成靜態的（也就是加上 static 關鍵字）。因為如果將方法宣告成靜態方法，其他類別（例如 Customer）在調用工廠中的方法時，就不需要再額外 new 一個工廠的物件出來，算是一種節省記憶體空間的操作。而這種把方法宣告成靜態的撰寫方式也可以稱為「靜態工廠」。但需要注意的是：靜態工廠並不是一種模式，僅僅是一種工廠模式的優化方法而已：\nclass FurnutireFactory { // 加入 static 關鍵字，使其成為靜態方法 public static Furniture createFurniture(String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new Chair(); else if(name.equals(\u0026#34;desk\u0026#34;)) furniture = new Desk(); else if(name.equals(\u0026#34;sofa\u0026#34;)) furniture = new Sofa(); else if(name.equals(\u0026#34;bed\u0026#34;)) furniture = new Bed(); else if(name.equals(\u0026#34;television\u0026#34;)) furniture = new Television(); else throw new FurnitureIsNotExistException(); return furniture; } } // 系統中的 [顧客] 類別 class Customer { private String account; private String password; public Furniture getFurniture(String name) { // 透過 [傢俱工廠] 直接獲得傢俱 // 省去了建立物件的過程 Furniture furniture = FurnutireFactory.createFurniture(name); return furniture; } } "},{"id":168,"href":"/docs/occultism/ziwei/","title":"紫微斗數","section":"命理相關","content":"\r紫微斗數\r#\rChatGPT 的說明 紫微斗數，又稱紫微星盤、紫微命盤，是一種古老的中國命理學體系，用來推測一個人的命運、性格、特徵以及未來的發展趨勢。它的由來可以追溯到古代中國。【古代天文學和占星術的結合】：紫微斗數的起源與中國代的天文學和占星術有關。在古代，人們相信天體運動與人類的命運有著密切的關聯。天文學家觀測天體的運行，並試圖解釋這些運動如何影響人類的生活和命運。【古代斗數術士】：在古代中國，有一些專門從事預測和命理學的術士，他們研究天文現象，以及如何將之與個人的出生生辰聯繫起來。這些術士被認為有能力預測人的命運，並透過他們的知識來為人指引方向。【紫微星】：紫微斗數中的「紫微」指的是北斗七星中的紫微星，也稱為紫微垣。在古代中國的天文學中，紫微星被認為是皇帝的象徵，象徵帝王的權力和統治。將這個星宿納入命理學中，也使得紫微斗數有了更高的地位和神秘感。【歷史的傳承與發展】：隨著時間的推移，紫微斗數逐漸發展成一門系統的命理學科。各種不同的流派和學派出現，並在中國歷史的不同階段受到不同程度的推崇和發展。一些著名的文人學者、道士以及王朝宮廷中的命理宮廷學士都對紫微斗數進行了研究和實踐，使其逐漸成為中國傳統文化中重要的一部分。\n維基百科的說明 紫微斗數，英文通常稱為 Purple Star Astrology 或 Ziwei doushu，是中國文化中算命的一種形式，與八字一樣，紫微斗數也是中國最為著名的算命方法之一。就像西方占星術一樣，紫微斗數聲稱利用一個人出生時的各星體位置來決定性格、職業、和婚姻前景 \u0026hellip;等。傳統上，紫微斗數被認為是唐代道士呂純陽（呂洞賓）所創。它在宋代由陳希夷進一步發展，後來由明代羅洪先發展成現在的形式。然而，它的確切起源仍然在不同學派之間存在爭議。與更廣為人知的命盤四柱八字不同，紫微斗數完全基於農曆和星空的位置。相較之下，八字與天干地支系統完全連結在一起，這通常與中國傳統的節氣曆相對應。有些人認為，這種差異使這兩個系統更像是互補而不是競爭。命學傳統上與天文學密切相關，紫微斗數是命學的一部分。歷史上，在王朝時代，有才華的天文學家和占星家被招募為官員到宮廷工作，為皇帝製作星象圖，因為他的個人命運直接與他的王朝有關。宮廷占星師在確定王位繼承人方面也發揮了重要作用。占星家在觀察星星時發現：在眾多星星中，只有一顆看似靜止不動，其餘的都圍繞著它旋轉。這顆恆星被古代的東方人命名為「紫微星」──相當於天上的皇帝，而在西方，這顆星星則被稱為「北極星」。雖然紫微斗數中的這顆星星有物理基礎，但系統中其餘的「星星」是時間循環流逝的表現，不代表天空中真實存在的星星。\n"},{"id":169,"href":"/docs/life/track_expenses/","title":"記帳","section":"生活相關","content":"\r記帳\r#\r2023/08 2023/09 2023/10 2023/11 2023/12 2024/01 2024/02 2024/03 "},{"id":170,"href":"/docs/life/track_expenses/202308/","title":"記帳 2023/08","section":"記帳","content":"\r記帳 2023/08\r#\r各方面金流\n台幣活存：4098 台股股票淨值：19278 借貸狀況： 借出共 143,500 + 50,000 元 貸款共 0 元 保險： 儲蓄型保單收到了 2 元的回饋 備註\n因為信用卡還沒開辦的原因，所以個人的信用評分應該還算是很低很低。加上現在還是處在比較高利的情況，所以我不打算去做一些跟信貸有關的相關操作。因此貸款的數字是 0。另外借出約 20 萬左右的金額，主要是由兩個人所組成，預計會在近 1-2 年內回收完畢吧？如果到時候還沒回收的話，可能就會採取比較激進一點的行動方針。\n活存的部分 \u0026hellip;只能說相當可怕啦。下個月的花錢必須要非常拮据與謹慎，不然一不小心就會直接死給大家看了。台股的淨值大約是 20k，它是我 4 個月定期應額 006208 的小小成果，基本上台股的部分不會有太多的更動，它就會是一個每個月固定 5000, 5000 投入的狀況。不打算做一點短線的投機，次要原因是目前沒有甚麼了解的標的在低檔位的股價，主要原因是沒有多餘的閒錢 （哭）\n大概是這樣，目前看來沒什麼大問題，除了活存的數字真的是有夠少之外 \u0026hellip;。整體而言，自評的話大概會給 57-58 左右吧？滿分是 100 分。不及格的部分是活存水位過低、沒有緊急預備金。但剩下的 \u0026hellip; 我覺得基本上沒有大問題，但這　1-2　個月要好好調整自己的用錢習慣就是，畢竟已經沒有研究室的研究補貼了，算命的收入要想辦法拉高一點。\n"},{"id":171,"href":"/docs/life/track_expenses/202309/","title":"記帳 2023/09","section":"記帳","content":"\r記帳 2023/09\r#\r各方面金流\n資產的部分 台幣活存 31,222 元 台股淨值 28,964 元 借出共 143,500 元 負債的部分 貸款共 157,000 元 備註\n這禮拜活存大概暴增了 3-4 萬有，是因為上個月有一筆的 5 萬的借款拿回來了。股票淨值多了大約 10k，是因為這個月多買了一次 5000 的零股，但台股的錢基本上不會去動啦，畢竟是 006208 的定期定額 \u0026hellip;。另外有一筆借出約 15 萬左右的款項被我劃掉了，因為那筆借貸目前在法院的訴訟中，但我覺得有高機率拿不回來 XDD，所以就先當沒這筆錢，因此目前的總資產大約落在 55-60 k 左右。\n負債的部分 \u0026hellip; 最近妹妹不小心被人騙錢了 XD 大概被騙了 15 萬左右，身為哥哥，當然就是全扛下來啦～雖然寫是寫「負債」，但比較像是「這筆錢妳就當我先跟妳借的，我再慢慢還妳」的那種感覺，所以比較像是無期限(? 的 0 利率貸款，超划算對吧～哈哈哈哈，不過之後還是要慢慢還就是了。\n"},{"id":172,"href":"/docs/life/track_expenses/202310/","title":"記帳 2023/10","section":"記帳","content":"\r記帳 2023/10\r#\r各方面金流\n資產的部分 台幣活存 23,368 元 台股淨值 33,297 元 借出共 143,500 元 錢包現金 2,977 元 負債的部分 貸款 157,000 元 備註\n這禮拜基本身上的錢沒什麼變化。定期定額仍然轉了大約 5,000 在 006208 上面，算命收到了大概 500-1000 左右的零用錢，家裡因為在大部分的情況下會幫我備餐，所以吃的錢幾乎沒什麼花到，然後借出的錢嘛 \u0026hellip;，雖然法院有寄強制執行的單子過來，但我猜帳戶大概率是沒錢啦？不過這兩天會去問看看、試試運氣。（雖然我還是打從心底覺得是我的錢終究會回到我身上就是了 XD）\n這個月有個 \u0026hellip;比較有趣的點？雖然最近沒在注意股市，不過 006208 的價格在這 1-2 個月越來越低了，這幾天應該會順便研究一下價格掉下來的原因？然後找個機會逢低加碼一些錢錢進去，算是早早存股、早早滾錢，預計多放個 3000-5000 進去？如果繼續跌的話，預計放進去的錢會再多一點。\n"},{"id":173,"href":"/docs/life/track_expenses/202311/","title":"記帳 2023/11","section":"記帳","content":"\r記帳 2023/11\r#\r各方面金流\n資產的部分 台幣活存 28,041 元 台股淨值 40,847 元 借出共 142,500 元 錢包現金 3,653 元 負債的部分 貸款 157,000 元（Angela） 貸款 5,000 元（千） 貸款 25,000 元（Richard） 備註\n上個月的結尾說要再看看，然後逢低買進 006208，結果在寫完之後的兩天 6208 就直接從 73.2 漲到 74.8 左右了。雖然沒有跟到（要在認真思考一下分批進場的時機跟方式），但是股票那邊的總損益總算是來到正的了（雖然前 1 個月也轉正了，但那個才 +0.3% 左右，算是隨時都有可能再跌回去的狀態）。現在大概 +2.6% ，扣掉最一開始買在 76 左右價格的幾次，其他的 6208 報酬都是正的了。\n此外，這個月因為有接到額外的小案子，內容是幫一個用 WordPress 寫好的前端網頁做一點文字、視覺、跟 RWD 上的修改。因為案子很小，所以這份專案只收不到 20k 左右的金額。但整體而言也算是不無小補的狀況拉～！我覺得在這邊也可以思考一下額外接案賺收入的可能性。如果之後的工作沒有到太忙的話，一個月大概也可以接個 1-2 個短期的專案（前後端、或者是其他程式類型的都可以）幫自己多賺點收入。\n最後，這個月跟兩個朋友（千、Richard）借了總共 3 萬塊。主要用途是還錢（算是先挖東補西的概念），當初拉了朋友 A 一起投資朋友 B 的生意，結果朋友 B 捲款跑了 QQ。出於自己的一些想法跟價值觀，最後的解決方法是我先把錢還給朋友 A，再慢慢跟朋友 B 拿回我和 A 的部分。但一時之間自己身上沒有足夠給 A 的金額，所以就先跟另另外的其他朋友借錢了。\n"},{"id":174,"href":"/docs/life/track_expenses/202402/","title":"記帳 2024/02","section":"記帳","content":"\r記帳 2024/02\r#\r各方面金流\n資產的部分 中信活存 18,258 元 郵局活存 32,384 元 台股淨值 66,541 元 錢包現金 1,583 元 借出共 142,500 元 負債的部分 貸款 157,000 元（Angela） 貸款 25,000 元（Richard） 備註\n有點久沒有記帳了。1/16 入伍當兵，在那之前豪賭了一把，把身上當時所有的活存金額（不含緊急備用金）全部 all in 到 006208 上面了。16 號當天早上最後一次看報酬率的時候是正負 2~3% 左右。直到 2/28 左右，報酬率已經成功突破雙位數了（+11.04%）。目前在 006208 上面有 795 股，我打算在之後湊到 1 張（1000 股）之後就停止買進，然後做好第一階段的資產分配，再看情況選擇買進或賣出。\n目前預期的資產配置如下：\n60% 美股大盤（VOO - S\u0026amp;P500） 10% 台股大盤（就是現在放的 006208） 10% 美國的長期債券上 10% 全球股市（VT） 最後 10% 拿去加密貨幣（BTC, ETH 各 5%） 上面的配置不包含身上立馬可用的活錢（包含一般定存、活存、儲蓄險、跟緊急備用金），活錢我目前打算只押成一個固定的數字，其他都丟到上面的地方，至於數字要訂多少 \u0026hellip;可能還要再思考一下。長債跟加密貨幣的詳細操作方目前還不清楚，國外證券的開戶和出入金流程現在也都還不確定，但已經有鎖定好要證券商了（First Trade）。所以「把它們研究清楚」會是我這幾天要完成的其中一項工作。另外一項工作是要找到（或者說 \u0026ldquo;穩定\u0026rdquo;）開源的所有細節，包含主業的挑選、副業的選擇與經營、以及其他零零散散的收入管道 \u0026hellip;。\n總而言之，之後會是忙碌的開始。\n"},{"id":175,"href":"/docs/life/track_expenses/202403/","title":"記帳 2024/03","section":"記帳","content":"\r記帳 2024/03\r#\r各方面金流\n資產的部分 台幣活存 71,512 元 台股淨值 80,718 元 錢包現金 1,580 元 借出共 157,000 元 負債的部分 貸款 200,000 元（Angela） 損益試算 資產新增 35,440 元 負債減少 -18,000 元 備註\n快過完今年唯一四化忌農歷 2 月了 \u0026hellip;，一想到之後還有其他的麻煩月份，心就好累（嘆）。雖然還沒有工作，但這個月身上還是一口氣多了 35k 左右的金額，主要還是住院的那 40 天可以從南山人壽那邊，請到近 80k 的保險。拿到錢的第一件事情是立馬通知 Richard，然後跟他拿了帳戶資訊，把 25k 的負債給還掉了。然後多塞了 5k-10k 左右的本金到 006208 上面，15k-20k 放在原本的帳戶裡，當作緊急備用金，8k 當作什一奉獻捐掉了。剩下的錢嘛 \u0026hellip;，除了留一點點自己花掉之外，很大一部分拿去還給 Angela 了。\n而那即便還了錢，還是不減反增的負債嘛 \u0026hellip;，是因為剛出院的那幾天有跟 Angela 吃過飯，聊了一下才發現他前前後後被前男友借了 5 萬 8 萬，目前拿不回來 \u0026hellip;。所以我就自掏腰包，把那個債權給買過來了(?)。因為是口頭約，所以沒有辦法用法律的途徑把錢要回來，我會再想想看要怎麼解決這件事情。最糟的狀況 \u0026hellip;就是請其他人幫我拿回來吧？雖然要付一點代工費，但至少有補貼一點回來。\n希望下個月可以繼續保持資產的增加。\n"},{"id":176,"href":"/docs/computer_science/design_pattern/","title":"設計模式","section":"資工相關","content":"\r設計模式\r#\rChatGPT 的說明 【設計模式】（Design Patterns）是一種軟體工程中的概念，它描述了一種解決特定問題的通用方法或解決方案。設計模式是一種被廣泛接受和應用的軟體設計指南，它們有助於提高程式碼的可讀性、可維護性和可擴展性。通常來說，一個設計模式通常包括下面的 3 種元素：［問題描述］問題描述用來描述該模式被用來解決的問題，或便於使用此模式的情境，通常來說，問題描述可能會涉及到關於程式的複雜性、耦合性、或可讀性\u0026hellip;等不同方面的問題。［解決方案］解決方案可以為我們提供一個關於「問題」的解決方法，通常來說，解決方案會包括含一個設計結構和一個（或多個）設計原則，以便應用在特定的問題或情境中。［程式細節］程式細節用來具體示範如何在程式碼中實現這個 \u0026ldquo;解決方案\u0026rdquo;，包括扮不限於類別的結構、方法、和關係。\n設計模式的主要目標是促進程式碼的重用性、減少程式的冗餘，提高程式的可維護性、可讀性、或可擴展性。通過使用設計模式，程式的開發人員可以借鑒已經證明有效的解決方法對專案中的程式進行撰寫，而不必重新尋找解決方案、重新發明輪子、重新測試方法的可靠性。設計模式也有助於提高程式碼的可讀性，因為這些模式通常都會提供一些通用的語言和程式結構，使得程式的開發人員更容易理解和操作。一些常見的設計模式包括單例模式、工廠模式、觀察者模式、策略模式、適配器模式等。每種設計模式都針對不同的問題和情境提供了一個優雅且經過驗證的解決方案。開發人員可以根據特定的需求選擇適當的設計模式，以改善其軟體設計。\n設計模式通常可以分為創建型模式、結構型模式、和行為型模式 \u0026hellip; 等 3 種類別，每個類別都包含一組相關的設計模式，用於解決特定類型的問題：［創建型模式］創建型模式的重點在於如何創建物件，以及如何管理物件的實例化過程。創建型模式的主要目標是隱藏實例的創建過程，從而使程式更具靈活性和可維護性，同時降低類別對魚特定物件的依賴性。［結構型模式］結構型設計模式關注如何組合類別和物件，以使程式可以形成更大的結構，以解決更高層次的問題。結構型模式的主要目標是改進系統的組織與結構，使其更具有靈活性和可擴展性，同時降低系統中各個部分的耦合程度。［行為型模式］行為型關注主要研究的內容是如何進行物件之間的相互通信和合作，以實現更好的交互作用與職責分工。行為型模式的主要目標是改進類別之間的溝通方式，使系統更容易理解和維護。\n以下是一些設計原則，與常見的設計模式：\n預備知識\nUML（Unified Modeling Language） 設計原則\n單一職責原則（Single Responsibility Principle） 開放封閉原則（Open Closed Principle） 里氏替換原則（Liskov Substitution Principle） 介面隔離原則（Interface Segregation Principle） 依賴反轉原則（Dependency Inversion Principle） 最少知識原則（Least Knowledge Principle） 合成/聚合複用原則（Composite/Aggregate Reuse Principle） 創建型模式\n簡單工廠模式（Simple Factory Pattern） 工廠方法模式（Factory Method Pattern） 抽象工廠模式（Abstract Factory Pattern） 單例模式（Singleton Pattern） 創建者模式（Builder Pattern） 原型模式（Prototype Pattern） 結構型模式\n適配器模式（Adapter Pattern） 裝飾器模式（Decorator Pattern） 橋接模式（Bridge Pattern） 代理模式（Proxy Pattern） 外觀模式（Facade Pattern） 組合模式（Composite Pattern） 享元模式（Flyweight Pattern） 行為型模式\n策略模式（Strategy Pattern） 模版方法模式（Template Method Pattern） 觀察者模式（Observer Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 狀態模式（State Pattern） 職責鏈模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 備忘錄模式（Memento Pattern） 解譯器模式（Interpreter Pattern） 訪客模式（Visitor Pattern） "},{"id":177,"href":"/docs/computer_science/design_pattern/adapter_pattern/","title":"適配器模式","section":"設計模式","content":"\r適配器模式\r#\rChatGPT 的說明 適配器模式（AdapterPattern）是一種結構型設計模式，該模式用於將一個類別的介面，轉換成客戶端所期望的另一個介面，從而使得原本不相容的類別能夠一起工作。適配器模式允許在不修改原始程式碼的情況下，將不同介面的類別組合在一起工作。適配器模式通常包含以下重要的類別和功能：【目標介面（Target）】：Target 是客戶端所期望使用的介面。適配器將來源介面適配成目標介面，使得客戶端可以使用目標介面來呼叫適配後的類別。【適配器（Adapter）】：適配器是實作了目標介面的類別，同時持有來源介面的一個實例。適配器的主要功能是「將來源介面的方法轉換成目標介面的方法。」並將客戶端的請求轉送給來源物件。【來源介面（Adaptee）】：它是需要被適配的類別，因其介面與目標介面不相容。適配器透過將 Adaptee 轉換成 Target，使得來源類別能夠與客戶端一起工作。\n適配器模式的功能和解決的問題主要包括：【解決介面不相容的問題】：當需要使用某一存在的類別，但其類別中的介面與客戶端所期望的介面不匹配時，適配器模式可以將其介面轉換成客戶端期望的介面，使得原本不相容的類別能夠一起工作。【封裝適配的轉換邏輯】：適配器將適配邏輯封裝在一個單獨的類別中，使得客戶端無需了解特定的適配細節，只需要透過目標介面來與適配後的類別互動。【提高程式碼可重用性】：適配器模式可以使得已經存在的類別與新的系統能夠一起工作，從而提高程式碼的複用性和可維護性。【透明地整合新功能】：當需要在現有的系統中整合新的功能時，可以透過適配器模式來實現，而無需修改現有的程式碼，從而保證系統的穩定性和可擴展性。\n簡單整理 問題描述：如何在不更改原始程式碼的前提下，對於多個具有相似功能的類別和方法進行統一\n解決方案：透過「適配器」類別來調整、揉和不同程式的功能\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在網路已經普及化很久的現代中，資料的交換和儲存是電腦網路裡非常常見且非常核心的一環。為了確保資料在不同的載體下，資料的結構和內容能夠準確地傳輸和解釋，早期和現代的工程師們開發了各種這樣的資料傳輸格式，其中包括但不限於 JSON、XML、YAML 和 RSS\u0026hellip;等，如果我們把這些資料儲存的方式用 Java 語言來呈現的話，大概可以寫成類似下面這些程式碼的感覺：\nimport java.io.*; import java.util.HashMap; import java.util.Map; public class JsonCrud { private final String filePath; private final Map\u0026lt;String, String\u0026gt; jsonData; public JsonCrud(String filePath) { this.filePath = filePath; this.jsonData = readJsonFile(); } private Map\u0026lt;String, String\u0026gt; readJsonFile() { Map\u0026lt;String, String\u0026gt; data = new HashMap\u0026lt;\u0026gt;(); try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) { StringBuilder content = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { content.append(line); } // Assuming data is stored as key-value pairs in JSON format // You may need to implement a proper JSON parser based on your JSON structure // Here, I\u0026#39;m simply splitting the content by commas and assuming key-value pairs String[] pairs = content.toString().split(\u0026#34;,\u0026#34;); for (String pair : pairs) { String[] keyValue = pair.split(\u0026#34;:\u0026#34;); String key = keyValue[0].trim().replace(\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); String value = keyValue[1].trim().replace(\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); data.put(key, value); } } catch (IOException e) { e.printStackTrace(); } return data; } private void writeJsonFile() { try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) { StringBuilder jsonBuilder = new StringBuilder(); jsonBuilder.append(\u0026#34;{\u0026#34;); for (Map.Entry\u0026lt;String, String\u0026gt; entry : jsonData.entrySet()) { jsonBuilder.append(\u0026#34;\\\u0026#34;\u0026#34;).append(entry.getKey()).append(\u0026#34;\\\u0026#34;:\\\u0026#34;\u0026#34;).append(entry.getValue()).append(\u0026#34;\\\u0026#34;,\u0026#34;); } jsonBuilder.deleteCharAt(jsonBuilder.length() - 1); jsonBuilder.append(\u0026#34;}\u0026#34;); writer.write(jsonBuilder.toString()); } catch (IOException e) { e.printStackTrace(); } } public void addJsonValue(String key, String value) { jsonData.put(key, value); writeJsonFile(); } public String showJsonValue(String key) { return jsonData.get(key); } public void updateJsonValue(String key, String newValue) { jsonData.put(key, newValue); writeJsonFile(); } public void removeJsonValue(String key) { jsonData.remove(key); writeJsonFile(); } } import org.w3c.dom.*; import javax.xml.parsers.*; import javax.xml.transform.*; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import java.io.*; public class XmlCrud { private final String filePath; private Document document; public XmlCrud(String filePath) { this.filePath = filePath; this.document = readXmlFile(); } private Document readXmlFile() { try { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); return builder.parse(new File(filePath)); } catch (Exception e) { e.printStackTrace(); return null; } } public void writeXmlFile() { try { TransformerFactory transformerFactory = TransformerFactory.newInstance(); Transformer transformer = transformerFactory.newTransformer(); transformer.setOutputProperty(OutputKeys.INDENT, \u0026#34;yes\u0026#34;); transformer.setOutputProperty(\u0026#34;{http://xml.apache.org/xslt}indent-amount\u0026#34;, \u0026#34;2\u0026#34;); DOMSource source = new DOMSource(document); StreamResult result = new StreamResult(new File(filePath)); transformer.transform(source, result); } catch (Exception e) { e.printStackTrace(); } } public void addToXml(String tagName, String value) { Element root = document.getDocumentElement(); Element newElement = document.createElement(tagName); newElement.appendChild(document.createTextNode(value)); root.appendChild(newElement); } public void deleteFromXml(String tagName) { NodeList nodeList = document.getElementsByTagName(tagName); if (nodeList.getLength() \u0026gt; 0) { Node nodeToRemove = nodeList.item(0); nodeToRemove.getParentNode().removeChild(nodeToRemove); } } public String getValueFromXml(String tagName) { NodeList nodeList = document.getElementsByTagName(tagName); if (nodeList.getLength() \u0026gt; 0) { return nodeList.item(0).getTextContent(); } else { return null; } } } import java.io.*; import java.util.ArrayList; import java.util.List; public class YamlCrud { private final String filePath; private List\u0026lt;String\u0026gt; lines; public YamlCrud(String filePath) { this.filePath = filePath; this.lines = inputYamlFile(); } private List\u0026lt;String\u0026gt; inputYamlFile() { List\u0026lt;String\u0026gt; content = new ArrayList\u0026lt;\u0026gt;(); try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) { String line; while ((line = reader.readLine()) != null) { content.add(line); } } catch (IOException e) { e.printStackTrace(); } return content; } public void writeYamlFile() { try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) { for (String line : lines) { writer.write(line); writer.newLine(); } } catch (IOException e) { e.printStackTrace(); } } public void appendToYaml(String key, String value) { lines.add(key + \u0026#34;: \u0026#34; + value); } public void deleteFromYaml(String key) { for (int i = 0; i \u0026lt; lines.size(); i++) { String line = lines.get(i); if (line.startsWith(key + \u0026#34;: \u0026#34;)) { lines.remove(i); break; } } } public String getValueFromYaml(String key) { for (String line : lines) { if (line.startsWith(key + \u0026#34;: \u0026#34;)) { return line.substring(key.length() + 2).trim(); } } return null; } } public class RssCrud { private final String filePath; private String rssContent; public RssCrud(String filePath) { this.filePath = filePath; this.rssContent = readRssFile(); } private String readRssFile() { StringBuilder content = new StringBuilder(); try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) { String line; while ((line = reader.readLine()) != null) { content.append(line).append(System.lineSeparator()); } } catch (IOException e) { e.printStackTrace(); } return content.toString(); } public void writeRssFile() { try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) { writer.write(rssContent); } catch (IOException e) { e.printStackTrace(); } } public void addToRss(String newElement) { StringBuilder updatedContent = new StringBuilder(rssContent); updatedContent.append(newElement).append(System.lineSeparator()); rssContent = updatedContent.toString(); writeRssFile(); } public void deleteFromRss(String elementToRemove) { StringBuilder updatedContent = new StringBuilder(); String[] lines = rssContent.split(System.lineSeparator()); for (String line : lines) { if (!line.contains(elementToRemove)) { updatedContent.append(line).append(System.lineSeparator()); } } rssContent = updatedContent.toString(); writeRssFile(); } public String getValueFromRss(String element) { String[] lines = rssContent.split(System.lineSeparator()); for (String line : lines) { if (line.contains(element)) { return line; } } return null; } } 不難發現到：不同的類別除了有不同的方法名稱之外，各自對於資料的操作、儲存方式也大相徑庭。因此如果只是單純利用上述 4 種不同的 Java class 直接進行不同格式的檔案操作的話，不難想像這會是一個很麻煩的工程 \u0026hellip;。因此一種比較好的做法是「讓所有的類別都統一」無論是方法名稱，還是方法中的參數數量、資料型態，如果能夠先將不同的地方給劃整齊，那麼在後續的操作上就能方便許多了。\ninterface CrudInterface { public void create(String key, String value); public void read(String key); public void update(String key, String newValue); public void delete(String key); } 只不過，在某些的情況下，直接修改這些類別中的原始程式碼可能不是一個可行的辦法。公司規定該程式碼不可進行修改、程式僅過第三方利用 API 或其他形式秀出接口，而非給予原始碼編輯（甚至是閱覽）的權限、類別已經存在已久，有大量的其他專案依賴著該類別，牽一髮而動全身可能會更加麻煩 \u0026hellip;等。諸如此類的限制和困難很常在現實的情境下遇到。因此，「如何在不更改原始程式碼的前提下，對於多個具有相似功能的類別和方法進行統一」即是適配器模式（Adapter pattern）存在的理由與意義。適配器模式可以充當現實中「轉接頭」的功用，將某些類別的方法轉換成另一種不同的表現方式，就拿上面的 JSON 來做舉例：我們可以設計一個 JsonAdapter 類別，用來轉換該類別中的所有方法：\npublic class JsonAdapter implements CrudInterface { private JsonCrud jsonCrud; public JsonAdapter(JsonCrud jsonCrud) { this.jsonCrud = jsonCrud; } @Override public void create(String key, String value) { jsonCrud.addJsonValue(key, value); } @Override public void read(String key) { jsonCrud.showJsonValue(key); } @Override public void update(String key, String newValue) { jsonCrud.updateJsonValue(key, newValue); } @Override public void delete(String key) { jsonCrud.removeJsonValue(key); } } 透過實作了 CrudInterface 介面的 JsonAdapter 類別，我們現在就可以使用 CrudInterface 中的共同方法對 Json 檔案進行 CRUD 的操作了。同樣的步驟也可以利用在 XML, YAML, 和 RSS 的類別上：分別建立關於這 3 種檔案格式的 Adapter，來讓所有的方法名稱進行統一，再透過統一的方法名稱進行資料的傳輸或轉換，無論在程式的複雜的上、還是可讀性上，都可以找到立竿見影的功效：\npublic class Client { public static void main(String[] args) { JsonCrud jsonCrud = new JsonCrud(\u0026#34;data.json\u0026#34;); CrudInterface jsonAdapter = new JsonAdapter(jsonCrud); XmlCrud xmlCrud = new XmlCrud(\u0026#34;data.xml\u0026#34;); CrudInterface xmlAdapter = new XmlAdapter(xmlCrud); YamlCrud yamlCrud = new YamlCrud(\u0026#34;data.yaml\u0026#34;); CrudInterface yamlAdapter = new YamlAdapter(yamlCrud); RssCrud rssCrud = new RssCrud(\u0026#34;data.rss\u0026#34;); CrudInterface rssAdapter = new RssAdapter(rssCrud); System.out.println(\u0026#34;Performing CRUD operations on JSON file:\u0026#34;); jsonAdapter.create(\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;); jsonAdapter.read(\u0026#34;name\u0026#34;); jsonAdapter.update(\u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;); jsonAdapter.read(\u0026#34;name\u0026#34;); jsonAdapter.delete(\u0026#34;name\u0026#34;); System.out.println(); System.out.println(\u0026#34;Performing CRUD operations on XML file:\u0026#34;); xmlAdapter.create(\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;); xmlAdapter.read(\u0026#34;name\u0026#34;); xmlAdapter.update(\u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;); xmlAdapter.read(\u0026#34;name\u0026#34;); xmlAdapter.delete(\u0026#34;name\u0026#34;); System.out.println(); System.out.println(\u0026#34;Performing CRUD operations on YAML file:\u0026#34;); yamlAdapter.create(\u0026#34;name\u0026#34;, \u0026#34;John\u0026#34;); yamlAdapter.read(\u0026#34;name\u0026#34;); yamlAdapter.update(\u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;); yamlAdapter.read(\u0026#34;name\u0026#34;); yamlAdapter.delete(\u0026#34;name\u0026#34;); System.out.println(); System.out.println(\u0026#34;Performing CRUD operations on RSS file:\u0026#34;); rssAdapter.create(\u0026#34;\u0026lt;item\u0026gt;\u0026lt;title\u0026gt;New Item\u0026lt;/title\u0026gt;\u0026lt;link\u0026gt;http://example.com/new-item\u0026lt;/link\u0026gt;\u0026lt;/item\u0026gt;\u0026#34;); rssAdapter.read(\u0026#34;\u0026lt;title\u0026gt;New Item\u0026lt;/title\u0026gt;\u0026#34;); rssAdapter.delete(\u0026#34;\u0026lt;item\u0026gt;\u0026lt;title\u0026gt;New Item\u0026lt;/title\u0026gt;\u0026lt;link\u0026gt;http://example.com/new-item\u0026lt;/link\u0026gt;\u0026lt;/item\u0026gt;\u0026#34;); rssAdapter.read(\u0026#34;\u0026lt;title\u0026gt;New Item\u0026lt;/title\u0026gt;\u0026#34;); System.out.println(); } } "},{"id":178,"href":"/_trash/design_pattern/liskov_substitution_principle/","title":"里氏替換原則","section":"_Trashes","content":"\r里氏替換原則\r#\rChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。\nLSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。\n這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。\n簡單整理 簡單來說：父類別沒有的，子別類不一定要有，但是父類別有的，子類別都一定要有\n程式碼範例 里氏替換原則討論的是關於類別（或介面）發生繼承時，應該遵守或者是留意一個規範或想法。大致上的重點在於「子類別應該完全實現父類別的想法」「子類別可以對付類別的想法作出補充」以及「子類別應該遵循與父類別一致的規則」這句話上面。簡單來說就是「父類別的擁有和要求，子類別都要做到」但「父類別沒有要求的，子類別可以不用做到」這兩句話上。\n自己稍微唸了一下，感覺還是有點饒口，直接用一個範例程式碼來做舉例好了：假設我們現在受到了某某大型運輸公司的委託，需要製作一個該公司的「交通工具查閱系統」，裡面需要包含一些常見的交通工具的相關資訊，像是汽車、船、機車、公車、腳踏車、直升機、飛機 \u0026hellip;等，在最最直觀的情況下，我們可以把所有的交通工具都寫成互不相關的獨立類別，就像是下面的這個樣子：\nclass Car { String id; String type; public void driving() { System.out.println(\u0026#34;在馬路上行駛\u0026#34;); } // 其他跟[汽車]有關的方法 // 其他跟[汽車]有關的方法 } class Boat { String id; String type; public void sailing() { System.out.println(\u0026#34;在河道或海中航行\u0026#34;); } // 其他跟[船]有關的方法 // 其他跟[船]有關的方法 } \u0026hellip;（還有其他好多類型的交通工具）\nclass Helicopter { String id; String type; public void flight() { System.out.println(\u0026#34;在天空中飛行\u0026#34;); } // 其他跟[直升機]有關的方法 // 其他跟[直升機]有關的方法 } 但因為不同的交通工具之間，多少還是會有類似的一些屬性或方法，像是大家都有 id, type，陸上交通工具都有 driving() 方法、船型工具都可以 sailing()、飛機跟直升機都可以flight() \u0026hellip;等，因此，一個更好的寫法可能是「把相同的部份提出來，作為一個共用的父類別，以提高程式的重用性，並減少程式的冗余。」就像是下面的這個樣子：先定義一個共同的 Vehicle 類別，然後把所有的變數和方法進行統一的定義跟宣告，再讓其餘的類別（Car, Boat \u0026hellip;等）進行實例化。\nabstract class Vehicle { protected String id; protected String type; public abstract void driving(); public abstract void sailing(); public abstract void flight(); } class Car extends Vehicle { // 實作關於 Vehicle 類別中的方法 }; class Boat extends Vehicle { // 實作關於 Vehicle 類別中的方法 }; // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... class Helicopter { // 實作關於 Vehicle 類別中的方法 }; 不過，這樣改寫的話，一個可能的問題就出現了：我們都知道，Car 這個類別就是一個單純的汽車，它的運輸方式就是普通的「在路上跑」，並不會什麼在海上跑啊、在天上飛啊 \u0026hellip;這類的方法。但因為我們在父類別 Vehicle 裡定義了 sailing() 和 flight() 的方法，理論上來說，我們還是得實利化這一些父類別所定義的抽象方法，所以就有可能會寫出像這樣的程式來：\nclass Car extends Vehicle { // 建構子，用於設定型號及車牌 public Car(String type, String id) { this.type = type; this.id = id; } // 改寫「在路上跑」的方法 @Override public void driving() { System.out.println(\u0026#34;車子利用 4 個輪子在道路上行駛\u0026#34;); }; // 雖然不會用到，但還是得進行改寫的其餘方法 @Override public void sailing() {}; @Override public void flight() {}; }; // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... 同樣的狀況，也會發生在所有無法陸海空三棲的交通工具上。\n所以，如果利用這種方式對原本的系統進行改寫的話，雖然不會產生邏輯上的問題（畢竟車子真的就不會在天上飛，所以車子的 flight() 就什麼都不寫），但這樣的寫法就不遵循里氏替換原則了。因為「子類別 Car 沒有辦法完整的實現父類別 Vehicle 所定義的所有方法。」比較好的改善方式有兩種：第一種是把所有的交通工具運行方式統一定義成像是 move() 這類的方法，再透過各子類進行更加細節的描述：\n// 父類別 Vehicle 用以涵蓋所有交通工具 abstract class Vehicle { protected String id; protected String type; // 抽象方法 move() 用來表示「交通工具都可以『行進』」 public abstract void move(); } // 子類別 Car 用來實現一種「真正的交通工具」 class Car extends Vehicle { // 建構子 public Car(String type, String id) { this.type = type; this.id = id; } // 改寫『行進』這個方法，並作更細節的描述 @Override public void move() { System.out.println(\u0026#34;車子利用 4 個輪子在道路上行駛\u0026#34;); }; }; // 子類別 Airplane 用來實現一種「真正的交通工具」 class Airplane extends Vehicle { // 建構子 public Airplane(String type, String id) { this.type = type; this.id = id; } // 改寫『行進』這個方法，並作更細節的描述 @Override public void move() { System.out.println(\u0026#34;飛機利用機翼在天空中飛行\u0026#34;); }; }; // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... 另一種更加符合「里氏替換原則」的思考模式的改寫方式，則是利用更加細緻的不同類別，來分別對不同的交通工具進行擴充：像是原本只有一個 Vehicle 類別作為父類，其餘子類別則直接實現 Vehicle 類別。現在我們可以修改成「有一個最高類別 Vehicle，中間有三個子類『陸上交通工具』『海上交通工具』和『空中交通工具 』，最最下面才有 Car, Airplane \u0026hellip;等不同的類別」，就像是下面這樣：\n// 父類別 Vehicle，現在只定義了「型號」與「車牌」 abstract class Vehicle { protected String id; protected String type; } // 陸上交通工具，包含了 Vehicle 與『陸上』專有的一些行為 abstract class LandVehicle extends Vehicle { public abstract void driving(); } // 海上交通工具，包含了 Vehicle 與『海上』專有的一些行為 abstract class Watercraft extends Vehicle { public abstract void sailing(); } // 空中交通工具，包含了 Vehicle 與『天上』專有的一些行為 abstract class Aircraft extends Vehicle { public abstract void flight(); } // 實體的交通工具 Car class Car extends LandVehicle { public Car(String type, String id) { this.type = type; this.id = id; } // 因為只繼承『陸上』交通工具 // 因此 Car 不具有海上和天上的行為 @Override public void driving() { System.out.println(\u0026#34;車子利用 4 個輪子在道路上行駛\u0026#34;); }; } // 實體的交通工具 Boat class Boat extends Watercraft { public Boat(String type, String id) { this.type = type; this.id = id; } // 因為只繼承『海上』交通工具 // 因此 Car 不具有陸上與空中的行為 @Override public void sailing() { System.out.println(\u0026#34;船可以在河道或海上航行\u0026#34;); }; } // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... 這樣一來，就保證了子類別會保留（和實現）父類別的所有行為，也就達成了里氏替換原則所想要傳達的訊息。\n值得一提的是：因為 Java 語言不允許多重繼承（也就是同時繼承 1 個以上的類別），所以在這樣的情況下，如果出現了一個「水路兩棲車」的類別，它就沒辦法同時繼承 LandVehicle 和 Watercraft。一個比較好的調整方式是把所有的父類調整成介面（Interface）的形式，再讓多棲的交通工具進行多種介面的實例化，像是下面這個樣子：\n// 父類別 Vehicle，只定義一些相關的成員變數 abstract class Vehicle { protected String id; protected String type; } // 陸上交通工具，宣告陸上的專有行為 abstract interface LandVehicle { public abstract void driving(); } // 海上交通工具，宣告海上的專有行為 abstract class Watercraft { public abstract void sailing(); } // 空中交通工具，宣告天上的專有行為 abstract class Aircraft { public abstract void flight(); } class SuperVehicle implements LandVehicle, Watercraft, Aircraft { public SuperVehicle(String id, String type) { this.id = id; this.type = type; } @Override public void driving() { System.out.println(\u0026#34;超級交通工具可以在『路上』行駛\u0026#34;); } @Override public void sailing() { System.out.println(\u0026#34;超級交通工具可以在『海上』航行\u0026#34;); } @Override public void flight() { System.out.println(\u0026#34;超級交通工具可以在『空中』飛行\u0026#34;); } } 同樣也可以完成里氏替換原則的規範。\n"},{"id":179,"href":"/docs/computer_science/design_pattern/liskov_substitution_principle/","title":"里氏替換原則","section":"設計模式","content":"\r里氏替換原則\r#\rChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。\nLSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。\n這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。\n簡單整理 父類別的方法，如果換成子類別來做，應該要得出一樣的結果\n程式碼範例 在所有的設計原則中，里氏替換原則應該是最難懂的（至少在我自己理解的過程中 XD），作為設計原則中的其中一項原則，里氏替換原則所討論，是關於類別與類別間的繼承（inherit）和改寫（override）的問題。里氏替換原則的核心，就是在確保簡單整理中的那句話：「父類別的方法，如果換成子類別來做，應該要得出一樣的結果。」也就是說，如果在一個程式裡面我們看到了 Parent.method(arg) 這樣的語句。里氏替換原則要求的，就是希望如果我們寫成 Child.method(arg) 時，程式同樣也可以呈現出原本的結果，不應該換了一個子類別執行，程式的結果就發生改變。\n更仔細一點的說，雖然我們在學習的過程中，被告知了「『繼承』即是包含了 is-a 的概念的兩個類別」，但該原則告訴了我們：嚴格一點來說，我們並不能夠單純地因為 A is-a B，就讓 A 跟 B 使用繼承（像是正方形 is-a 矩形，企鵝 is-a 鳥類 \u0026hellip;等），在使用繼承的時候，應該要更加嚴謹，更加小心。里氏替換原則包含以下幾個想法：子類別的參數數量和順序應該與父類別完全相同、子類別的前置條件不應該比父類別嚴格、子類別的後續條件不應該比父類別寬鬆、以及在父類別中沒有被改變的參數，子類別也應該對其保持不變。\n我們用一個簡單的例子，快速了解這之中的差別：在數學的定義上，我們可以知道「矩形」是四個角都是直角的四邊形，「正方形」是四個角都是直角、且四個邊都有相同長度的四邊形。因此，在數學的分類上，我們可以說「正方形是一種矩形」也就是「Sruare is a Rectangle」，那在程式上，我們同樣也能說出「Sruare is a Rectangle」嗎？讓我們用程式來觀察觀察，我們先假設正方形是長方形的一種：\n// 長方形 class Rectangle { protected int width; protected int height; // 建構子 public Rectangle() {} // 長方形的 setter (getter 就先省略了) public void setWidth(int width) { this.width = width; } public void setHeight(int height) { this.height = height; } // 長方形中的一些方法（以面積為例子） public int getArea() { return width * height; } } class Square extends Rectangle { // 建構子 public Square() {} // 描述一下正方形裡更嚴格的定義 ... // 改寫一下原來的方法 // 設定「寬」就等於設定「高」 @Override public void setWidth(int width) { this.width = width; this.height = width; } // 改寫一下原來的方法 // 設定「高」就等於設定「寬」 @Override public void setHeight(int height) { this.width = height; this.height = height; } // 方法 \u0026#39;getArea()\u0026#39; 可以不用改，畢竟也是長 x 寬沒錯 // public int getArea() { // return width * height; // } } 看起來沒什麼問題？我們試著執行一次：\nclass Test { public static void main(String[] args) { Rectangle rectangle = new Rectangle(); rectangle.setHeight(3); rectangle.setWidth(7); System.out.println(\u0026#34;area: \u0026#34; + rectangle.getArea()); Square square = new Square(); square.setHeight(5); System.out.println(\u0026#34;area: \u0026#34; + square.getArea()); } } area: 21 area: 25 結果也很符合預期，那麼應該就沒有什麼問題了吧？的確，如果單純從「程式本身的執行邏輯」還有「繼承的特性」去做切入的話，這支程式無論是在設定還是在執行上面，都沒有什麼需要挑惕的地方，但重點就在於「它在某些情況下『人的預期』和『實際的程式』會不一樣」，什麼意思呢？意思是如果我們之後寫了一組「設定/測試矩形的相關係數」的程式，人的預期和實際的程式就會產生誤差，就像是下面的這個樣子：\n// 測試程式 class Test { public static void main(String args[]) { Test obj = new Test(); obj.testRectangle(new Rectangle()); obj.testRectangle(new Square()); } public void testRectangle(Rectangle rectangle) { System.out.println(\u0026#34;測試類別 \u0026#34; + rectangle.getClass()); rectangle.setHeight(7); rectangle.setWidth(13); if(rectangle.getArea() != 91) { String message = r.getClass() + \u0026#34;area != 91\u0026#34;; throw new AreaCalculationException(message); } } } 測試類別 class Rectangle 測試類別 class Square Exception in thread \u0026#34;main\u0026#34; AreaCalculationException: class Squarearea != 91 at Test.testRectangle(Test.java:71) at Test.main(Test.java:57) 到這邊為止，可能有一部分的人會有「這\u0026hellip;好啦它是有一點問題沒錯，但不就只是一個 Square 或者是一個 Rectangle 的面積嗎？事情是能夠嚴重到哪裡去？」的想法，那讓我們再舉一個比較實際一點的例子：我們假設現在在做一個公司的登入系統，預設密碼不能為空的，然後我們想要讓不同的人（ex. 員工、經理、老闆、客戶 \u0026hellip;等）有各自的類別，於是工程師寫成了以下的樣子：\n// 類別 [系統] class LogInSystem { // 負責登入的主要函數 \u0026#39;logIn()\u0026#39; public boolean logIn(String account, String password) { // pseudo code 用來假設一個獲取資料的情境 Database database = Database.getDatabase(\u0026#34;company_members\u0026#34;); // 假設 table 會回傳像是 \u0026#34;老闆\u0026#34; \u0026#34;經理\u0026#34; \u0026#34;員工\u0026#34; \u0026#34;客戶\u0026#34;... 等不同種類的資料表 // 這邊同樣假設了不同表之間的帳號不會重複 // 所以 \u0026#39;getTable()\u0026#39; 可以依照帳號去判斷要回傳哪個表格 Table table = database.getTable(\u0026#34;position\u0026#34;, account); // 回傳登入的結果，但 \u0026#39;要怎麼判斷能不能登入\u0026#39; 則依照表格自己的方法決定 return table.loginTest(account, password); } } // 抽象類別 [資料表] abstract class Table { // 資料表名稱 protected String name; // 驗證登入的方法 boolean loginTest(String account, String password) { // 密碼想當然不可以是空的 if(password.equals(\u0026#34;\u0026#34;)) { return false; } // 拿到 account 對應的 password String sql = \u0026#34;SELECT `password` from \u0026#34; + name + \u0026#34; where `account` = \u0026#34; account; // 檢查密碼是否一致 String result = Table.getResult(sql); // 回傳結果 return (password == result); } } 現在，公司聘用了好幾個工程師，分別負責不同資料表的登入功能（也許員工登入之前，需要主管給予權限？也許客戶在登入的時候，只允許某些時段 \u0026hellip;等），然後，負責 BossTable 的工程師其實是老闆的兒子，他爸爸跟他說「我就不設密碼了，反正看到是我的帳號，就直接讓我登入就好」所以 BossTable 的程式就變成了類似下面的樣子：\nclass BossTable extends Table { @Override public boolean loginTest(String account, String password) { return true; } } 然後 Boss 的資料表實際上長這個樣子\n+-------+--------+ |account|password| +-------+--------+ | boss| NULL| +-------+--------+ 到這裡為止，如果單看程式邏輯的話，一切都還在很合理的範疇，但接下來問題出現了：公司在原來執行「撤銷離職員工的帳密」的操作的時候，因為一些原因，他們決定「撤銷」這個動作，並不是直接把員工資料刪掉，而是直接把離職員工的密碼刷成 NULL。然後再在 table.loginTest() 裡面寫上一個「如果密碼是 NULL，則直接回傳登入失敗」的語句（畢竟在正常情況下，沒有會把密碼設成 NULL，而且 Table 原本的判斷也防止了有人想要把密碼設成 NULL 的狀況）。\n然後又過了 3-5 年，負責資料庫的主管發現「誒？最近離職員工的資料好像越來越佔空間了欸」所以他就在主管開會的時候，提議了「把離職員工的資料從資料庫中清除」的提案，想當然提案毫無阻礙地通過了。所以他就跟下面的工程師說「幫我寫個程式，檢查一下所有的表格，把離職的員工資料都刪一刪。」然後，因為該員工很直覺的理解成「哦？離職員工，密碼是 NULL 的那些嘛～」，所以 \u0026hellip;沒錯 \u0026hellip;你們想像中的事情就發生了 \u0026hellip;，\nclass Database { // 上面有一些 `getDatabase`, `getTable()` 之類的方法 // 上面有一些 `getDatabase`, `getTable()` 之類的方法 // 上面有一些 `getDatabase`, `getTable()` 之類的方法 public static void deleteDepartedEmployeeData() { // 取出所有資料表 List\u0026lt;Table\u0026gt; tables = Database.getAllTables(); // 對所有的資料表逐一進行操作 for(Table table: tables) { // 取出資料表內所有的帳號和密碼 List\u0026lt;Data\u0026gt; data = table.getAllData(\u0026#34;account\u0026#34;, \u0026#34;password\u0026#34;); // 逐一檢查資料表內的內容 for(Data row_data: data) { // 判斷資料中的密碼欄位是否為 \u0026#39;NULL\u0026#39; if(row_data.get(\u0026#34;password\u0026#34;).isNull()) { // 刪除資料 String account = row_data.get(\u0026#34;account\u0026#34;); String sql = \u0026#34;delete from \u0026#34; + table.name + \u0026#34; where `account` = \u0026#34; account; table.update(sql); } } } } } 嗯\u0026hellip; 或許接下來我們就可以探討「老闆在發現自己的資料都消失後，會有怎樣的反應」以及「誰該負責這件事情」的問題，但在那之前，我們或許可以從程式上的角度上來思考，為什麼這樣的問題會發生？這跟最一開始的長方形、正方形又有什麼關係？可能有些人覺得沒有關係，可能有些人會有自己的解釋或說法，不過在這邊呢，畢竟文章還是跟設計原則有關，所以我會給出的答案是：「它們都沒有達成『父類別的方法，如果換成子類別來做，應該要得出一樣的結果』。」也就是「它們都沒有遵守『里氏替換原則』」。\n說得仔細一點，矩形的案例犯的錯是「明明 Rectangle 的 setWidth() 和 setHeight() 都只有對特定變數行操作，但在 Square() 裡面，無論是 setWidth() 還是 setHeight() 都還有對其他變數進行操作。」而老闆密碼的案例則是「明明 Table 都已經先說了『密碼不可以是 NULL』，但是在 BossTable 那邊卻還是讓 NULL 通過。」\n那麼，如果要系統化一點的說，既然我們知道了他們的錯是「沒有遵守『父類別的方法，如果 \u0026hellip; 的結果』」，那怎麼樣寫才能避免這種事情呢？畢竟在正常思考下，「正方形 is a 長方形」跟「老闆説他不要設密碼，我們就放 NULL 在密碼裡面」都是很人性化也很直覺的邏輯。也因此，里氏替換原則為了讓我們能快速搞懂哪些東西是「乍看之下很有邏輯，實際上在程式裡面會出問題」的寫法，它列舉了好幾項大注意事項。\n而簡單來說，我們只要遵循以下的幾個條件，就可以確保我們的程式能遵守里氏替換原則了，它們分別是「參數的數量跟順序要保持一致」「子類別的輸入，不能減去原本可以的選擇」「子類別的輸出，不能多出原本沒有的選擇」以及「父類別在方法中沒有修改的變數，子類別也不要修改。」聽起來可能有點饒口？直接用一個例子來做說明可能會更好一點，下面我們用一個簡單的計算機父類別（Calculator）來做舉例：\nabstract class Calculator { // 自定義的數字類別 protected RationalNumber add(NaturalNumber x, PrimeNumber y) { if(x \u0026gt; 100 || y \u0026gt; 100) { throw new NumberOverflowException(); } RationalNumber result = x + y; return result; } } 參數的數量跟順序要保持一致 這個沒什麼好說的，很直觀、很好懂。數量要相同、順序不能換。\n子類別的輸入，不能減去原本可以的選擇 用字面上的例子理解：在 Calculator.add() 中，參數可以進到程式主體的條件有三個：分別是 x 為自然數、 y 為質數、以及 x, y 都要小於等於 100。所以如果有一個Calculator 的子類別想要改寫 add() 方法，那這個 add() 的輸入，就不可以少掉原本的這些，像是設定 x 成奇數（讓原本的偶數不見了）、設定 y 成孿生質數（讓原本的非孿生質數不見了）、或者是限制 x,y 都得小於等於 70（讓原本 70-100 的選擇不見了）\u0026hellip;等。\n子類別的輸出，不能多出原本沒有的選擇 理解 2 之後，3 應該就會比較好懂了：輸出選擇一般指的是回傳，或執行回傳的條件。在 Calculator.add() 中，該方法實際上有兩個回傳：分別是比較直觀的 return result 以及例外處理中的 Exception。先從一般的 return 來看，result 的回傳是一個有理數（RationalNumber），所以在想要改寫 add() 的子類別中，我們可以輸出的東西，最多最多就是原定的那些有理數的範圍，因此像無理數、實數、複數\u0026hellip;等，就不可以拿來被回傳。\n但是輸出的選擇可以維持原樣（或者變得更少），所以回傳有理數、整數、自然數、或質數 \u0026hellip;等都是可以的。此外 Exception 的情況是「只要 x 或 y 大於 100，就輸出例外」，因此如果子類別想要改寫這個條件的話，就至少要維持 if 內的判斷可以包含所有 100 以上的數字（因此 x \u0026gt; 101 之類的就不允許）。此外，這一點也是老闆密碼案例裡違反的項目：父類別中並不允許遇到 NULL 可以回傳 true，但這句話 BossTable 那邊被修改了。\n父類別在有修改的變數，子類別也不要修改 這個「變數」指的是父類別和子類別共同擁有的變數，像是在 Rectangle 和 Square 中共有的 width, height \u0026hellip;等。在父類別中，如果我們沒在方法裡對參數進行修改，那麼在子類別的改寫方法中，就不可以對那些沒動的參數進行修改。而這也是矩形案例裡違反原則的原因：在 Rectenglr.setWidth() 中，我們只有對 width 這個變數進行修改，沒有對 height 做操作，但 Square.setWidth() 就犯規了。\n因此，如果我們想要寫出一的類別，讓它繼承 Calculator，並改寫 add() 方法，就可以寫成：\n// 繼承了 [計算機] 類別的 [子計算機] class SubCalculator extends Calculator { @Override public PosisiveInteger add(NaturalNumber x, PositiveNumber y) { if(x \u0026gt; 100 || y \u0026gt; 100) { throw new NumberOverflowException(); } PosisiveInteger result = x + y; return result; } } 稍微檢查一下：［參數的數量跟順序要保持一致］沒什麼問題，都是 2 個參數、都是數字類型。［子類別的輸入，不能減去原本可以的選擇］沒有問題，x 維持在自然數沒有調整，而 y 從質數變成了任何大於 0 的正數，也沒有變少（反而還變多！）。［子類別的輸出，不能多出原本沒有的選擇］同樣成立～原本輸出的類型是任意實數，現在我們把它變成了正整數，雖然減去了一些，但正整數原本就有包含在實數裡面。［父類別在有修改的變數，子類別也不要修改］兩個類別都沒有修改變數，自然就沒有違反囉。\n"},{"id":180,"href":"/_trash/creation/novel/practice/giant_rat/","title":"鑿城鼠","section":"作品練習","content":"\r作品練習：鑿城鼠\r#\r滴答…滴答…滴答…\n水滴沉沉地敲擊由石塊所構築成的狹小走道，聲音在整個空間裡迴盪起來。\n滴答…滴答…滴答…\n邁著小心翼翼的步伐，少年全神貫注地警惕四周的動靜，不敢放過身旁的任何一絲細節。\n滴答…滴答…滴答…\n高舉著手中的火炬，上頭的微弱火光，是這裡唯一的弱小光源。\n「鑿城鼠有囤積閃亮東西的習慣，從它們的巢穴裡，有時候可以找到一些不錯的東西。」少年默默地在心中念起方才無意所聽到的對話，火炬的亮光照出了前方一分為二的岔路。\n「不錯的東西？」\n「大部分是一些光滑的石頭，或者是旅人在行徑森林之後所遺留下來的物品，像是衣袖、紋章、或者是一些碎飾。偶爾也能找到像是金幣、短刀、甚至是水晶這類的值錢玩意兒。」經歷了一番抉擇之後，他選擇向右邊的道路前進。\n少年名叫格雷瑪，是名居住在福洛斯村的 14 歲青年。該村落以領主赫拉爾·杰弗里斯的三子福洛斯·杰弗里斯為名，佔地約 130 公頃。是赫拉爾預計在福洛斯成年時分封給他的一塊領地。\n因為福洛斯村的東邊緊鄰著坎澤爾森林的緣故，村落的居民大部分以林業和木類加工業為主，此外，由於森林的魔力有時候也會讓住在森林裡的動物變得暴躁、強悍、甚至是襲擊村落的設施，這裡時不時也會聚集一些透過委託或者是請求而從外地來的冒險者們，討伐那些變異的魔物。\n「這麼說，只要能到牠們的洞穴裡瞧瞧，說不定就能找到什麼好東西囉？」\n「你也可以這麼理解。但在大多時候，直接闖入可不是什麼好決定。」格雷瑪又向巢穴的深處探了幾步。愈發潮濕的環境，以及泥濘中混雜的腐敗氣味令他的鼻腔感到逐漸不適。\n「為什麼？」\n「除了地域性、攻擊性極強之外，作為被森林影響的一種魔物，鑿城鼠的聽覺、嗅覺、和移動能力也有著顯著的提升，它那龐大的體型、強而有力的門牙、和銳利的爪子更是許多初來乍到的冒險者的一大剋星。這也是為什麼它會被命名為『鑿城鼠』的一大原因。」\n「因此，相對於直接闖入，我們會利用熏煙的方式，在巢穴的門口鋪設少量的干草、將之點燃。因為老鼠的靈敏嗅覺，鑿城鼠在聞到燃燒的氣味之後，便會傾巢而出。通常我們才會趁著那個時候，走進牠們的洞穴一探究竟。」或許是適應了巢穴內的黑暗，也或許是愈發加深的恐懼感，少年的步伐開始由緩轉急。眼前出現的第二個岔口，更是想都沒想的往左前進。\n「但從鼠群竄出，到它們返回巢穴的時間間隔大概只有 15 分鐘，如果鼠群回到巢穴之後你還在裡面的話，結果就不用我多加說明了吧。」\n「嗚姆……」\n「因此，除非隊伍有配置天屬性的小隊成員，否則我們一般會以『三個岔路』作為計時單位，如果走了三個岔路，仍然沒有找到什麼值錢的東西的話，在遇到第四個岔路的時候，我們就會原地往返。」繞過腳邊的遺骸小骨，想到這裡的同時，格雷瑪的眼前出現了第三個岔路路口。 ——還是選擇左邊⋯⋯嗎？\n像是在尋求神明回答似的，格雷瑪在在岔路的路口停了下來，但緊接著，「在想什麼東西啊」和「得抓緊時間才行呢」等接二連三的念頭，促使著他向左邊的道路前進。\n「所以，可以理解成『在不以討伐為前提的條件下，煙熏過後 15 分鐘內的鼠巢是個好入侵的空白時段』是嗎？」微弱的火光在照耀前方道路的同時，也稍微反射了一些向前行進的光線。這意味著前方的地面上有著什麼閃亮的東西。\n——是錢幣！\n格雷瑪再次地加快腳步上前查看。\n——沒錯！是錢幣，看這個的數量⋯⋯大概有個 2-3 銀幣左右的價格。\n「在大部分的情況下是可以這麼理解的。」\n「大部分？」\n『『⋯⋯吱⋯吱吱』』\n——！ ！ ！ ！ ！ ！ ！ ！ ！ ！ ！ ！ ！ ！\n少年瞪大了雙孔並屏住呼吸。此刻，越發急促的心跳聲是他希望在腦海裡能夠聽得到的唯一聲音。\n『『⋯⋯吱⋯吱吱』』\n試探性的將火把微微向前，光緣的尾端逐漸照映出了一雙沾滿泥濘的巨大爪子。\n「在煙熏的情況下，鼠穴只有一種可能還會留有老鼠，那就是如果巢穴裡有無法行動的幼鼠的時候，母鼠會抱持著保護孩子的心情也待在巢穴裡頭。在那個時候，那種老鼠的危險性應該可以從 C級一下子提升到 B或 B- 吧？但這情況幾乎是微乎其微就是了。」\n「那⋯⋯如果在那個很小很小的機率上，真的碰著了該怎麼辦呢？」\n——吶⋯⋯當然是選擇趕快逃跑或者是死在它的爪下囉。\n「出於保護幼鼠心態，巢穴內的母鼠在遇到敵人之後，並不會立刻發起攻擊，反而會先以一種低頻的聲音發出警戒，並死死地盯著擅自闖入巢穴的外來者。」少年正努力地回想方才所聽到的字句。\n『唧………』鑿城鼠的低沉怒吼，伴隨著火炬的噼咔噪響，迴盪在巢穴中的每個角落。狹小空間的悶熱空氣，更是將原本劍拔弩張的氛圍帶到了一個更加上方的高度。僵滯，或許已經是此時此刻能採取的一種最好方法。\n「那接下來該怎麼辦阿？」\n「如果沒有信心打敗牠的話，那就不要跟牠有眼神上的接觸。畢竟對方可是等級 B 的魔物。對牠們來說，從『眼神』和『敵我氛圍』來判斷彼此之間的戰力並不是什麼太難的事。也因此，換句話說…」\n——死死的盯著地面就好。\n或許是出自於本能的反應？也或許是早已把忠告牢記在心。格雷瑪在得知母鼠的存在之後，就一直單純且純粹地望著火把所映照出的某個地方，而非順著火把的餘光，朝向魔物所在的位置視去。\n從「保護自己」的這點來看，他做的非常地好。\n「接下來要做的事情是安靜的離開現場。這點就沒什麼竅門了，總之就是腳步盡量放輕，然後身體慢慢移動。」少年仍維持右手伸出、身體稍微前傾的姿勢，先前嘗試踏出的右腳，正以非常緩慢的速度向後移動。\n待到右腳的位置移動至身體的後方之後，少年便將懸空的腳尖微微地向下擺放。等到腳尖有了接觸地面的感覺之後，再慢慢地、慢慢地將足弓、腳跟…等右腳的其餘部分貼合地面。\n然後將右邊的膝蓋微蹲，控制身體的重心由原來的左膝轉移至身體右側，並輕輕地抬起左腳，重複剛剛的動作，讓左腳輕微、但用盡全力地向後跨出。\n一步……\n火炬在顫慄的右手之下，搖曳的更加劇烈。\n兩步……\n諾大的汗水，正緩慢地從額頭滑落。\n三步……\n工靴的金屬材質、和褲管尾端的鈕扣在每次的移動中都會產生些微的碰撞。雖然從邏輯上來看，它們發出的聲音極為細小，但此刻，全身緊繃的神經並沒有辦法準確地判斷實際的音量為何？因此格雷瑪只能祈禱著這樣的聲音不至於加深老鼠的怒火，從而對自己發起攻擊。\n「通常母鼠會在岔路後的5-10公尺左右定巢和安置幼鼠。」少年持續地回想著冒險者教科書般的對話內容。\n「一般來說，只要能離開母鼠所在的那條岔路，後續也不發出什麼大聲響，危險的程度就算是降到和牠面對面的五分之一或以下了。」\n「因為相對於打倒入侵者來說，保護幼鼠才是牠的首要目標。」銘記著腦海裡擁有的少數情報，少年仍在嘗試踏出危險的邊緣。\n——這就是面臨死亡的感覺嗎？\n他又再往後退了幾步。\n——這就是那些人平常的生活嗎？\n他嘗試透過自我對話的方式，覆蓋掉由內心恐懼所帶來的呆滯與無力。\n——這就是所謂的「冒險者」嗎？\n火炬的外側，在向後的過程中，照耀出了另一條由老鼠所開鑿的道路。這表示格雷瑪已經退到了岔路所在的地方。\n『唧………』雖然魔物的聲音逐漸變小，但可以確定的是牠仍在觀察。不管是由牠所發出的聲音，或者是內心那種「正被直勾勾的盯著」的直覺都能加以佐證。再一步、再一步…再快一點、再快一點…的想法在少年的腦海中瘋狂打轉。並促使著他的腳步愈發加速。\n機械性地繼續往後踏出一步，正如同前幾次所做的那樣，少年的腳尖感受到了一種類似於石塊的觸感。他並沒有多想，也沒有多做確認，只是單純地著對腳尖所碰觸到的地方施力，同時將自己的重心移往腳尖所在的那個位置。\n「最後就是一些額外的提醒了：因為是野獸的緣故，所以牠們並不會固定在某一個地方進食，而是只要在巢穴裡頭，確認自己『沒有危險』『足夠安全』之後，就會直接啃食到手的食物。」\n【喀！喀噠！】\n一個清脆的聲音從少年的腳下響起。 「也因為牠們是野獸的緣故，所以一些像是骨頭阿、金屬阿這類比較硬的、不能夠咬東西，就會直接被牠們隨地吐在旁邊。」\n腳尖原本類似於『石塊』的觸感正逐漸由『空氣』所取代，這也表示少年原本所預期的著腳點正在消失。為了不失去重心，他下意識地退了幾步，並在後退的過程中，不停地製造出踩碎東西的聲音。\n【喀啦！喀啦！噠！喀啦！】\n待到腳步回穩之後，他才發現原本前方預計下腳的地方，正有著一些已經被自己踩碎的、由動物的骨頭所堆積而成的小峰。而那些正是老鼠們在用餐過後，所遺棄的動物頭骨。\n「如果不小心踩碎巢穴裡的骨頭的話，那可是個不小的聲響呢。」\n『吱！！！！！！！！！！！』\n尖銳的高頻叫聲，幾乎是毫無懸念地在耳邊響起。\n同時，或者説幾乎是同一時間，少年由原本的微蹲姿態，直接調整為向後起跑的姿勢，並且開始朝著轉頭之後所看到的道路即起狂奔。\n——我還不想死！我還不想死！\n危險的氣息，重新回到了最開始的高點……不對，甚至比那還要更高！\n『吱吱吱！！！！！』\n——不能被追上！不能被追上！\n身後愈發急促的腳步聲，暗示著自己與魔物的距離正在逐漸接近。\n——要再快一點！要再快一點！\n腎上腺素逼迫著全身上下的每個細胞超速運作，大腿的肌肉以從來都沒有過的速度進行延展和收縮，這也使得少年能夠以更加迅捷的速度向前移動。 此外，除了身體的下半身，左手的手臂也同樣在配合雙腳的動作，在它們交替踏出時不停地前後擺動，以維持自己的身體動力和平衡，讓肌肉能夠更有效率的完成此時大腦所指定的工作。\n而右手呢？則是緊緊握著四周唯一的光線來源，並盡其所能地向上高舉，以確保火炬能夠最大限度地開闢出眼前的道路，並利用雙眼將光線所提供的情報傳給自己的大腦。以便於身體能在最短的時間內判斷出「該往哪裡前進」的訊息。\n『吱！！！！吱吱！！！！！』\n危險仍然沒有消失。而且正如剛才所說，牠還在愈發靠近。\n格雷瑪快速地通過了另一個初來時的岔口，但緊接著，後方的魔物也在僅僅幾秒之後，就通過了原本少年所在的地方。\n——我不要！！！！\n【可能在離開洞口之前，就會被母鼠追上】的想法不停地敲擊著本就已經足夠最弱的幼小心靈。少年一邊奔跑，一邊本能地在內心裡抗拒地嘶吼著。\n或許是這個反抗的意識，也或許是身體開始熟稔超頻運作下的工作方式，他奔跑的速度逐漸加快，雙腿的步伐能夠向前邁得更加大步，兩手的手臂也能更有規律和節奏地配合著身體的規則擺動。\n「母鼠在保護幼鼠的時候，不會離開巢穴。」冒險者的聲音仍然在少年的耳邊響起，同時他也通過了距離出口的最後一個岔口，但想當然地…後方的魔物也還沒放棄追逐眼前這個擅自闖進巢穴的入侵者。\n「所以只要能夠成功地逃離老鼠的巢穴內，那怕只是一步，都可以讓自己在極度危險的情況下瞬間變得安全。」原本需要借由火炬才能提供光明的一片漆黑，在少年經過了某個拐角之後，出現了一個白色的光點。緊接著，光點的範圍從中心開始愈來愈大、愈來愈大。雖然他現在還看不清楚白光後方的景色，但毫無疑問，對於現在的少年來說，眼前的白光正是「終點」的所在！\n最後，他在距離洞口 3 公尺的地方向前一躍，懸浮於空中。下個瞬間，少年的身體開始承受不住來自地面的引力而開始落下，他將身體捲曲，令自己在接觸到地面的同時可以以「滾動」的狀態持續前進。\n洞穴的外頭是個緩而長的斜坡，也因此，少年在離開了鑿城鼠的巢穴之後，仍然向前滾動了一段距離才完全停下。\n格雷瑪在這之後勉強地拖起傷痕累累的身軀向後望去，只見高度約 2-3 尺的巨大魔物向巢穴外探出了一半的身軀，在「房屋」的大門以向前微蹲的姿態持續地盯著眼前這位來這不善的「客人」。一段時間過後，鑿城鼠才緩慢地從洞口退回去，但牠仍惡狠狠地盯著眼前的這位不速之客。\n而格雷瑪也在這之後，逐漸放下了心中的恐懼、昏沉過去。\n1373 年 11 月 27 日，下午 5 點 31分，弗洛斯村靠近中央廣場旁的孚爾契酒館。一名身高約 140 公分左右，帶有一頭淺橘色捲髮的矮人男子，正大口大口的喝著店裡最為上好的美酒。\n「呼啊～～果然只有這裡的萊姆才是真正的萊姆啊。」酒滴從男子的嘴角和杯緣滑落，接著再順著那粗獷的橘色鬍鬚落至由杉木所組成的圓桌上。\n「瓦爾斯，我還是不覺得這是一個好主意。」與眼前的橘髮男子不同，聲音的主人是一名有著淺黃色長髮、左耳的耳角帶有華麗耳飾、穿著綠色上衣，但又用一席深色長袍覆蓋著全身的精靈女子。儀態端莊地坐在男子的對面，細細品嚐店裡的其他美食。\n「什～麼主意啊～提朵？」瓦爾斯兩手撐在圓桌，略微強烈的醉意微微地壓著他的肩膀，使得這個身高只有 1 米 4 的矮人更需要將頭稍稍的斜仰，才能夠看向眼前的精靈女子。\n「老鼠的事。」提朵不悅地說。\n「呼哈～你說那個赫力在意的小子嗎～我也只不過是把我所知道的魔物情報說給其他冒險者聽而已嘛～至於其他人有沒有聽到？聽到了之後又會有怎樣的反應？可就不關我的事了吧～」即使這已經不知道是他今天的第幾杯了，瓦爾斯依舊毫無顧忌的又喝了一口手中的萊姆酒。\n「這也就表示你知道那孩子有聽到，而且也會真的跑進去，對吧？」提朵暫停了用餐的動作，用著微微散發殺氣的眼神，死死盯著眼前的矮人男子。\n「挖喔～～別用這麼凶狠的眼神看著我嘛～至少風險跟應對的方法我也都有講出來阿，不是只跟他說裡面會有好東西而已嘛～」瓦爾斯稍微別過自己的臉，但提在嘴角前的酒杯和略為瞇著的眼睛仍然出賣不了自己喜悅的心情。\n「而且我覺得妳要再重新思考對於不同種族來說，『孩子』代表什麼意思哦？妳是不是覺得無論任何種族，只要歲數低於一定的數字都是小孩啊？對我們矮人來說，雖然他那個年紀雖然還不到成年，但早就已經是個可以獨當一面的戰士了呢～哈哈哈哈哈！」豪爽的笑聲帶起了周圍本就活絡的氣氛，瓦爾斯用眼神致意，讓店裡的服務生再拿兩瓶萊姆酒過來。\n「但他還不是個冒險者。」重新拾起桌上的餐具，提朵在繼續用餐之前又唸了一段。\n「但也『還』不是個冒險者而已不是嗎？」瓦爾斯放下了手中的酒杯。愈發強烈的酒意雖然讓這名矮人的臉頰變得更為通紅，但從他的眼神來看，可以確定方才他所說出來的話語並不是酒後的胡言亂語。\n「所以你覺得讓他闖進一個有著母鼠的巢穴，再帶著洞穴內的戰利品出來，公會就有機會讓他成為一個合格的冒險者嗎？」提朵的心情變得更加不悅了。\n「不對～不對～不對～～這句話有兩個地方說錯了～」瓦爾斯搖著頭。\n「首先～那裡不是一個『有著母鼠的巢穴』，而是一個『經調查之後，對母鼠的存在抱持著高度肯定的巢穴。』這也就是說，在一定的機率下，那裡還是有機會不出現有母鼠的～」看了看右手已經被自己清空的容器之後，矮人又從桌子的其他位置拿起了一杯全滿的酒杯。\n「其次，如果有一個莫約 12 歲的人族男子，在獨自一人闖進了有著母鼠的巢穴之後，還能夠平安地回來的話，公會並不是『有機會』讓他成為冒險者，而應該更傾向『直接將他視為冒險者』才對。」\n「你這個守序邪惡的爛人。」\n雖然並沒有望向眼前的矮人男子，但心中的怒火並沒有因為方才的辯解而達到減弱的趨勢。 但瓦爾斯的這一席話，的確也讓提朵開始思考著事情的其他含意：沒錯，雖然對於一般的冒險者來說，要單獨討伐難度 B- 或 B 的魔物並非毫無勝算可言。畢竟在定義上來說，難度 B 的意思是「等級 1 至 3 的冒險者『建議』以小隊的形式進行討伐的魔物，等級 4 及以上則不在此限。」但定義上是以『建議』的條文進行輸血，而非『必須』這個字眼，這也就表示，即使母鼠的威脅相對於普通的鑿城鼠還要更高，對於公會來說，這也還不到禁止初階冒險者單獨討伐的程度。\n那在這樣的前提之下，如果公會聽聞了「一名莫約 12 歲的人族男性，在闖入了有著母鼠的巢穴之後，還能平安無事、或至少活著的走出來」的消息之後，省略掉常規的檢定手續，而直接將他視為一位合格的冒險者也不是什麼出乎意料的事。\n——只不過……\n「對於一個普通的人族少年來說，還是太過勉強了吧。」修正了自己對於年紀上的認知，精靈女子望向了店裡遠方的魔物標本說道。\n「而且對於一個初階的冒險者來說，要單獨打倒至少 -B 級的魔物，至少也得做好身體（武器與防具）和心理（了解恐懼和風險）的準備，才有辦法達成吧？這樣對他來說，難度難道仍舊不會太高嗎？」\n「所～以～說～嘛～～如果在這樣的情況下，那個小子還能夠達成的話～不就代表真的有料嗎？而且妳不也說過什麼…『那小子有資質成為冒險者～』『小小的妖精也時常跟著他』之類的話嗎～」\n「我說的是他有著通常人族不具有的『魔力容器』。」提朵修正道。\n個體的妖精一般不會接近人族，因為祂們不喜歡沒有魔力的東西。因此相對於絕大多數「白紙」一般的人類來說，祂們更寧願在路邊一顆被丟棄的小石子上停滯和逗留。因此在半個月前，在提朵準備踏進酒館時，酒館門口那望著酒館內部、且肩上留有妖精停留痕跡的褐髮少年的確吸引到了自己的注意。\n也不由得讓自己對他使用了一次【魔力感知】。進而發現那.孩.子.天.生.就.帶.有.容.器.的事實。\n「但就算他有容器，在人族中也不算極其罕見的情況吧？至少你我除了那個孩子之外，也認識了好幾個帶有容器的人類不是嗎？」酒館內的服務生將兩杯滿量的特大號酒杯、和一份豐盛的地方餐點擺放至兩人的餐桌上，長髮精靈在這之後則將視線從遠方的目標移回眼前的料理中。\n「唉啊～～～人家不是都說精靈是善於觀察跟思考的種族嗎？怎麼從這點來看，我比妳還要更像你們這群捨不得衣服髒的小公主小王子啊～」\n無視著前方傳來愈發強烈的憤怒，矮人喝了一口從服務生承遞過來的大酒之後又繼續說道：「我看的是眼神阿～眼神！管他什麼年紀什麼魔力的，他那個就像在說『讓我去吧』『我也要加入』的眼神，不覺得將來就是個很不錯的小子嗎？哈哈哈哈哈！」\n時而嚴肅時而醉意的語氣除了讓提朵對於餐間的對話感到相當不悅之外，就沒有任何其餘的情緒了。也因此，她並沒有對瓦爾斯的說法提出任何的回覆。僅僅將之作為耳邊風，中斷談話，並專注地品嘗眼前的美味佳餚。\n"},{"id":181,"href":"/docs/computer_science/design_pattern/open_closed_principle/","title":"開放封閉原則","section":"設計模式","content":"\r開放封閉原則\r#\rChatGPT 的說明 開放封閉原則（Open-Closed Principle，OCP）是物件導向程式設計中的一個重要原則，由著名的軟體工程師貝瑞·波 (Bertrand Meyer) 在他的著作《Object-Oriented Software Construction》中首次提出。該原則強調軟體實體（例如類別、模組、函數 \u0026hellip;等）應該對擴展保持開放，對修改保持封閉。這樣做可以實現程式碼的可擴展性和可維護性。具體來說，開放封閉原則有以下兩個重要概念：首先是［開放性］：開放性表示軟體應該在不需要修改現有程式碼的前提下，允許新增新的功能或新的特性。當系統需要新增功能時，應該通過擴展現有的實體，而不是修改原有的程式來完成。這有助於防止對現有程式碼的不必要修改，降低了引入錯誤的風險。其次是［封閉性］：封閉性說明程式實現某一功能後，程式本身應該被封閉，即不應該再對其內容進行修改。當一個實體達到預期的功能時，應該停止對它的修改，而是應該通過擴展或建立新的實體來添加新功能。\n開放封閉原則的優勢包括下列幾項：首先是可擴展性，當需要新增功能時，開發人員可以通過創建新的子類別、新的模組或擴展介面來實現，而不需要修改原有的程式碼，這有助於降低風險，並維護程式碼的穩定性。其次是可維護性，因為不需要經常修改原有的程式碼，所以程式碼變得更容易維護。每個功能都位於獨立的模組、類別、或者介面之中，使得錯誤的追蹤與修復能變得更加容易。此外程式的重用性也會被提高，因為功能被分割成獨立的實體，我們可以更容易地重用這些已經撰寫完成的程式碼，這有助於提高程式的效率和一致性。\n簡單整理 OCP 在說的就是：寫好的程式需要有『容易擴展』和『不再需要更改』兩種特性\n程式碼範例 開放封閉原則算是一個滿好理解的設計原則，基本上就是「寫好的程式碼，盡量保持在不需要頻繁編輯的狀態」跟「寫好的程式碼，要容易被後來的程式碼飲用或擴充」這兩句話。用一個比較常見的舉例方式來解釋的話，讓我們考慮以下的情境：假設我們需要撰寫一支程式，該程式需要能夠透過不同參數，生成不同的圖形（圓形、正方形、長方形 \u0026hellip;等），並且程式也要能夠計算該圖形的面積。如果不使用開放封閉原則的話，可能會寫出以下的程式：\n// 定義各種不同的圖形 class Circle { Double radius; public Circle(Double radius) { this.radius = radius; } } class Square { Double sideLength; public Square(Double sideLength) { this.sideLength = sideLength; } } class Rectangle { Double width; Double height; public Rectangle(Double width, Double height) { this.width = width; this.height = height; } } // 定義一個用來計算圖形面積的類別 class AreaCalculator { public Double getArea(Object shape) { if(shape instanceof Circle) return ((Circle)shape).radius * ((Circle)shape).radius * Math.PI; else if(shape instanceof Square) return ((Square)shape).sideLength * ((Square)shape).sideLength; else if(shape instanceof Rectangle) return ((Rectangle)shape).width * ((Rectangle)shape).height; else throw new ShapeAreaCalculationException(); } } 程式在邏輯上本身沒有什麼問題，但在可擴展性和可讀性上就有可以著墨的地方了：雖然對於各種不同的圖形（Circle, Square, 或 Rectanle \u0026hellip;等）我們都可以利用 AreaCalculator 類別中的 getArea() 方法進行面積計算，同時這個方法也幫我們寫好了非圖形類別時的例外處理，但 getArea() 本身的內容卻重度依賴著各種不同的圖形。在可預想的範圍內，我們不難思考出：之後每在程式裡面新增一個圖形，getArea() 這個方法就會需要重新被修改一次。因此，對於 getArea() 這個方法來說，就沒有很好地遵守「開放封閉原則」了。\n修改的方法其實很簡單，在類似於上述的狀況下，我們通常會使用「共同的介面」或者是「繼承同一個父類別」來做改進：先在共同的介面（或父類別）裡面定義一個所有子類別都可以使用的方法，再讓其繼承的類別去改寫該方法，就能夠避免其他調用者需要重複調整程式的情況了，就像是下面的這個樣子：\n// 定義一個所有圖形都共同繼承的父類別 abstract class Shape { // 定義父類別中的共同方法 \u0026#39;getArea()\u0026#39; public Double getArea() { throw new ShapeAreaCalculationException(); } } // 定義各種不同的圖形 class Circle extends Shape { Double radius; public Circle(Double radius) { this.radius = radius; } // 改寫父類別的 getArea() 方法 @Override public Double getArea() { return this.radius * this.radius * Math.PI; } } class Square extends Shape { Double sideLength; public Square(Double sideLength) { this.sideLength = sideLength; } // 改寫父類別的 getArea() 方法 @Override public Double getArea() { return this.sideLength * this.sideLength; } } class Rectangle extends Shape { Double width; Double height; public Rectangle(Double width, Double height) { this.width = width; this.height = height; } // 改寫父類別的 getArea() 方法 @Overrie public Double getArea() { return this.width * this.height; } } // 定義一個用來計算圖形面積的類別 class AreaCalculator { public Double getArea(Object obj) { if(obj instanceof Shape) return ((Shape) obj).getArea(); else throw new ObjectIsNotInheritedFromShapeException(); } } 透過定義一個共同的父類別 Shape，並在各個子類別中改寫原父類別的 getArea() 方法，往後如果我們需要再創建其他不同的形狀（像是三角形、橢圓形 \u0026hellip;等），我們只需要讓該形狀繼承 Shape 類別，然後重寫一次類別中的 getArea()，就可以保證能夠被 AreaCalculator 正確地計算面積，也就達成了程式裡「便於擴展」的需求了（開放性(v)）；此外，往後無論我們再增加哪怕是數十種、甚至是數百種不同的形狀，只要那個形狀記得繼承 Shape 類別，AreaCalculator 裡面的 getArea() 都不再需要進行任何的調整，也能夠正確計算出該圖形的面積。也就達到了「寫完程式之後，就不需要再更動這個程式」的需求（封閉性(v)）。\n"},{"id":182,"href":"/docs/life/reading_experience/","title":"閱讀心得","section":"生活相關","content":"\r閱讀心得\r#\r書籍\r#\r深入淺出設計模式 祈念之樹 電影\r#\r排球少年！！垃圾場的決戰 "},{"id":183,"href":"/docs/occultism/divination/is_it_a_good_decision_to_submit_your_resignation_tomorrow/","title":"阿公哪時候可以出院","section":"隨手當神棍","content":"\r隨手當神棍\r#\r問題：阿公哪時候可以出院？\r#\r使用工具：塔羅牌（線上抽牌網站）\n結果： 解析：\n簡單的三張翻牌。正位的聖杯七，代表著幻想、思考、白日夢、嚮往、不切實際 \u0026hellip;等意思。最直接的說法就是「這個決定聽起來超不切實際的，你有想好之後要做什麼嗎？什麼都還沒規劃對吧？別癡人說夢了」類似這種感覺。雖然蠻直接的但我並不討厭，只是當下超～無法接受的就是了（一心只想個找到別人尋求認同，然後就被啪啪打臉）。第二張牌是逆位的錢幣七，主要的意思有兩個：第一個訊息是「愜意」，代表現在的工作相對很輕鬆，辭職真的不是一個很好的決定，再想想再想想；第二個則是「沒有收穫」，意思是我從開始做這份工作到現在為止也才過去幾天而已，什麼都還不知道，也什麼都還沒學，這樣就走掉有點可惜，也有點浪費。最後是第三張牌——逆位的太陽，逆位的太陽代表美好的事情即將到來，現在看到的不好的事情都只是資訊之後好事的養分而已，再給自己一點時間吧～別那麼快就走掉！\n驗證： 嘛 \u0026hellip;不知道要怎麼寫驗證？但總之後來沒有提出辭呈。多吃幾顆要讓自己鎮靜下來之後，工作大致上就做的沒什麼問題了。老實說直到現在我時不確定我到底是「不喜歡這份工作」還是「不喜歡『工作』這件事情。」用我此時此刻的想法來看的話，我覺得後者的比重會更大一些。所以我覺得還是繼續撐下去可能是比較好的決定。雖然我超不情願的，但我那個算命先生的理智又跟我說我的牌是真的很準。好啦再一下下就好。最慢兩年，最快明年拿到 27,000,000 的隔天就走。\n"},{"id":184,"href":"/docs/occultism/divination/when_can_grandpa_be_discharged_from_hospital/","title":"阿公哪時候可以出院","section":"隨手當神棍","content":"\r隨手當神棍\r#\r問題：阿公哪時候可以出院？\r#\r使用工具：塔羅牌（線上抽牌網站）\n結果： 解析：\n這副牌是禮拜二抽的，採用的是簡單的時間之流、一張一天的抽牌方式。解牌的規則設定的很簡單：大致以正逆位來判斷哪時候可以出院？排意則用來輔助說明那天為什麼可以（或者為什麼不可以）出院。結果分別是：惡魔(正)、權杖八(逆)、隱者(逆)、寶劍八(正)、和戀人(正)。基本上抽完牌結果就出來了：我是從明天開始問的，所以時間依序是星期 3, 4, 5, 6, 日。\n星期三是正位的惡魔。這邊雖然正位可以用「可以出院」來做解釋，但因為牌是惡魔，代表慾望、想法，所以這個惡魔比較像是「阿公內心希望明天就可以趕快出院」，但實際上並不能出院。從現實面來看，我們也不會讓他明天就出院就是了（除非檢查真的做超快的，但機率不到 0.1%）；然後是星期四的逆位權杖八。首先這張牌是逆味的，所以出院的機率不高，再加上逆位的權杖八有緩慢、暫停、等待、休息、間歇 \u0026hellip;等意思，所以出院機率也很低（大概只有 1-2%）；星期五是逆位的隱者，單從正逆來看，是「不能出院」的意思，但因為隱者是大牌，解釋層面比較廣。我不確定這張是代表「更加迷失方向」還是「結束了迷茫」的情境？如果是前者，那無庸置疑無法出院。但如果是後者，就有可能這天會出去。機率的話我可能會給個 20-30%；再來是禮拜六的正位的寶劍八。這張牌是正位的，所以出院的機率高，寶劍八指的是「一種雖然可以踏出去，但自己還是有點擔心」的情境。所以它本質上是指「沒問題了」的一張牌。出院機率 70%+；最後是禮拜天戀人。戀人這邊指的是阿公跟阿嬤重逢，所以不管怎麼樣，這天一定會見到阿嬤，所以這時候已經回家了（100% 回家）。\n所以出院的日期是禮拜 6，且星期天一定會見到阿嬤。\n驗證： 禮拜六出院沒錯。禮拜五的逆位的隱者指的是「撥雲見日。」那天原本可以出院，但因為被醫生告知的時候是上午 10:00 左右，同時醫生說如果要出院，需要在 12:00 之前把手續全部完成。家人那時候都不在醫院附近，要這樣趕過來可能有點拼，所以就多延了一天，禮拜六才走。此外，從醫生的角度來看，他們也覺得明天走會比較好：一方面行政上不會那麼趕，一方面他們也可以再多多觀察一下阿公的狀況。\n"},{"id":185,"href":"/docs/occultism/divination/","title":"隨手當神棍","section":"命理相關","content":"\r隨手當神棍\r#\r2024 / 03\r#\r（塔羅）阿公哪時候可以出院 2024 / 04\r#\r（塔羅）明天提出辭呈是不是個好決定 "},{"id":186,"href":"/_trash/divination/what_happens_at_the_interview/","title":"面試會發生的情況與結果","section":"_Trashes","content":"\r隨手當神棍\r#\r問題：面試會發生的情況與結果？\r#\r使用工具：紫微斗數（亂數隨機起盤）\n結果： 解析：\n盤一跳出來，官祿丁卯的機巨自化科忌嚇了我一跳 XD。\n因為天機巨門都是動星，遇到化科化忌的話，就容易有想太多、或者是過分敘述的現象。如果是後者的話還好，因為是在面試，是有可能大部分都是我在講話的；至於前者嘛 \u0026hellip;想太多很容易發揮爆開，我不太樂見，所以轉頭看向了福德宮的狀態（丁丑日月自化祿）——看來現象的呈現主要會是後者，那應該就沒什麼問題了。命宮是天同獨坐亥宮，對宮天梁生年科自化科 + 陀羅天馬。感覺是個自我發揮很滿的一場面試。雖然偶爾可能會卡嘴、緊張結巴、或者是遇到回不出來的問題，但大致能有不錯的發揮。整體而言這個命財官遷我會給到 78 左右的分數，\n至於主面試官的狀態：紫相坐戊辰，遷移甲戌破軍自化權，會是一個當下性格比較直接、但同時也比較穩重的主面試官。官祿廉貞文曲忌，顯得他很在意技術相關的問題，或者是一個比較要求工作上的規矩或原則的人之類的。從四化來看：戊干天機忌入我的官祿，所以對我自己的體感來說，約束感或者是壓迫感還蠻重的。但本身又祿入本命田宅照他的官，所以大致的約束跟壓迫都是基於「我們在工作上能夠更方便、更有效率」的原則下，蠻合理的～面試官的疾厄跟福德也沒有往我身上沖，所以也不會很討厭我，真是太好了！\n最後簡單看了一下公司狀況：疾厄庚午坐七殺、文昌、祿存，對宮父母武府生年祿。光是命遷吃到武府的雙祿巡逢就明示了這是一間很有獲利能力的公司，何況公司本身的命財官遷又沒有煞忌做把這個雙祿巡逢打壞 \u0026hellip;，果然相對於自己努力去算命；跟著勢頭走，往資訊業發展才是賺錢最快的選擇嗎（哈哈哈哈）。公司本身也是祿入我的財福、忌入我命，從「錢」的角度來看，是很穩紮穩打的「財入我庫」的狀態，所以薪水也不用煩惱了。\n至於田宅丙寅的逆水忌嘛 \u0026hellip;自己再注意就好。\n驗證： （待補\u0026hellip;）\n"}]