<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Fonu Site</title>
    <link>https://fonu195713.github.io/docs/</link>
    <description>Recent content in Docs on Fonu Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://fonu195713.github.io/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>最少知識原則</title>
      <link>https://fonu195713.github.io/docs/_trash/least_knowledge_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/least_knowledge_principle/</guid>
      <description>最少知識原則#ChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 &amp;ldquo;朋友&amp;rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 &amp;ldquo;封裝&amp;rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。
此外在物件導向程式設計中，一個物件的 &amp;ldquo;朋友&amp;rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 &amp;ldquo;朋友&amp;rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 &amp;ldquo;朋友&amp;rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 &amp;ldquo;朋友&amp;rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 &amp;ldquo;朋友&amp;rdquo;。 需要注意的是，儘管可以與這些 &amp;ldquo;朋友&amp;rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。
簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。
程式碼範例 迪米特法則的核心是「盡量保持鬆耦合」的設計思想：當一個物件（或一個方法）需要透過很 &amp;ldquo;遠&amp;rdquo; 的呼叫，才可以完成某項功能時，就代表該物件對於呼叫中的所有東西都保持著依賴關係，那這時候，只要這一條依賴關係的任一截點出現問題，就都有可能導致功能的毀損，進而影響整個程式的運作。舉個例子：我們假設在一間上市公司中，從公司最大的「老闆」一路到最基層的「員工」有以下的這幾個階層：老闆（Boss）&amp;gt; 各部門的部處長（DepartmentDirector）&amp;gt; 專案經理（ProjectManager）&amp;gt; 員工（Staff）。然後今天老闆想要讓自己的公司網頁新增一項功能，他將這件事情告訴了 IT 部門的部處長，處長為此成立了一個「網站專案團隊」，並指派一位資深員工為專案經理讓他挑選幾位處理該專案的員工（Staff）來完成老闆所需的工作。如果在這樣的情況下，老闆想要追蹤一下這個網頁功能的更新，那可能會發生這樣的問題：
Log websiteInfo = boss.getDepartmentDirector(&amp;#34;IT&amp;#34;).getProjectManager(&amp;#34;web&amp;#34;).getStaff().getTaskLog(); 我們可以看到：光是 Boss 想要拿到一條「網站的更新紀錄」，就需要經過至少 3 ~ 4 個人的手，除了在實務的情況下，這麼做的效率可能有點低下之外，對於程式的撰寫來說，這種寫法也是挺有風險的，畢竟我們沒有辦法保證「呼叫上的所有方法即使產生了細節上的改變，程式也能完整運行」（例如 getProjectManager() 突然不用 &amp;ldquo;專案名稱&amp;rdquo; 做為參數，改用 &amp;ldquo;專案代號&amp;rdquo; 之類的），因此，迪米特法則告訴了我們「不要跟這麼多人講話」，也就是不要依賴過多的 &amp;ldquo;陌生人&amp;rdquo;。盡可能只透過，跟身邊的「朋友」聊天，就能拿到必要的資訊。降低方法間的相互調用，也就降低了「依賴於 &amp;lsquo;方法&amp;rsquo; 的一致性」，進而提升程式整體的品質，就是迪米特法則想要告訴我們的事情。
Log websiteInfo = boss.getInfo(&amp;#34;WebsiteUpdate&amp;#34;); 朋友 知道了法則想要傳遞的訊息之後，接下來就可以往下一步走了：哪些人、哪些東西、哪些物件、哪些方法才是所謂的「朋友」？一般來說，常見對於「朋友」的定義有以下四種：「類別本身的成員變數」「類別本身的方法」「父類別的所有成員與方法」「傳入方法中的所有參數」以及「在方法中建立的任何物件」。可以發現到朋友的類型可以根據是類別還是方法有所不同，這也是該原則比較特別的一個地方：不僅適用於類別的角度，也適用於方法的角度。
類別本身的成員變數 這個應該蠻好理解的？畢竟是「自己本身就有的東西」。「類別本身的成員變數」可以視為是一個自己的親近朋友，無論是 &amp;ldquo;基本資料型態&amp;rdquo;（像是 int, float, long, double &amp;hellip;等），或者是 &amp;ldquo;參考資料型態&amp;rdquo;（各種類別：諸如 Object, System, Boss, Staff, Library &amp;hellip;等），只要是類別自己有的東西，都可以視為自己的朋友，這點也包含所有的父類別、父父類別、父父父類別 &amp;hellip;等。</description>
    </item>
    
    <item>
      <title>里氏替換原則</title>
      <link>https://fonu195713.github.io/docs/_trash/liskov_substitution_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/liskov_substitution_principle/</guid>
      <description>里氏替換原則#ChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。
LSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。
這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。
簡單整理 簡單來說：父類別沒有的，子別類不一定要有，但是父類別有的，子類別都一定要有
程式碼範例 里氏替換原則討論的是關於類別（或介面）發生繼承時，應該遵守或者是留意一個規範或想法。大致上的重點在於「子類別應該完全實現父類別的想法」「子類別可以對付類別的想法作出補充」以及「子類別應該遵循與父類別一致的規則」這句話上面。簡單來說就是「父類別的擁有和要求，子類別都要做到」但「父類別沒有要求的，子類別可以不用做到」這兩句話上。
自己稍微唸了一下，感覺還是有點饒口，直接用一個範例程式碼來做舉例好了：假設我們現在受到了某某大型運輸公司的委託，需要製作一個該公司的「交通工具查閱系統」，裡面需要包含一些常見的交通工具的相關資訊，像是汽車、船、機車、公車、腳踏車、直升機、飛機 &amp;hellip;等，在最最直觀的情況下，我們可以把所有的交通工具都寫成互不相關的獨立類別，就像是下面的這個樣子：
class Car { String id; String type; public void driving() { System.out.println(&amp;#34;在馬路上行駛&amp;#34;); } // 其他跟[汽車]有關的方法 // 其他跟[汽車]有關的方法 } class Boat { String id; String type; public void sailing() { System.out.println(&amp;#34;在河道或海中航行&amp;#34;); } // 其他跟[船]有關的方法 // 其他跟[船]有關的方法 } &amp;hellip;（還有其他好多類型的交通工具）
class Helicopter { String id; String type; public void flight() { System.</description>
    </item>
    
  </channel>
</rss>
