<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="狀態模式（State Pattern）#說明 ChatGPT：狀態模式（State Pattern）是一種行為型設計模式，它允許物件在相異的狀態下展現不同的行為，並讓使用者看起來好像改變了它的類別。這種模式可以將物件的狀態封裝在不同的類別中，並且使物件能夠在運行時根據狀態的改變而改變其行為。狀態模式的主要目的是將複雜的條件判斷轉換成一組一組相關的狀態類別，從而使代碼更具可讀性、可維護性和可擴展性。它遵循開放-封閉原則，因為可以通過添加新的狀態類別來擴展系統的行為，而無需修改現有的代碼。使用狀態模式，可以將每個狀態實現為一個具體狀態類別，並將狀態相關的行為封裝在這些類別中。上下文類別（VendingMachine）持有當前狀態的引用，並將相應的請求委派給當前狀態對象。當狀態發生改變時，上下文物件將切換到新的狀態，並且行為也隨之改變。透過狀態模式，可以實現狀態機進行狀態轉換和行為管理的解耦，使得系統更靈活、可擴展且易於維護。
維基百科：狀態模式是一種行為型設計模式，它允許對象在内部狀態改變時，改變其行為。該模式與有限狀態機的概念密切相關。狀態模式可以解释為一種策略模式，通過調用模式接口中定義的方法來切換策略。狀態模式在軟體工程中用於封裝同一對象的不同行為，基於其內部狀態。這可以是對象在運行時改變行為的一種清晰呈現，而無需使用大量的 if else 語句，從而提高可維護姓。狀態模式旨在解决兩個主要問題：「對象在何時改變其狀態與行為」「不同的狀態與行為該如何定義」。也就是說，在狀態模式下，增添新的狀態並不會影響原有的狀態與各自的行為。此外，因為直接在一個類別中實特定狀態的行為是不靈活的因此該模式會為每個狀態定義一個單獨的狀態接口，並定義單獨的狀態對象，封装每個狀態的特定行為。並於類別中切換與調用。
特點 將每一種「狀態」各自定義成一個類別 透過委託的方式，讓各狀態分別實現不同的行為 通常會配合枚舉（enum）一同使用 State Graphic stateDiagramStand --&gt; SquatDownStand --&gt; WalkStand --&gt; JumpStand --&gt; AttackSquatDown --&gt; StandSquatDown --&gt; AttackWalk --&gt; StandWalk --&gt; RunWalk --&gt; JumpWalk --&gt; AttackRun --&gt; StandRun --&gt; RollRun --&gt; JumpRun --&gt; AttackRoll --&gt; StandRoll --&gt; AttackJump --&gt; StandJump --&gt; WalkJump --&gt; AttackAttack --&gt; Stand內文 假設我們正在製作一款 2D 橫向卷軸的 RPG 遊戲，玩家可以透過不同的按鍵操縱遊戲中的角色。在不使用狀態模式的程式撰寫方法下，我們可能會需要利用一些的條件判斷語句來完成「角色移動」的這個概念，就如下面的程式所示：">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="狀態模式（State Pattern）" />
<meta property="og:description" content="狀態模式（State Pattern）#說明 ChatGPT：狀態模式（State Pattern）是一種行為型設計模式，它允許物件在相異的狀態下展現不同的行為，並讓使用者看起來好像改變了它的類別。這種模式可以將物件的狀態封裝在不同的類別中，並且使物件能夠在運行時根據狀態的改變而改變其行為。狀態模式的主要目的是將複雜的條件判斷轉換成一組一組相關的狀態類別，從而使代碼更具可讀性、可維護性和可擴展性。它遵循開放-封閉原則，因為可以通過添加新的狀態類別來擴展系統的行為，而無需修改現有的代碼。使用狀態模式，可以將每個狀態實現為一個具體狀態類別，並將狀態相關的行為封裝在這些類別中。上下文類別（VendingMachine）持有當前狀態的引用，並將相應的請求委派給當前狀態對象。當狀態發生改變時，上下文物件將切換到新的狀態，並且行為也隨之改變。透過狀態模式，可以實現狀態機進行狀態轉換和行為管理的解耦，使得系統更靈活、可擴展且易於維護。
維基百科：狀態模式是一種行為型設計模式，它允許對象在内部狀態改變時，改變其行為。該模式與有限狀態機的概念密切相關。狀態模式可以解释為一種策略模式，通過調用模式接口中定義的方法來切換策略。狀態模式在軟體工程中用於封裝同一對象的不同行為，基於其內部狀態。這可以是對象在運行時改變行為的一種清晰呈現，而無需使用大量的 if else 語句，從而提高可維護姓。狀態模式旨在解决兩個主要問題：「對象在何時改變其狀態與行為」「不同的狀態與行為該如何定義」。也就是說，在狀態模式下，增添新的狀態並不會影響原有的狀態與各自的行為。此外，因為直接在一個類別中實特定狀態的行為是不靈活的因此該模式會為每個狀態定義一個單獨的狀態接口，並定義單獨的狀態對象，封装每個狀態的特定行為。並於類別中切換與調用。
特點 將每一種「狀態」各自定義成一個類別 透過委託的方式，讓各狀態分別實現不同的行為 通常會配合枚舉（enum）一同使用 State Graphic stateDiagramStand --&gt; SquatDownStand --&gt; WalkStand --&gt; JumpStand --&gt; AttackSquatDown --&gt; StandSquatDown --&gt; AttackWalk --&gt; StandWalk --&gt; RunWalk --&gt; JumpWalk --&gt; AttackRun --&gt; StandRun --&gt; RollRun --&gt; JumpRun --&gt; AttackRoll --&gt; StandRoll --&gt; AttackJump --&gt; StandJump --&gt; WalkJump --&gt; AttackAttack --&gt; Stand內文 假設我們正在製作一款 2D 橫向卷軸的 RPG 遊戲，玩家可以透過不同的按鍵操縱遊戲中的角色。在不使用狀態模式的程式撰寫方法下，我們可能會需要利用一些的條件判斷語句來完成「角色移動」的這個概念，就如下面的程式所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fonu195713.github.io/docs/computer_science/design_pattern/state_pattern/" /><meta property="article:section" content="docs" />


<title>狀態模式（State Pattern） | Fonu Site</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.b54adc0d1f3cdbd5dd5cddc405501c63daae88faf5272c571655f8ba52e6e6fa.css" integrity="sha256-tUrcDR8829XdXN3EBVAcY9quiPr1JyxXFlX4ulLm5vo=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.a2bed4b1c44cda6c45f4d1619c882e14c04fbe6fb55bcf6e7a63c9f9b7fb6cd5.js" integrity="sha256-or7UscRM2mxF9NFhnIguFMBPvm&#43;1W89uemPJ&#43;bf7bNU=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <meta http-equiv="Permissions-Policy" content="interest-cohort=()">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js" integrity="sha512-8pbzenDolL1l5OPSsoURCx9TEdMFTaeFipASVrMYKhuYtly+k3tcsQYliOEKTmuB1t7yuzAiVo+yd7SJz+ijFQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Fonu Site</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f4362153a9424eb450dd350e64dfffc7" class="toggle"  />
    <label for="section-f4362153a9424eb450dd350e64dfffc7" class="flex justify-between">
      <a role="button" class="">生活相關</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/working_log/" class="">［置頂］工作日誌</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/to_do_list/" class="">［置頂］待辦事項</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5f16b5923caa653815be6bb5f018b2f0" class="toggle"  />
    <label for="section-5f16b5923caa653815be6bb5f018b2f0" class="flex justify-between">
      <a role="button" class="">人生節點</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/nodes/masters_degree/" class="">碩士的畢業證書</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-68339e45fbc633241628720af6b731c7" class="toggle"  />
    <label for="section-68339e45fbc633241628720af6b731c7" class="flex justify-between">
      <a role="button" class="">日常札記</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/xinxinmota/" class="">新新魔塔 v2.6.6</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/heart_sutra_beforehand/" class="">一千份的手抄心經</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/japan/" class="">日本旅行 7 萬步</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-37b9dc15f655a4535748c0ebbd58c56b" class="toggle"  />
    <label for="section-37b9dc15f655a4535748c0ebbd58c56b" class="flex justify-between">
      <a role="button" class="">閱讀心得</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/reading_experience/head_first_design_pattern/" class="">《深入淺出設計模式》</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-65fbf0e97cd47327287d9b0d7cc4b6ee" class="toggle" checked />
    <label for="section-65fbf0e97cd47327287d9b0d7cc4b6ee" class="flex justify-between">
      <a role="button" class="">資訊工程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/recommended_books/" class="">推薦書單</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3975d187eb6b0c47dcb29d31a654027a" class="toggle" checked />
    <label for="section-3975d187eb6b0c47dcb29d31a654027a" class="flex justify-between">
      <a href="/docs/computer_science/design_pattern/" class="">設計模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/mediator_pattern/" class="">中介者模式（Mediator Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/flyweight_pattern/" class="">享元模式（Flyweight Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/proxy_pattern/" class="">代理模式（Proxy Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/prototype_pattern/" class="">原型模式（Prototype Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/command_pattern/" class="">命令模式（Command Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/singleton_pattern/" class="">單例模式（Singleton Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/facade_pattern/" class="">外觀模式（Facade Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/factory_method_pattern/" class="">工廠方法模式（Factory Method Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/abstract_factory_pattern/" class="">抽象工廠模式（Abstract Factory Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/template_method_pattern/" class="">模板方法模式（Template Method Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/bridge_pattern/" class="">橋接模式（Bridge Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/state_pattern/" class="active">狀態模式（State Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/builder_pattern/" class="">生成器模式（Builder Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/strategy_pattern/" class="">策略模式（Strategy Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/simple_factory_pattern/" class="">簡單工廠模式（Simple Factory Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/composite_pattern/" class="">組合模式（Composite Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/decorator_pattern/" class="">裝飾器模式（Decorator Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/observer_pattern/" class="">觀察者模式（Observer Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/interpreter_pattern/" class="">解釋器模式（Interpreter Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/visitor_pattern/" class="">訪問者模式（Visitor Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/chain_of_responsibility_pattern/" class="">責任鏈模式（Chain of Responsibility Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/iterator_pattern/" class="">迭代器模式（Iterator Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/adapter_pattern/" class="">適配器模式（Adapter Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/interface_segregation_principle/" class="">介面隔離原則（Interface Segregation Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/dependency_inversion_principle/" class="">依賴反轉原則（Dependency Inversion Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/" class="">合成/聚合複用原則（Composite/Aggregate Reuse Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/single_responsibility_principle/" class="">單一職責原則（Single Responsibility Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/least_knowledge_principle/" class="">最少知識原則（Least Knowledge Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/liskov_substitution_principle/" class="">里式替換原則（Liskov Substitution Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/open_closed_principle/" class="">開放封閉原則（Open Closed Principle）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-1a4dbc7dea1f032b131bd8b36ee77901" class="toggle"  />
    <label for="section-1a4dbc7dea1f032b131bd8b36ee77901" class="flex justify-between">
      <a role="button" class="">宗教命理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-19690d2784a95bdc527a8beb46f9ad15" class="toggle"  />
    <label for="section-19690d2784a95bdc527a8beb46f9ad15" class="flex justify-between">
      <a href="/docs/fortune_telling/tarot/" class="">偉特塔羅</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/fortune_telling/tarot/daily_log/" class="">［置頂］每日一翻</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-757e6157ed0a4d3981b7c5e4754c7bc2" class="toggle"  />
    <label for="section-757e6157ed0a4d3981b7c5e4754c7bc2" class="flex justify-between">
      <a role="button" class="">自由創作</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>狀態模式（State Pattern）</strong>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
  <article class="markdown"><h1 id="狀態模式state-pattern">
  狀態模式（State Pattern）
  <a class="anchor" href="#%e7%8b%80%e6%85%8b%e6%a8%a1%e5%bc%8fstate-pattern">#</a>
</h1>
<hr>
<ul>
<li><strong>說明</strong></li>
</ul>
<p><strong>ChatGPT</strong>：狀態模式（State Pattern）是一種行為型設計模式，它允許物件在相異的狀態下展現不同的行為，並讓使用者看起來好像改變了它的類別。這種模式可以將物件的狀態封裝在不同的類別中，並且使物件能夠在運行時根據狀態的改變而改變其行為。狀態模式的主要目的是將複雜的條件判斷轉換成一組一組相關的狀態類別，從而使代碼更具可讀性、可維護性和可擴展性。它遵循開放-封閉原則，因為可以通過添加新的狀態類別來擴展系統的行為，而無需修改現有的代碼。使用狀態模式，可以將每個狀態實現為一個具體狀態類別，並將狀態相關的行為封裝在這些類別中。上下文類別（VendingMachine）持有當前狀態的引用，並將相應的請求委派給當前狀態對象。當狀態發生改變時，上下文物件將切換到新的狀態，並且行為也隨之改變。透過狀態模式，可以實現狀態機進行狀態轉換和行為管理的解耦，使得系統更靈活、可擴展且易於維護。</p>
<p><strong>維基百科</strong>：狀態模式是一種行為型設計模式，它允許對象在内部狀態改變時，改變其行為。該模式與有限狀態機的概念密切相關。狀態模式可以解释為一種策略模式，通過調用模式接口中定義的方法來切換策略。狀態模式在軟體工程中用於封裝同一對象的不同行為，基於其內部狀態。這可以是對象在運行時改變行為的一種清晰呈現，而無需使用大量的 if else 語句，從而提高可維護姓。狀態模式旨在解决兩個主要問題：「對象在何時改變其狀態與行為」「不同的狀態與行為該如何定義」。也就是說，在狀態模式下，增添新的狀態並不會影響原有的狀態與各自的行為。此外，因為直接在一個類別中實特定狀態的行為是不靈活的因此該模式會為每個狀態定義一個單獨的狀態接口，並定義單獨的狀態對象，封装每個狀態的特定行為。並於類別中切換與調用。</p>
<hr>
<ul>
<li><strong>特點</strong></li>
</ul>
<ol>
<li>將每一種「狀態」各自定義成一個類別</li>
<li>透過委託的方式，讓各狀態分別實現不同的行為</li>
<li>通常會配合枚舉（enum）一同使用</li>
</ol>
<hr>
<ul>
<li><strong>State Graphic</strong></li>
</ul>


<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
</script>

  <script>mermaid.initialize({
  "flowchart": {
    "useMaxWidth":true
  },
  "theme": "default"
}
)</script>




<p class="mermaid">
stateDiagram
    Stand --> SquatDown
    Stand --> Walk
    Stand --> Jump
    Stand --> Attack

    SquatDown --> Stand
    SquatDown --> Attack

    Walk --> Stand
    Walk --> Run
    Walk --> Jump
    Walk --> Attack

    Run --> Stand
    Run --> Roll
    Run --> Jump
    Run --> Attack

    Roll --> Stand
    Roll --> Attack
    
    Jump --> Stand
    Jump --> Walk
    Jump --> Attack

    Attack --> Stand
</p>

<hr>
<ul>
<li><strong>內文</strong></li>
</ul>
<p>假設我們正在製作一款 2D 橫向卷軸的 RPG 遊戲，玩家可以透過不同的按鍵操縱遊戲中的角色。在不使用狀態模式的程式撰寫方法下，我們可能會需要利用一些的條件判斷語句來完成「角色移動」的這個概念，就如下面的程式所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Character</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(key.press(left)) {
</span></span><span style="display:flex;"><span>            MoveLeft();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(key.press(right)) {
</span></span><span style="display:flex;"><span>            MoveRight();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>在上述的程式中，我們總共定義了 2 種不同的動作，分別是「往左」和「往右」。接下來，我們對角色添增更多的行為：角色再左右移動的時候，可以重複按一次相同的移動按鍵，如此一來，就可以從【走路】切換為【跑步】，而在【跑步】的過程中，如果放開按鍵，則會直接回到原本站立的姿勢。那這樣一來，程式就可能會變成下面的樣子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Character</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(key.press(left)) {
</span></span><span style="display:flex;"><span>            MoveLeft();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>((key.pressAgain(left))) {
</span></span><span style="display:flex;"><span>                RunLeft();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(key.press(right)) {
</span></span><span style="display:flex;"><span>            MoveRight();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>((key.pressAgain(right))) {
</span></span><span style="display:flex;"><span>                RunRight();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>接下來，我們想要讓角色可以進行蹲下的動作，並且這個【蹲下】有幾種不同的狀況：如果角色是貼立於地面的話則會進行普通的蹲下，如果角色是移動中收到了「蹲下」的指令，同樣也是原地蹲下，但角色如果在【跑步】狀態下按下蹲下，角色就會【前滾翻一圈】之後【蹲下】，程式也許就會變成這個樣子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Character</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(key.press(left)) {
</span></span><span style="display:flex;"><span>            MoveLeft();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(key.press(down)) {
</span></span><span style="display:flex;"><span>                SquatDown();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>((key.pressAgain(left))) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(key.press(down)) {
</span></span><span style="display:flex;"><span>                    Roll();
</span></span><span style="display:flex;"><span>                    SquatDown();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(key.press(right)) {
</span></span><span style="display:flex;"><span>            MoveRight();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(key.press(down)) {
</span></span><span style="display:flex;"><span>                SquatDown();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>((key.pressAgain(right))) {
</span></span><span style="display:flex;"><span>                RunRight();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(key.press(down)) {
</span></span><span style="display:flex;"><span>                    Roll();
</span></span><span style="display:flex;"><span>                    SquatDown();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(key.press(down)) {
</span></span><span style="display:flex;"><span>            SquatDown();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>我們可以發現到：在這樣的程式撰寫之下，我們每為角色進行增添一個新的動作， <code>move()</code> 這個函數就會以有方常大量和散亂的地方需要進行修改與修正，而且因為動作某些動作必須要用前置動作觸發，像是【翻滾】之前必須要【跑步】，【跑步】之前一定要【行走】，因此動作的判定就會越來越巢狀，越來越波動拳 &hellip;。如果我們今天又想要新增一個【跳躍】的函數，它可以在「站立時跳」「行走時跳」「跑步時跳」甚至「蹲下能跳得更高」&hellip;，最後再加上各種角色姿勢下的攻擊行為和特效：站立攻擊、衝刺攻擊、低重心攻擊、跳躍攻擊、向下斬擊、翻滾之後向上突刺&hellip;。光是聽到這些需求，就足夠你頭痛好久了。</p>
<p><img src="/images/hadoken_code.gif" alt="波動拳程式" /></p>
<p>因此，為了解決這種情況，我們決定將「狀態模式」加進程式的架構裡面：狀態模式可以將一個物件的 <strong>每.一.種.狀.態.</strong> 都視為一個獨立的類別，並進行不同的組合與套用。在上述的例子中，我們就會把【站立】【行走】【跑步】【蹲下】【跳躍】【翻滾】【攻擊】&hellip;等不同的角色行為，全部宣告成各自獨立的類別，並將所有類別繼承在一個名為【動作】的類別之下，再透過「方法」的方式，建立狀態與狀態之間的關係：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Action</span> {};
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Stand</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Action {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">just_stand</span>() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Stand.&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">from_run</span>() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Stand after run.&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">from_squat_down</span>() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Stand after squat down.&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Walk</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Action {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">walking</span>() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Walking.&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">from_stand</span>() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;start walking ...&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Other actions ...
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JAVA" data-lang="JAVA"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Character</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    Stand<span style="color:#f92672">*</span> stand<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    Walk<span style="color:#f92672">*</span> walk<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    Run<span style="color:#f92672">*</span> run<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    SquatDown<span style="color:#f92672">*</span> squat_down<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    Jump<span style="color:#f92672">*</span> jump<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    Roll<span style="color:#f92672">*</span> roll<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    Attack<span style="color:#f92672">*</span> attack<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> State <span style="color:#f92672">{</span> STAND<span style="color:#f92672">,</span> WALK<span style="color:#f92672">,</span> RUN<span style="color:#f92672">,</span> SQUATDOWN<span style="color:#f92672">,</span> JUMP<span style="color:#f92672">,</span> ROLL<span style="color:#f92672">,</span> ATTACK <span style="color:#f92672">};</span>
</span></span><span style="display:flex;"><span>    State state <span style="color:#f92672">=</span> STAND<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span><span style="color:#f92672">(</span>state<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> STAND<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>pressing_walking_key<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    state <span style="color:#f92672">=</span> WALK<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                    walk<span style="color:#f92672">.</span><span style="color:#a6e22e">from_stand</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>pressing_squat_down_key<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    state <span style="color:#f92672">=</span> SQUATDOWN<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                    squat_down<span style="color:#f92672">.</span><span style="color:#a6e22e">from_stand</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>pressing_attack_key<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    state <span style="color:#f92672">=</span> ATTACK
</span></span><span style="display:flex;"><span>                    attack<span style="color:#f92672">.</span><span style="color:#a6e22e">from_stand</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    stand<span style="color:#f92672">.</span><span style="color:#a6e22e">just_stand</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> WALK<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Other codes ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// Other codes ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// Other codes ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">};</span>
</span></span></code></pre></div><p>相較於將所有動作的判斷放進【角色】的 <code>move()</code> 方法中，將 &ldquo;每一個【動作】都定義成類別&rdquo; 可以讓整個【角色】與 <code>move()</code> 方法得到更大的彈性和可讀性。雖然現在【角色】類別裡面的成員變數增加了許多，像是 <code>Stand* stand</code>, <code>Walk* walk</code>&hellip;等，但在程式的撰寫上卻是更加地平易近人：</p>
<p>在這樣的程式邏輯下，對於【角色】來說，雖然還是免不了有著許多的 if else 判斷，但相對於第一版的巢狀判斷，如果我們現在需要對某些動作做新增或刪除，例如新增「一個【跑步】時可以【迴避】怪物的攻擊」的動作，我們只需要先新增一個 <code>Escape()</code> 類別，再在 <code>case RUN:</code> 裡面加上一個 <code>if press_escape_key: escape.from_run()</code> 之類的語句，並在 <code>Escape()</code> 類裡實作出「跑步時要怎麼迴避」就可以了。</p>
<p>像這種「將相互有關聯的不同【狀態】獨立開來，再利用不同的『方法』重新建立起【狀態】與【狀態】之間的關聯」就是狀態模式想要傳達的精隨與真諦了。</p>
<hr>
<ul>
<li><strong>小結</strong></li>
</ul>
<p>狀態模式的優點：</p>
<ul>
<li>減少了條件判斷語句的巢狀使用</li>
<li>增加程式的可讀性與可維護性</li>
<li>將相關的動作封裝在不同的狀態類別中，使系統結構清晰</li>
<li>符合開放-封閉原則</li>
<li>容易擴展新的狀態類別</li>
</ul>
<p>狀態方法的缺點：</p>
<ul>
<li>類別的數量會與狀態的數量呈正相關</li>
<li>程式的邏輯關聯會被打散</li>
<li>過多的類別可能使程式占用的空間變大</li>
</ul>
</article>
 
      <div id="gitalk-container"></div>

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  </main>

  <script>
    const elements = document.getElementsByClassName("markdown");

    Array.from(elements).forEach(element => {
        const links = element.getElementsByTagName("a");
        Array.from(links).forEach(link => {
        link.target = "_blank";
        });
    });
</script>

<script>
    const gitalk = new Gitalk({
        clientID: '91e953a7402d79bcef6c',
        clientSecret: '22897328fab72d26e1f3a88e83ab654467232514',
        repo: 'fonu195713.github.io',     
        owner: 'fonu195713',
        admin: ['fonu195713'],
        distractionFreeMode:  false ,  
        pagerDirection: 'last',
        language: 'zh-TW',
        createIssueManually:  false ,
        enableHotKey:  true ,
        id: md5(location.pathname),      
    });
    gitalk.render('gitalk-container');
</script>
</body>
</html>












