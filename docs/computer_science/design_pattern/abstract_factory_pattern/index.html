<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="抽象工廠模式（Abstract Factory Pattern）#說明 ChatGPT：抽象工廠模式（Abstract Factory Pattern）是一種創建型設計模式，它提供了一種「創建一系列相關或相互依賴對象」的接口，而無需指定具體的類別。該模式允許客戶端使用抽象接口來創建一組相關的對象，而不必關心實際的對象實現細節。抽象工廠模式的目標是實現產品族的創建，其中產品族是指「一組相互關聯的產品」，這些產品之間有共同的約束或邏輯關係。抽象工廠模式使得系統更具靈活性，易於切換產品族，而不需要修改客戶端程式。總的來說，抽象工廠魔是總共由四個核心部分組成：抽象工廠（Abstract Factory）：定義創建產品族的接口，通常由一個抽像類或接口來表示。該接口包含多個抽象方法，每個方法用於創建一個具體產品。具體工廠（Concrete Factory）：實現【抽象工廠】中的接口，負責創建具體的產品對象。抽象產品（Abstract Product）：定義產品族中的某類產品的接口，可以是抽象類別或接口。具體產品（Concrete Product）：實現【抽象產品】中的接口，負責定義實際產品的樣貌與屬性，【具體工廠】會創建這些產品的實例。
維基百科：抽象工廠模式（Abstract factory pattern）是一種軟體開發設計模式。抽象工廠模式提供了一種方式，可以將一組具有同一主題的單獨的工廠封裝起來。在正常使用中，客戶端程式需要建立抽象工廠的具體實現，然後使用抽象工廠作為介面來建立這一主題的具體對象。客戶端程式不需要知道（也不需要關心）它從這些內部的工廠方法中獲得對象的具體類型，因為客戶端程式僅使用這些對象的通用介面。抽象工廠模式將「一組對象的實現細節」與「它們的使用」分離開來。【工廠】類別是建立產品的地方，其目的是將產品的建立與產品的使用分離。抽象工廠模式的目的，是將若干抽象產品的介面，與不同主題產品的具體實現分離開。這樣就能在增加新的具體工廠的時候，不用修改參照抽象工廠的客戶端代碼。使用抽象工廠模式，能夠在具體工廠變化的時候，不用修改使用工廠的客戶端代碼，甚至是在執行時。然而，使用這種模式或者相似的設計模式，可能給編寫代碼帶來不必要的複雜性和額外的工作。
特點 將物件的「創建」與「使用」分離 可以輕易擴展 符合開放封閉原則 UML Graphic classDiagramclass MonsterMonster &lt;|-- ZombieMonster &lt;|-- GoblinMonster &lt;|-- Skeletonclass WeaopnWeaopn &lt;|-- SwordWeaopn &lt;|-- AxeWeaopn &lt;|-- BowclassDiagramclass MonsterFactory {Monster* create();}class ZombieFactory {Monster* create() new Zombie()}class GoblinFactory {Monster* create() new Goblin()}class SkeletonFactory {Monster* create() new Skeleton()}MonsterFactory &lt;|-- ZombieFactoryMonsterFactory &lt;|-- GoblinFactoryMonsterFactory &lt;|-- SkeletonFactoryclassDiagramclass WeaponFactory {Weapon* create();}class SwordFactory {Weapon* create() new Sword()}class AxeFactory {Weapon* create() new Axe()}class BowFactory {Weapon* create() new Bow()}WeaponFactory &lt;|-- SwordFactoryWeaponFactory &lt;|-- AxeFactoryWeaponFactory &lt;|-- BowFactoryclassDiagramclass AdvancedMonster {Monster* createAdvancedMonster();}note &#34;">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="抽象工廠模式（Abstract Factory Pattern）" />
<meta property="og:description" content="抽象工廠模式（Abstract Factory Pattern）#說明 ChatGPT：抽象工廠模式（Abstract Factory Pattern）是一種創建型設計模式，它提供了一種「創建一系列相關或相互依賴對象」的接口，而無需指定具體的類別。該模式允許客戶端使用抽象接口來創建一組相關的對象，而不必關心實際的對象實現細節。抽象工廠模式的目標是實現產品族的創建，其中產品族是指「一組相互關聯的產品」，這些產品之間有共同的約束或邏輯關係。抽象工廠模式使得系統更具靈活性，易於切換產品族，而不需要修改客戶端程式。總的來說，抽象工廠魔是總共由四個核心部分組成：抽象工廠（Abstract Factory）：定義創建產品族的接口，通常由一個抽像類或接口來表示。該接口包含多個抽象方法，每個方法用於創建一個具體產品。具體工廠（Concrete Factory）：實現【抽象工廠】中的接口，負責創建具體的產品對象。抽象產品（Abstract Product）：定義產品族中的某類產品的接口，可以是抽象類別或接口。具體產品（Concrete Product）：實現【抽象產品】中的接口，負責定義實際產品的樣貌與屬性，【具體工廠】會創建這些產品的實例。
維基百科：抽象工廠模式（Abstract factory pattern）是一種軟體開發設計模式。抽象工廠模式提供了一種方式，可以將一組具有同一主題的單獨的工廠封裝起來。在正常使用中，客戶端程式需要建立抽象工廠的具體實現，然後使用抽象工廠作為介面來建立這一主題的具體對象。客戶端程式不需要知道（也不需要關心）它從這些內部的工廠方法中獲得對象的具體類型，因為客戶端程式僅使用這些對象的通用介面。抽象工廠模式將「一組對象的實現細節」與「它們的使用」分離開來。【工廠】類別是建立產品的地方，其目的是將產品的建立與產品的使用分離。抽象工廠模式的目的，是將若干抽象產品的介面，與不同主題產品的具體實現分離開。這樣就能在增加新的具體工廠的時候，不用修改參照抽象工廠的客戶端代碼。使用抽象工廠模式，能夠在具體工廠變化的時候，不用修改使用工廠的客戶端代碼，甚至是在執行時。然而，使用這種模式或者相似的設計模式，可能給編寫代碼帶來不必要的複雜性和額外的工作。
特點 將物件的「創建」與「使用」分離 可以輕易擴展 符合開放封閉原則 UML Graphic classDiagramclass MonsterMonster &lt;|-- ZombieMonster &lt;|-- GoblinMonster &lt;|-- Skeletonclass WeaopnWeaopn &lt;|-- SwordWeaopn &lt;|-- AxeWeaopn &lt;|-- BowclassDiagramclass MonsterFactory {Monster* create();}class ZombieFactory {Monster* create() new Zombie()}class GoblinFactory {Monster* create() new Goblin()}class SkeletonFactory {Monster* create() new Skeleton()}MonsterFactory &lt;|-- ZombieFactoryMonsterFactory &lt;|-- GoblinFactoryMonsterFactory &lt;|-- SkeletonFactoryclassDiagramclass WeaponFactory {Weapon* create();}class SwordFactory {Weapon* create() new Sword()}class AxeFactory {Weapon* create() new Axe()}class BowFactory {Weapon* create() new Bow()}WeaponFactory &lt;|-- SwordFactoryWeaponFactory &lt;|-- AxeFactoryWeaponFactory &lt;|-- BowFactoryclassDiagramclass AdvancedMonster {Monster* createAdvancedMonster();}note &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fonu195713.github.io/docs/computer_science/design_pattern/abstract_factory_pattern/" /><meta property="article:section" content="docs" />


<title>抽象工廠模式（Abstract Factory Pattern） | Fonu Site</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.b54adc0d1f3cdbd5dd5cddc405501c63daae88faf5272c571655f8ba52e6e6fa.css" integrity="sha256-tUrcDR8829XdXN3EBVAcY9quiPr1JyxXFlX4ulLm5vo=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.ef8aba15fc3c96d7e294fdf955d3686086bf1d9ade8e677ae1a9e7260296eca3.js" integrity="sha256-74q6Ffw8ltfilP35VdNoYIa/HZrejmd64annJgKW7KM=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <meta http-equiv="Permissions-Policy" content="interest-cohort=()">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js" integrity="sha512-8pbzenDolL1l5OPSsoURCx9TEdMFTaeFipASVrMYKhuYtly+k3tcsQYliOEKTmuB1t7yuzAiVo+yd7SJz+ijFQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Fonu Site</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f4362153a9424eb450dd350e64dfffc7" class="toggle"  />
    <label for="section-f4362153a9424eb450dd350e64dfffc7" class="flex justify-between">
      <a role="button" class="">生活相關</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/working_log/" class="">［置頂］工作日誌</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/to_do_list/" class="">［置頂］待辦事項</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5f16b5923caa653815be6bb5f018b2f0" class="toggle"  />
    <label for="section-5f16b5923caa653815be6bb5f018b2f0" class="flex justify-between">
      <a role="button" class="">人生節點</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/nodes/masters_degree/" class="">碩士的畢業證書</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-68339e45fbc633241628720af6b731c7" class="toggle"  />
    <label for="section-68339e45fbc633241628720af6b731c7" class="flex justify-between">
      <a role="button" class="">日常札記</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/xinxinmota/" class="">新新魔塔 v2.6.6</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/heart_sutra_beforehand/" class="">一千份的手抄心經</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/japan/" class="">日本旅行 7 萬步</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-37b9dc15f655a4535748c0ebbd58c56b" class="toggle"  />
    <label for="section-37b9dc15f655a4535748c0ebbd58c56b" class="flex justify-between">
      <a role="button" class="">閱讀心得</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/reading_experience/head_first_design_pattern/" class="">《深入淺出設計模式》</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-65fbf0e97cd47327287d9b0d7cc4b6ee" class="toggle" checked />
    <label for="section-65fbf0e97cd47327287d9b0d7cc4b6ee" class="flex justify-between">
      <a role="button" class="">資訊工程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/recommended_books/" class="">推薦書單</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3975d187eb6b0c47dcb29d31a654027a" class="toggle" checked />
    <label for="section-3975d187eb6b0c47dcb29d31a654027a" class="flex justify-between">
      <a href="/docs/computer_science/design_pattern/" class="">設計模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/mediator_pattern/" class="">中介者模式（Mediator Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/flyweight_pattern/" class="">享元模式（Flyweight Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/proxy_pattern/" class="">代理模式（Proxy Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/prototype_pattern/" class="">原型模式（Prototype Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/command_pattern/" class="">命令模式（Command Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/singleton_pattern/" class="">單例模式（Singleton Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/facade_pattern/" class="">外觀模式（Facade Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/factory_method_pattern/" class="">工廠方法模式（Factory Method Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/abstract_factory_pattern/" class="active">抽象工廠模式（Abstract Factory Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/template_method_pattern/" class="">模板方法模式（Template Method Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/bridge_pattern/" class="">橋接模式（Bridge Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/state_pattern/" class="">狀態模式（State Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/builder_pattern/" class="">生成器模式（Builder Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/strategy_pattern/" class="">策略模式（Strategy Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/simple_factory_pattern/" class="">簡單工廠模式（Simple Factory Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/composite_pattern/" class="">組合模式（Composite Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/decorator_pattern/" class="">裝飾器模式（Decorator Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/observer_pattern/" class="">觀察者模式（Observer Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/interpreter_pattern/" class="">解釋器模式（Interpreter Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/visitor_pattern/" class="">訪問者模式（Visitor Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/chain_of_responsibility_pattern/" class="">責任鏈模式（Chain of Responsibility Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/iterator_pattern/" class="">迭代器模式（Iterator Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/adapter_pattern/" class="">適配器模式（Adapter Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/interface_segregation_principle/" class="">介面隔離原則（Interface Segregation Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/dependency_inversion_principle/" class="">依賴反轉原則（Dependency Inversion Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/" class="">合成/聚合複用原則（Composite/Aggregate Reuse Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/single_responsibility_principle/" class="">單一職責原則（Single Responsibility Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/least_knowledge_principle/" class="">最少知識原則（Least Knowledge Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/liskov_substitution_principle/" class="">里式替換原則（Liskov Substitution Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/open_closed_principle/" class="">開放封閉原則（Open Closed Principle）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-1a4dbc7dea1f032b131bd8b36ee77901" class="toggle"  />
    <label for="section-1a4dbc7dea1f032b131bd8b36ee77901" class="flex justify-between">
      <a role="button" class="">宗教命理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-19690d2784a95bdc527a8beb46f9ad15" class="toggle"  />
    <label for="section-19690d2784a95bdc527a8beb46f9ad15" class="flex justify-between">
      <a href="/docs/fortune_telling/tarot/" class="">偉特塔羅</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/fortune_telling/tarot/daily_log/" class="">［置頂］每日一翻</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-757e6157ed0a4d3981b7c5e4754c7bc2" class="toggle"  />
    <label for="section-757e6157ed0a4d3981b7c5e4754c7bc2" class="flex justify-between">
      <a role="button" class="">自由創作</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>抽象工廠模式（Abstract Factory Pattern）</strong>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
  <article class="markdown"><h1 id="抽象工廠模式abstract-factory-pattern">
  抽象工廠模式（Abstract Factory Pattern）
  <a class="anchor" href="#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%bb%a0%e6%a8%a1%e5%bc%8fabstract-factory-pattern">#</a>
</h1>
<hr>
<ul>
<li><strong>說明</strong></li>
</ul>
<p><strong>ChatGPT</strong>：抽象工廠模式（Abstract Factory Pattern）是一種創建型設計模式，它提供了一種「創建一系列相關或相互依賴對象」的接口，而無需指定具體的類別。該模式允許客戶端使用抽象接口來創建一組相關的對象，而不必關心實際的對象實現細節。抽象工廠模式的目標是實現產品族的創建，其中產品族是指「一組相互關聯的產品」，這些產品之間有共同的約束或邏輯關係。抽象工廠模式使得系統更具靈活性，易於切換產品族，而不需要修改客戶端程式。總的來說，抽象工廠魔是總共由四個核心部分組成：抽象工廠（Abstract Factory）：定義創建產品族的接口，通常由一個抽像類或接口來表示。該接口包含多個抽象方法，每個方法用於創建一個具體產品。具體工廠（Concrete Factory）：實現【抽象工廠】中的接口，負責創建具體的產品對象。抽象產品（Abstract Product）：定義產品族中的某類產品的接口，可以是抽象類別或接口。具體產品（Concrete Product）：實現【抽象產品】中的接口，負責定義實際產品的樣貌與屬性，【具體工廠】會創建這些產品的實例。</p>
<p><strong>維基百科</strong>：抽象工廠模式（Abstract factory pattern）是一種軟體開發設計模式。抽象工廠模式提供了一種方式，可以將一組具有同一主題的單獨的工廠封裝起來。在正常使用中，客戶端程式需要建立抽象工廠的具體實現，然後使用抽象工廠作為介面來建立這一主題的具體對象。客戶端程式不需要知道（也不需要關心）它從這些內部的工廠方法中獲得對象的具體類型，因為客戶端程式僅使用這些對象的通用介面。抽象工廠模式將「一組對象的實現細節」與「它們的使用」分離開來。【工廠】類別是建立產品的地方，其目的是將產品的建立與產品的使用分離。抽象工廠模式的目的，是將若干抽象產品的介面，與不同主題產品的具體實現分離開。這樣就能在增加新的具體工廠的時候，不用修改參照抽象工廠的客戶端代碼。使用抽象工廠模式，能夠在具體工廠變化的時候，不用修改使用工廠的客戶端代碼，甚至是在執行時。然而，使用這種模式或者相似的設計模式，可能給編寫代碼帶來不必要的複雜性和額外的工作。</p>
<hr>
<ul>
<li><strong>特點</strong></li>
</ul>
<ol>
<li>將物件的「創建」與「使用」分離</li>
<li>可以輕易擴展</li>
<li>符合開放封閉原則</li>
</ol>
<hr>
<ul>
<li><strong>UML Graphic</strong></li>
</ul>


<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
</script>

  <script>mermaid.initialize({
  "flowchart": {
    "useMaxWidth":true
  },
  "theme": "default"
}
)</script>




<p class="mermaid">
classDiagram
    class Monster
    Monster <|-- Zombie
    Monster <|-- Goblin
    Monster <|-- Skeleton
    
    class Weaopn
    Weaopn <|-- Sword
    Weaopn <|-- Axe
    Weaopn <|-- Bow
</p>



<p class="mermaid">
classDiagram
    class MonsterFactory {
        Monster* create();
    }

    class ZombieFactory {
        Monster* create() new Zombie()
    }

    class GoblinFactory {
        Monster* create() new Goblin()
    }

    class SkeletonFactory {
        Monster* create() new Skeleton()
    }

    MonsterFactory <|-- ZombieFactory
    MonsterFactory <|-- GoblinFactory
    MonsterFactory <|-- SkeletonFactory
</p>



<p class="mermaid">
classDiagram
    class WeaponFactory {
        Weapon* create();
    }

    class SwordFactory {
        Weapon* create() new Sword()
    }

    class AxeFactory {
        Weapon* create() new Axe()
    }

    class BowFactory {
        Weapon* create() new Bow()
    }

    WeaponFactory <|-- SwordFactory
    WeaponFactory <|-- AxeFactory
    WeaponFactory <|-- BowFactory
</p>



<p class="mermaid">
classDiagram
    class AdvancedMonster {
        Monster* createAdvancedMonster();
    }

    note "Monster* createAdvancedMonster() {\n　Monster* monster = MonsterFactory.create();\n　Weapon* weapon = WeaponFactory.create();\n　monster.equip(weapon);\n　return monster;\n}"
</p>

<hr>
<ul>
<li><strong>內文</strong></li>
</ul>
<p>小建議：可以先看過<a href="/docs/computer_science/design_pattern/simple_factory_pattern/">簡單工廠模式</a>，和<a href="/docs/computer_science/design_pattern/factory_method_pattern/">工廠方法模式</a>，再回來看這個「抽象工廠模式」比較好。</p>
<p>在程式的架構上，「抽象工廠模式」是三種工廠模式裡面最為複雜的一種。不同於<a href="/docs/computer_science/design_pattern/simple_factory_pattern/">簡單工廠模式</a>僅僅是將生成產品的程式從【客戶】的類別中，拉到新增的【工廠】類別。也不同於<a href="/docs/computer_science/design_pattern/factory_method_pattern/">工廠方法模式</a>定義了一個抽象的【工廠】，再藉由實作不同種類的【實體工廠】以生成各式各樣的【實體產品】。「抽象工廠模式」則是從「工廠方法模式」去做延伸，不僅僅將【工廠】抽象化，同時也將【產品】進行了抽象化，讓兩者都可以在最大程度上，都可以解除對另外一方的依賴，以解決<a href="/docs/computer_science/design_pattern/simple_factory_pattern/">簡單工廠模式</a>和<a href="/docs/computer_science/design_pattern/factory_method_pattern/">工廠方法模式</a>都存在的「類別依賴」問題。</p>
<p>假設我們現在在製作一個 RPG 遊戲，遊戲的中後期階段，玩家會遇上一些比較高階的怪物，但這些怪物說穿了就是配備武器的普通怪物。如果是利用「簡單工廠模式」來實作這樣的怪物的話，可能會寫出類似於下面的程式出來：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MonsterFactory</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> createAdvancedMonster<span style="color:#f92672">(</span>Monster monster<span style="color:#f92672">,</span> string weapon<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            Monster advanced_monster <span style="color:#f92672">=</span> nullptr
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">switch</span><span style="color:#f92672">(</span>monster<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">case</span> Zombie<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                    advanced_monster <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Zombie<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>weapon <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Sword&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                        advanced_monster<span style="color:#f92672">.</span><span style="color:#a6e22e">equip</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Sword<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>weapon <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Axe&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                        advanced_monster<span style="color:#f92672">.</span><span style="color:#a6e22e">equip</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Axe<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>weapon <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Bow&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                        advanced_monster<span style="color:#f92672">.</span><span style="color:#a6e22e">equip</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Bow<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">case</span> Goblin<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                    advanced_monster <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Goblin<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>weapon <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Sword&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                        advanced_monster<span style="color:#f92672">.</span><span style="color:#a6e22e">equip</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Sword<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>weapon <span style="color:#f92672">...)</span>
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// other codes ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> advanced_monster<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">};</span>
</span></span></code></pre></div><p>簡單來說，「簡單工廠」的做法就是最純粹的各種判斷暴力破解。</p>
<p>相對於簡單工廠，「工廠方法」的實作模式會再稍微有彈性一點點：工廠方法的做法會是先把所有的怪物拉出來獨立做一個【怪物】的工廠，再讓各種不同的【殭屍工廠】、【哥布林工廠】、【骷髏工廠】&hellip;等去實作進階怪物的樣式。整體而言，雖然加了一點抽象化，增加類別的數量，但程式會變得比較好懂：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MonsterFactory</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> monster;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">virtual</span> Monster<span style="color:#f92672">*</span> equipSword() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">virtual</span> Monster<span style="color:#f92672">*</span> <span style="color:#a6e22e">equipAxe</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">virtual</span> Monster<span style="color:#f92672">*</span> <span style="color:#a6e22e">equipBow</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ZombieFactory</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MonsterFactory {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        ZombieFactory() <span style="color:#f92672">:</span> monster(<span style="color:#66d9ef">new</span> Zombie()) {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> equipSword() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> monster.equip(<span style="color:#66d9ef">new</span> Sword());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> <span style="color:#a6e22e">equipAxe</span>() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> monster.equip(<span style="color:#66d9ef">new</span> Axe());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> <span style="color:#a6e22e">equipBow</span>() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> monster.equip(<span style="color:#66d9ef">new</span> Bow());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MonsterGenerator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> monster_factory;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> getSwordMonster() {
</span></span><span style="display:flex;"><span>            monster_factory <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ZombieFactory();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> monster_factory.equipSword();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">changeMonsterFactory</span>(MonsterFactory<span style="color:#f92672">*</span> factory) {
</span></span><span style="display:flex;"><span>            monster_factory <span style="color:#f92672">=</span> factory;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>在「工廠方法」裡面，我們會需要定義「抽象工廠」、「具體工廠」、和「產品」三種東西。在上述的程式邏輯中，抽象工廠就是【怪物工廠】。具體工廠是【殭屍工廠】【哥布林工廠】&hellip;等，產品則是【武器】。根據「工廠方法」的特性，抽象工廠中會有許多製造產品的方法，在這個例子裡就是「怪物裝備劍」「怪物裝備斧」「怪物裝備弓」&hellip;等不同的高階怪物。實體工廠則負責這些產品的製作流程，因此【殭屍工廠】裡才會改寫【怪物工廠】裡面的方法。</p>
<p>最後，我們會有一個【客戶】類別，用來接收不同的高階怪物，在這裡，客戶就是 <code>MonsterGenerator</code>。還記得嗎？剛剛說過：「產品是武器。」因此在這樣的架構下，我們不關心是何種怪物拿著武器，只關心<strong>怪物拿著什麼武器</strong>。所以通過調用 <code>getSwordMonster()</code> 方法，我們可以直接拿到一個「手中有劍的一隻怪物。」這就是「工廠方法模式」在生成高階怪物的時候的邏輯。</p>
<p>同樣地，「工廠方法」相對於「簡單工廠」來說，在沒有複雜判斷的情況下，可以滿足「單一職責原則」與「開放封閉原則」但工廠方法的缺點同樣也有著「類別依賴」的問題。如果今天的【產品】驟增（怪物突然可以拿上百種的武器），那麼【怪物工廠】需要依賴的對象就不僅僅只有 <code>Sword</code>, <code>Axe</code>, <code>Bow</code> 那麼簡單了&hellip;，因此為了解決這個問題，我們可以利用「抽象工廠模式」來達成這份任務：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Monster</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Zombie</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Monster {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Goblin</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Monster {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Skeleton</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Monster {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MonsterFactory</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">virtual</span> Monster<span style="color:#f92672">*</span> createMonster() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ZombieFactory</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MonsterFactory {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> createMonster() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">new</span> Zombie());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GoblinFactory</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MonsterFactory {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> createMonster() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">new</span> Goblin());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SkeletonFactory</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MonsterFactory {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> createMonster() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">new</span> Skeleton());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Weapon</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sword</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Weapon {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Axe</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Weapon {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Box</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Weapon {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeaopnFactory</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">virtual</span> Weapon<span style="color:#f92672">*</span> createWeapon() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SwordFactory</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> WeaopnFactory {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Weapon<span style="color:#f92672">*</span> createWeapon() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">new</span> Sword());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AxeFactory</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> WeaopnFactory {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Weapon<span style="color:#f92672">*</span> createWeapon() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">new</span> Sword());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BowFactory</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> WeaopnFactory {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Weapon<span style="color:#f92672">*</span> createWeapon() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">new</span> Sword());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AdvancedMonsterGenerator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Monster<span style="color:#f92672">*</span> createAdvancedMonster(MonsterFactory<span style="color:#f92672">*</span> mf, WeaopnFactory<span style="color:#f92672">*</span> wf) {
</span></span><span style="display:flex;"><span>            Monster<span style="color:#f92672">*</span> monster <span style="color:#f92672">=</span> monster_factory <span style="color:#f92672">-&gt;</span> createMonster();
</span></span><span style="display:flex;"><span>            Weapon<span style="color:#f92672">*</span> weapon <span style="color:#f92672">=</span> weapon_factory <span style="color:#f92672">-&gt;</span> createWeapon();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> monster.equip(Weapon);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>同樣也是「怪物工廠、武器產品」的邏輯，在「抽象工廠方法」的解決方案中，我們總共定義了五個東西：分別是【抽象工廠】（<code>MonsterFactory</code>）、【實體工廠】（<code>ZombieFactory</code>, <code>GoblinFactory</code>, <code>SkeletonFactory</code>）、【抽象產品】（<code>Weapon</code>）、【實體產品】（<code>Sword</code>, <code>Axe</code>, <code>Box</code>）、和【客戶】（<code>AdvancedMonsterGenerator</code>）。</p>
<p>在「抽象工廠」中，【客戶】在 <code>createAdvancedMonster()</code> 的方法中，並不需要直接知道它會用到哪個【怪物工廠】（可能是殭屍？可能是骷髏&hellip;），以及怪物會被裝備哪一種類型的武器（劍？還是斧？抑或是弓&hellip;）整體而言，它只知道「會有一個工廠，把怪物生出來。然後會有另外一個工廠，幫我把這隻怪物配上武器。」整體的實作流程被工廠封裝的死死地，使得客戶對所有的細節完全無法理解，極度概念化與抽象化，這就是「抽象工廠模式」想要傳達的意涵。</p>
<ul>
<li><strong>比較</strong></li>
</ul>
<ol>
<li>簡單工廠模式（Simple Factory Pattern）</li>
</ol>
<p>「簡單工廠模式」通過新增一個【工廠】類別來創建對象，【客戶】無需關心【產品】的實現流程與步驟，只需要提供給【工廠】參數或條件，讓【工廠】可以根據參數或條件創建對應的【產品】。此外，因為簡單工廠的【工廠】中，通常會使用個靜態方法來生成產品，因此也被稱為「靜態工廠模式」。然而，隨著【產品】的增加，「簡單工廠模式」的【工廠】可能會變得龐大，產生類別依賴的問題，同時，「簡單工廠模式」也不符合「開放封閉原則」。如果【產品】類型有做更動，【工廠】的方法也需要進行調整。</p>
<ol start="2">
<li>工廠方法模式（Factory Method Pattern）</li>
</ol>
<p>「工廠方法模式」透過將工廠區分成【抽象工廠】與【實體工廠】來達成「簡單工廠模式」不符合的「開放封閉原則」。在工廠方法模式中，每一個產品的生成，都先被定義在【抽象工廠】的方法之中。【實體工廠】只需要繼承並改寫該方法即可。不同【產品】之間的程式並不會相互影響，因此不會產生「新增或刪除一個產品，就會需要修改工廠中的所有方法」的情況。但同時，因為【產品】還是會直接在【實體工廠】中製作，因此當【產品】的數量過多時，同樣也會產生類別依賴的問題。這是該模式與簡單工廠模式都存在的既定問題。</p>
<ol start="3">
<li>抽象工廠模式（Abstract Factory Pattern）</li>
</ol>
<p>「抽象工廠」模式將整體流程定義成【抽象工廠】【實體工廠】【抽象產品】【實體產品】與【客戶】五項類別。【抽象工廠】負責定義【實體工廠】可能會需要的所有方法。【抽象產品】則定義【實體產品】中的各種係數，本質上兩者沒有過多的關聯。最後再由【客戶】分別透過【抽象工廠】的接口，與【抽象產品】的接口，去得到想要的【實體產品】。由於該模式本身的架構，無論是【實體工廠】還是【實體產品】，都不會對彼此帶有依賴。因此解決掉了前兩種模式中都無法改善的類別依賴問題。但與之相對的，「抽象工廠模式」也是需要最多類別實踐、以及擁有最複雜程式邏輯的工廠模式。</p>
<hr>
<ul>
<li><strong>簡單來說</strong>
<ul>
<li>簡單工廠模式：適合【工廠】跟【產品】兩種類別「皆無需要」擴增與更動的情況。</li>
<li>工廠方法模式：適合【工廠】或【產品】兩種類別「其一需要」擴增與更動的情況。</li>
<li>抽象工廠模式：適合【工廠】跟【產品】兩種類別「皆有需要」擴增與更動的情況。</li>
</ul>
</li>
</ul>
<p>沒有最完美的模式，只有最適合某種情境的設計模式。</p>
</article>
 
      <div id="gitalk-container"></div>

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  </main>

  <script>
    const elements = document.getElementsByClassName("markdown");

    Array.from(elements).forEach(element => {
        const links = element.getElementsByTagName("a");
        Array.from(links).forEach(link => {
        link.target = "_blank";
        });
    });
</script>

<script>
    const gitalk = new Gitalk({
        clientID: '91e953a7402d79bcef6c',
        clientSecret: '22897328fab72d26e1f3a88e83ab654467232514',
        repo: 'fonu195713.github.io',     
        owner: 'fonu195713',
        admin: ['fonu195713'],
        distractionFreeMode:  false ,  
        pagerDirection: 'last',
        language: 'zh-TW',
        createIssueManually:  false ,
        enableHotKey:  true ,
        id: md5(location.pathname),      
    });
    gitalk.render('gitalk-container');
</script>
</body>
</html>












