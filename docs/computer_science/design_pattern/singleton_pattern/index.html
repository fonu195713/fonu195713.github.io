<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="單例模式（Singleton Pattern）#說明 ChatGPT：單例模式（Singleton Pattern）是一種創建型設計模式，它確保一個類別只有一個唯一的實例，並提供一個全局的訪問點來訪問該實例。單例模式確保一個類別只有一個實例，並且提供全局的訪問點來訪問該實例。實現單例模式的一種常見方式是使用一個私有的靜態成員變量來存儲類別的唯一實例，並提供一個公共的靜態方法來獲取這個實例。在這個方法中，方法首先會檢查實例是否已經存在？如果存在，則返回該實例，否則創建一個新的實例並返回。此外，為了防止通過其他途徑創建額外的實例。單例模式會將類別的構造函數設為私有。
維基百科：單例模式（Singleton Pattern）也叫單子模式，是一種常用的軟體設計模式，屬於創建型模式的一種。在應用這個模式時，單例對象的類必須保證只有一個實例存在。實現單例模式的思路是：一個類僅能返回對象一個引用（永遠是同一個）和一個獲得該實例的方法（必須是靜態方法，通常使用 getInstance() 這個名稱）；當我們調用這個方法時，如果類持有的引用不為空就返回這個引用，如果類保持的引用為空就創建該類的實例，並將實例的引用賦予該類保持的引用；同時我們還將該類的構造函數定義為私有方法，這樣其他處的代碼就無法通過調用該類的構造函數來實例化該類的對象，只有通過該類提供的靜態方法來得到該類的唯一實例。
特點 可以確保一個類別只會生成一個物件 提供簡易的接口，讓程式對實例的訪問與操作更為簡單 可以延遲實例，僅在需要時才創建，節省資源使用 UML Graphic classDiagramclass Singleton {static Singleton obj;static Singleton* getInstance();}內文 單例模式是一個很簡單的概念，就是「單一類別，只會生成單一物件（也就是單一實例）的一種設計模式。」雖說概念很簡單，但實作起來，還是有點眉角在裡面的。在直覺上的想法中，「透過私有的建構子，讓生成物件的權限只限制給類別本身」「『靜態變數』是讓類別中所有物件共用的一個變數」這兩個想法，就可以生成一個簡單的單例模式的程式了，就如下方所示：
class Singleton { static Singleton* obj; private: Singleton() {} public: static Singleton* getInstance() { if(obj == nullptr) { obj = new Singleton(); } return obj; } }; Singleton::obj = nullptr; 在上方的程式中，透過將 Singleton() 建構子宣告成私有的方式，來讓「生成物件」這項工作只有 Singleton 類本身能夠做到，接著讓 obj 初始化成 nullptr，並在 getInstance() 中做一個 obj 的判斷，如果 obj == nullptr，那就生成一個 obj，否則就直接回傳 obj 的記憶體位址。透過這樣的寫法，可以保證 obj 只要一被生成，那麼 obj = new Singleton(); 這件事情就不會被執行，也就代表了一定程度上的「單一類別只會有單一實例」的任務。">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="單例模式（Singleton Pattern）" />
<meta property="og:description" content="單例模式（Singleton Pattern）#說明 ChatGPT：單例模式（Singleton Pattern）是一種創建型設計模式，它確保一個類別只有一個唯一的實例，並提供一個全局的訪問點來訪問該實例。單例模式確保一個類別只有一個實例，並且提供全局的訪問點來訪問該實例。實現單例模式的一種常見方式是使用一個私有的靜態成員變量來存儲類別的唯一實例，並提供一個公共的靜態方法來獲取這個實例。在這個方法中，方法首先會檢查實例是否已經存在？如果存在，則返回該實例，否則創建一個新的實例並返回。此外，為了防止通過其他途徑創建額外的實例。單例模式會將類別的構造函數設為私有。
維基百科：單例模式（Singleton Pattern）也叫單子模式，是一種常用的軟體設計模式，屬於創建型模式的一種。在應用這個模式時，單例對象的類必須保證只有一個實例存在。實現單例模式的思路是：一個類僅能返回對象一個引用（永遠是同一個）和一個獲得該實例的方法（必須是靜態方法，通常使用 getInstance() 這個名稱）；當我們調用這個方法時，如果類持有的引用不為空就返回這個引用，如果類保持的引用為空就創建該類的實例，並將實例的引用賦予該類保持的引用；同時我們還將該類的構造函數定義為私有方法，這樣其他處的代碼就無法通過調用該類的構造函數來實例化該類的對象，只有通過該類提供的靜態方法來得到該類的唯一實例。
特點 可以確保一個類別只會生成一個物件 提供簡易的接口，讓程式對實例的訪問與操作更為簡單 可以延遲實例，僅在需要時才創建，節省資源使用 UML Graphic classDiagramclass Singleton {static Singleton obj;static Singleton* getInstance();}內文 單例模式是一個很簡單的概念，就是「單一類別，只會生成單一物件（也就是單一實例）的一種設計模式。」雖說概念很簡單，但實作起來，還是有點眉角在裡面的。在直覺上的想法中，「透過私有的建構子，讓生成物件的權限只限制給類別本身」「『靜態變數』是讓類別中所有物件共用的一個變數」這兩個想法，就可以生成一個簡單的單例模式的程式了，就如下方所示：
class Singleton { static Singleton* obj; private: Singleton() {} public: static Singleton* getInstance() { if(obj == nullptr) { obj = new Singleton(); } return obj; } }; Singleton::obj = nullptr; 在上方的程式中，透過將 Singleton() 建構子宣告成私有的方式，來讓「生成物件」這項工作只有 Singleton 類本身能夠做到，接著讓 obj 初始化成 nullptr，並在 getInstance() 中做一個 obj 的判斷，如果 obj == nullptr，那就生成一個 obj，否則就直接回傳 obj 的記憶體位址。透過這樣的寫法，可以保證 obj 只要一被生成，那麼 obj = new Singleton(); 這件事情就不會被執行，也就代表了一定程度上的「單一類別只會有單一實例」的任務。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fonu195713.github.io/docs/computer_science/design_pattern/singleton_pattern/" /><meta property="article:section" content="docs" />


<title>單例模式（Singleton Pattern） | Fonu Site</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.b54adc0d1f3cdbd5dd5cddc405501c63daae88faf5272c571655f8ba52e6e6fa.css" integrity="sha256-tUrcDR8829XdXN3EBVAcY9quiPr1JyxXFlX4ulLm5vo=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.ed30a1dd6eafd1d47f13e0cb36215ac46df221107f111b2fcf8b4304dca4503c.js" integrity="sha256-7TCh3W6v0dR/E&#43;DLNiFaxG3yIRB/ERsvz4tDBNykUDw=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <meta http-equiv="Permissions-Policy" content="interest-cohort=()">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js" integrity="sha512-8pbzenDolL1l5OPSsoURCx9TEdMFTaeFipASVrMYKhuYtly+k3tcsQYliOEKTmuB1t7yuzAiVo+yd7SJz+ijFQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Fonu Site</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f4362153a9424eb450dd350e64dfffc7" class="toggle"  />
    <label for="section-f4362153a9424eb450dd350e64dfffc7" class="flex justify-between">
      <a role="button" class="">生活相關</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/working_log/" class="">［置頂］工作日誌</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/to_do_list/" class="">［置頂］待辦事項</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5f16b5923caa653815be6bb5f018b2f0" class="toggle"  />
    <label for="section-5f16b5923caa653815be6bb5f018b2f0" class="flex justify-between">
      <a role="button" class="">人生節點</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/nodes/masters_degree/" class="">碩士的畢業證書</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-68339e45fbc633241628720af6b731c7" class="toggle"  />
    <label for="section-68339e45fbc633241628720af6b731c7" class="flex justify-between">
      <a role="button" class="">日常札記</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/xinxinmota/" class="">新新魔塔 v2.6.6</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/heart_sutra_beforehand/" class="">一千份的手抄心經</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/osaka_3_days/" class="">日本旅行 7 萬步</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/notes/ask_buddha_for_advice/" class="">第 2 次的佛母問事</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-37b9dc15f655a4535748c0ebbd58c56b" class="toggle"  />
    <label for="section-37b9dc15f655a4535748c0ebbd58c56b" class="flex justify-between">
      <a href="/docs/daily_life/reading_experience/" class="">閱讀心得</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/daily_life/reading_experience/head_first_design_pattern/" class="">《深入淺出設計模式》</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-65fbf0e97cd47327287d9b0d7cc4b6ee" class="toggle" checked />
    <label for="section-65fbf0e97cd47327287d9b0d7cc4b6ee" class="flex justify-between">
      <a role="button" class="">資訊工程</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/recommended_books/" class="">推薦書單</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3975d187eb6b0c47dcb29d31a654027a" class="toggle" checked />
    <label for="section-3975d187eb6b0c47dcb29d31a654027a" class="flex justify-between">
      <a href="/docs/computer_science/design_pattern/" class="">設計模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/mediator_pattern/" class="">中介者模式（Mediator Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/flyweight_pattern/" class="">享元模式（Flyweight Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/proxy_pattern/" class="">代理模式（Proxy Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/prototype_pattern/" class="">原型模式（Prototype Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/command_pattern/" class="">命令模式（Command Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/singleton_pattern/" class="active">單例模式（Singleton Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/facade_pattern/" class="">外觀模式（Facade Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/factory_method_pattern/" class="">工廠方法模式（Factory Method Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/abstract_factory_pattern/" class="">抽象工廠模式（Abstract Factory Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/template_method_pattern/" class="">模板方法模式（Template Method Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/bridge_pattern/" class="">橋接模式（Bridge Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/state_pattern/" class="">狀態模式（State Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/builder_pattern/" class="">生成器模式（Builder Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/strategy_pattern/" class="">策略模式（Strategy Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/simple_factory_pattern/" class="">簡單工廠模式（Simple Factory Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/composite_pattern/" class="">組合模式（Composite Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/decorator_pattern/" class="">裝飾器模式（Decorator Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/observer_pattern/" class="">觀察者模式（Observer Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/interpreter_pattern/" class="">解釋器模式（Interpreter Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/visitor_pattern/" class="">訪問者模式（Visitor Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/chain_of_responsibility_pattern/" class="">責任鏈模式（Chain of Responsibility Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/iterator_pattern/" class="">迭代器模式（Iterator Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/adapter_pattern/" class="">適配器模式（Adapter Pattern）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/interface_segregation_principle/" class="">介面隔離原則（Interface Segregation Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/dependency_inversion_principle/" class="">依賴反轉原則（Dependency Inversion Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/" class="">合成/聚合複用原則（Composite/Aggregate Reuse Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/single_responsibility_principle/" class="">單一職責原則（Single Responsibility Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/least_knowledge_principle/" class="">最少知識原則（Least Knowledge Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/liskov_substitution_principle/" class="">里式替換原則（Liskov Substitution Principle）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/computer_science/design_pattern/open_closed_principle/" class="">開放封閉原則（Open Closed Principle）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-1a4dbc7dea1f032b131bd8b36ee77901" class="toggle"  />
    <label for="section-1a4dbc7dea1f032b131bd8b36ee77901" class="flex justify-between">
      <a role="button" class="">宗教命理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-19690d2784a95bdc527a8beb46f9ad15" class="toggle"  />
    <label for="section-19690d2784a95bdc527a8beb46f9ad15" class="flex justify-between">
      <a href="/docs/fortune_telling/tarot/" class="">偉特塔羅</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/fortune_telling/tarot/daily_log/" class="">［置頂］每日一翻</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-864e224496c434788eb81e9c00014c73" class="toggle"  />
    <label for="section-864e224496c434788eb81e9c00014c73" class="flex justify-between">
      <a href="/docs/fortune_telling/tarot/meaning/" class="">牌意解析</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-757e6157ed0a4d3981b7c5e4754c7bc2" class="toggle"  />
    <label for="section-757e6157ed0a4d3981b7c5e4754c7bc2" class="flex justify-between">
      <a role="button" class="">自由創作</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-23c1c82952b3319dfd43505af2b9e2b1" class="toggle"  />
    <label for="section-23c1c82952b3319dfd43505af2b9e2b1" class="flex justify-between">
      <a role="button" class="">小說相關</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/creative_writing/novel/note/" class="">［置頂］0 號手稿的筆記</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-60d4ebcd6c164d340b1d7189c38a8df4" class="toggle"  />
    <label for="section-60d4ebcd6c164d340b1d7189c38a8df4" class="flex justify-between">
      <a href="/docs/creative_writing/novel/new_write/" class="">套牢仔的新連載</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-cb235bd036abdb9662e3601dcf76f3e0" class="toggle"  />
    <label for="section-cb235bd036abdb9662e3601dcf76f3e0" class="flex justify-between">
      <a role="button" class="">第 01 章</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/creative_writing/novel/new_write/ch01/01/" class="">不速之客的打擾 - 1</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/creative_writing/novel/new_write/ch01/02/" class="">不速之客的打擾 - 2</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/creative_writing/novel/new_write/ch01/03/" class="">白髮精靈 - 1</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/creative_writing/novel/new_write/ch01/04/" class="">白髮精靈 - 2</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/creative_writing/novel/new_write/ch01/05/" class="">白髮精靈 - 3</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3c2cdaded05b3242a7bd0b086945efa1" class="toggle"  />
    <label for="section-3c2cdaded05b3242a7bd0b086945efa1" class="flex justify-between">
      <a role="button" class="">劇透區</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/creative_writing/novel/new_write/note/worldview/" class="">（據透）小說世界觀</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/creative_writing/novel/new_write/note/note/" class="">（據透）筆記區</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-7ff3a1315befa34720796dd8959dd1aa" class="toggle"  />
    <label for="section-7ff3a1315befa34720796dd8959dd1aa" class="flex justify-between">
      <a href="/docs/creative_writing/novel/new_write/note/character/" class="">人物列表</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/creative_writing/code_projects/" class="">程式作品</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>單例模式（Singleton Pattern）</strong>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
  <article class="markdown"><h1 id="單例模式singleton-pattern">
  單例模式（Singleton Pattern）
  <a class="anchor" href="#%e5%96%ae%e4%be%8b%e6%a8%a1%e5%bc%8fsingleton-pattern">#</a>
</h1>
<hr>
<ul>
<li><strong>說明</strong></li>
</ul>
<p><strong>ChatGPT</strong>：單例模式（Singleton Pattern）是一種創建型設計模式，它確保一個類別只有一個唯一的實例，並提供一個全局的訪問點來訪問該實例。單例模式確保一個類別只有一個實例，並且提供全局的訪問點來訪問該實例。實現單例模式的一種常見方式是使用一個私有的靜態成員變量來存儲類別的唯一實例，並提供一個公共的靜態方法來獲取這個實例。在這個方法中，方法首先會檢查實例是否已經存在？如果存在，則返回該實例，否則創建一個新的實例並返回。此外，為了防止通過其他途徑創建額外的實例。單例模式會將類別的構造函數設為私有。</p>
<p><strong>維基百科</strong>：單例模式（Singleton Pattern）也叫單子模式，是一種常用的軟體設計模式，屬於創建型模式的一種。在應用這個模式時，單例對象的類必須保證只有一個實例存在。實現單例模式的思路是：一個類僅能返回對象一個引用（永遠是同一個）和一個獲得該實例的方法（必須是靜態方法，通常使用 <code>getInstance()</code> 這個名稱）；當我們調用這個方法時，如果類持有的引用不為空就返回這個引用，如果類保持的引用為空就創建該類的實例，並將實例的引用賦予該類保持的引用；同時我們還將該類的構造函數定義為私有方法，這樣其他處的代碼就無法通過調用該類的構造函數來實例化該類的對象，只有通過該類提供的靜態方法來得到該類的唯一實例。</p>
<hr>
<ul>
<li><strong>特點</strong></li>
</ul>
<ol>
<li>可以確保一個類別只會生成一個物件</li>
<li>提供簡易的接口，讓程式對實例的訪問與操作更為簡單</li>
<li>可以延遲實例，僅在需要時才創建，節省資源使用</li>
</ol>
<hr>
<ul>
<li><strong>UML Graphic</strong></li>
</ul>


<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
</script>

  <script>mermaid.initialize({
  "flowchart": {
    "useMaxWidth":true
  },
  "theme": "default"
}
)</script>




<p class="mermaid">
classDiagram
    class Singleton {
        static Singleton obj;
        static Singleton* getInstance();
    }
</p>

<hr>
<ul>
<li><strong>內文</strong></li>
</ul>
<p>單例模式是一個很簡單的概念，就是「單一類別，只會生成單一物件（也就是單一實例）的一種設計模式。」雖說概念很簡單，但實作起來，還是有點眉角在裡面的。在直覺上的想法中，「透過私有的建構子，讓生成物件的權限只限制給類別本身」「『靜態變數』是讓類別中所有物件共用的一個變數」這兩個想法，就可以生成一個簡單的單例模式的程式了，就如下方所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> Singleton<span style="color:#f92672">*</span> obj;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Singleton() {}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> Singleton<span style="color:#f92672">*</span> getInstance() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(obj <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>                obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> obj;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Singleton<span style="color:#f92672">::</span>obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span></code></pre></div><p>在上方的程式中，透過將 <code>Singleton()</code> 建構子宣告成私有的方式，來讓「生成物件」這項工作只有 <code>Singleton</code> 類本身能夠做到，接著讓 obj 初始化成 <code>nullptr</code>，並在 <code>getInstance()</code> 中做一個 obj 的判斷，如果 <code>obj == nullptr</code>，那就生成一個 obj，否則就直接回傳 obj 的記憶體位址。透過這樣的寫法，可以保證 obj 只要一被生成，那麼 <code>obj = new Singleton();</code> 這件事情就不會被執行，也就代表了一定程度上的「單一類別只會有單一實例」的任務。</p>
<p>但這樣的寫法，在多執行緒的環境下，並沒有辦法保證其單一物件的實現。如果有兩條執行緒，其中 thread A 在剛判斷完「<code>obj == nullptr</code>」之後，就把 CPU 的使用權限轉交給 thread B，同時 thread B 也剛好要執行 <code>Singleton::getInstance()</code>，在這個情況下，因為 <code>obj</code> 還沒有被生成 <code>obj == nullptr</code> 的回傳結果會是 <code>true</code>，因此 thread B 就會利用 <code>obj = new Singleton();</code> 建立一個新的物件。等到 thread B 將 CPU 的使用權限重新交付給 thread A 之後，因為 thread A 先前已經檢查過「<code>obj == nullptr</code>」了（當時的情況是 true），所以 thread A 也會執行一次 <code>obj = new Singleton();</code>，這樣一來，<code>new Singleton()</code> 就被執行兩次了。</p>
<p>因此，在多執行緒的程式環境下，我們多半會把單例模式的部分內容加上一個「鎖頭」，限制「某一段的程式區間，不可以同時有一個以上的執行緒進行訪問與操作」，就如同下面的演示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>mutex mutex;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> Singleton<span style="color:#f92672">*</span> obj;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Singleton() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> Singleton<span style="color:#f92672">*</span> getInstance() {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(mutex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (obj <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>                obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> obj;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Singleton<span style="color:#f92672">*</span> Singleton<span style="color:#f92672">::</span>instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>mutex Singleton<span style="color:#f92672">::</span>mutex;
</span></span></code></pre></div><p>透過將 <code>std::lock_guard&lt;std::mutex&gt; lock(mutex);</code> 寫在 <code>getInstance()</code> 一開始的方式，限制所有的執行緒只要一進到函數中，就會進行上鎖的檢查，如果沒有鎖頭沒被鎖上，就將鎖頭鎖上，並接續執行下方的 if 判與 return。而在過程之中，如果執行緒將 CPU 使用權限交付給其餘執行緒，也不用擔心會重複實例的問題，因為其餘執行緒只要一進到 <code>getInstance()</code> 中檢查鎖頭，就會發現該鎖頭已被鎖上（因此程式中的後續操作都會先被禁止操作）。而這種「一進到函數中，就檢查鎖頭是否鎖上」的上鎖方式，稱之為【互斥鎖】。</p>
<p>除了互斥鎖以外，實現類別單一實例的方式還有很多，像是雙重鎖、自旋鎖、原子操作生成實例 &hellip;等，每一種實現的方式都有其各自的優缺點，像是互斥鎖可以保證實例絕對單一，但因每次進到 <code>getInstance()</code> 都會進行鎖檢查，因此在一定程度上，互斥鎖是一個很沒有效率的實現方式；又或者雙重鎖雖然在效率上遠勝於互斥鎖，但是在某些語言（例如 java）下可能仍然會有多執行緒的安全性問題&hellip;等等。總而言之，各模式都有其擅長的環境與短版的地方，考量到各種實務上的環境之後，再選擇最適合當前方案的實現方式才是上策。</p>
<hr>
<ul>
<li><strong>小結</strong></li>
</ul>
<p>單例模式的優點：</p>
<ul>
<li>確保一個類別只有一個實例，對於需要共享資源和避免衝突的情境非常有用</li>
<li>提供一個全域的訪問方式，使得對實例的訪問更加簡單，無需繁瑣的初始化過程</li>
<li>可以實現延遲初始化，僅在需要時才創建實例，節省資源的使用</li>
</ul>
<p>單例模式的缺點：</p>
<ul>
<li>可能會增加系統的複雜性與加深對類別與依賴性</li>
<li>類別的行為進行單元測試會變得比較困難</li>
<li>不易擴展，如果需要將類別修改為多實例的情況，會增加重購的複雜性</li>
</ul>
</article>
 
      <div id="gitalk-container"></div>

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  </main>

  <script>
    const elements = document.getElementsByClassName("markdown");

    Array.from(elements).forEach(element => {
        const links = element.getElementsByTagName("a");
        Array.from(links).forEach(link => {
        link.target = "_blank";
        });
    });
</script>

<script>
    const gitalk = new Gitalk({
        clientID: '91e953a7402d79bcef6c',
        clientSecret: '22897328fab72d26e1f3a88e83ab654467232514',
        repo: 'fonu195713.github.io',     
        owner: 'fonu195713',
        admin: ['fonu195713'],
        distractionFreeMode:  false ,  
        pagerDirection: 'last',
        language: 'zh-TW',
        createIssueManually:  false ,
        enableHotKey:  true ,
        id: md5(location.pathname),      
    });
    gitalk.render('gitalk-container');
</script>
</body>
</html>












