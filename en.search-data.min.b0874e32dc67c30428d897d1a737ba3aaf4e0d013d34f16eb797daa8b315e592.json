[{"id":0,"href":"/docs/daily_life/working_log/","title":"［置頂］工作日誌","section":"生活相關","content":"\r［置頂］工作日誌\r#\r2023, 7 月\r...\r日期 標題 分類 備註 07-07 《深入淺出設計模式》 心得 . 07-08 設計模式 分類 . 07-09 策略模式 內容 . 07-10 模板方法模式 內容 . 07-11 享元模式 內容 . 07-12 狀態模式 內容 . 07-13 單例模式 內容 . 07-14 簡單工廠模式 內容 . 07-14 工作日誌 內容 . 07-14 文章留言板 功能 . 07-15 工廠方法模式 內容 . 07-16 抽象工廠模式 內容 . 07-17 生成器模式 內容 . 07-18 原型模式 內容 . 07-21 適配器模式 內容 . 07-22 橋接模式 內容 . 07-22 裝飾者模式 內容 . 07-22 外觀模式 內容 . 07-23 代理模式 內容 . 07-23 組合模式 內容 . 07-24 塔羅牌 分類 . 07-25 觀察者模式 內容 . 07-27 新新魔塔 札記 . 2023, 8 月\r...\r日期 標題 分類 備註 08-01 命令模式 內容 . 08-02 責任鏈模式 內容 . 08-03 訪問者模式 內容 . 08-04 中介者模式 內容 . 08-05 解釋器模式 內容 . 08-05 迭代器模式 內容 . 08-05 單一職責原則 內容 . 08-05 開放封閉原則 內容 . 08-05 里氏替換原則 內容 . 08-06 介面隔離原則 內容 . 08-06 依賴反轉原則 內容 . 08-06 合成/聚合複用原則 內容 . 08-06 最少知識原則 內容 . 08-06 一千份的手抄心經 內容 . 08-13 偉特塔羅牌 分類 更新內文 08-14 [牌意解析][38] 分類 . 2023, 9 月（無內容）\r...\r"},{"id":1,"href":"/docs/daily_life/to_do_list/","title":"［置頂］待辦事項","section":"生活相關","content":"\r［置頂］待辦事項\r#\r日本的心得文 小說 "},{"id":2,"href":"/docs/fortune_telling/tarot/daily_log/","title":"［置頂］每日一翻","section":"偉特塔羅","content":"\r每日一翻\r#\r2023, 8 月\r...\r日期 牌卡 準確度 備註 08-13 寶劍八（逆） ★★★★☆ 心得連結 08-14 聖杯侍者（逆） ★★★☆☆ 心得連結 08-15 權杖侍者（逆） ★★★★★ 心得連結 08-16 正義（逆） ★★★★★ 心得連結 08-17 權杖騎士（逆） ★★★★☆ \u0026hellip; 08-18 聖杯王后（逆） ★★★☆☆ 心得連結 08-19 隱者（逆） ★★★★☆ 心得連結 08-20 權杖三（逆） ★★★★☆ 心得連結 08-21 皇后（正） ★★★★☆ 心得連結 08-22 太陽（正） ★★★★☆ [心得連結][9] 2023, 9 月（無內容）\r...\r"},{"id":3,"href":"/docs/creative_writing/novel/note/","title":"［置頂］筆記","section":"套牢仔的新連載","content":"衝突或反差：背景、遭遇、招式、能力、外表、性格（同時有強有弱）。人際、感情觀、個人能力\n情節 + 情節 + 情節 = 分場（艾斯被抓、白鬍子、背叛、救到、黑鬍子） 分場 + 分場 + 分場 = 篇章（角色的故事） 篇章 + 篇章 + 篇章 = 故事 「硬」的人不去做最「硬」的事\n第一話的 5 個步驟\r#\r介紹世界觀 告訴觀眾主角想要做什麼 交代主角的背景 讓主角經歷一些衝突 用一個巨大的變化來做收尾 (1 + 2 + 3 + 4) = 5\n什麼背景的人，經歷了什麼事情，造成他怎麼樣的麻煩（或加強他哪方面的心境） 可以用世界觀讓主角的背景變得既普通又特殊 巨人：用新的坑來填補舊有的坑，讓【所.有.】的坑都不離第一個坑太遠\n獵人：開放式劇情，讓所有的故事在【當下】就全.部.講.完.\n封閉式劇情：自問自答式的劇情\n"},{"id":4,"href":"/_docs/example/","title":"Example Site","section":"_docs","content":"\rIntroduction\r#\rFerre hinnitibus erat accipitrem dixi Troiae tollens\r#\rLorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\nPedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret Est simul fameque tauri qua ad\r#\rLocum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol\r#\rNec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue,\rviralItunesBalancing, bankruptcy_file_pptp)) {\rfile += ip_cybercrime_suffix;\r}\rif (runtimeSmartRom == netMarketingWord) {\rvirusBalancingWin *= scriptPromptBespoke + raster(post_drive,\rwindowsSli);\rcd = address_hertz_trojan;\rsoap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui);\r} else {\rmegabyte.api = modem_flowchart - web + syntaxHalftoneAddress;\r}\rif (3 \u0026lt; mebibyteNetworkAnimated) {\rpharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle(\rdvrSyntax, cdma);\radf_sla *= hoverCropDrive;\rtemplateNtfs = -1 - vertical;\r} else {\rexpressionCompressionVariable.bootMulti = white_eup_javascript(\rtable_suffix);\rguidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1,\rmanagementRosetta(webcamActivex), 740874);\r}\rvar virusTweetSsl = nullGigo;\rTrepident sitimque\r#\rSentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":5,"href":"/_docs/example/table-of-contents/with-toc/","title":"With ToC","section":"Table of Contents","content":"\rCaput vino delphine in tamen vias\r#\rCognita laeva illo fracta\r#\rLorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\nTe at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere\r#\rPectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\nPhrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\nLimitibus misere sit\r#\rAurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua\r#\rIuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta\r#\rMortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"},{"id":6,"href":"/docs/computer_science/design_pattern/mediator_pattern/","title":"中介者模式（Mediator Pattern）","section":"設計模式","content":"\r中介者模式（Mediator Pattern）\r#\r說明 ChatGPT：中介者模式（Mediator Pattern）是一種行為型設計模式，用於降低多個物件之間的直接溝通。物件會透過一個名為【中介者】的物件來進行通信。中介者模式有助於減少物件之間的耦合性，使得物件之間的交互更加靈活和可維護。在中介者模式中，多個物件（也稱為同事物件）不再直接相互溝通，而是通過【中介者】進行間接通訊。當其中一個物件需要與其他物件進行交互時，它不會直接調用其他物件的方法，而是通過中介者的方法來進行調用請求，然後中介者再將請求訊息傳遞給該物件。這樣一來，各個物件之間的相互依賴關係就減少了，它們只需要依賴於【中介者】這個抽象介面，而不需要知道彼此的存在。這樣不僅降低了物件之間的耦合性，同時也使得程式的結構更加清晰，易於維護和擴展。中介者模式適用於以下情況：「當多個物件之間的交互複雜且互相依賴時，使用中介者模式可以簡化物件之間的耦和與依賴，使得物件之間的關係更加清晰。」；「當物件之間的耦合性過高，導致修改一個物件可能影響到其他物件時，可以使用中介者模式將這些物件的交互集中在中介者中，從而降低耦合性」；「當一個物件需要和多個其他物件進行通信時，使用中介者模式可以避免物件之間建立大量的相互引用關係，從而提高程式的可讀性和可維護性。」\n維基百科：在軟體工程中，中介者模式定義了一個「封裝了一組物件互動方式」的物件。由於這種模式可以改變程式的運行行為，因此被認為是一種行為型設計模式。在物件導向程式設計中，程序通常會由許多的類別組成，各種邏輯和計算會在這些類別之間分散和互相調用。然而，隨著在程式中添加更多的類別或方法，在維護或重構程式期間，因為類別之間相互的高度耦和，使得維護與重構程式需要耗費巨大的時間成本。此外，由於任何更改都可能影響到其他幾個類別中的程式邏輯，因此更改程式會變得更為困難。因此中介者模式會將物件之間的通信，封裝在一個【中介者】物件中。讓其餘物件不再直接通信，而是通過【中介者】進行通信。這減少了物件之間的相依性，從而減少了耦合。中介者模式是 23 種著名的設計模式之一，該模式可以解決的問題有：「對高度耦和的物件進行解耦的動作」「讓物件彼此的行為各自獨立，而不依賴於其餘類別。」中介者模式描述的解決方案是：定義一個單獨的【中介者】物件，讓該物件封裝「物件之間的互動」。其餘物件將其互動的請求委派給【中介者】，而不是直接物件進行互動。物件通過一個 \u0026ldquo;控制\u0026rdquo; 和 \u0026ldquo;協調互動\u0026rdquo; 的種介者物件間接地與彼此互動。使得物件之間可以維持鬆散地耦合。\n特點 封裝物件的互動，讓物件只透過【中介者】進行溝通與調節 將物件的行為集中控制，從而避免混亂的調用 減少物件與物件之間的耦和，降低程式的維護成本 UML Graphic classDiagram\rclass Mid\r內文 中介者模式的用途就是「在多個物件之中提供一個協調的『管道』或『平台』」，透過一個【中介者】類別，【物件】可以直接將所需要的請求託付給【中介者】處理，或者是經由【中介者】取得其他【物件】所回傳過來的回應或參數。我們可以用一個 RPG 遊戲來解釋「中介者模式」的運作方式：假設在一個 RPG 遊戲中，我們要實作一個回合制的戰鬥場景。戰鬥總共分為兩方陣營（主角方與怪物方），如果沒有使用中介者模式的話，程式有可能會像是下面的這個樣子：\nclass Character { public: string name; int hp; int atk; public: Character(string name, int hp, int atk) : name(name), hp(hp), atk(atk) {} public: string getName() { return name; } public: virtual void attack(Character* target) = 0; virtual void takeDamage(int atk) = 0; }; class Player : public Character { public: Player(string name) : name(name) {} public: void attack(Character* target) override { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; attacked \u0026#34; \u0026lt;\u0026lt; (targrt -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; endl; targrt -\u0026gt; takeDamage(10); } void takeDamage(int atk) { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; took \u0026#34; \u0026lt;\u0026lt; atk \u0026lt;\u0026lt; \u0026#34; points of damage.\u0026#34; \u0026lt;\u0026lt; endl; } }; class Monster : public Character { public: Monster(string name, int hp, int atk) : name(name), hp(hp), atk(atk) {} public: void attack(Character* target) override { cout \u0026lt;\u0026lt; \u0026#34;A monster attacked \u0026#34; \u0026lt;\u0026lt; (targrt -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; endl; targrt -\u0026gt; takeDamage(10); } void takeDamage(int atk) { cout \u0026lt;\u0026lt; \u0026#34;A monster took \u0026#34; \u0026lt;\u0026lt; atk \u0026lt;\u0026lt; \u0026#34; points of damage.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(void) { Player* player = new Player(\u0026#34;玩家\u0026#34;, 100, 20); Monster* enemy1 = new Monster(\u0026#34;敵人1\u0026#34;, 50, 10); Monster* enemy2 = new Monster(\u0026#34;敵人2\u0026#34;, 60, 15); player.attack(enemy1); enemy1.attack(player); return 0; } 程式在這看之下是挺合理的，沒什麼過於明顯或者是過於繁冗的問題。但如果我們今天將情況設計得更加複雜一點：角色除了使用一般的攻擊 attack() 之外，還可以使用帶有元素屬性的魔法攻擊 magicAttack()，魔法攻擊分為火土風水四種不同的屬性，此外，怪物在受到不同屬性的魔法攻擊的時候，會展現出不同的抗性：可能【骷髏】對於水屬性的抗性特別高，但不利於土屬性；【殭屍】這個怪物對於土屬性的抗性特別高，但不擅長應付火屬性的攻擊 \u0026hellip;等。此外，在使用普通攻擊的時候，主角方和怪物方都有一定的機率產生爆擊 crit()，且無論哪種攻擊，主角方和怪物方都有一定的機率去做迴避 dodge() 的動作。\n在這樣的情況下，如果我們還是使用方才的程式撰寫方法的話，我們除了要在角色設定各種不同的元素抗性之外，最麻煩的事情是：當角色遭受到攻擊的時候，我們需要在 takeDamage() 的方法裡面進行龐大的攻防計算。這無疑會加重了 Player 類別和 Monster 類別的負擔。因此，在「中介者」模式下，我們可以先建立一個【戰鬥中介者】類別，再將這些 \u0026ldquo;複雜的計算\u0026rdquo; 委託給【戰鬥中介者】去進行。無論是【角色】還是【怪物】，現在都只關心「如何攻擊」以及「受到多少攻擊」這兩件事，就像是下面這個樣子：\nclass Character; enum Element { FIRE, EARTH, WIND, WATER }; class Mediator { public: virtual void attack(Character* attacker, Character* target, int damage) = 0; virtual void magicAttack(Character* attacker, Character* target, const Element element, int damage) = 0; virtual bool checkCrit() = 0; virtual bool checkDodge() = 0; } class BattleMediator : public Mediator { public: void attack(Character* attacker, Character* target, int damage) { if(checkDodge(attacker, target)) { cout \u0026lt;\u0026lt; (target -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34; evaded \u0026#34; \u0026lt;\u0026lt; (attacker -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34;\u0026#39;s attack.\u0026#34; \u0026lt;\u0026lt; endl; return; } if(checkCrit(attacker, target)) { cout \u0026lt;\u0026lt; (target -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34; dealt critical damage to the \u0026#34; \u0026lt;\u0026lt; (attacker -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; endl; damage *= 2; } target -\u0026gt; takeDamage(damage); } void magicAttack(Character* attacker, Character* target, const Element element, int damage) { if(checkDodge(attacker, target)) { cout \u0026lt;\u0026lt; (target -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34; evaded \u0026#34; \u0026lt;\u0026lt; (attacker -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34;\u0026#39;s attack.\u0026#34; \u0026lt;\u0026lt; endl; return; } if(checkCrit(attacker, target)) { cout \u0026lt;\u0026lt; (target -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34; dealt critical damage to the \u0026#34; \u0026lt;\u0026lt; (attacker -\u0026gt; name) \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; endl; damage *= 2; } damage = damage * (target -\u0026gt; defendRate)[element]; target -\u0026gt; takeDamage(damage); } }; class Character { public: Mediator* mediator; string name; int health; int attackDamage; double defendRate[4]; public: Character(string name, int health, int attackDamage) : mediator(mediator), name(name), health(health), attackDamage(attackDamage) {} public: void attack(Character* target) { mediator -\u0026gt; attack(this, target, attackDamage); } void MagicAttack(Character* target, Element element) { mediator -\u0026gt; magicAttack(this, target, element, damage); } void TakeDamage(int damage) { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; took \u0026#34; \u0026lt;\u0026lt; damage \u0026#34; points of damage.\u0026#34; \u0026lt;\u0026lt; endl; } public: void setMediator(Mediator* mediator) { mediator = mediator; } }; class Player : Character { public: Player(string name, int health, int attackDamage) : mediator(mediator), name(name), health(health), attackDamage(attackDamage) { defendRate[Element::FIRE] = 1.0; defendRate[Element::EARTH] = 1.0; defendRate[Element::WIND] = 1.0; defendRate[Element::WATER] = 1.0; } }; class Skeleton : Character { public: Skeleton(string name, int health, int attackDamage) : mediator(mediator), name(name), health(health), attackDamage(attackDamage) { defendRate[Element::FIRE] = 1.0; defendRate[Element::EARTH] = 0.3; defendRate[Element::WIND] = 1.0; defendRate[Element::WATER] = 2.5; } }; class Zombie : Character { public: Zombie(string name, int health, int attackDamage) : mediator(mediator), name(name), health(health), attackDamage(attackDamage) { defendRate[Element::FIRE] = 0.1; defendRate[Element::EARTH] = 3.1; defendRate[Element::WIND] = 1.0; defendRate[Element::WATER] = 1.0; } }; int main() { Character* player = new Player(\u0026#34;主角\u0026#34;, 100, 20); Character* skeleton = new Skeleton(\u0026#34;骷髏\u0026#34;, 80, 15); Character* zombie = new Zombie(\u0026#34;殭屍\u0026#34;, 120, 10); // battle Mediator* battleMediator = new BattleMediator(); player -\u0026gt; setMediator(battleMediator); skeleton -\u0026gt; setMediator(battleMediator); zombie -\u0026gt; setMediator(battleMediator); player -\u0026gt; magicAttack(zombie, ELEMENT::FIRE); skeleton -\u0026gt; attack(player); zombie -\u0026gt; attack(player); } 像種樣「把一部分（或全部）的程式執行細節委託給【中介者類別】，使得【原類別】只需要調用【中介者類別】的方法，就可以完成程式的功能」的撰寫方式，就是中介者模式想要傳達的意涵。雖然從上述的例子上來看，感覺很像只是「把程式的細節內容從 A 移動到 B」而已。但在多個物件需要進行複雜溝通的程式邏輯中（像是如果我們又再加上一個【地形】的類別，可以使各種各樣的攻擊，會根據不同的環境或地形有著不同的加成\u0026hellip;等），那麼「攻擊」attack() 可能就會需要先與【地形】進行互動，再將計算後的數值傳送給【怪物】。\n又或者是再單獨把【元素抗性】的內容拉出來撰寫，程式就會從｛【角色】\u0026gt; 攻擊 \u0026gt;【怪物】｝的順序，變成了｛【角色】\u0026gt; 攻擊 \u0026gt; 【地形】\u0026gt;【元素抗性】\u0026gt;【怪物】｝這樣的順序\u0026hellip;。在可預見的範圍內，我們可以發現到：如果全部的判斷條件都擠在【角色】的 attack() 中，程式就會變得極度冗長。所以我們才會需要一個【中介者】，把所有的「麻煩事」都交給它去做。讓其餘類別只需要撰寫比較抽象化的、簡易的程式碼就好。我們也可以透過【中介者】讓類別與類別的依賴給斷開，降低程式的耦合程度。\n小結 中介者模式的優點：\n將物件之間的依賴斷開，從而降低相互的耦合性 提供了統一的中介者介面，簡化了物件之間的通訊難度 提高系統的靈活性與可擴展性。 中介者模式的缺點：\n單一失敗點問題，如果有重大差錯在中介者，程式會崩潰 增加了類別的數量，因此會降低程式的效能與增加成本 中介者需要負責各種各樣的通訊工作，因此違反單一職責原則 "},{"id":7,"href":"/docs/computer_science/design_pattern/flyweight_pattern/","title":"享元模式（Flyweight Pattern）","section":"設計模式","content":"\r享元模式（Flyweight Pattern）\r#\r說明 ChatGPT：享元模式（Flyweight Pattern）是一種結構型設計模式，旨在通過共享對象来最大程度地减少資源消耗和提高性能。該模式適用於存在大量相同或近似對象的情况，通過共享對象的方式，減少對象的創建和記憶體開銷。在享元模式中，對象共分為兩種類型：共享對象（Flyweight）：是可以被共享的對象，包含內部狀態和外部狀態。內部狀態是不變的，因此可以被多個相同的對象共享；外部狀態是可變的，需要在使用時傳遞给共享對象。非共享對象（Unshared Flyweight）：是不可共享的對象，每個對象都是獨立的。通過將對象的狀態分為內部狀態和外部狀態，享元模式可以實現共享內部狀態，減少對象的數量，並通過傳遞外部狀態來保持對象的獨立性。\n維基百科：享元模式（英語：Flyweight Pattern）是一種軟體設計模式。它使用物件用來儘可能減少記憶體使用量；於相似物件中分享儘可能多的資訊，共享數據結構的概念稱為「哈希共享」。當大量物件近乎重複方式存在，因而使用大量記憶體時，此法適用。通常物件中的部分狀態（state）能夠共享。常見做法是把它們放在資料結構外部，當需要使用時再將它們傳遞給享元。典型的享元模式的例子為文書處理器中以圖形結構來表示字符：每個字形有其字型外觀、字模、和其它格式資訊，如果要全部儲存，會使每個字符就耗用掉上千位元組。因此，我們會使用享元模式，將每個字符參照到一個【共享字形】物件，此物件會被其它有共同特質的字符所分享和使用；只有每個字符的獨特資訊（例如位置訊息）才需要另外儲存。享元模式（Flyweight Pattern）指的是通過與其他相似對象共享一部分數據，來最小化記憶體使用的一種程式設計模式。\n特點 將物件定義為「內部狀態」與外部狀態 同一物件的內部狀態會完全相同，外部狀態會因物件而異 物件的內部狀態可以被定義為一個共同的參照 減少大量的記憶體消耗 通常會與「工廠模式」一併使用 UML Graphic classDiagram\rclass Map {\rTreeFactory* tree_factory;\rTree[] tree_ary\rcreateMap() : create tree and building\rcreateTree() : tree_factory.createTree()\r}\rclass TreeFactory {\rTree* tree_records[]\rcreateTree();\r}\rMap --\u003e TreeFactory\rnote \"Tree* createTree() {\\n　Tree tree = Rnd.tree(name)\\n　if(tree in tree_records) {\\n　return tree;\\n　}else{\\n　Tree* t = new Tree(name);\\n　tree_records.add(t);\\n　return t;\\n　}\\n}\"\rclassDiagram\rclass Tree {\rType static_items\rLocation* location\r}\rTree \u003c|-- Bush\rTree \u003c|-- Flower\rTree \u003c|-- Oak\rTree \u003c|-- MapleTree\r內文 享元模式很像是類別裡面的 static 關鍵字。同樣的類別，即使用上百、甚至式上千個物件，只要將某一屬性宣告成 static，那麼該類別的所有物件都會參照到同一個記憶體位址上。在 RPG 遊戲中，我們也可以找到許多類似的例子：例如遊戲的【地圖】中，我們可能會在一張地圖上建立大量重複的物件，像是樹木、花、草叢、建築物、道路、水井、橋梁\u0026hellip;等，有時候一張大地圖裡面有上百上千個同樣或類似的樹木都很正常。這個時候，如果我們把每一個樹木的所有屬性（外觀、大小、顏色\u0026hellip;等）都分別建立起來的話，這樣就會花費掉及大量的程式空間，不但會使得程式的運行效率降低，也會讓程式的記憶體負擔變得很大。\n為此，在這樣的情況下，我們可以利用「享元模式」將一些物件的「元素」做「共享」，例如：每個樹木的大小、外觀都是取自相同的圖檔和設定，那麼，我們就可以把所有樹木的大小參數與外觀參數共用，至於樹木的位置、擺放方式（直向還是傾斜？）則可能會不太一樣，這些屬性再由樹木本身自己設定與存取即可。而這樣的狀況下，樹木的「內部狀態」即是樹木的大小、外觀，而「內部狀態」則是樹木擺放的位置、與傾斜程度。\n或者是遊戲角色中的【背包】系統，每位玩家裡面可能都有許多重複的裝備、或藥水\u0026hellip;等內容物，如果今天某位玩家有【100 個回復藥水】我們就把這 100 個藥水全部實例化一次，對於遊戲伺服器或玩家主機本身的記憶體負擔就會超級巨大了，因此在一種比較好的解決方案，是讓所有的玩家都共享一個「回復藥水」的外觀、描述\u0026hellip;等設定，再由每位玩家分別記錄擁有的數量。而在這樣的情況下，回復藥水的「內部狀態」即是藥水的外觀與描述，而「外部狀態」則是玩家本身所擁有的數量。\nclass MapItem {}; class Tree : public MapItem { string name; Tree(string name) : name(name) {} }; class Building : public MapItem { string name; Building(string name) : name(name) {} }; class MapItemFactory { MapItem[] Item_record; MapItem* getItem(string name) { if(Item_record.find(name)) { return Item_record[name]; } switch(name) { case \u0026#34;Bush\u0026#34;: case \u0026#34;Flower\u0026#34;: case \u0026#34;Oak\u0026#34;: case \u0026#34;MapleTree\u0026#34;: Item_record[name] = new Tree(name); break; case \u0026#34;LogCabin\u0026#34;: case \u0026#34;TownHall\u0026#34;: case \u0026#34;Roads\u0026#34;: case \u0026#34;WaterWell\u0026#34;: Item_record[name] = new Building(name); break; } return Item_record[name]; } }; 小結 享元模式的優點：\n減少電腦各類資源的消耗 簡化物件的管理 輕量化、提高程式性能 享元模式的缺點：\n可能增加程式的複雜性 執行緒相關問題 限制了物件的複雜度與多樣性 "},{"id":8,"href":"/docs/computer_science/design_pattern/proxy_pattern/","title":"代理模式（Proxy Pattern）","section":"設計模式","content":"\r代理模式（Proxy Pattern）\r#\r說明 ChatGPT：代理模式（Proxy Pattern）是一種結構型設計模式，它允許通過使用一個「代理對象」來代表真實對象，從而控制對真實對象的訪問。代理模式提供了一個額外的層次，用於處理對真實對象的訪問，並可以在不改變真實對象的情況下，為其添加一些額外的功能。代理模式的核心思想是：「在【客戶端】和【真實對象】之間引入一個【代理對象】」，這個代理對象充當了客戶端和真實對象之間的中間人。當客戶端想要訪問真實對象時，它不直接與真實對象進行交互，而是通過代理對象來進行訪問。代理對象在接收到客戶端的訪問請求後，可以選擇是否轉發請求給真實對象，並可以在轉發請求前後執行一些額外的操作。代理模式主要包含以下幾個角色：Subject（主題）：主題定義了真實對象和代理對象之間的共同接口，這樣在任何使用真實對象的地方都可以使用代理對象。RealSubject（真實主題）：真實對象實現了 Subject 定義的接口，也就是真實對象，客戶端並不直接與它進行交互。Proxy（代理）：代理同樣也實現了 Subject 定義的接口，內部包含一個真實對象的引用，客戶端通過訪問該對象來代替訪問真實對象。\n維基百科：代理模式（英語：Proxy Pattern）是軟體工程中的一種設計模式。所謂的【代理者】是指一個類別可以作為其它東西的介面。【代理者】可以作任何東西的介面：例如網路連接、記憶體中的大物件、某些特定檔案、或其它昂貴或無法複製的資源。著名的代理模式例子為參照計數（英語：reference counting）指標物件。此外，當一個複雜物件的多份副本須存在時，代理模式可以結合享元模式以減少記憶體用量，典型的作法是建立一個複雜物件及多個代理者，每個代理者都會參照到原本的複雜物件，而作用在代理者的運算會轉送到原本物件，而一旦所有的代理者都不存在時，該複雜物件將會被移除。\n特點 通過代理者減少對於實體對象的依賴 能夠保持真實對象的穩定與獨立 可以客製化地提供真實對象的擴充功能 UML Graphic classDiagram\rclass Server\rclass Proxy\rServer \u003c|-- Proxy\rclass User {\rProxy* proxy\rvoid call_server()\r}\rUser --\u003e Proxy\rnote \"void call_server() {\\n　proxy.request();\\n}\"\r內文 類似於「霧運算」或者是「邊緣計算」的概念，代理模式的功能是透過一個【代理者】類別，將【真實對象】的工作給區分出去，讓【客戶】有需要進行一些對於【真實對象】的存取時，可以透過【代理者】來進行，從而減少對【真實對象】的依賴或負擔。例如在一個 RPG 遊戲中，我們每次在創建線上遊戲的角色的時候，都會需要做一個「確認 ID 是否重複」的事情，在程式的撰寫上可能會有向下面這樣的例子：\nclass GameServer { public: std::vector\u0026lt;string\u0026gt; id_vector; public: bool name_duplicated(string str) { auto it = std::find(id_vector.begin(), id_vector.end(), str); if(it != id_vector.end()) return true; else return false; } }; class Character { private: std::string name; public: void set_user_name() { GameServer server = new GameServer(); std::string tmp_name; std::cin \u0026gt;\u0026gt; tmp_name; while(server.name_duplicated()) { std::cout \u0026lt;\u0026lt; \u0026#34;Name is duplicated.\u0026#34; \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; tmp_name; } server.set_user_name(tmp_name); name = tmp_name; } }; 這樣做會有幾個缺點：首先是程式的運行會對伺服器有著很大的負擔。如果【客戶】裡所有大大小小的事情都必須要交給【伺服器】去做處理時，那伺服器的工作量就會變得巨量龐大。其次，因為大量的工作被湧進【伺服器】的排程中，因此可預見的：使用者的等待時間或者是體驗分數就會被大打折扣。因此，對於這樣的情況，我們可以使用「代理模式」來解決問題：代理模式可以在【客戶】和【伺服器】之間建立一個【代理者】。【代理者】允許被擁有部分（或全部）【伺服器】可以執行的操作或功能。讓【客戶】想要操作一些資料的時候，直接去找【代理者】即可。\n這樣做有幾個好處：首先是「控制訪問權限」。我們可以透過代理者，先初步過濾不合法的一些操作或請求（例如客戶端想要存取伺服器重要資料之類的），以提升程式的安全性。此外，我們也可以利用【代理者】進行 Lazy Loading，讓一些程式資源不需要一開始就先全部準備好（會花很多時間，讓賀酷的使用者體驗變差），透過背景加載、或者是需要時再加載\u0026hellip;等方法彈性地運用程式資源。此外，我們也可以把【代理者】當成一個小小的暫存空間，透過對【代理者】的存取，除了可以提升程式的運行速度之外，也可以進一步降低對【伺服器】的重複請求。還有其他優點，像是簡化客戶端的程式、提升存取效率、可以利用代理者進興一些擴增的伺服器操作\u0026hellip;等。\nclass Server {}; class GameServer : public Server { private: static std::vector\u0026lt;string\u0026gt; id_vector; protected: static std::vector\u0026lt;string\u0026gt; get_id_vector() { return id_vector; } static void insert_id(std::string id) { id_vector.push_back(id); } }; class Proxy : public Server { private: std::vector\u0026lt;string\u0026gt; id_vector; public: Proxy() : id_vector(GameServer::get_id_vector()) {}; public: bool name_duplicated(string str) { auto it = std::find(id_vector.begin(), id_vector.end(), str); if(it != id_vector.end()) return true; else return false; } void set_user_name(std::string name) { GameServer::insert_id(name); id_vector = GameServer::get_id_vector(); } }; class Character { private: std::string name; public: void set_user_name() { Proxy proxy = new Proxy(); std::string tmp_name; std::cin \u0026gt;\u0026gt; tmp_name; while(proxy.name_duplicated()) { std::cout \u0026lt;\u0026lt; \u0026#34;Name is duplicated.\u0026#34; \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; tmp_name; } proxy.set_user_name(tmp_name); name = tmp_name; } } 總的來說，代理模式提供了一個額外的【代理者】來控制【客戶】對【真實對象】的訪問，同時可以為【真實對象】提供額外的功能。這樣的設計除了可以降低【真實對象】的工作負擔之外，更可以提升【客戶】的使用者體驗，也有助於降低系統的耦合度，提高程式的可讀性、可維護性、遠程訪問和安全控制\u0026hellip;等需求。\n小結 代理模式的優點：\n控制【客戶】對於【真實對象】的訪問，增加程式安全性 簡化伺服器的工作與負擔，提升伺服器的運行效率 可以延遲加載，提升用戶在使用程式時的使用者體驗 原型模式的缺點：\n因為多了【代理者】類別，因此增加了程式的複雜性 過多的代理者可能同樣會對【伺服器】造成負擔 可能會因為【代理者】協調不彰，造成類似 Deadlock 的問題 "},{"id":9,"href":"/docs/computer_science/design_pattern/prototype_pattern/","title":"原型模式（Prototype Pattern）","section":"設計模式","content":"\r原型模式（Prototype Pattern）\r#\r說明 ChatGPT：原型模式（Prototype Pattern）是一種軟體設計模式，屬於創建型模式的一種。它的主要目的是「通過複製現有的物件」來創建新的物件，而不需要知道具體的建構過程。這種方式可以避免重複性的建構過程，特別是當物件建構較為複雜或耗時的時候。在原型模式中，每個物件都是一個原型（prototype），可以通過複製（clone）來創建新的物件。這裡的「複製」不僅僅是複製物件的內容，而是將整個物件的狀態複製一份給新建的物件，新物件與原物件是相互獨立的，對其中一個物件的修改不會影響另一個。原型模式的核心概念是基於現有物件（原型）來創建新物件，而不是從頭開始創建。這樣可以節省建構時間和資源，同時提高程式碼的效率和可讀性。原型模式通常需要實現一個拷貝方法（Clone Method），用於複製物件。這個拷貝方法可以是淺拷貝（Shallow Copy）或深拷貝（Deep Copy），具體取決於物件的需求和關聯性。\n維基百科：原型模式是一種創建型設計模式。當要創建的物件類型由原型實例確定時，可以通過拷貝（clone）該原型來產生新的物件。該模式的使用可以避免在客戶端應用程式中對物件創建者進行子類別化，就像工廠方法模式所做的那樣，並且可以避免以標準方式（例如使用 \u0026ldquo;new\u0026rdquo; 關鍵字）創建新物件時所帶來的固有成本，尤其是對於某些應用程式來說這樣做代價過高的情況。要實現這種模式，客戶端先聲明一個原型基類，其中定義了一個 clone() 方法。任何需要具備「多型建構子」功能的類別都要繼承該類別，並實作 clone() 方法。客戶端不再直接在程式中使用 new 來建立物件，而是呼叫原型的 clone() 方法，一個常見的原型模式的例子是細胞的有絲分裂，一個細胞可以產生兩個相同的細胞，彼此相同，但彼此並不相關聯，就是原型模式的一個例子。\n特點 通過複製物件快速得到新物件，而不需重新執行建構的過程 將物件的建構細節隱藏在物件內部。 動態地增減物件，通過複製不同類型的原型來創建物件 UML Graphic classDiagram\rclass World {\rstring name\rMap* maps[]\rvoid add_map();\r}\rclass Map {\rItem* items[]\r}\rclass Monster {\rMonster* clone();\r}\rWorld \u003c|-- Map\rMap \u003c|-- Building\rMap \u003c|-- NPC\rMap \u003c|-- Monster\rMonster \u003c|-- Zombie\rMonster \u003c|-- Skeleton\r內文 簡單來說，原型模式就是透過 clone() 函數來代替用 new 的方法創立物件。這麼做有幾種好處，同樣用製作一個 RPG 遊戲來做舉例：首先是「快速初始化」，如果我們想要快速地創建多個相同類別的怪物物件的時候，雖然用 new 是一個不錯的方法，但如果考慮到怪物也許在某些地方會有某些加成，像是殭屍在靠近墓地的時候，會比一般殭屍高出一點點攻擊、防禦、和血量。這時候相對於「用 new 新增一個原本的殭屍，再微調每一個殭屍的所有數值。」，用 clone() 的方法複製第一個已經調整好參數的殭屍會來的更加簡潔。\nclass Zombie { public: int hp; int mp; int atk; int def; string name; public: Zombie() : hp(450), mp(100), atk(160), def(30), name(\u0026#34;Zombie\u0026#34;) {}; public: void setHp(int new_hp); void setMp(int new_mp); void setAtk(int new_atk); void setDef(int new_def); public: int getHp(); int getMp(); int getAtk(); int getDef(); public: Monster* clone(Zombie\u0026amp; old_zombie) { Monster zombie = new Zombie(); zombie -\u0026gt; setHp(old_zombie.getHp()); zombie -\u0026gt; setMp(old_zombie.getMp()); zombie -\u0026gt; setAtk(old_zombie.getAtk()); zombie -\u0026gt; setDef(old_zombie.getDef()); return zombie; } } 快速初始化特別適用於複雜的物件，像是如果一個 RPG 遊戲的【地圖】預設是一張空白地圖，我們在裡面添增的每一棟建築、每一棵樹、每一朵花、和每一位 NPC 都算是物件的話，這樣如果我們想要「複製一個已經做好的地圖」，相對於重新 new Map() 重新對每一個物件 addItem(), setLocation()，直接用類似 map.clone() 的方法就會快速許多。\n另外，原型模式的 clone() 有分成「淺層拷貝」和「深層拷貝」兩種，所謂的「淺層拷貝」指的就是「不遞迴地使用 clone() 來對物件進行拷貝」使用情境的話\u0026hellip;像是剛剛的那種創建一個已經做好的地圖就還算合適，因為【地圖】本身的元素（像是【建築】【樹木】【NPC】\u0026hellip;等）並不會需要有進一層的初始化。每個元素的樣貌、外觀\u0026hellip;等參數都可以從物件本身的 get...() 去取得。但如果是深度的複雜物件的話：像是【世界】有著很多個【地圖】，【地圖】裡面可能又有【怪物】【NPC】【道路】【屏障】\u0026hellip;等物件。有些物件又可以繼續往下探求，這時候利用「深層拷貝」遞迴地創建物件或許就會來的更加有效率了。\nclass World { public: string name; Maps* map[] public: World(string name) : name(name), map([]) {}; public: add_map(Map* m) { map.insert(m); } public: World* clone(World\u0026amp; old_world) { World* world = new World(); world.name = old_world.name; world.map = array.clone(old_world.name); for(Map m : world.map) { m.clone(); } } } 小結 原型模式的優點：\n減少物件在創建時的過程、程式撰寫 提高程式碼的可讀性、可延展性 相對單純的建構子，它提供了彈性地物件生成方式 原型模式的缺點：\n物件與物件之先產生依賴，會增加程式耦合 增加維護成本 需要額外去撰寫 clone() 方法 "},{"id":10,"href":"/docs/computer_science/design_pattern/command_pattern/","title":"命令模式（Command Pattern）","section":"設計模式","content":"\r命令模式（Command Pattern）\r#\r說明 ChatGPT：命令模式（Command Pattern）是一種行為型設計模式，它將請求（request）或操作封裝成一個獨立的對象，使得能夠將客戶端的請求參數化、延遲執行或者將請求排入佇列中。這樣可以使請求的發送者和接收者解耦。在命令模式中，主要包含以下角色：【命令】（Command）：它是一個抽象類或接口，聲明了執行請求的方法 execute()。【具體命令】（Concrete Command）：具體命令實現了命令接口，包含了具體的操作和接收者。通常會持有接收者的實例，用來執行實際的請求。【接收者】（Receiver）：接收者知道如何執行真正的操作，接收者會被具體命令所調用。【調用者】（Invoker）：調用者持有命令對象，並在需要的時候調用命令的 execute() 方法。【客戶端】（Client）：創建具體命令對象，設置命令的接收者，並將命令對象設置給調用者。命令模式的核心思想是將「操作」和「操作的執行」解耦，將它們封裝成對象，從而實現請求的發送者和接收者之間的解耦。這使得我們可以輕鬆地增加新的請求類型，或進行撤銷、重做等功能，，對於實現複雜的交互操作和請求發送的場景非常有用。\n維基百科：在物件導向程式設計中，命令模式是一種行為型設計模式，它使用一個物件來封裝所有執行動作或稍後觸發事件所需的資訊。這些資訊包括方法名稱、擁有該方法的物件和該方法的參數值。命令模式通常與四個術語相關，它們是命令（Command）、接收者（Receiver）、調用者（Invoker）和客戶端（Client）。一個【命令】了解接收者並調用接收者的方法，該方法的參數值會存儲在命令中。【接收者】用於執行這些方法。當調用【命令】中的 execute() 方法時，【接收者】便開始執行工作。【調用者】物件知道如何執行一個命令，並可以選擇性地進行有關命令執行的記錄。【調用者】不知道具體的命令，只知道【命令】的介面。【客戶端】持有【調用者】、【命令】和【接收者】。【客戶端】決定將哪些【接收者】指派給【命令】，以及將哪些【命令】指派給【調用者】。【客戶端】決定在何時執行哪些命令。為了執行一個命令，它將【命令】傳遞給【調用者】。使用【命令】可以更容易地構建通用元件，這些元件需要在它們選擇的時間點委派、序列化、或執行方法的呼叫，而無需了解方法的類別或方法的參數。這個設計模式的核心思想與「函數式程式設計」中的「一等函數」和「高階函數」的語義非常相似，具體來說，【調用者】是高階函數，而【命令】是一等參數。\n特點 將請求封裝成【命令】，使得命令可以參數化 可以將【調用者】和【接收者】解耦 容易進行擴展操作，且支持命令的延遲執行 UML Graphic classDiagram\rclass Command~Interface~ {\rCharacter* character\rvoid execute();\rvoid undo();\r}\rCommand \u003c|-- AttackCommand\rCommand \u003c|-- DefenceCommand\rclass AttackCommand {\rvoid execute() : character.attack();\rvoid undo() : character.cancelAttack();\r}\rclass DefenceCommand {\rvoid execute() : character.defence();\rvoid undo() : character.cancelDefence();\r}\rclassDiagram\rclass Character~Interace~\rCharacter \u003c|-- Warrior\rCharacter \u003c|-- Bowman\rCharacter \u003c|-- Magician\rCharacter \u003c|-- Thief\rclass Character {\rvoid attack();\rvoid cancelAttack();\rvoid defence();\rvoid cancelDefence();\r}\rclass CommandInvoker {\rCommand* command\rvoid setCommand(Command* cmd);\rvoid execute() : cmd.execute();\rvoid undo() : cmd.undo();\r}\r內文 命令模式主要有三種角色：命令的內容、執行命令的物件、跟決定哪時候要執行命令的物件，這三個角色依序是【命令】（Command）【接收者】（Receiver）和【調用者】（Invoker）。讓我們用 RPG 遊戲做個舉例：【命令】就是執行動作的內容，一般會用 Command 類別來表示，【命令】通常是一個抽象類別，裡面會有 execute(), undo() 兩種方法，分別代表「執行命令」與「取消執行」。其他繼承【命令】的子類別（像是【攻擊命令】、【防禦命令】\u0026hellip;等）會實作不同的命令指令（像是 attack(), cancelAttack(), defence(), cancelDefence() \u0026hellip;等）。\n【接收者】就是可以真正執行命令的類別，在 RPG 遊戲裡面可以是【角色】【怪物】、或其他 NPC \u0026hellip;等，【接收者】會實作不同的命令細節，可能 Warrior 類的 attack() 是用斧頭攻擊、Bowman 的類別則會變成用弓箭射擊 \u0026hellip;等等。【接收者】在命令模式下只負責「不同的命令要怎麼執行」，換句話來說：「何時要執行命令」與「要執行哪一個命令」並不是【接收者】所關心的議題，它們是【調用者】所關心的議題。\n【調用者】負責「調用」命令，也就是決定那些命令要在哪個時候執行。調用者裡面同樣也會有 execute() 和 undo() 兩種方法。但不同於【命令】中的 execute() 會直接實作具體的命令內容，【調用者】的 execute() 只會透過呼叫自己成員變數 command 的 execute() 來執行某些命令，也因此，調用者不會知道【命令】的具體細節，它只會負責決定哪時候要執行命令而已。\n// Commands class Command { public: virtual ~Command() {} virtual void execute() = 0; virtual void undo() = 0; }; class AttackCommand : public Command { private: Player* player; Monster* target; public: AttackCommand(Player* player, Monster* target) : player(player), target(target) {} void execute() override { player -\u0026gt; attack(target); } void undo() override {} }; class DefendCommand : public Command { private: Player* player; public: DefendCommand(Player* player) : player(player) {} void execute() override { player -\u0026gt; defend(); } void undo() override {} }; // Receivers class Character { private: string name; public: virtual attack() = 0; virtual defend() = 0; }; class Player : public Character { void attack(Monster* target) { // Some codes about attacks } void defend() { // Some codes about defend } } class Monster : public Character { void attack(Player* target) { // Some codes about attacks } void defend() { // Some codes about defend } } // Invoker class BattleManager { private: Command* command; public: BattleManager() : currentCommand(nullptr) {} void setCommand(Command* cmd) { command = cmd; } void execute() { if(command) { command -\u0026gt; execute(); } } void undo() { if (command) { command -\u0026gt; undo(); } } }; 小結 命令模式的優點：\n解耦【發送者】和【接收者】的程式 可以支持「執行」和「撤銷」的兩種令操作 容易擴展不同的命令 命令模式的缺點：\n會讓類別的數量變多 執行效率可能會因為類別的各種呼叫而噌加 增加記憶體的佔用和消耗 "},{"id":11,"href":"/docs/computer_science/design_pattern/singleton_pattern/","title":"單例模式（Singleton Pattern）","section":"設計模式","content":"\r單例模式（Singleton Pattern）\r#\r說明 ChatGPT：單例模式（Singleton Pattern）是一種創建型設計模式，它確保一個類別只有一個唯一的實例，並提供一個全局的訪問點來訪問該實例。單例模式確保一個類別只有一個實例，並且提供全局的訪問點來訪問該實例。實現單例模式的一種常見方式是使用一個私有的靜態成員變量來存儲類別的唯一實例，並提供一個公共的靜態方法來獲取這個實例。在這個方法中，方法首先會檢查實例是否已經存在？如果存在，則返回該實例，否則創建一個新的實例並返回。此外，為了防止通過其他途徑創建額外的實例。單例模式會將類別的構造函數設為私有。\n維基百科：單例模式（Singleton Pattern）也叫單子模式，是一種常用的軟體設計模式，屬於創建型模式的一種。在應用這個模式時，單例對象的類必須保證只有一個實例存在。實現單例模式的思路是：一個類僅能返回對象一個引用（永遠是同一個）和一個獲得該實例的方法（必須是靜態方法，通常使用 getInstance() 這個名稱）；當我們調用這個方法時，如果類持有的引用不為空就返回這個引用，如果類保持的引用為空就創建該類的實例，並將實例的引用賦予該類保持的引用；同時我們還將該類的構造函數定義為私有方法，這樣其他處的代碼就無法通過調用該類的構造函數來實例化該類的對象，只有通過該類提供的靜態方法來得到該類的唯一實例。\n特點 可以確保一個類別只會生成一個物件 提供簡易的接口，讓程式對實例的訪問與操作更為簡單 可以延遲實例，僅在需要時才創建，節省資源使用 UML Graphic classDiagram\rclass Singleton {\rstatic Singleton obj;\rstatic Singleton* getInstance();\r}\r內文 單例模式是一個很簡單的概念，就是「單一類別，只會生成單一物件（也就是單一實例）的一種設計模式。」雖說概念很簡單，但實作起來，還是有點眉角在裡面的。在直覺上的想法中，「透過私有的建構子，讓生成物件的權限只限制給類別本身」「『靜態變數』是讓類別中所有物件共用的一個變數」這兩個想法，就可以生成一個簡單的單例模式的程式了，就如下方所示：\nclass Singleton { static Singleton* obj; private: Singleton() {} public: static Singleton* getInstance() { if(obj == nullptr) { obj = new Singleton(); } return obj; } }; Singleton::obj = nullptr; 在上方的程式中，透過將 Singleton() 建構子宣告成私有的方式，來讓「生成物件」這項工作只有 Singleton 類本身能夠做到，接著讓 obj 初始化成 nullptr，並在 getInstance() 中做一個 obj 的判斷，如果 obj == nullptr，那就生成一個 obj，否則就直接回傳 obj 的記憶體位址。透過這樣的寫法，可以保證 obj 只要一被生成，那麼 obj = new Singleton(); 這件事情就不會被執行，也就代表了一定程度上的「單一類別只會有單一實例」的任務。\n但這樣的寫法，在多執行緒的環境下，並沒有辦法保證其單一物件的實現。如果有兩條執行緒，其中 thread A 在剛判斷完「obj == nullptr」之後，就把 CPU 的使用權限轉交給 thread B，同時 thread B 也剛好要執行 Singleton::getInstance()，在這個情況下，因為 obj 還沒有被生成 obj == nullptr 的回傳結果會是 true，因此 thread B 就會利用 obj = new Singleton(); 建立一個新的物件。等到 thread B 將 CPU 的使用權限重新交付給 thread A 之後，因為 thread A 先前已經檢查過「obj == nullptr」了（當時的情況是 true），所以 thread A 也會執行一次 obj = new Singleton();，這樣一來，new Singleton() 就被執行兩次了。\n因此，在多執行緒的程式環境下，我們多半會把單例模式的部分內容加上一個「鎖頭」，限制「某一段的程式區間，不可以同時有一個以上的執行緒進行訪問與操作」，就如同下面的演示：\n#include \u0026lt;mutex\u0026gt; class Singleton { public: static std::mutex mutex; static Singleton* obj; private: Singleton() {} public: static Singleton* getInstance() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (obj == nullptr) { obj = new Singleton(); } return obj; } }; Singleton* Singleton::instance = nullptr; std::mutex Singleton::mutex; 透過將 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); 寫在 getInstance() 一開始的方式，限制所有的執行緒只要一進到函數中，就會進行上鎖的檢查，如果沒有鎖頭沒被鎖上，就將鎖頭鎖上，並接續執行下方的 if 判與 return。而在過程之中，如果執行緒將 CPU 使用權限交付給其餘執行緒，也不用擔心會重複實例的問題，因為其餘執行緒只要一進到 getInstance() 中檢查鎖頭，就會發現該鎖頭已被鎖上（因此程式中的後續操作都會先被禁止操作）。而這種「一進到函數中，就檢查鎖頭是否鎖上」的上鎖方式，稱之為【互斥鎖】。\n除了互斥鎖以外，實現類別單一實例的方式還有很多，像是雙重鎖、自旋鎖、原子操作生成實例 \u0026hellip;等，每一種實現的方式都有其各自的優缺點，像是互斥鎖可以保證實例絕對單一，但因每次進到 getInstance() 都會進行鎖檢查，因此在一定程度上，互斥鎖是一個很沒有效率的實現方式；又或者雙重鎖雖然在效率上遠勝於互斥鎖，但是在某些語言（例如 java）下可能仍然會有多執行緒的安全性問題\u0026hellip;等等。總而言之，各模式都有其擅長的環境與短版的地方，考量到各種實務上的環境之後，再選擇最適合當前方案的實現方式才是上策。\n小結 單例模式的優點：\n確保一個類別只有一個實例，對於需要共享資源和避免衝突的情境非常有用 提供一個全域的訪問方式，使得對實例的訪問更加簡單，無需繁瑣的初始化過程 可以實現延遲初始化，僅在需要時才創建實例，節省資源的使用 單例模式的缺點：\n可能會增加系統的複雜性與加深對類別與依賴性 類別的行為進行單元測試會變得比較困難 不易擴展，如果需要將類別修改為多實例的情況，會增加重購的複雜性 "},{"id":12,"href":"/docs/computer_science/design_pattern/facade_pattern/","title":"外觀模式（Facade Pattern）","section":"設計模式","content":"\r外觀模式（Facade Pattern）\r#\r說明 ChatGPT：外觀模式（Facade Pattern）是一種結構型設計模式，它提供了一個簡單的介面（外觀），用於封裝一組複雜的子系統，使得客戶端可以通過這個簡單的介面來訪問子系統的功能，而不需要直接與子系統的細節互動。外觀模式的目的是「簡化客戶端和子系統之間的交互」，降低客戶端對於子系統的依賴程度，同時提供了一個高層次的介面來統一訪問子系統的功能。這樣的設計有助於降低整個系統的複雜性，提高程式的可讀性和可維護性。在外觀模式中，通常有以下兩個角色：Facade（外觀）：這是外觀模式的核心類別，它負責提供了一個簡單的介面，用於封裝子系統的複雜操作。客戶端通常只與外觀類進行交互，而不需要直接訪問子系統。Subsystem（子系統）：這是一組相互關聯的類別或功能，它們共同實現了一個（或一些）複雜的功能。外觀模式將這些子系統封裝起來，使得客戶端不需要了解子系統的細節，只需通過外觀類來使用子系統的功能。\n維基百科：外觀模式（Facade pattern），是軟體工程中常用的一種軟體設計模式，它為子系統中的一組介面提供一個統一的高層介面，使得子系統更容易使用。外觀模式是一個物件導向程式設計中常用的設計模式。類似於一個建築學中的立面，該立面作為一個前端接口，來屏蔽更複雜的底層或結構代碼。外觀模式可以提供以下功能：「通用簡化的 API 屏蔽與更複雜的內部組件和結構，以提高 Software library 的可讀性和可用性」「為更通用的功能提供上下文特定的接口」「為 Monolithic System 或 Tight coupling 的軟體系統提供一個簡化的啟動點，更有利於更多的鬆耦合程式」。當一個系統非常複雜或難以理解時，開發人員通常會使用外觀模式，因為原系統通常有許多相互依賴的類別，或者因為其它的原因，使得直接調用原始程式碼會耗費極大的成本。Facade pattern 隱藏了更大系統的複雜性，為客戶端提供了一個更簡單的接口。\n特點 定義了一個算法族 封裝算法族中的每一個算法 不同的算法可以互相替換 UML Graphic classDiagram\rclass SkillFacade {\rvoid show();\r}\rclass Swordman {\rvoid chop();\rvoid hack();\rvoid parry();\r}\rclass Magician {\rvoid fire_magic_attack();\rvoid earth_magic_attack();\rvoid wind_magic_attack();\rvoid water_magic_attack();\rvoid heal();\r}\rclass Bowman {\rvoid aim();\rvoid throw();\rvoid toss();\rvoid shoot();\r}\rclass Thief {\rvoid poke();\rvoid kick();\rvoid evade();\rvoid counter_attack();\rvoid ninjutsu();\r}\rSkillFacade --\u003e Swordman\rSkillFacade --\u003e Magician\rSkillFacade --\u003e Bowman\rSkillFacade --\u003e Thief\rnote \"void show() {\\n　print(swordman.chop());\\n　print(swordman.hack());\\n　print(swordman.parry());\\n　print(magician.fire_magic_attack());\\n　print(magician.earth_magic_attack());\\n　print(magician.wind_magic_attack());\\n　print(magician.water_magic_attack());\\n　print(bowman.aim());\\n　print(bowman.throw());\\n　print(bowman.toss());\\n　print(bowman.shoot());\\n　print(thief.poke());\\n　print(thief.kick());\\n　print(thief.evade());\\n　print(thief.counter_attack());\\n　print(thief.ninjutsu());\\n}\"\r內文 外觀模式是一個相對來說比較好理解的設計模式。它的核心功能在於「簡化對子系統的操作」。我們用一個 RPG 遊戲來做說明：假設在一個 RPG 遊戲中，我總共可以選擇四種不同的職業作為遊玩的角色，分別是戰士、法師、弓箭手、和盜賊。不同的角色會有著不同的攻擊方法：戰士有橫劈、斜砍、格檔\u0026hellip;等技能；法師可以使用火、土、風、水\u0026hellip;等四種不同的元素攻擊，以及治癒；弓箭手可以透過瞄準提高下回合的傷害與命中，也可以進行射擊或投擲；盜賊則有普通揮砍、踢技、閃躲、反擊、和忍術\u0026hellip;等不同的攻擊方式。\n現在我們想要幫遊戲做一個「攻擊預覽」的頁面，裡面可以呈現每一個角色的每一種攻擊方式、攻擊描述、與攻擊特效。【視窗】的標題要跟隨不同的職業有所更換，【技能闡述】的位置也要根據技能有所不同，【動畫】當然也要依續撥放不同的技能動畫。【資訊欄】擇要顯示該攻擊模式的攻擊力、冷卻時間\u0026hellip;等不同的技能資訊\u0026hellip;。如果把所有程式寫在一起的話，可能就會像是這個樣子：\nint main(void) { Skill skill; Window* window = new Window(); AnimeWindow anime = window.getAnimeWindow(); InfoTable table = window.getInfoTable(); Swordman* swordman = new Swordman(); window.set_title(\u0026#34;Swordman\u0026#34;) window.set_subtitle(\u0026#34;chop\u0026#34;); skill = swordman.get_skill(\u0026#34;chop\u0026#34;); anime.show(swordman.skill.anime()); table.set_info(skill.description); window.set_subtitle(\u0026#34;hack\u0026#34;); skill = swordman.get_skill(\u0026#34;hack\u0026#34;); // more and more code... // more and more code... } 可以發現到：目前主程式 main 需要依賴很多個不同的類別與介面才能夠正常運行，包含了 Skill（技能類別）、Window（控制視窗的類別）、AnimeWindow（動畫視窗）、InfoTable（資訊欄）、以及各種不同的職業（Swordman, Magician, Bowman, 和 Thief）\u0026hellip;等，整體而言，是一個比較龐大和冗長的主程式。那為了簡化主程式的負擔，這邊我們可以採用「外觀模式」的程式撰寫方法：首先將整個系統分成【客戶】【外觀介面】與【子系統】三個部分：【客戶】就是目前的主程式 main、【外觀介面】是下面定一個一個類別、【子系統】則是包含 Window, Magician 在內的所有剛剛出現過的類別，我們可以透過「【客戶】呼叫【外觀介面】的方法，讓【外觀介面】決定要執行那些複雜的【子系統】」的方式，去簡化 main 的負擔，就如同以下的程式撰寫方法：\nclass SkillFacade { public: void show_all_skills(Character::Type type = Character::Type::ALL, int change_time = 10, bool change_button = false) { Window* window = new Window(); window.set_change_time(10); switch(type) { case Character::Type::ALL: show_swordman_skill(); show_bowman_skill(); show_magician_skill(); show_thief_skill(); break; case Character::Type::SWORDMAN: show_swordman_skill() break; // other codes ... } } void show_swordman_skill() { Skill skill; Window* window = new Window(); AnimeWindow anime = window.getAnimeWindow(); // other codes ... }; void show_swordman_skill() { /* codes ... */ }; void show_bowman_skill() { /* codes ... */ }; void show_magician_skill() { /* codes ... */ }; void show_thief_skill() { /* codes ... */ }; }; int main(void) { // show all skills SkillFacade facade = new SkillFacade(); facade.show_all_skills(); // magician skills only facade.show_magician_skills(Character::Type::MAGICIAN); // other codes ... } 透過一個統一的【外觀介面】（在這個例子下是 SkillFacade），透過包裝【子系統】（Window, InfoTable 或者是 Swordman \u0026hellip;等）讓【客戶】main 可以只通過簡單的方法調用（ex. facade.show()）就達成預期的系統需求，就是「外觀模式」所要傳達的理念。這樣的寫法不僅可以簡化【客戶】端的程式之外，也可以讓【客戶】那邊的程式達到更簡化、更易懂的功效。但這樣做也是有風險的：因為將程式全部轉嫁到【外觀介面】上，因此【外觀介面】容易有過多的依賴，此外，如果我們需要新的功能，也需要重新修改【外觀介面】中的程式，這違反了設計原則中的「開放封閉原則」。因此，除了了解外觀模式的功能之外，懂得何時使用更是一個需要好好研究的課題。\n小結 外觀模式的優點：\n可以簡化【客戶】端的程式 降低【客戶】與【子系統】的耦合程度 提高程式的可讀性和彈性 外觀模式的缺點：\n增加類別的數量，使系統愈發龐大 違背「開放封閉原則」 過多的功能可能會讓 Facade 有過多的依賴 "},{"id":13,"href":"/docs/computer_science/design_pattern/factory_method_pattern/","title":"工廠方法模式（Factory Method Pattern）","section":"設計模式","content":"\r工廠方法模式（Factory Method Pattern）\r#\r說明 ChatGPT：工廠方法模式（Factory Method Pattern）是一種軟體設計模式，屬於創建型模式之一。它提供了一種「分離物件的創建與使用」的方式，通過使用工廠類別內的方法來創建物件，而不是直接在客戶端代碼中使用 new 關鍵字。 在工廠方法模式中，工廠會定義了一個接口（或抽象類別），其中包含了創建產品物件的抽象方法，具體的物件創建則由實現該接口的具體工廠類別來實現。這樣一來，客戶端代碼只需要和工廠接口進行交互，而不需要知道具體的物件創建細節。工廠方法模式的核心思想是：「將物件的創建延遲到子類別中」，使得客戶端的程式與具體的物件創建解耦。這樣做的好處是，當需要新增一種具體的產品時，只需要擴展相應的具體工廠類別即可，不需要額外修改客戶端代碼，因此符合設計原則中的「開放封閉原則」。\n維基百科：在物件導向程式設計中，工廠方法模式（Factory Method Pattern）是一種創建型模式，它使用工廠方法來處理創建物件的問題，而不需要明確指定將要創建的物件的確切類別。這是通過調用工廠中的方法來創建物件來實現的，而不是通過調用構造函數來實現。其中，工廠中的方法可以在介面中抽象化，並由子類實現，或者在類別本身中實現，並由子類別選擇性地覆蓋。創建物件通常會擁有一個複雜的流程，該流程並不適合再複合類別中實現。物件的創建可能導致代碼的重複、可能需要組合物件無法訪問的資訊、可能無法提供足夠的抽象層次、或者可能與組合物件的關注點無關。因此，工廠方法模式通過「定義一個獨立的方法來創建物件」來解決這些問題，子類可以覆蓋該方法以指定將要創建的衍生類型。\n特點 將物件的「創建」與「使用」分離 可以輕易擴展 符合開放封閉原則 UML Graphic classDiagram\rclass EnchantingFactory~Interface~ {\rSword* createSword();\r}\rclass KnockbackFactory {\rSword* createSword() return KnockbackSword();\r}\rclass FireAspectFactory {\rSword* createSword() return FireAspectSword();\r}\rEnchantingFactory~Interface~ \u003c|-- KnockbackFactory\rEnchantingFactory~Interface~ \u003c|-- FireAspectFactory\r內文 小建議：可以先看過簡單工廠模式，再回來看這個「工廠方法模式」會比較好。\n如同簡單工廠模式所述：在四人幫的著作裡面，工廠模式共分為簡單工廠模式、工廠方法模式、和抽象工廠模式這三種。相對於「在【工廠】中直接建立【產品】」的簡單工廠模式，工廠方法模式更在乎「其他的『工廠』有沒有依循著同樣的『方法』」來建立物件。通常來說，工廠方法會先定義出一個『工廠介面』，再讓其他的【工廠】去繼承這個工廠介面，從而確保所有的【工廠】都有類似或相同的產品製造方法。用另外一個 RPG 遊戲來做舉例，假設在一個遊戲中，我們想要實作出不同附魔類別的劍，簡單工廠的方法可能會像是下面的樣子：\nclass SimpleFactory { public: static Sword* enchantSword(Enchantments enchantments) { Sword* sword = nullptr; switch(enchantments) { case Knockback: sword = new KnockbackSword(); break; case FireAspect: sword = new FireAspectSword(); break; // other codes ... } } }; 透過一個靜態方法 SimpleFactory::createSword()，打包跟整理所有製造不同附魔劍的流程，就是「簡單工廠模式」想要傳達的核心意念，簡單粗暴，但也淺顯易懂。但這樣做的壞處，在上一篇也有說明過了：高度的類別依賴，使得【工廠】類別變得難以維護，加上違反了「開放封閉原則」，使得程式在遇到不同版本的蝶帶或更新時，就會需要重新打開該方法來做修改。因此面對到「可能會頻繁調整不同類型的『附魔劍』」的情況，「工廠方法」的解決方式會是先定義一個【工廠介面】，再讓不同附魔類型的【工廠】去繼承並時做【工廠介面】中的方法：\nclass EnchantFactory { public: virtual Sword* enchantSword() { return (new Sword()); }; }; class KnockbackFactory : public EnchantFactory { public: Sword* enchantSword() override { return (new KnockbackSword()); }; }; class FireAspectFactory : public EnchantFactory { public: Sword* enchantSword() override { return (new FireAspectSword()); }; }; class Workspace { public: Sword* enchantKnockbackSword() { return (new KnockbackFactory()) -\u0026gt; enchantSword(); } Sword* enchantFireAspectSword() { return (new FireAspectFactory()) -\u0026gt; FireAspectSword(); } }; 透過把【附魔】這個動作拉出來，先定義一個抽象的【附魔工廠】，再讓各種不同的附魔（像是擊退、燃燒、鋒利、耐久\u0026hellip;等）分別開設不同的【工廠】，分開來處理「將『劍』附魔」這件事情，就是「工廠方法模式」會採取的解決方案了。相較於「簡單工廠」，工廠方法很好地將「附魔各種屬性」這份工作給獨立了出來。除此之外，工廠方法還具有一些其他的優勢：像是易於擴展同一層級的類別與物件。例如我們今天想要新增一個「高經驗」的武器屬性，讓玩家在獲得這把武器之後，如果用此武器擊殺怪物，可以獲得比較高的經驗值。在「簡單工廠」裡面，我們可能會需要先重新改寫 enchantSword() 的方法，加上一個 switch 裡面的 case 判斷，再在多依賴一個 HighExpSword 類別之類的。但在「工廠方法」之中，我們只需要新定義一個【高經驗工廠】，並且讓該工廠去改寫原【工廠】的 enchantSword() 就可以了。不需要去修改舊有的、已經存在的方法或類別。\n同時，不同於「簡單工廠」，因為在「工廠方法」中，我們獨立實作了不同種類的附魔，因此對付魔的新增或修改，都不會對【角色】程式，或其餘【附魔工廠】的程式產生易動，所以在「開放封閉原則」上面，「工廠方法」是有乖乖遵守的。同時，「工廠方法」也不再需要依賴大量的附魔型別。在「簡單工廠」中，如果我們要新增多個附魔的種類，就會需要讓【工廠】依賴更多的類別。但是在「工廠方法」中，每一個工廠只需要依賴一個【附魔項】以及「它所能夠附魔的武器種類」就可以了。\n所以話說到這邊，比較細心的朋友可能就有發現了：在這個例子裡面，工廠方法雖然分離了不同的【附魔項】，但它仍然依賴於某些【武器】類別。如果今天我們需要新增數以量計的【武器】類，這是不是就會讓「工廠方法」產生跟「簡單工廠」一樣的問題了呢？答案是\u0026hellip;對。\n框架一點來說，「工廠方法」在做的事情是「將【工廠】抽象化，不將【產品】抽象化。」在上述的例子裡，【工廠】就是各種的附魔工廠，可以是擊退工廠、燃燒工廠、高經驗工廠\u0026hellip;等。【產品】則是各種武器，包含劍、斧頭、弓\u0026hellip;等等。當然這個例子比較特別，可以把工廠跟產品的位置對調，變成武器工廠、附魔產品。但無論是做哪種更改，都無法改變「產品一多，依賴穰然會變嚴重」的問題，這同樣也是「工廠方法」天生的劣勢，因此「工廠方法」僅適用於「產品項不會有劇烈更動」的情況。\n如果你的「工廠」既需要滿足【工廠】的多樣性，同時也要保證【產品】變多之後，仍然不會產生高度依賴問題，那就不是「簡單工廠」跟「工廠方法」擅長的事情了，可以去了解看看「抽象工廠」模式。\n小結 工廠方法模式的優點：\n將【客戶】與【產品】分離，減少兩者間的依賴 簡化客戶端的接口與程式，提升可讀性 可以依據【客戶】的需求動態創建不同的【產品】物件 保有「開放封閉原則」，使維護程式的代價降低 工廠方法模式的缺點：\n類別的數量相對於「簡單工廠」會有更多 單純的「工廠方法」會讓【客戶】需要對【工廠】具有依賴 當【產品】過多，同樣也有「類別依賴」的問題 "},{"id":14,"href":"/docs/computer_science/design_pattern/abstract_factory_pattern/","title":"抽象工廠模式（Abstract Factory Pattern）","section":"設計模式","content":"\r抽象工廠模式（Abstract Factory Pattern）\r#\r說明 ChatGPT：抽象工廠模式（Abstract Factory Pattern）是一種創建型設計模式，它提供了一種「創建一系列相關或相互依賴對象」的接口，而無需指定具體的類別。該模式允許客戶端使用抽象接口來創建一組相關的對象，而不必關心實際的對象實現細節。抽象工廠模式的目標是實現產品族的創建，其中產品族是指「一組相互關聯的產品」，這些產品之間有共同的約束或邏輯關係。抽象工廠模式使得系統更具靈活性，易於切換產品族，而不需要修改客戶端程式。總的來說，抽象工廠魔是總共由四個核心部分組成：抽象工廠（Abstract Factory）：定義創建產品族的接口，通常由一個抽像類或接口來表示。該接口包含多個抽象方法，每個方法用於創建一個具體產品。具體工廠（Concrete Factory）：實現【抽象工廠】中的接口，負責創建具體的產品對象。抽象產品（Abstract Product）：定義產品族中的某類產品的接口，可以是抽象類別或接口。具體產品（Concrete Product）：實現【抽象產品】中的接口，負責定義實際產品的樣貌與屬性，【具體工廠】會創建這些產品的實例。\n維基百科：抽象工廠模式（Abstract factory pattern）是一種軟體開發設計模式。抽象工廠模式提供了一種方式，可以將一組具有同一主題的單獨的工廠封裝起來。在正常使用中，客戶端程式需要建立抽象工廠的具體實現，然後使用抽象工廠作為介面來建立這一主題的具體對象。客戶端程式不需要知道（也不需要關心）它從這些內部的工廠方法中獲得對象的具體類型，因為客戶端程式僅使用這些對象的通用介面。抽象工廠模式將「一組對象的實現細節」與「它們的使用」分離開來。【工廠】類別是建立產品的地方，其目的是將產品的建立與產品的使用分離。抽象工廠模式的目的，是將若干抽象產品的介面，與不同主題產品的具體實現分離開。這樣就能在增加新的具體工廠的時候，不用修改參照抽象工廠的客戶端代碼。使用抽象工廠模式，能夠在具體工廠變化的時候，不用修改使用工廠的客戶端代碼，甚至是在執行時。然而，使用這種模式或者相似的設計模式，可能給編寫代碼帶來不必要的複雜性和額外的工作。\n特點 將物件的「創建」與「使用」分離 可以輕易擴展 符合開放封閉原則 UML Graphic classDiagram\rclass Monster\rMonster \u003c|-- Zombie\rMonster \u003c|-- Goblin\rMonster \u003c|-- Skeleton\rclass Weaopn\rWeaopn \u003c|-- Sword\rWeaopn \u003c|-- Axe\rWeaopn \u003c|-- Bow\rclassDiagram\rclass MonsterFactory {\rMonster* create();\r}\rclass ZombieFactory {\rMonster* create() new Zombie()\r}\rclass GoblinFactory {\rMonster* create() new Goblin()\r}\rclass SkeletonFactory {\rMonster* create() new Skeleton()\r}\rMonsterFactory \u003c|-- ZombieFactory\rMonsterFactory \u003c|-- GoblinFactory\rMonsterFactory \u003c|-- SkeletonFactory\rclassDiagram\rclass WeaponFactory {\rWeapon* create();\r}\rclass SwordFactory {\rWeapon* create() new Sword()\r}\rclass AxeFactory {\rWeapon* create() new Axe()\r}\rclass BowFactory {\rWeapon* create() new Bow()\r}\rWeaponFactory \u003c|-- SwordFactory\rWeaponFactory \u003c|-- AxeFactory\rWeaponFactory \u003c|-- BowFactory\rclassDiagram\rclass AdvancedMonster {\rMonster* createAdvancedMonster();\r}\rnote \"Monster* createAdvancedMonster() {\\n　Monster* monster = MonsterFactory.create();\\n　Weapon* weapon = WeaponFactory.create();\\n　monster.equip(weapon);\\n　return monster;\\n}\"\r內文 小建議：可以先看過簡單工廠模式，和工廠方法模式，再回來看這個「抽象工廠模式」比較好。\n在程式的架構上，「抽象工廠模式」是三種工廠模式裡面最為複雜的一種。不同於簡單工廠模式僅僅是將生成產品的程式從【客戶】的類別中，拉到新增的【工廠】類別。也不同於工廠方法模式定義了一個抽象的【工廠】，再藉由實作不同種類的【實體工廠】以生成各式各樣的【實體產品】。「抽象工廠模式」則是從「工廠方法模式」去做延伸，不僅僅將【工廠】抽象化，同時也將【產品】進行了抽象化，讓兩者都可以在最大程度上，都可以解除對另外一方的依賴，以解決簡單工廠模式和工廠方法模式都存在的「類別依賴」問題。\n假設我們現在在製作一個 RPG 遊戲，遊戲的中後期階段，玩家會遇上一些比較高階的怪物，但這些怪物說穿了就是配備武器的普通怪物。如果是利用「簡單工廠模式」來實作這樣的怪物的話，可能會寫出類似於下面的程式出來：\nclass MonsterFactory { public: Monster* createAdvancedMonster(Monster monster, string weapon) { Monster advanced_monster = nullptr switch(monster) { case Zombie: advanced_monster = new Zombie(); if(weapon == \u0026#34;Sword\u0026#34;) advanced_monster.equip(new Sword()); else if(weapon == \u0026#34;Axe\u0026#34;) advanced_monster.equip(new Axe()); else if(weapon == \u0026#34;Bow\u0026#34;) advanced_monster.equip(new Bow()); break; case Goblin: advanced_monster = new Goblin(); if(weapon == \u0026#34;Sword\u0026#34;) advanced_monster.equip(new Sword()); else if(weapon ...) // other codes ... return advanced_monster; } } }; 簡單來說，「簡單工廠」的做法就是最純粹的各種判斷暴力破解。\n相對於簡單工廠，「工廠方法」的實作模式會再稍微有彈性一點點：工廠方法的做法會是先把所有的怪物拉出來獨立做一個【怪物】的工廠，再讓各種不同的【殭屍工廠】、【哥布林工廠】、【骷髏工廠】\u0026hellip;等去實作進階怪物的樣式。整體而言，雖然加了一點抽象化，增加類別的數量，但程式會變得比較好懂：\nclass MonsterFactory { public: Monster* monster; public: virtual Monster* equipSword() = 0; virtual Monster* equipAxe() = 0; virtual Monster* equipBow() = 0; }; class ZombieFactory : public MonsterFactory { public: ZombieFactory() : monster(new Zombie()) {}; public: Monster* equipSword() override { return monster.equip(new Sword()); } Monster* equipAxe() override { return monster.equip(new Axe()); } Monster* equipBow() override { return monster.equip(new Bow()); } }; class MonsterGenerator { public: Monster* monster_factory; public: Monster* getSwordMonster() { monster_factory = new ZombieFactory(); return monster_factory.equipSword(); } void changeMonsterFactory(MonsterFactory* factory) { monster_factory = factory; } }; 在「工廠方法」裡面，我們會需要定義「抽象工廠」、「具體工廠」、和「產品」三種東西。在上述的程式邏輯中，抽象工廠就是【怪物工廠】。具體工廠是【殭屍工廠】【哥布林工廠】\u0026hellip;等，產品則是【武器】。根據「工廠方法」的特性，抽象工廠中會有許多製造產品的方法，在這個例子裡就是「怪物裝備劍」「怪物裝備斧」「怪物裝備弓」\u0026hellip;等不同的高階怪物。實體工廠則負責這些產品的製作流程，因此【殭屍工廠】裡才會改寫【怪物工廠】裡面的方法。\n最後，我們會有一個【客戶】類別，用來接收不同的高階怪物，在這裡，客戶就是 MonsterGenerator。還記得嗎？剛剛說過：「產品是武器。」因此在這樣的架構下，我們不關心是何種怪物拿著武器，只關心怪物拿著什麼武器。所以通過調用 getSwordMonster() 方法，我們可以直接拿到一個「手中有劍的一隻怪物。」這就是「工廠方法模式」在生成高階怪物的時候的邏輯。\n同樣地，「工廠方法」相對於「簡單工廠」來說，在沒有複雜判斷的情況下，可以滿足「單一職責原則」與「開放封閉原則」但工廠方法的缺點同樣也有著「類別依賴」的問題。如果今天的【產品】驟增（怪物突然可以拿上百種的武器），那麼【怪物工廠】需要依賴的對象就不僅僅只有 Sword, Axe, Bow 那麼簡單了\u0026hellip;，因此為了解決這個問題，我們可以利用「抽象工廠模式」來達成這份任務：\nclass Monster {}; class Zombie : public Monster {}; class Goblin : public Monster {}; class Skeleton : public Monster {}; class MonsterFactory { public: virtual Monster* createMonster() = 0; }; class ZombieFactory : public MonsterFactory { public: Monster* createMonster() override { return (new Zombie()); } }; class GoblinFactory : public MonsterFactory { public: Monster* createMonster() override { return (new Goblin()); } }; class SkeletonFactory : public MonsterFactory { public: Monster* createMonster() override { return (new Skeleton()); } }; class Weapon {}; class Sword : public Weapon {}; class Axe : public Weapon {}; class Box : public Weapon {}; class WeaopnFactory { public: virtual Weapon* createWeapon() = 0; }; class SwordFactory : public WeaopnFactory { public: Weapon* createWeapon() override { return (new Sword()); } }; class AxeFactory : public WeaopnFactory { public: Weapon* createWeapon() override { return (new Sword()); } }; class BowFactory : public WeaopnFactory { public: Weapon* createWeapon() override { return (new Sword()); } }; class AdvancedMonsterGenerator { public: Monster* createAdvancedMonster(MonsterFactory* mf, WeaopnFactory* wf) { Monster* monster = monster_factory -\u0026gt; createMonster(); Weapon* weapon = weapon_factory -\u0026gt; createWeapon(); return monster.equip(Weapon); } }; 同樣也是「怪物工廠、武器產品」的邏輯，在「抽象工廠方法」的解決方案中，我們總共定義了五個東西：分別是【抽象工廠】（MonsterFactory）、【實體工廠】（ZombieFactory, GoblinFactory, SkeletonFactory）、【抽象產品】（Weapon）、【實體產品】（Sword, Axe, Box）、和【客戶】（AdvancedMonsterGenerator）。\n在「抽象工廠」中，【客戶】在 createAdvancedMonster() 的方法中，並不需要直接知道它會用到哪個【怪物工廠】（可能是殭屍？可能是骷髏\u0026hellip;），以及怪物會被裝備哪一種類型的武器（劍？還是斧？抑或是弓\u0026hellip;）整體而言，它只知道「會有一個工廠，把怪物生出來。然後會有另外一個工廠，幫我把這隻怪物配上武器。」整體的實作流程被工廠封裝的死死地，使得客戶對所有的細節完全無法理解，極度概念化與抽象化，這就是「抽象工廠模式」想要傳達的意涵。\n比較 簡單工廠模式（Simple Factory Pattern） 「簡單工廠模式」通過新增一個【工廠】類別來創建對象，【客戶】無需關心【產品】的實現流程與步驟，只需要提供給【工廠】參數或條件，讓【工廠】可以根據參數或條件創建對應的【產品】。此外，因為簡單工廠的【工廠】中，通常會使用個靜態方法來生成產品，因此也被稱為「靜態工廠模式」。然而，隨著【產品】的增加，「簡單工廠模式」的【工廠】可能會變得龐大，產生類別依賴的問題，同時，「簡單工廠模式」也不符合「開放封閉原則」。如果【產品】類型有做更動，【工廠】的方法也需要進行調整。\n工廠方法模式（Factory Method Pattern） 「工廠方法模式」透過將工廠區分成【抽象工廠】與【實體工廠】來達成「簡單工廠模式」不符合的「開放封閉原則」。在工廠方法模式中，每一個產品的生成，都先被定義在【抽象工廠】的方法之中。【實體工廠】只需要繼承並改寫該方法即可。不同【產品】之間的程式並不會相互影響，因此不會產生「新增或刪除一個產品，就會需要修改工廠中的所有方法」的情況。但同時，因為【產品】還是會直接在【實體工廠】中製作，因此當【產品】的數量過多時，同樣也會產生類別依賴的問題。這是該模式與簡單工廠模式都存在的既定問題。\n抽象工廠模式（Abstract Factory Pattern） 「抽象工廠」模式將整體流程定義成【抽象工廠】【實體工廠】【抽象產品】【實體產品】與【客戶】五項類別。【抽象工廠】負責定義【實體工廠】可能會需要的所有方法。【抽象產品】則定義【實體產品】中的各種係數，本質上兩者沒有過多的關聯。最後再由【客戶】分別透過【抽象工廠】的接口，與【抽象產品】的接口，去得到想要的【實體產品】。由於該模式本身的架構，無論是【實體工廠】還是【實體產品】，都不會對彼此帶有依賴。因此解決掉了前兩種模式中都無法改善的類別依賴問題。但與之相對的，「抽象工廠模式」也是需要最多類別實踐、以及擁有最複雜程式邏輯的工廠模式。\n簡單來說 簡單工廠模式：適合【工廠】跟【產品】兩種類別「皆無需要」擴增與更動的情況。 工廠方法模式：適合【工廠】或【產品】兩種類別「其一需要」擴增與更動的情況。 抽象工廠模式：適合【工廠】跟【產品】兩種類別「皆有需要」擴增與更動的情況。 沒有最完美的模式，只有最適合某種情境的設計模式。\n"},{"id":15,"href":"/docs/computer_science/recommended_books/","title":"推薦書單","section":"資訊工程","content":"\r推薦書單\r#\r書名 類型 閱讀難度 推薦指數 心得(?) 《深入淺出設計模式》 軟體工程 ★★★☆☆ ★★★★★ 心得連結 "},{"id":16,"href":"/docs/computer_science/design_pattern/template_method_pattern/","title":"模板方法模式（Template Method Pattern）","section":"設計模式","content":"\r模板方法模式（Template Method Pattern）\r#\r說明 ChatGPT：模板方法模式（Template Method Pattern）是一種行為設計模式，它定義了一个演算法的「框架」，並將該演算法的細節程式延遲到子類中進行實現。在模板方法模式中，一個抽象類別會公開定義一個（或多個）方法的骨架，而將一些方法中的具體細節推遲稻子類別中。這樣可以确保方法的整體結構不會改變，但允許子類別根據需要，重新定義某些步骤。在模板方法模式中，主要有三種類型的方法：模板方法（Template Methods）：模板方法會在方法內部定義一系列該方法的執行步驟。抽象方法（Abstract Methods）：抽象方法由抽象類別聲明，它們没有具體的程式細節，在模板方法模式中，子類必須實作這些方法。鉤子方法（Hook Methods）：鉤子方法有一個預設的程式實作，但子類別可以選擇性地呼叫或重寫它們，鉤子方法可以在模板方法中的不同步骤中，插入自定義的行為。\n維基百科：模板方法模式是一種行為設計模型和設計模式。模板方法（template method）是一個定義在父類別的方法，負責處理流程和演算法的不變部分。模板方法會呼叫多個定義在父類別的其他工具方法（helper method），這些方法是演算法的可變部分，有的工具方法可能只是抽象方法，並沒有實作，也有的工具方法已經有一些實作的程式，但仍允許子類改寫。模板方法僅決定這些抽象方法的執行順序，這些抽象方法由子類別負責實作。此外，子類別不允許覆蓋模板方法（意即不能重寫處理流程）。這種設計模式是一種控制反轉的實現方式。因為高層級的程式不再需要控制演算法的細節實作，而僅需在意演算法的框與流程。\n特點 定義了一個算法流程 將各流程的實際實作延遲至子類進行實踐 子類的實作方式各不同，但流程相同 UML Graphic classDiagram\rclass CharacterCreator {\rRace* race;\rAppearance* appearance;\rAttribute* attribute;\rvoid createCharacter(); : cannot override\rvoid selectRace();\rvoid selectAttributes();\rvoid customizeAppearance();\rbool hasUniqueAbility();\rvoid customizeUniqueAbility();\rvoid saveCharacter();\r}\rnote \"void createCharacter() {\\n　selectRace()\\n　selectAttributes()\\n　customizeAppearance()\\n　if(hasUniqueAbility()) {\\n　customizeUniqueAbility()\\n　}\\n　saveCharacter()\\n}\"\rclass Orcish {\rselectRace(): \"orcish\"\r}\rclass NightElf {\rselectRace(): \"night elf\"\rhasUniqueAbility() : true\rcustomizeUniqueAbility() : invisible at night\r}\rclass Undead {\rselectRace(): \"undead\"\r}\rCharacterCreator \u003c|-- Human\rCharacterCreator \u003c|-- Orcish\rCharacterCreator \u003c|-- NightElf\rCharacterCreator \u003c|-- Undead\r內文 模板方法模式顧名思義，就是一種「模式」，該模式提供了一個「方法」，會在該方法裡面先定義好一系列的算式、演算法\u0026hellip;等作為「模板」，並提供給所有繼承此類別的子類去做使用。就像上面的 UML 圖的例子。在【創建角色】的類別裡面，我們定義了一個名為 createCharacter() 的方法，並在方法內部先定義好一系列創漸漸角色的過程：像是種族 selectRace()、屬性 selectAttributes()、外觀 customizeAppearance()、特殊技能 hasUniqueAbility()\u0026hellip;等等。並讓【人類】【半獸人】【夜精靈】【不死族】這四個類別繼承【創建角色】，以便它們 4 個各自去實作各自的角色造型與能力。\n在這之中，定義演算法框架，同時又無法子類別所改寫的方法 createCharacter() 就是「模板方法」。其餘像是 selectRace(), selectAttributes() \u0026hellip; 等方法可以統稱叫「工具方法」。工具方法在父類別中如果沒有程式的實作，則也可以被稱為「抽象方法」，最後，子類別可以自行選擇執行與否的方法（像是 hasUniqueAbility() 與 customizeUniqueAbility()）除了被稱作「工具方法」之外，也可以被稱為「鉤子方法」。\n除了上述的 RPG 例子之外，現實中還有許多例子可以使用到模板方法模式：例如有個【選擇陣列中第 n 小的元素】的方法，除了可以直接寫死演算法之外，它可以被定義為一個模板方法：\nclass ArrayOperation\u0026lt;T\u0026gt; { Array* ary; abstract void sort(ary); abstract T choose(ary, n); final T n_th_element(ary, n) { sort(ary); T element = choose(ary, n); return element; } } 在這個 n_th_element() 的方法中，我們只有定義該方法需要「先進行排序」「再進行挑選」，但我們並沒有說明要「如何排序？如何挑選？」因此任何繼承 ArrayOperation 的類別都可以自由選擇排序與選擇的方式，可能 A 類別會實作一個泡沫排序 + 依序搜尋的演算法，B 類別會實作一個快速排序 + 二元搜尋的演算法 \u0026hellip;等等。\n小結 模板方法模式的優點：\n保持各種操作流程的一致 降低重複程式的撰寫 易擴展、方便程式重複使用 提高程式的彈性、可讀性、替換性 模板方法模式的缺點：\n限制了部分的程式創作彈性 增加程式的複雜性 在某些語言（ex. JAVA）可能會受到單一繼承的限制 "},{"id":17,"href":"/docs/computer_science/design_pattern/bridge_pattern/","title":"橋接模式（Bridge Pattern）","section":"設計模式","content":"\r橋接模式（Bridge Pattern）\r#\r說明 ChatGPT：橋接模式（Bridge Pattern）是軟體設計模式的一種，它屬於結構型模式之一。橋接模式的主要目的是「將『抽象部分』與『實現部分』分離」，使它們可以獨立地變化，從而降低了它們之間的耦合性。在軟體開發中，常常會遇到「類之間的耦合」和「功能之間的耦合」。類之間的耦合指的是一個類與另一個類之間的相依關係，而功能之間的耦合則是指一個類內部不同功能模塊之間的相依關係。當類之間的耦合度過高時，一個類的變化可能會影響到其他相關的類，這樣的系統就會變得脆弱且難以擴展。橋接模式通過使用抽象和實現之間的分離，解決了這些耦合性問題。在橋接模式中，『抽象部分』和『實現部分』分別由兩個獨立的類層次結構來表示。抽象部分包含高層次的抽象介面，而實現部分則包含具體的實現細節。這樣，抽象部分和實現部分可以獨立擴展，互不影響。\n維基百科：橋接模式（Bridge Pattern）是軟體工程中使用的一種設計模式，它旨在「將抽象與其實現分離，以便兩者可以獨立變化」，是由四人幫引入的一種設計模式。橋接模式使用封裝、聚合，並且可以使用繼承將職責分離到不同的類中。當類別經常變化時，物件導向程式設計的功能就變得非常有用，因為即使對程式有很少的先驗知識，也可以輕鬆地更改程式代碼。當類別及其功能經常變化時，橋接模式會顯得非常有用。類別本身可以被視為抽象，而類別可以做的行為則被視為實例。橋接模式也可以被認為是兩層抽象。\n特點 分離抽象介面與實例創建的程式邏輯 可將抽象類別與實例類別獨立開來 採用「組合」的方式減少「繼承」的大量使用 UML Graphic classDiagram\rclass Character~Interface~ {\rWeapon* weapon\rArmor* armor;\rvoid equip();\rvoid attack()\rvirtual void weild();\rvirtual void swing();\rvirtual void unweild();\r}\rnote \"void equip() {\\n　print(equip weapon.name);\\n　print(equip armor.name);\\n}\"\rnote \"void attack() {\\n　weapon.waild();\\n　weapon.swing();\\n　weapon.unweild();\\n}\"\rCharacter~Interface~ \u003c|-- Knight\rCharacter~Interface~ \u003c|-- Warrior\rCharacter~Interface~ \u003c|-- Thief\rclassDiagram\rWeapon~Interface~ \u003c|-- Sword\rWeapon~Interface~ \u003c|-- Axe\rWeapon~Interface~ \u003c|-- Dagger\rArmor~Interface~ \u003c|-- AlloyArmor\rArmor~Interface~ \u003c|-- IronArmor\rArmor~Interface~ \u003c|-- LeatherArmor\r內文 橋接模式的核心觀念是「多用組合、少用繼承」。也就是合成/聚合複用原則（CARP - Composite/Aggregate Reuse Principle）所提倡的概念。橋接模式的用途在於「將二維（或多維）的程式邏輯轉變為兩個（或多個）一維的狀態」讓我們用一個 RPG 遊戲來做舉例：假設我們這在撰寫一個 RPG 遊戲，遊戲裡面提供了「騎士、戰士、和盜賊」3 種不同的職業類別。遊戲裡面也定義了「劍、斧頭、和匕首」3 種不同的武器選項，以及「皮製護具、鐵製鎧甲、與合金盔甲」3 種不同的防禦性裝備。因為我們允許不同的職業做不同的武器防具組合（『騎士 + 劍 + 鐵製鎧甲』，或者『盜賊 + 斧頭 + 皮製護具』\u0026hellip;等），因此在當前的情況下，總共會有 \\(3 \\times 3 \\times 3 = 27\\)\r種不同的組合。那如果我們單純用 Character 類別 + 繼承來實現這組遊戲腳色的程式的話，可能就會像下面這個樣子：\nclass Character {}; class Knight_With_Sword_And_AlloyArmor : public Character {}; class Knight_With_Sword_And_IronArmor : public Character {}; class Knight_With_Sword_And_LeatherArmor : public Character {}; class Knight_With_Axe_And_AlloyArmor : public Character {}; class Knight_With_Axe_And_IronArmor : public Character {}; // more and more classes class Thief_With_Dagger_And_LeatherArmor : public Character {}; 像這樣的程式，雖不失為一種撰寫方法，但很明顯地，當我們想要對於特定的維度進行調整時（新增一個職業；修改武器的描述\u0026hellip;等），無疑是對工程師的一大夢魘。因此，在這樣的情況下（也就是程式含有二維或多維個變因的情形），利用「橋接模式」來代替「大量繼承」會是一個相對比較好的撰寫方法：也就是將所有的抽象類別組合、聚集起來，再由實例類別進行組裝、實際黏合，就像是下面這個樣子：\nclass Weapon {}; class Sword : public Weapon {}; class Axe : public Weapon {}; class Dagger : public Weapon {}; class Armor {}; class AlloyArmor : public Armor {}; class IronArmor : public Armor {}; class LeatherArmor : public Armor {}; class Character { Weapon* weapon; Armor* armor; } class Knight : public Character { public: Knight(Weapon* w, Armor* a) : weapon(w), armor(a); }; class Warrior : public Character { public: Warrior(Weapon* w, Armor* a) : weapon(w), armor(a); }; class Thief : public Character { public: Thief(Weapon* w, Armor* a) : weapon(w), armor(a); }; 在上述的程式中，我們共定義了 3 個抽象類別（Weapon, Armor, Character）和 9 個實例類別（各 3 種武器、防具、與職業）。透過這 12 個不同的抽象類和實例類，我們就可以完成上述的程式要求了。除此之外，如果今天我們想要編輯一些不同維度的遊戲資料（例如剛剛所說的：新增一個職業、或者是修改武器的描述\u0026hellip;等）相對於過去的做法可能會需要新增大量的繼承類別，現在我們只要在某一個抽象類別中，新增實例類別就可以了（ex. class Bow : public Weaopn()），對於其他程式碼的影響幾乎是微乎其微，或者是完全不會影響。除了提升程式的可讀性之外，也大大地降低了程式的維護成本。\n小結 橋接模式的優點：\n分離抽象類別和實例類別的程式 可以動態地切換或組合不同部件中的實例 提高程式的可讀性與降低程式維護成本 橋接模式的缺點：\n過多的組合可能會生成大量的類別 增加系統的大小、複雜度變高 不適合在簡單、小型的程式專案上面使用 "},{"id":18,"href":"/docs/computer_science/design_pattern/state_pattern/","title":"狀態模式（State Pattern）","section":"設計模式","content":"\r狀態模式（State Pattern）\r#\r說明 ChatGPT：狀態模式（State Pattern）是一種行為型設計模式，它允許物件在相異的狀態下展現不同的行為，並讓使用者看起來好像改變了它的類別。這種模式可以將物件的狀態封裝在不同的類別中，並且使物件能夠在運行時根據狀態的改變而改變其行為。狀態模式的主要目的是將複雜的條件判斷轉換成一組一組相關的狀態類別，從而使代碼更具可讀性、可維護性和可擴展性。它遵循開放-封閉原則，因為可以通過添加新的狀態類別來擴展系統的行為，而無需修改現有的代碼。使用狀態模式，可以將每個狀態實現為一個具體狀態類別，並將狀態相關的行為封裝在這些類別中。上下文類別（VendingMachine）持有當前狀態的引用，並將相應的請求委派給當前狀態對象。當狀態發生改變時，上下文物件將切換到新的狀態，並且行為也隨之改變。透過狀態模式，可以實現狀態機進行狀態轉換和行為管理的解耦，使得系統更靈活、可擴展且易於維護。\n維基百科：狀態模式是一種行為型設計模式，它允許對象在内部狀態改變時，改變其行為。該模式與有限狀態機的概念密切相關。狀態模式可以解释為一種策略模式，通過調用模式接口中定義的方法來切換策略。狀態模式在軟體工程中用於封裝同一對象的不同行為，基於其內部狀態。這可以是對象在運行時改變行為的一種清晰呈現，而無需使用大量的 if else 語句，從而提高可維護姓。狀態模式旨在解决兩個主要問題：「對象在何時改變其狀態與行為」「不同的狀態與行為該如何定義」。也就是說，在狀態模式下，增添新的狀態並不會影響原有的狀態與各自的行為。此外，因為直接在一個類別中實特定狀態的行為是不靈活的因此該模式會為每個狀態定義一個單獨的狀態接口，並定義單獨的狀態對象，封装每個狀態的特定行為。並於類別中切換與調用。\n特點 將每一種「狀態」各自定義成一個類別 透過委託的方式，讓各狀態分別實現不同的行為 通常會配合枚舉（enum）一同使用 State Graphic stateDiagram\rStand --\u003e SquatDown\rStand --\u003e Walk\rStand --\u003e Jump\rStand --\u003e Attack\rSquatDown --\u003e Stand\rSquatDown --\u003e Attack\rWalk --\u003e Stand\rWalk --\u003e Run\rWalk --\u003e Jump\rWalk --\u003e Attack\rRun --\u003e Stand\rRun --\u003e Roll\rRun --\u003e Jump\rRun --\u003e Attack\rRoll --\u003e Stand\rRoll --\u003e Attack\rJump --\u003e Stand\rJump --\u003e Walk\rJump --\u003e Attack\rAttack --\u003e Stand\r內文 假設我們正在製作一款 2D 橫向卷軸的 RPG 遊戲，玩家可以透過不同的按鍵操縱遊戲中的角色。在不使用狀態模式的程式撰寫方法下，我們可能會需要利用一些的條件判斷語句來完成「角色移動」的這個概念，就如下面的程式所示：\nclass Character { void move() { while(key.press(left)) { MoveLeft(); } while(key.press(right)) { MoveRight(); } } }; 在上述的程式中，我們總共定義了 2 種不同的動作，分別是「往左」和「往右」。接下來，我們對角色添增更多的行為：角色再左右移動的時候，可以重複按一次相同的移動按鍵，如此一來，就可以從【走路】切換為【跑步】，而在【跑步】的過程中，如果放開按鍵，則會直接回到原本站立的姿勢。那這樣一來，程式就可能會變成下面的樣子：\nclass Character { void move() { while(key.press(left)) { MoveLeft(); while((key.pressAgain(left))) { RunLeft(); } } while(key.press(right)) { MoveRight(); while((key.pressAgain(right))) { RunRight(); } } } }; 接下來，我們想要讓角色可以進行蹲下的動作，並且這個【蹲下】有幾種不同的狀況：如果角色是貼立於地面的話則會進行普通的蹲下，如果角色是移動中收到了「蹲下」的指令，同樣也是原地蹲下，但角色如果在【跑步】狀態下按下蹲下，角色就會【前滾翻一圈】之後【蹲下】，程式也許就會變成這個樣子：\nclass Character { void move() { while(key.press(left)) { MoveLeft(); if(key.press(down)) { SquatDown(); break; } while((key.pressAgain(left))) { if(key.press(down)) { Roll(); SquatDown(); return; } } } while(key.press(right)) { MoveRight(); if(key.press(down)) { SquatDown(); break; } while((key.pressAgain(right))) { RunRight(); if(key.press(down)) { Roll(); SquatDown(); return; } } } if(key.press(down)) { SquatDown(); } } }; 我們可以發現到：在這樣的程式撰寫之下，我們每為角色進行增添一個新的動作， move() 這個函數就會以有方常大量和散亂的地方需要進行修改與修正，而且因為動作某些動作必須要用前置動作觸發，像是【翻滾】之前必須要【跑步】，【跑步】之前一定要【行走】，因此動作的判定就會越來越巢狀，越來越波動拳 \u0026hellip;。如果我們今天又想要新增一個【跳躍】的函數，它可以在「站立時跳」「行走時跳」「跑步時跳」甚至「蹲下能跳得更高」\u0026hellip;，最後再加上各種角色姿勢下的攻擊行為和特效：站立攻擊、衝刺攻擊、低重心攻擊、跳躍攻擊、向下斬擊、翻滾之後向上突刺\u0026hellip;。光是聽到這些需求，就足夠你頭痛好久了。\n因此，為了解決這種情況，我們決定將「狀態模式」加進程式的架構裡面：狀態模式可以將一個物件的 每.一.種.狀.態. 都視為一個獨立的類別，並進行不同的組合與套用。在上述的例子中，我們就會把【站立】【行走】【跑步】【蹲下】【跳躍】【翻滾】【攻擊】\u0026hellip;等不同的角色行為，全部宣告成各自獨立的類別，並將所有類別繼承在一個名為【動作】的類別之下，再透過「方法」的方式，建立狀態與狀態之間的關係：\nclass Action {}; class Stand : public Action { void just_stand() { cout \u0026lt;\u0026lt; \u0026#34;Stand.\u0026#34;; } void from_run() { cout \u0026lt;\u0026lt; \u0026#34;Stand after run.\u0026#34;; } void from_squat_down() { cout \u0026lt;\u0026lt; \u0026#34;Stand after squat down.\u0026#34;; } }; class Walk : public Action { void walking() { cout \u0026lt;\u0026lt; \u0026#34;Walking.\u0026#34;; } void from_stand() { cout \u0026lt;\u0026lt; \u0026#34;start walking ...\u0026#34;; } }; // Other actions ... class Character { Stand* stand; Walk* walk; Run* run; SquatDown* squat_down; Jump* jump; Roll* roll; Attack* attack; enum State { STAND, WALK, RUN, SQUATDOWN, JUMP, ROLL, ATTACK }; State state = STAND; void move() { switch(state) { case STAND: if(pressing_walking_key()) { state = WALK; walk.from_stand(); } else if(pressing_squat_down_key()) { state = SQUATDOWN; squat_down.from_stand(); } else if(pressing_attack_key()) { state = ATTACK attack.from_stand(); } else { stand.just_stand(); } break; case WALK: // Other codes ... // Other codes ... // Other codes ... } } }; 相較於將所有動作的判斷放進【角色】的 move() 方法中，將 \u0026ldquo;每一個【動作】都定義成類別\u0026rdquo; 可以讓整個【角色】與 move() 方法得到更大的彈性和可讀性。雖然現在【角色】類別裡面的成員變數增加了許多，像是 Stand* stand, Walk* walk\u0026hellip;等，但在程式的撰寫上卻是更加地平易近人：\n在這樣的程式邏輯下，對於【角色】來說，雖然還是免不了有著許多的 if else 判斷，但相對於第一版的巢狀判斷，如果我們現在需要對某些動作做新增或刪除，例如新增「一個【跑步】時可以【迴避】怪物的攻擊」的動作，我們只需要先新增一個 Escape() 類別，再在 case RUN: 裡面加上一個 if press_escape_key: escape.from_run() 之類的語句，並在 Escape() 類裡實作出「跑步時要怎麼迴避」就可以了。\n像這種「將相互有關聯的不同【狀態】獨立開來，再利用不同的『方法』重新建立起【狀態】與【狀態】之間的關聯」就是狀態模式想要傳達的精隨與真諦了。\n小結 狀態模式的優點：\n減少了條件判斷語句的巢狀使用 增加程式的可讀性與可維護性 將相關的動作封裝在不同的狀態類別中，使系統結構清晰 符合開放-封閉原則 容易擴展新的狀態類別 狀態方法的缺點：\n類別的數量會與狀態的數量呈正相關 程式的邏輯關聯會被打散 過多的類別可能使程式占用的空間變大 "},{"id":19,"href":"/docs/computer_science/design_pattern/builder_pattern/","title":"生成器模式（Builder Pattern）","section":"設計模式","content":"\r生成器模式（Builder Pattern）\r#\r說明 ChatGPT：生成器模式（Builder Pattern）是一種軟體設計模式，用於創建複雜物件時，將建構過程和表示分離，使得同樣的建構過程可以創建不同的表示。這種模式通常用於創建具有多個可選屬性的物件，以及具有多個步驟或配置過程的物件。通常來說，一個創建者模式裡面，主要包含以下幾個元素：產品（Product）：這是要建構的複雜物件，通常包含多個屬性。它可以是一個複雜的類別或結構。建構者（Builder）：建構者通常是一個介面（或抽象類別），它定義了建構產品的各個步驟，並且可能包含設置屬性的方法。具體建構者（Concrete Builder）：實現建構者介面的類別，負責實際建構物件並設置其屬性。指揮官（Director）：可選元素，對於複雜的建構過程，可以使用指揮者來將建構過程進行組織和管理，以確保生成符合需求的物件。\n維基百科：生成器模式（Builder Pattern）是一種設計模式，又名：建造者模式、創建者模式，是一種對象構建模式。它可以將對象的建造過程，利用一系列抽象的步驟提取出來，使這個抽象過程的不同實現方法可以構造出不同表現（屬性）的對象。生成器模式解決了以下的幾問題：一個類別如何擁有類似的建構過程，但又可以創建出具有不同屬性的物件？一個類別如果包含大量的屬性，它該如何簡化包含建構複雜物件的類別？生成器設計模式描述了如何解決這些問題的方法：將「創建」和「組裝複雜物件」的部分封裝在一個獨立的建構者（Builder）物件中。類別將物件的建構委託給建構者，而不是直接創建物件。\n特點 可以分離生成物件的過程 相對於建構子，具有有更佳的彈性和擴展性 支援不同種類的物件生成方式 UML Graphic classDiagram\rclass Character {\rstring name\rRole* role\rWeapon* weapon\rArmor* armor\rElement* element\r}\rclass CharacterBuilder {\rvoid setName()\rvoid setRole()\rvoid setWeapon()\rvoid setArmor()\rvoid setElement()\rCharacter* getCharacter()\r}\rCharacterBuilder \u003c|-- WarriorBuilder\rCharacterBuilder \u003c|-- MagicianBuilder\rCharacterBuilder \u003c|-- ArcherBuilder\rCharacterBuilder \u003c|-- AssassinBuilder\rclass CharacterDirector {\rCharacterDirector(CharacterBuilder* b)\r}\rCharacter --\u003e CharacterDirector\rCharacterDirector o-- CharacterBuilder\r內文 假設我們在製作一款 RPG 遊戲，其中在「創建角色」的過程，角色可以選定「戰士、弓箭手、法師、盜賊」其中一種職業遊玩。角色的屬性主要分成以下四種類型：【名稱】名稱由玩家自行填寫，不可為空。【武器】武器會根據角色所選的職業有所不同，戰士可以手持劍或斧、弓箭手固定為弓、法師的武器固定為長杖、盜賊固定為匕首。【護具】護具同樣由職業做綁定：戰士使用鐵製護具，弓箭手使用皮革護具、盜賊同樣使用皮革護具，法師則沒有護具。【元素屬性】元素屬性也是綁定職業：戰士不具有任何元素屬性（純物理攻擊）、弓箭手固定為風屬性、盜賊可以選擇不持有屬性或持有風屬性的能力、法師則可以在火土風水之中選擇一種主要屬性使用。\n可以發現到：在程式裡面，如果我們想要生成一個角色，它至少需要帶有五項參數（名稱、職業、武器、護具類型、屬性）且除了名稱與職業之外，其餘的三項參數都有許多不同的變化，其中護具與屬性更是可能為空（法師沒有護具、戰士不具有屬性、盜賊屬性可選，但選項固定）。在這樣的情況下，如果我們打算利用 Character 的建構子暴力完成角色的創建的話，可能會寫出類似下面的程式出來：\nclass Role {}; class Warrior : public Role {}; class Magician : public Role {}; class Archer : public Role {}; class Assassin : public Role {}; class Weapon {}; class Sword : public Weapon {}; class Axe : public Weapon {}; class Bow : public Weapon {}; class Dagger : public Weapon {}; class Staff : public Weapon {}; class Armor {}; class IronArmor : public Armor {}; class LeatherArmor : public Armor {}; class NoArmor : public Armor {}; class Element {}; class NoneElement : public Element {}; class Wind : public Element {}; class Fire : public Element {}; class Water : public Element {}; class Earth : public Element {}; class Character { public: // create for Warrior Character(string name, Role* role, Weapon* weapon, Armor* armor); // create for Archer / Assassin Character(string name, Role* role, Weapon* weapon, Armor* armor, Element* element); // create for Magician Character(string name, Role* role, Weapon* weapon, Element* element); // create for Assassin Character(string name, Role* role, Weapon* weapon, rmor* armor); // other codes ... } 顯而易見，這樣的程式並不具備彈性和擴充性。如果我們今天想要做一點修改：新增「副武器」這項屬性，同樣也是副武器會針對不同的職業有著不同的情境；新增「海盜」這個職業，海盜不具有護甲和元素屬性；此外增強「戰士」，讓它除了「無」屬性之外，可以多選擇「火」屬性提升攻擊，或選擇「土」屬性提升防禦\u0026hellip;。可想而知，如果用「建構子模式」來實現這些改動的話，除了費工又容易出錯之外，對於往後的更新也是很難進行的。因此，在生成器模式中，我們會對這個不好的程式寫法做以下的改動：\n將創建【角色】的任務從【角色】本身抽離 如果所有的角色創建都要在【角色】裡面進行實作的話，不可避免的，根據不同的需求，我們會需要超多不同的建構子。這將使得【角色】類別變得愈發龐大、可讀性變差、複雜性變高、同時也不符合「開放封閉原則」，因為每當有角色需要進行修改，就要重新打開【角色】這個類別的程式進行修繕。所以，取而代之的，我們會先建立一個名為【創建角色】的抽象類別（Builder），讓所有繼承【創建角色】的類別去實作創建角色這件事情，在這邊會以職業作為區分，生成【創建戰士】【創建弓箭手】\u0026hellip;等不同類型。這樣一來，之後如果需要修改程式（例如：新增職業、修改職業的預設屬性\u0026hellip;等）只要針對該職業的【創建】去做修改就行，就不會影響到其他職業的程式了。\nclass Character { public: string name; Role* role; Weapon* weapon; Armor* armor; Element* element; private: Character() {}; public: static getEmptyCharacter() { Character character = new Character(); character -\u0026gt; name = \u0026#34;\u0026#34;; character -\u0026gt; role = nullptr; character -\u0026gt; weapon = nullptr; character -\u0026gt; armor = new NoArmor(); character -\u0026gt; element = new NoElement(); }; } class CharacterBuilder { private: Character* character; public: CharacterBuilder() { character = Character::getEmptyCharacter(); } } 讓【創建角色】可以設定【角色】中的參數項 這應該沒甚麼問題？畢竟【創建角色】的工作就是要生成一個角色，既然你要生成角色，那可以透過該類別去修改或調整【角色】中的屬性應該是顯而易見的。所以在實作上，我們會根據【角色】的不同屬性，去撰寫不同的「方法」，像是 setName(), setRole(), setWeapon() \u0026hellip; 等等。這邊可以注意一個小細節：雖然在想法上【創建角色】可以進行所有屬性的設定，但對於一些固定不變的東西（像是戰士固定無屬性、弓箭手固定風屬性、法師固定沒有護具、盜賊的武器度固定是匕首\u0026hellip;等），在各職業的創建類別中就不一定要去撰寫方法了。\nclass CharacterBuilder { protected: Character* character; public: CharacterBuilder() { character = Character::getEmptyCharacter(); } public: virtual void setName(string name) {}; virtual void setRole(Role* role) {}; virtual void setWeapon(Weapon* weapon) {}; virtual void setArmor(Armor* armor) {}; virtual void setElement(Element* element) {}; } 把所有的步驟重新串起來 這個步驟有兩種做法：一種是在【創建角色】中新增一個 build() 方法（或 create()），讓該方法可以 return 一個角色回去。這種作法通常會搭配 chaining （鏈式呼叫）一同執行，讓程式最後變得像是 Builder .setName() .setRole() .setWeapon() \u0026hellip; .build() 這樣的感覺，算是一種蠻常見的作法，像是在 Java 的 Awt, Swing，或者是 String 中就可以看到。實際做出來的感覺會像是下面的這個樣子：\nclass WarriorBuilder : public CharacterBuilder { void setName(string name) override { character -\u0026gt; name = name; }; void setRole(Role* role) override { character -\u0026gt; role = new Warrior(); }; // other codes ... Character* build() { return character; } } int main(void) { Character* Janna = (new MagicianBuilder()) .setName(\u0026#34;Janna\u0026#34;) .serRole(new Magician()) .setWeapon(new Staff()) .setArmor(new NoArmor()) .setElement(new Wind()) .build(); } 另一種做法是調用一個指揮官（Director），先把 Builder 丟給 Director，再從在 Director 裡面建立一個方法（例如 getCharacter()），並在該方法裡面執行所有的 Builder 要做的所有事情，最後再返回一個【角色】的物件回去。整體而言，它有點像是模板方法模式在做的事情，這種方法的好處是，即使每一個 Builder 裡面都有分別實作不同的方法、設定不同的參數 \u0026hellip;等，但無論方法內部是怎麼處理，在創建程序的最後最後，我們都可以透過一個 Director 去確保所有創建程序的一致性，寫法會像是下面這個樣子：\nclass MagicianBuilder : public CharacterBuilder { private: string name; Element* element; public: MagicianBuilder(string name, Element* element) : name(name), element(element) {} public: void setName() { character -\u0026gt; name = name; } void setRole() { character -\u0026gt; role = new Magician(); } // other codes ... Character* getCharacter() { return character; } } class CharacterDirector { public: static Character* createCharacter(CharacterBuilder* builder) { builder -\u0026gt; setName(); builder -\u0026gt; setRole(); builder -\u0026gt; setWeapon(); builder -\u0026gt; setArmor(); builder -\u0026gt; setElement(); return builder -\u0026gt; getCharacter(); } }; int main(void) { CharacterBuilder builder = new MagicianBuilder(\u0026#34;Janna\u0026#34;, new Wind()); Character* Janna = CharacterDirector::createCharacter(builder); } 小結 創建者模式的優點：\n封裝建構物件的過程，減少建構子的負擔 提高程式碼的可讀性、可過展性 支援逐步建構、不同參數的建構方式 創建者模式的缺點：\n增加程式碼複雜性和記憶體消耗 不適用於簡單生成的物件 過多的 Builder 可能會導致類別的數量遽增 "},{"id":20,"href":"/docs/computer_science/design_pattern/strategy_pattern/","title":"策略模式（Strategy Pattern）","section":"設計模式","content":"\r策略模式（Strategy Pattern）\r#\r說明 ChatGPT：策略模式（Strategy Pattern）是一種行為型設計模式，該模式允許在程式運行時，根據不同的需求，選擇不同的算法或行為。策略模式將演算法的定義、演算法的實現、和演算法的使用分離，這種彈性的程式撰寫方式，使得它們可以彼此獨立地變化，互相替換。策略模式的核心思想，是將「行為」封裝各種成獨立的「策略」，使得使用者（或程式）可以根據需要，選擇實踐不同的策略，同時需要改變策略的程式碼。這種靈活性和可替換性，使得策略模式在需要動態地改變物件的行為的情況下非常有用，並且能夠實現高度可定制和可擴展的系統設計。\n維基百科：策略模式是一種行為型軟體設計模式，它可以在運行時選擇一個演算法。程式在撰寫的過程中，不會直接實現單一的演算法，而是根據運行時的指示。從一系列的篩選方式中，選擇一個方法出來。策略模式使得演算法能夠獨立於使用它的客戶端變化，它將「選擇使用哪個演算法」的決策推遲到運行時，可以使呼叫程式的方式更靈活和可重用。例如，對輸入數據進行驗證的類別可以使用策略模式，根據類型、來源、使用者選擇、或其他區分因素來選擇驗證演算法。因為這些後天的因素需要直到運行時才知道，因此不同的輸入可能需要執行完全不同的驗證。在此情況下，將驗證演算法（策略）與驗證的物件分開封裝，可以在系統的不同區域（甚至不同系統）中由其他驗證物件使用，而無需重複編寫代碼。\n特點 定義了一個算法族 封裝算法族中的每一個算法 不同的算法可以互相替換 UML Graphic classDiagram\rclass Character {\rAttackMethod* atk\rattack() : atk.attack()\r}\rclass AttackMethod~Interface~ {\rattack()\r}\rCharacter *-- AttackMethod\rclass PhysicalAttack {\rattack() \"Physical attack\"\r}\rclass MagicAttack {\rattack() \"Magic attack\"\r}\rAttackMethod \u003c|-- PhysicalAttack\rAttackMethod \u003c|-- MagicAttack\r內文 光看維基百科的說明可能會有點霧煞煞，我們拿 RPG 遊戲來做一個舉例好了：設想今天，我們有一個 RPG 遊戲，裡面的角色可以選擇「劍士、盜賊、弓箭手、法師、和海盜」五種角色，同時每種角色都有其獨特的攻擊方式（劍士用刀劍、弓箭手用弓弩、海盜用手槍指虎\u0026hellip;等等）。在不使用策略模式的情況下，如果我們想要實現遊戲中的程式，可能就會需要有一個像下面的 pesudo code：\nclass Role { enum character {Warrior, Thief, Bowman, Magician, Pirate}; void attack() { switch(character) { case Warrior: print(\u0026#34;Using a sword to attack.\u0026#34;); break; case Thief: print(\u0026#34;Using a dagger to attack.\u0026#34;); break; case Bowman: print(\u0026#34;Using a bow to shoot arrows.\u0026#34;); break; case Magician: print(\u0026#34;Using magic attacks with different attributes.\u0026#34;); break; case Pirate: print(\u0026#34;Using a handgun or knuckles to attack.\u0026#34;); break; } } }; 這樣的程式本身並沒有問題，但麻煩的點在於：如果我們每次新增一個新的職業，抑或是新增一個攻擊方式的話（像是法師有元素攻擊，可以再細拆成冰、雷、火、毒\u0026hellip;等不同種類）那我們每次都要重新打開這個 Role 類別，並修改其裡頭的程式，久而久之，就會讓這份程式變得更加龐大、沉重，耦合性也會變高，就會變得很不好維護（光是 attack() 可能就有 200-300 行程式，還不包含各種職業對於防禦、閃避、移動、或者是屬性提升之類的其他判斷 \u0026hellip;）。\n因此，策略模式主張的程式撰寫方法就是「拆分」以及「組合」。我們可以將一個「攻擊的行為」外包給一個「攻擊的類別」去做處理，角色本身只需要持有一個「可以進行『攻擊』的類別與方法」，剩下的細節（如何攻擊？用什麼攻擊？攻擊範圍是多少？有沒有屬性加成或剋制？）全都不由「角色」這個類別去處理。類似如下：\nclass Role { AttackMethod* attack_method; void changeAttackMethod(AttackMethod* method) { attack_method = method; } void attack() { attack_method.attack(); } }; class AttackMethod { abstract void attack(); }; class SwordAttack extends AttackMethod { void attack() { print(\u0026#34;Attacks with sword\u0026#34;); } } class DaggerAttack extends AttackMethod { void attack() { print(\u0026#34;Attacks with dagger\u0026#34;); } } class Staff extends AttackMethod { void attack() { print(\u0026#34;Attacks with magic power\u0026#34;); } } ... 這樣一來，雖然在類別的數量上，相較於原本的做法（只有一個 Role）來說，多出了許多新的類別（AttackMethod 和其他所有繼承該類別的所有類別），但程式的其他效能卻提高了許多：可以預先實現許多不同的攻擊方式，但不需要修改 Role 類別內的程式碼，使原始類別 Role 保持簡潔；將類別的分工拆解得更加明確，增加各程式的可讀性與邏輯呈現；可以重複利用相同的程式，不同職業如果需要相同的攻擊方式，只需要組合同樣的類別即可，不再需要重複撰寫一樣的功能；將類別與類別的依賴程度降低（也就是解耦合），「角色」不再與「攻擊細節」相關，也就不需要負擔「攻擊方式、效果、屬性加減、傷害判定」\u0026hellip;等額外的工作；透過父類別（AttackMethod）做為一種「接口」，在特殊的情況下（例如轉職？）可以輕鬆的實現攻擊模式的抽換、更替，同時不會對於任何一個類別造成額外的程式負擔 \u0026hellip;\n小結 策略模式的優點：\n提高程式的彈性、可讀性、替換性 維持低耦合 降低重複程式的撰寫 策略模式的缺點：\n增加類別的總數量 增加程式的複雜性 "},{"id":21,"href":"/docs/computer_science/design_pattern/simple_factory_pattern/","title":"簡單工廠模式（Simple Factory Pattern）","section":"設計模式","content":"\r簡單工廠模式（Simple Factory Pattern）\r#\r說明 ChatGPT：簡單工廠模式（Simple Factory Pattern）是一種軟體設計模式，屬於創建型模式之一。它提供了一個集中化的「工廠」類別，負責根據客戶端的要求創建不同的產品物件，而客戶端不需要直接與具體的產品物件或其創建細節進行交互。通常，一個普通的簡單工廠會有以下的三種角色：產品（Product）：定義了一個產品的共同介面。具體產品（Concrete Product）：實現了產品的一個介面，是工廠所創建的具體物件。簡單工廠（Simple Factory）：負責根據客戶端的要求，創建具體產品物件的工廠類別。在簡單工廠模式中，客戶端通過傳入相應的參數，調用簡單工廠類別的靜態方法（或非靜態方法），由簡單工廠根據參數的不同來創建具體的產品物件。客戶端不需要關心具體的物件創建細節，只需要與簡單工廠類別進行交互即可。\n維基百科：簡單工廠模式是一種創建型模式，該模式創建了一個單一的工廠類別，並在類別中宣告產生具體產品的方法。用戶端可以對該工廠輸入不同的參數，而工廠則根據參數的不同，實現不同的具體對象返回給客戶端。這種工廠類別因為與使用者的交互相對單純，因此可以將工廠方法設定為靜態方法。簡單工廠封裝了對象的建立過程。如果物件的建立過程非常複雜或繁瑣，工廠方法就非常有用了。我們可以將這種選擇邏輯包裝在一個簡單工廠中。\n特點 可以集中化的物件創建 封裝創建細節，將用戶與具體產品解偶 如果打算增加新產品，則需修改工廠類別中的方法 UML Graphic classDiagram\rclass Role {\rChatacter* chatacter;\rWeapon* getReward() RewardFactory.getReward(chatacter);\r}\rclass RewardFactory {\rWeapon* getReward(Character* chatacter);\r}\rclass Weapon {\r}\rRole o-- RewardFactory\rRewardFactory --\u003e Weapon\rWeapon \u003c|-- Sword\rWeapon \u003c|-- Bow\rWeapon \u003c|-- Dagger\rWeapon \u003c|-- Staff\r內文 在 GoF 的設計模式裡面，簡單工廠模式、工廠方法模式、和抽象工廠模式為三種不同的「工廠模式」，分別可以對於不同複雜度的程式降低不同程度的複雜性、和提升程式的擴展性與其他效能。「簡單工廠模式」顧名思義，就是可以透過一個「工廠」來「簡單地」生成物件的程式撰寫方式。假設我們現在有一個 RPG 遊戲，裡面需要實做一個「當玩家完成某項任務之後，遊戲可以依照其玩家的職業，給予相對應的武器作為獎賞」的程式，對於一般的程式撰寫方式，我們可能會寫出類似於下面的程式邏輯：\nclass Role { public: Weapon* getReward() { Weapon* reward = nullptr; switch(this -\u0026gt; character) { case Warrior: reward = new Sword(); break; case Thief: reward = new Dagger(); break; case Bowman: reward = new Bow(); break; case Magician: reward = new Staff(); break; case Pirate: reward = new HandGun(); break; } return reward; } }; 這樣的寫法並沒有什麼特別的邏輯錯誤，但這樣的寫法會產生幾個缺點：首先是「getReward() 方法的長度會隨著職業的增加而逐漸變大。」如果今天遊戲中的職業為一個恆定的數量，那麼這樣的寫作方式其實也還算允許，但如果在某一次的改版中，我們被要求「新增大約 5-10 種不同的職業，並針對這些新增的職業額外撰寫可以獲得任務獎勵。」那麼程式的量級就會愈發龐大了。另外來說，因為不同的職業會需要不同的任務獎勵，因此這樣的寫法上，【角色】類別也會依賴於各種【任務獎勵】的類別。\n此外，「可讀性」也是一個問題，在這樣的寫法下，我們並沒有辦法很簡單的一眼就看出該程式所想要傳達的想法為何（可能有些人會覺得『還好阿～不過就只是一些 switch 的判斷而已』，這邊只是舉例，不用太過較真 XD），所以如果可以修改成一個可讀性更高的寫法，或許也不失為一種手段？最後，這樣的寫法也違反了「單一職責原則」，也就是一項類別只負責一項工作的程式設計原則。在這樣的程式撰寫方式下，Role 這個類別除了要負責管理「角色的屬性」之外，還需要額外處理「獲得哪一種任務獎勵？」這項任務，違反了單一職責原則。\n因此，根據上述的幾項缺點（【角色】與【獎勵】的耦合、程式的可讀性、單一職責原則\u0026hellip;等），我們會將方才的程式轉換為「簡單工廠模式」的程式撰寫方式：透過讓【角色】與一個【工廠】對話，抽離【角色】需要對各種【獎勵】的依賴。再透過輸入不同的參數（例：職業）讓【工廠】可以回傳相對應的【產品】（也就是我們的任務獎勵）。以此來改善高耦合、可讀性、和設計原則：\nclass Weapon {}; class Sword : public Weapon {}; class Axe : public Weapon {}; class Dagger : public Weapon {}; class Bow : public Weapon {}; class Staff : public Weapon {}; class HandGun : public Weapon {}; class Knuckles : public Weapon {}; class RewardFactory { public: static Weaopn* getReward(Character* character) { Weapon* reward = nullptr; switch(character) { switch(this -\u0026gt; character) { case Warrior: reward = new Sword(); break; case Thief: reward = new Dagger(); break; case Bowman: reward = new Bow(); break; case Magician: reward = new Staff(); break; case Pirate: reward = new HandGun(); break; }; return reward; } }; class Role { public: Weaopn* getReward() { Weapon* reward = RewardFactory::getReward(character); return reward; } }; 這樣一來，【角色】的程式不會再因為道具獎勵的新增刪除而有所變動，程式的可讀性也變得比較強。除此之外，我們也修正了【角色】之前需要同時負責「紀錄角色的各種屬性或行為」和「判斷角色需要得到哪一種類型的獎勵」的問題。這就是相對於最初版的程式，「簡單工廠模式」所帶來的好處。此外，簡單工廠因為其結構簡單，通常不具有高度複雜的方法或判斷條件，因此我們通常在撰寫簡單工廠模式的時候，會將工廠模式的方法都設為靜態方法（static）以節省一些記憶體空間。所以「簡單工廠模式」通常也會被人稱為「靜態工廠模式」。\n不過，簡單工廠模式畢竟是一個「簡單的」工廠模式。它所能做的，僅僅是稍微降低程式的耦合、提高可讀性、與解決單一職責的問題。簡單工廠模式還是有著幾種比較明顯的缺點，其中最廣為詬病的兩種即是「嚴重的類別依賴」與「違反『開放封閉原則』」兩種。\n「嚴重的類別依賴」指的是一個類別需要正常運作，需要先保證大量的其餘類別都能正常運行。在簡單工廠模式中，因為【工廠】會直接生成【產品】，因此就會需要依賴大量不同的【產品】類別。在這樣的情況下，如果某一個【產品】的程式出現問題，作為依賴方的【工廠】也不免可能會發生運行錯誤。此外，同樣也是因為【工廠】直接生成【產品】的緣故，如果某一個【產品】的建構子，或者是其他跟產品相關的方法出現更改（例如：參數項的調整），那麼【工廠】這邊的程式可能就會連動地需要修改，非常繁雜。\n此外，簡單工廠也違反了「開放封閉原則」的設計原則。所謂的「開放封閉原則」簡單來說，就是「對【未完成類別】保持『開放』，讓【未完成類別】可以利用【已完成類別】的某些方法或接口，來達成程式的擴增或改寫」；「同時，對於【已完成類別】本身則保持『關閉』，當類別或方法已經完成撰寫，就不要再去重新地打開它、修改它、更動它。」簡單工廠模式很明顯地，並沒有對【已完成類別】保持『關閉』：如果我們需要修改或新增某些【產品】，就得要重新修改工廠中產出產品的方法。\n小結 簡單工廠模式的優點：\n將【客戶】與【產品】分離，減少兩者間的依賴 簡化客戶端的接口與程式，提升可讀性 可以依據【客戶】的需求動態創建不同的【產品】物件 簡單工廠模式的缺點：\n對【產品】類別具有高度依賴，提高【工廠】本身的複雜度 不符合「開放封閉原則」，降低程式的安全性 如果【工廠】中具有複雜的判斷邏輯，可能也會違反「單一職責原則」 "},{"id":22,"href":"/docs/computer_science/design_pattern/composite_pattern/","title":"組合模式（Composite Pattern）","section":"設計模式","content":"\r組合模式（Composite Pattern）\r#\r說明 ChatGPT：組合模式（Composite Pattern）是一種結構型設計模式，它允許將對象組織成樹狀結構以表示「部分 - 整體」的層次結構。組合模式使得用戶可以一致地處理單個對象和組合的對象，並且無需對它們進行區分。在組合模式中，有以下幾個角色：Component（組件）：組件定義了組合中所有對象的通用接口，它可以是接口或抽象類別。它聲明了一些管理和訪問子組件的方法，並可以提供默認的實例方法。Leaf（葉子）：表示組合中的葉子節點，即沒有子節點的對象。葉子對象實現了 Component 接口。Composite（組合）：表示組合中的複合節點，即包含子節點的對象。組合對象實現了 Component 接口，並保存了一個子節點的列表。組合模式的核心思想是「讓用戶對『單個對象』和『組合的對象』進行統一處理」，從而降低了用戶程式的複雜性。用戶不需要區分當前處理的是單個對象還是組合的對象，而是統一通過 Component 接口來進行操作。\n維基百科：在軟體工程中，組合模式是一種結構型模式。組合模式描述了一組對象，這些對象的處理方式與同一類型對象的單個實例相同。組合的目的是將對象「組合」成樹結構，以表示「部分 - 整體」層次結構。實現組合模式可以讓客戶端統一處理單個對象和組合。組合模式是 23 個著名的設計模式之一，它描述瞭如何解決重複出現的設計問題，以靈活的設計且可重用的物件導向程式解決問題，意即更容易實現、更改、測試和重用的對象。組合模式可以解決什麼問題？：組合模式利用了部分 - 整體的層次結構，讓客戶端可以統一對待部分和整體對象。組合模式描述了什麼解決方案？ 組合模式會將物件的部分（Leaf）和整體（Composite）定義一個統一的組件接口。各個 Leaf 直接實例 Component，而 Composite 則將請求轉發到其子組件（可能是 Leaf 或 Composite）。這使得客戶端能夠通過 Component 的接口來統一處理所有程式使得客戶端更容易實現、更改、測試和重用。\n特點 利用「部分 - 整體」的遞迴結構實現單一操作的功能 UML Graphic classDiagram\rclass Character~Interface~ {\rvoid attack();\r}\rCharacter \u003c|-- Monster~Interface~\rCharacter \u003c|-- Player~Interface~\rCharacter \u003c|-- Team~Interface~\rclass Team {\rCharacter[] teammate\r}\rTeam --\u003e Character\r內文 組合模式所強調的「部分 - 整體」有點類似一即全，全即一的感覺，透過對於「單個物件的操作」可以遞迴影響到「整個物件群組」舊式組合模式想要解釋的概念。我們可以用一個 RPG 遊戲的例子來解釋組合模式：在一個 RPG 遊戲中，我們想要設定一個「主角可以與一同前行的人物組成『隊伍』，並透過與不同的『怪物們』相互對戰之後，最終打敗大 BOSS 取得勝利」作為一個核心的遊戲戰鬥機制。在這個機制下，所有的「成員」都是「隊伍」的一部分。而「隊伍」即是所有「成員」的組成。\n也因此，所謂的「成員」就是「一」也就是「部分」。所稱呼的「隊伍」即是「全」也就是「整體」。在組合模式的語言中，我們會把這個「部分」稱之為 葉節點（Leaf），然後把「整體」稱之為 組件（Composite）。一個【葉節點】裡面只會有一個單一的物件實例（就是一個角色、或一隻怪物），而在【組件】裡面，則可以包含【葉節點】與【組件】（也就是「隊伍」可以包含隊伍成員與其他隊伍）整體而言，程式可以撰寫成以下的樣子：\nclass Character { public: virtual void attack() {}; } class Player : public Character {}; class Monster : public Character {}; class Warrior : public Player {}; class Bowman : public Player {}; class Magician : public Player {}; class Thief : public Player {}; class Zombie : public Monster {}; class Slime : public Monster {}; class Goblin : public Monster {}; class Skeleton : public Monster {}; class Team : public Character { public: vector\u0026lt;Character*\u0026gt; teammate; public: void addTeammate(Character* teammate) { teammate.push_back(teammate); } void attack() override { for(Character* character : teammate) { character -\u0026gt; attack(); } } } int main(void) { Team playerTeam; playerTeam.addTeammate(new Warrior()); playerTeam.addTeammate(new Bowman()); playerTeam.addTeammate(new Magician()); playerTeam.addTeammate(new Thief()); Team monster_team_1; monster_team_1.addTeammate(new Zombie()); monster_team_1.addTeammate(new Slime()); Team monster_team_2; monster_team_2.addTeammate(new Goblin()); monster_team_2.addTeammate(new Skeleton()); Team monsterTeams; monsterTeams.addTeammate(\u0026amp;monster_team_1); monsterTeams.addTeammate(\u0026amp;monster_team_2); while(!battle_end()) { playerTeam.attack(); monsterTeams.attack(); } } 透過組合的方式，可以讓【隊伍】中擁有【隊伍】或【隊員】兩種角色，並透過 team.attack 的方式統一且遞迴遞呼叫 attack 方法，確保【隊員】以及【隊伍中的隊員】（和隊伍中的隊伍中的隊員，和 \u0026hellip;等）都可以執行到 attack() 方法，就是組合模式想叫傳達的概念和想法。\n小結 組合模式的優點：\n可以用統一的呼叫方法遞迴執行所有成員方法 提升程式的靈活性與可擴展性 組合模式的缺點：\n遞迴的邏輯結構容易讓程式在執行的時候出錯 難以限制 Composite 中的所有元件，可能會有極深的層次 因為遞迴的緣故，性能可能會以很大的量級增長 "},{"id":23,"href":"/docs/computer_science/design_pattern/decorator_pattern/","title":"裝飾器模式（Decorator Pattern）","section":"設計模式","content":"\r裝飾器模式（Decorator Pattern）\r#\r說明 ChatGPT：裝飾器模式（Decorator Pattern）是一種結構型設計模式，它允許動態地為對象添加額外的功能，並且不需要修改其代碼。這種模式通常用於擴展一個類的功能，並且提供了比繼承更靈活的解決方案。 在裝飾器模式中，將功能的實現分成核心部分和裝飾部分。核心部分代表原始類，它可以是一個抽象類或接口，裝飾部分則是一系列具體的裝飾器類，用於擴展核心部分的功能。裝飾器模式的典型應用場景是在不改變原始類的情況下，動態地擴展功能。例如，可以用來為一個圖形繪製程式添加不同的效果，如邊框、陰影、填充等，這些效果可以在運行時動態地添加，且不影響圖形本身的類結構。通常來說，一個裝飾器模式的基本結構包含以下角色：Component（組件）：定義了核心功能的接口，可以是抽象類或接口。Concrete Component（具體組件）：實現了 Component 接口的具體類，代表原始類。Decorator（裝飾器）：維持一個指向 Component 的引用，並實現 Component 接口，這樣可以動態地添加功能。ConcreteDecorator（具體裝飾器）：擴展 Decorator 的功能，並實現具體的裝飾行為。\n維基百科：裝飾器模式又叫做「修飾模式」，是物件導向程式領域中，一種動態地往一個類別中添加新的行為的設計模式。就功能而言，裝飾器模式相比生成子類別更為靈活，這樣可以給某個對象而不是整個類別添加一些功能。通過使用裝飾器模式，可以在程式運行時，動態地擴充一個類別的功能。原理是：增加一個「修飾類」去包裹原來的類別，包裹的方式是在修飾類的構造函數中將原來的類以參數的形式傳入。裝飾類實現新的功能，但是，在不需要用到新功能的地方，它可以直接調用原來的類別中的方法。此外，修飾類必須和原來的類別有相同的接口。裝飾器模式是類別繼承的另外一種選擇。類繼承在編譯時候增加行為，而裝飾器模式則是在程式運行時增加行為。當有幾個相互獨立的功能需要擴充時，這個區別就變得很重要。在有些物件導向的程式語言中，類別不能在運行時被創建，通常在設計的時候也不能預測到有哪幾種功能組合。這就意味著要為每一種組合創建一個新類別。相反，裝飾器模式是在程式運行時候的實例化物件的，這樣就可以在程式運行的時後，根據需要進行不同地組合。\n特點 可以通過裝飾器類，動態地擴展物件的功能 可以對物件任意組合功能，使得系統的擴展性更好 遵從設計原則中的「開放封閉原則」 UML Graphic classDiagram\rWeapon \u003c|-- Sword\rWeapon \u003c|-- Axe\rWeapon \u003c|-- Dagger\rclass Decorator~Interface~ {\rDecorator(Weapon* w)\r}\rWeapon \u003c|-- Decorator~Interface~\rDecorator~Interface~ \u003c|-- AttackBuff\rDecorator~Interface~ \u003c|-- CritBuff\rDecorator~Interface~ \u003c|-- PenetratingBuff\r#\r內文 裝飾器模式是一種比較特別的設計模式，它的核心用途是「利用『非繼承』的方式，擴增原本的類別」。因為裝飾器模式可以遞迴執行（或者說它的本質就是遞迴執行），因此也適用在「重複疊加某一種效果的需求」的情境上。讓我們用一個 RPG 遊戲來當例子：假設我們在實現一個【武器強化】的功能，可以針對不同的武器（像是劍、斧頭、匕首\u0026hellip;等）進行不同種的強化（增益攻擊、爆擊、或護甲穿透\u0026hellip;等），如果我們用「繼承」的方式來寫的話，可能會寫出類似於下面這樣的程式碼：\nclass Weapon {}; class Sword : public Weapon {}; class Attack_Buff_Sword : public Sword {}; class Crit_Buff_Sword : public Sword {}; class Penetrating_Buff_Sword : public Sword {}; class Axe : public Weapon {}; class Attack_Buff_Axe : public Axe {}; class Crit_Buff_Axe : public Axe {}; class Penetrating_Buff_Axe : public Axe {}; class Dagger : public Weapon {}; class Attack_Buff_Dagger : public Dagger {}; class Crit_Buff_Dagger : public Dagger {}; class Penetrating_Buff_Dagger : public Dagger {}; 這樣子的做法有幾個壞處：首先是程式的類別會依照【武器】與【增益效果】的變多而快速增加。在當前的狀況下，如果我們想要新增兩種武器（長槍、弓箭）那麼我們除了新增 Lance, Bow 兩種類別之外，我們還要根據不同的類別分別實作攻擊增益、爆及增益、以及穿透護甲增益三種類別。那如果再之後我們打算多新增 \\(x\\)\r種武器和 \\(y\\)\r種增益效果，類別的數量就會以驚人的速度成長了。\n第二個比較明顯的壞處是它無法遞回疊加。同樣拿剛剛的「武器增益」來作例子，在大部分的遊戲中，武器的增益通常都是可以進行 1 次以上的，並且除了通常的「劍 +1」「劍 +2」之外，也有可能會出現「劍【攻擊+1】【穿透 +3%】」類似這樣的複合效果、或疊加效果。如果我們想要讓程式實現類似這樣的效果的話，單用「繼承」可能就不是一個好方法了。因為你會需要考慮「當前的劍的狀態是什麼？」「增益之後又會變成什麼狀態？」類別的數量也會以指數的量級提升 Sword_3_attack, Sword_2_attack_1_crit \u0026hellip; Sword_3_Penetrating，基本上把類別全部寫完就會想要放棄該功能了 XD。\n因此在這樣的情況下，裝飾器模式就可以很好的起到改善的作用了：裝飾器顧名思義，就是用來「裝飾類別」的類別。在剛剛的例子下，我們可以把「裝飾」這件事情拉成一個【裝飾類別】來呈現，並讓不同的增益效果（攻擊增益、爆擊增益、護甲穿透增益\u0026hellip;等）繼承在這個【裝飾類別】下面，整體的程式就會變成類似於下面的樣子：\nclass Weapon { public: string name; } class Sword : public Weapon {}; class Axe : public Weapon {}; class Dagger : public Weapon {}; class WeaponDecorator : public Weapon {}; class AttackBuff : public WeaponDecorator { AttackBuff(Weapon* weapon) : WeaponDecorator(weapon) { cout \u0026lt;\u0026lt; \u0026#34;weapon attack += 5\u0026#34;; }; }; class CritBuff : public WeaponDecorator { CritBuff(Weapon* weapon) : WeaponDecorator(weapon) { cout \u0026lt;\u0026lt; \u0026#34;weapon crit += 1%\u0026#34;; }; }; class PenetratingBuff : public WeaponDecorator { PenetratingBuff(Weapon* weapon) : WeaponDecorator(weapon) { cout \u0026lt;\u0026lt; \u0026#34;weapon penetrating damage += 1%\u0026#34;; }; }; 先讓 Weapon 擁有一個名為 WeaponDecorator 的裝飾類別，再讓其他繼承於 WeaponDecorator 的子類別分別實現不同的增益功能。這樣一來，我們就可以動態地寫出像是 new AttackBuff(sword) 這類的「增益攻擊之後的『劍』」了。此外，因為我們把【增益】和【武器】分開來實現，所以現在不管是增加【增益】或者是增加【武器】，都不會影響到另一邊的程式碼，也算是提升了程式的可維護性。最後，因為現在所有的增益都是被「包裹」進武器裡面的，所以我們也可已寫出類似以下的程式。透過包裹的方式，讓原本的 Sword 一層、一層的提升攻擊、提升爆擊。這樣就能實現複合增益、疊加增益的效果了：\n// sword now attack = 25 Weapon* superSword = new Sword(); for(int i = 1; i \u0026lt;= 100; i++) { // each for loop, atk += 5 superSword = new AttackBuff(superSword); } // sword now attack = 525 // sword now attack = 525, crit += 6% superSword = new CritBuff(new CritBuff(superSword)); 小結 裝飾器模式的優點：\n靈活擴展，可以根據需程式需求套用不同物件效果 將物件「本身」與物件的「附帶功能」分離 利用類似組合的方式，可以提供更加彈性的物件呈現 裝飾器模式的缺點：\n增加類別的數量，提高系統的大小 因為是用「包裹」的方式，可能會產生複雜的程式結構 因為不是單純的「繼承」，因此效能會比較低下 "},{"id":24,"href":"/docs/computer_science/design_pattern/observer_pattern/","title":"觀察者模式（Observer Pattern）","section":"設計模式","content":"\r觀察者模式（Observer Pattern）\r#\r說明 ChatGPT：觀察者模式（Observer Pattern）是一種行為型設計模式，也被稱為發布-訂閱（Publish-Subscribe）模式或模型-視圖（Model-View）模式。它用於建立對象之間的一對多的依賴關係，當一個對象的狀態發生變化時，所有依賴它的對象都會收到通知並自動更新。在觀察者模式中，有兩個主要角色：主題（Subject）：也稱為「可觀察對象」或「被觀察者」。它是一個被觀察的對象，當其狀態發生變化時，它會通知所有註冊過的觀察者。觀察者（Observer）：也稱為「訂閱者」或「觀察者」。它是依賴於主題的對象，當【主題】的狀態發生變化時，【觀察者】會收到通知並根據新的狀態進行更新。觀察者模式的主要目的是解耦主題和觀察者，使它們之間不需要直接相互交互，從而提高程式的靈活性和可重用性。【主題】不需要知道【觀察者】的具體類型，只需要知道它們實現了共同的觀察者接口。這樣在未來添加新的觀察者時，【主題】的程式不需要進行修改。\n維基百科：觀察者模式是行為型設計模式的一種，用於建立對象之間的一對多依賴關係。在此種模式中，一個目標物件管理所有相依於它的觀察者物件，並且在它本身的狀態改變時主動發出通知。這通常透過呼叫各觀察者所提供的方法來實現。此種模式通常被用在即時事件處理系統。通常來說，觀察者模式包含以下幾種結構：【抽象主題介面】 抽象主題介面會提供一個介面，讓【觀察者】進行添附（Attach）與解附（Detach）的作業，此類別內會包含一個不公開的【觀察者】串列，且通常具有以下三種方法：添附 attach() 可以新增觀察者到串列內，以追蹤主題的變化。解附 detach() 可以將已經存在的觀察者從串列中移除。通知 notify() 利用觀察者所提供的更新函式來通知此目標已經產生變化。【主題類別】 主題類別提供了【觀察者】欲追蹤的主題，【觀察者】可以透過【目標主題】的 getState() 方法取得主題的狀態。【抽象觀察者介面】 抽象觀察者介面會定義觀察者都擁有的更新用介面，此介面是用來接收目標類別所發出的更新通知。 【觀察者類別】 觀察者類別含有一個（或多個）主題，並可以透過 update() 方法來更新主題的狀態。\n特點 可以通過該模式，建立簡單地一對多關係 將【主題】與【觀察者】解耦和抽象 可以動態的對【主題】與【觀察者】進行調整與修改 UML Graphic classDiagram\rclass Subject~Interface~ {\rObservers list[]\rvoid attach()\rvoid detach()\rvoid notify()\rvoid getState()\r}\rSubject \u003c|-- Character\rclass Observer~Interface~ {\rSubject* subject\rvoid update()\r}\rSubject --\u003e Observer\rObserver \u003c|-- Group\r內文 觀察者模式是一個蠻常見的設計模式，通常用於即時性的程式需求上，例如 GUI 介面、彈出式訊息、或者是 MVC 的應用程式\u0026hellip;等。在觀察者模式中，會有一個【主題】與一個（或多個）【觀察者】。如果用 RPG 來舉例的話，線上遊戲的「公會頻道」「隊與頻道」\u0026hellip;等訊息就可以用觀察者模式實作。我們可以想像一個情境：玩家 A 在加入公會 X 之前，如果公會的成員在「公會頻道」發出文字訊息的話，玩家 A 是不會收到任何訊息的，但在玩家 A 加入了 X 之後，如果公會中的其他成員在「公會頻道」丟出文字訊息的話，那麼 A 就會收到該訊息了。\n在上述的情況下，公會 X 就是一個【主題】，公會裡面的成員與玩家 A 就是【觀察者】。【觀察者】在該模式中，可以選擇是否要訂閱（attach()）某一個主題（也就是加入公會與否？），如果【觀察者】選擇訂閱（也就是加入公會），那麼在【主題】的觀察者清單裡面，就會多一個【觀察者】的 id、名稱、或其他可辨識的符號（公會成員 +1）。那麼接下來，當【主題】的「狀態」發生改變時（例：有個人在公會頻道發訊息），就會觸發【主題】的 notify()，通知所有的【觀察者】狀態進行改變了（公會成員都收到該訊息）。等到【觀察者】想要「解除訂閱」的時候，【觀察者】可以選擇呼叫【主題】的 detach 方法來解除與該【主題】的聯繫（退出公會）。這樣如果主題又有更新狀態的時候，就不會發布給該【觀察者】了（不會再收到公會訊息）。整體來說，程式可能會像是下面的這個樣子：\nclass Subject; // abstract observer class Observer { public: Subject* subject; public: virtual void subscribe(Subject* subject) = 0; virtual void unsubscribe() = 0; virtual void update(string message) = 0; }; // abstract subject class Subject { public: vector\u0026lt;Observer\u0026gt; observers; public: virtual void attach(Observer* observer) = 0; virtual void detach(Observer* observer) = 0; virtual void notify(string message) = 0; }; // concrete subject class Guild : public Subject { private: std::string name; public: Guild(string name) : name(name) {} public: void attach(Observer* observer) override { observers.push_back(observer); this -\u0026gt; notify(\u0026#34;A member has joined the guild\u0026#34;); } void detach(Observer* observer) override { observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end()); this -\u0026gt; notify(\u0026#34;Member has left the guild\u0026#34;); } void notify(const std::string\u0026amp; message) override { for (Observer* member : members) { member -\u0026gt; update(message); } } }; // concrete observer class Member : public Observer { private: string name; bool hasGuild; Subject* guild; public: GuildMember(string\u0026amp; name) : name(name), guild(nullptr) {} public: void subscribe(Subject* subject) override { if(!hasGuild) { guild = subject; guild -\u0026gt; attach(this); hasGuild = true; } } void unsubscribe() override { guild -\u0026gt; detach(this); guild = nullptr; hasGuild = false; } void update(string message) override { cout \u0026lt;\u0026lt; \u0026#34;guide message: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } }; int main() { Guild guild(\u0026#34;Good Guild\u0026#34;); Member memberA(\u0026#34;member A\u0026#34;); Member memberB(\u0026#34;member B\u0026#34;); Member memberC(\u0026#34;member C\u0026#34;); memberA.subscribe(\u0026amp;guild); memberB.subscribe(\u0026amp;guild); memberC.subscribe(\u0026amp;guild); memberB.unsubscribe(); } 小結 觀察者模式的優點：\n可以將【觀察者】與【主題】解耦，減少兩者間的依賴 容易擴展，方便建立不同【主題】與【觀察者】 可以簡化一對多關係，降低程式邏輯上的複雜程度 觀察者模式的缺點：\n類別增加，會額外的記憶體消耗 避免循環引用，須注意【觀察者】和【主題】間的生命週期 如果 notify() 有通知順序的問題，需要額外撰寫 "},{"id":25,"href":"/docs/computer_science/design_pattern/interpreter_pattern/","title":"解釋器模式（Interpreter Pattern）","section":"設計模式","content":"\r解釋器模式（Interpreter Pattern）\r#\r說明 ChatGPT：解釋器模式（Interpreter Pattern）是一種行為型設計模式，它主要用於「定義一種語言文法的表示」，並提供一個【解釋器】來解釋這種語言中的句子。該模式通常用於解決特定領域中的問題，例如解釋語言、數學表達式或查詢語句等。解釋器模式的主要組件包括：抽象表達式（Abstract Expression）、終端表達式（Terminal Expression）、非終端表達式（Non-terminal Expression）、上下文（Context）、和解釋器（Interpreter）。【抽象表達式】會定義一個抽象的介面，包含一個 interpret() 方法，這個方法會根據特定語言文法進行解釋。【終端表達式】實現了抽象表達式的 interpret() 方法，代表該語言中的終端符號，不能再分解成更小的元素。【非終端表達式】也同樣會實現【抽象表達式】的 interpret() 方法，用於組合多個終端表達式，形成複雜的語句。【上下文】包含要解釋的語句，通常由解釋器進行操作。【解釋器】則會根據語言文法對表達式進行解釋。 解釋器模式的工作流程如下：首先我們需要定義「語言文法」，並將其分解成【終端表達式】和【非終端表達式】。接下來，我們會創建對應的【表達式】類別，實現 interpret() 方法，根據語言文法進行解釋。然後，會構建一個語句的抽象語法樹（AST - Abstract Syntax Tree），將表達式組合成複雜的語句。再創建上下文，傳遞要解釋的語句。最後創建解釋器，根據語句的 AST 對其進行解釋，生成結果。\n維基百科：在物件導向程式設計中，「解譯器模式」是一種行為型設計模式，用於指定「如何評估一種『語言』中的句子」。基本思想是為專門的電腦語言中的每個符號建立一個（或一些）類別，其中包含【終端類別】與【非終端類別】。該語言中，「句子」的語法樹是組合模式的實例，用於為客戶端「解釋」該句子。解譯器設計模式是 23 種著名的 GoF 設計模式之一，GoF 設計模式描述了如何解決反復出現的設計問題，以設計靈活且可重用的物件導向程式，即更容易實施、更容易變更、更容易測試和重用的對象。「解譯器設計模式可以解決哪些問題？」解釋器模式透過定義一種簡單語言的語法，讓程式可以簡單地「解釋」該語法中的不同語句。當某種問題經常一類似的結構發生時，我們可以考慮將其表示為一種新的、簡單的語言中的句子，以便【解譯器】可以通過解釋該語句來解決問題。例如：當需要指定許多不同或複雜的搜索表達式時。將它們直接硬編寫到類別中是不靈活的，因為它會使類別受限於特定的表達式，並且無法獨立於類別之外的新的表達式或更改現有的表達式。因此在這樣的情況下，透過新增一個【解釋器】，並將語句定義為各種【終端語句】與【非終端語句】會更為靈活與彈性。\n特點 可以通過「語言解釋」將複雜的語句轉變為一系列的程式邏輯 可以解耦【語法】和【程式執行】，使其更為彈性 可以自由組合不同的語句，形成各種多樣語靈活的表示方法 UML Graphic classDiagram\rclass Character {\rvoid spellcast()\r}\rclass Expression~Interface~ {\rinterpret();\r}\rExpression \u003c|-- FixedExpression\rExpression \u003c|-- GodExpression\rExpression \u003c|-- StateExpression\r#\r內文 從體感上來看，個人認為解釋器模式是 23 種常見的設計模式裡最難讓人搞懂得一個模式。有學過「編譯器」這門課的人對於解釋器在做的工作應該會比較能夠有感：整體而言，解釋器模式的工作就是在「拆分」與「分析」一段句子是否符合邏輯？和他想要表達什麼樣的意思。讓我們用一個 RPG 遊戲來舉例：假設在一個 RPG 遊戲中，我們打算實踐一個「咒文詠唱系統」。其功能是讓玩家（一個法師）在進行戰鬥的時候，可以透過『輸入一串咒文』來達成「強力施法」這件事情。並且在這樣的情況下，我們定義了一個「傷害反彈」的詠唱詞：「誠惶誠恐呼喚日不見神，先祖之產土神。領受已久之山河，誠惶誠恐，僅此奉還於。(註１)」如果成功在某一特定的秒數內詠唱該詞句，便可以增加玩家的防禦力。在不使用「解釋器模式」的狀況下：可能會撰寫出類似下面的程式：\nclass Character { public: string name; int defense; public: Player(string name) : name(name) : defense(20) {} void spellCasting(string prayer) { if (prayer == \u0026#34;誠惶誠恐呼喚日不見神，先祖之產土神。領受已久之山河，誠惶誠恐，僅此奉還於爾\u0026#34;) { defense += 10; cout \u0026lt;\u0026lt; \u0026#34;defense += 10\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } } void displayStats() { cout \u0026lt;\u0026lt; \u0026#34;Defence: \u0026#34; \u0026lt;\u0026lt; defense \u0026lt;\u0026lt; endl; } }; 在上述的程式碼中，我們定義了一段詠唱文（誠惶誠恐\u0026hellip;奉還於爾），只要玩家能夠打出上述的詠唱文，便可以在接下來的一段時間內提升防禦力。但問題出現了：如果我們現在想要新增一個【元素】系統，讓法師的每個攻擊都包含著風、火、水、土中的任一元素，此外，針對不同的元素，除了 \u0026ldquo;日不見神\u0026rdquo; 和 \u0026ldquo;產土神\u0026rdquo; 之外，我們也需要在不同的情境下，對不同的【神明】進行祈禱，此外，其增幅的能力也會因為祈禱文內容而有所改變，像是 \u0026ldquo;奉還於爾\u0026rdquo; 代表「反擊」，其他字詞可能就會有其他意思\u0026hellip;等。在這樣的情境要求下，如果我們採取暴力破解（也就是分別輸入所有可能的咒文，然後再一一對應該咒文的能力）可想而知，就會使整個程式的量提變得極為龐大和低效。也因此，我們可以改用【解釋器】來完成上述的咒文能力要求：\nclass Expression { public: virtual bool interpret(string input) = 0; }; class FixedExpression : public Expression { private: string value; public: FixedExpression(string value) : value(value) {} bool interpret(string input) override { return input == value; } }; class GodExpression : public Expression { private: static vector\u0026lt;string\u0026gt; validGods = {\u0026#34;產土神\u0026#34;, \u0026#34;日不見神\u0026#34;, \u0026#34;蛭子神\u0026#34;, \u0026#34;風之神\u0026#34;}; public: GodExpression(string str) {} public: bool interpret(string\u0026amp; input) override { return find(validGods.begin(), validGods.end(), input) != validGods.end(); } }; class StateExpression : public Expression { private: static vector\u0026lt;string\u0026gt; validGods = {\u0026#34;奉還於爾\u0026#34;, \u0026#34;惡鬼亡滅\u0026#34;, \u0026#34;揮除百懨\u0026#34;, \u0026#34;護守吾身\u0026#34;}; public: bool Interpret(const string\u0026amp; input) override { return find(validGods.begin(), validGods.end(), input) != validGods.end(); } }; class ChantContext { private: vector\u0026lt;Expression*\u0026gt; expressions; public: ChantContext() { expressions.push_back(new FixedExpression(\u0026#34;誠惶誠恐呼喚\u0026#34;)); expressions.push_back(new GodExpression(\u0026#34;[神明]\u0026#34;)); expressions.push_back(new FixedExpression(\u0026#34;先祖之\u0026#34;)); expressions.push_back(new GodExpression(\u0026#34;[神明]\u0026#34;)); expressions.push_back(new FixedExpression(\u0026#34;領受已久之山河\u0026#34;)); expressions.push_back(new FixedExpression(\u0026#34;誠惶誠恐\u0026#34;)); expressions.push_back(new StateExpression(\u0026#34;[狀態]\u0026#34;)); } void validateChant(Character* character, vector\u0026lt;string\u0026gt; input) { if (input.size() != expressions.size()) { return; } for (int i = 0; i \u0026lt; input.size(); i++) { if (!expressions[i] -\u0026gt; interpret(input[i])) { return; } } return true; } }; class Character { public: string name; int attack; int defence; float counterRate; public: void spellcast() { vector\u0026lt;string\u0026gt; prayer = getPrayer(); ChantContext chantContext; bool validChant = chantContext.validateChant(prayer); if (validChant) { applyEffects(); displayStats(); } else { cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } } private: vector\u0026lt;string\u0026gt; getPrayer() { string input; getline(cin, input); vector\u0026lt;string\u0026gt; words; istringstream iss(input); for (string word; iss \u0026gt;\u0026gt; word;) { words.push_back(word); } return words; } }; int main() { Character magician = new Character(); magician.spellcast(); } 像這樣將整段語句進行拆分，我們可以分別檢查「固定字詞」（FixedExpression）「非固定字詞」（GodExpression, StateExpression）是否符合原本的輸入邏輯。這僅僅是一個簡單的例子。在實際的解釋器模式下，我們還可以利用組合模式將語句轉變為更為複雜的、樹狀的形式，以此來表示更為複雜的意涵或者是狀態表達。而這種「透過將一段語句進行拆分、解析，從而判斷該語句所代表的原始意涵」的行為，即是解釋器模式想要傳達的訊息。\n註１：該詠唱詞取自於【鈴芽之旅】\n小結 解釋器模式的優點：\n透過拆分語句，可對於語句進行靈活的擴展與修改 因為拆分語句的緣故，使得各子句之間變得更為容易理解 解釋器模式的缺點：\n解釋器通常只能針對特定的語法進行解析，因此不易大量泛用 增加類別的數量，提高了系統的複雜度 會需要使多個類別彼此交互，因此會稍微降低系統的效率 "},{"id":26,"href":"/docs/computer_science/design_pattern/visitor_pattern/","title":"訪問者模式（Visitor Pattern）","section":"設計模式","content":"\r訪問者模式（Visitor Pattern）\r#\r說明 ChatGPT：訪問者模式（Visitor Pattern）是一種行為型設計模式，它用於將算法操作從物件的結構中分離出來。訪問者模式允許「在不修改已有的物件結構」的情況下，定義新的操作。這種模式主要用於對一組相關的物件進行某種操作，而不必修改這些物件的類別。在訪問者模式中，有兩個主要角色：分別是訪問者（Visitor）和元素（Element）。【訪問者】是一個接口或者一個抽象類別，它定義了對物件結構中，操作每個元素的方法。具體的【訪問者】類別將實現這些方法，以定義特定的操作。【元素】則是一個接口或抽象類，它定義了接受訪問者的方法。每個元素類別將實現這個方法，以便在【訪問者】來訪時，調用【訪問者】的相應方法。訪問者模式的核心思想是：「當需要對物件結構中的元素進行不同的操作時，不需要修改元素類別，而是定義新的訪問者類別來實現這些操作。」這樣可以實現操作的「新增」而不改變元素結構，同時也不會影響其他的操作。訪問者模式適用於以下情況：「當一個物件結構包含多種類型的元素，且需要對這些元素進行不同的操作時。」「當物件想要新增新的操作，同時也希望不影響現有元素類別時。」與「當對象結構中的元素結構相對穩定，但其操作算法可能會經常更改時。」總的來說，訪問者模式可以幫助我們實現對物件結構的不同元素進行多種操作，同時保持類別的相對穩定，並提高了系統的可擴展性和可維護性。\n維基百科：訪問者模式（Visitor Pattern）是一種軟體設計模式，用於將演算法與物件結構分離。由於這種分離，使用者可以在不修改物件結構的情況下，向現有的物件結構添加新的操作。這是在 \u0026ldquo;物件導向程式\u0026rdquo; 和 \u0026ldquo;軟體工程\u0026rdquo; 中，遵循開放封閉原則的一種方法。基本上，訪問者允許在一個類族中添加新的虛擬函數，而無需修改這些類。接著，再創建一個訪問者類，其中實現了所有適當的虛擬函數的實例化。訪問者接收實例引用作為輸入，並通過雙重派發（double dispatch）來實現目標。訪問者模式能夠輕鬆地分支處理物件的類型，並在定義了訪問者尚未處理的新物件類型時生成編譯器錯誤。此外，訪問者設計模式也是 23 種著名的四人幫設計模式之一，它（四人幫設計模式）描述了如何解決重複性的設計問題，以設計靈活且可重用的面向對象軟體，即易於實現、更改、測試和重用的物件。「什麼問題可以通過訪問者設計模式解決？」：如果想要在不更改類的情況下，為物件結構的（某些）類別定義新操作，可以使用此類別。「訪問者設計模式描述了什麼解決方案？」訪問者模式定義一個單獨的【訪問者】物件，該物件實現對物件結構的元素執行的操作。客戶端可以遍歷物件結構，並在元素上調用訪問者進行元素操作：意即將操作將請求分派（委派）給【被接受的訪問者物件】。然後，訪問者物件對元素執行操作（\u0026ldquo;訪問元素\u0026rdquo;）。這樣一來，可以通過添加新的訪問者物件獨立於物件結構的類別來創建新的操作。\n特點 可以分離【元素】與【操作】的高度耦和 新增【操作】不會影響到原【元素】的程式碼 增加程式的彈性與靈活性 UML Graphic classDiagram\rclass Character~Interface~ {\rvoid accept(Visitor* visitor);\r}\rnote \"void accept(Visitor* visitor) {\\n　visitor.visit(this);\\n}\"\rCharacter \u003c|-- Role\rCharacter \u003c|-- Monster\rRole \u003c|-- Warrior\rRole \u003c|-- Bowman\rRole \u003c|-- Magician\rRole \u003c|-- Thief\rMonster \u003c|-- Zombie\rMonster \u003c|-- Slime\rMonster \u003c|-- Skeleton\rclassDiagram\rclass Visitor~Interface~ {\rvoid visit(Role* role);\rvoid visit(Monster* monster);\r}\rVisitor \u003c|-- PhysicalAttackVisitor\rVisitor \u003c|-- MagicAttackVisitor\rVisitor \u003c|-- EscapeVisitor\r內文 訪問者模式主要要解決的問題是「在不更動原始物件的前提下，對原始物件進行一些新的功能擴充」也就是在不影響原始物件的前提下，進行物件的方法擴充。我們用一個 RPG 遊戲的戰鬥過程來做舉例：假設在一個 RPG 的回合制戰鬥中，【角色】總共可以對【怪物】進行兩種不同的攻擊方式，分別是「普通攻擊（物理攻及）」和「魔法攻擊」這兩種。在不使用訪問者模式的程式撰寫情境下，我們可能會寫出類似於下面的程式碼：\nclass Character { public: virtual void physicalAttack(Character* character) {}; virtual void magicAttack(Character* character) {}; }; class Role : public Character {}; class Warrior : public Role {}; class Bowman : public Role {}; class Magician : public Role {}; class Thief : public Role {}; class Monster : public Character {}; class Zombie : public Monster {}; class Slime : public Monster {}; class Skeleton : public Monster {}; 在上述的程式中，因為總共有 7 個不同的實際角色，分別是【戰士】【弓箭手】【法師】【盜賊】【殭屍】【史萊姆】和【骷髏】，因此在程式上，我們會需要對每一個不同的實際角色去做 physicalAttack() 和 magicAttack() 的改寫。這樣的狀況一眼看下去是沒有問題的，但如果今天這個 RPG 遊戲推出了一種新的攻擊機制：爆擊攻擊，此外也對魔法攻擊做出更加細化的屬性攻擊（火、土、風、水之類的），那這樣我們就要重新地開啟這些實際的角色類別，然後再重新撰寫類別內的程式碼了，也就違反了「開放封閉原則」想要闡述的念頭。\n所以在「訪問者」模式上，我們會透過「將『方法』設定為『類別』」的方式，對於這些 \u0026ldquo;方法依賴\u0026rdquo; 的情況做出一些改善：我們會先將整個機制分為兩個部分，分別是「訪問者（Visitor）」和「元素（Element）」。【訪問者】就是原本的方法，在這個例子下就是 physicalAttack() 和 magicAttack()。通常【訪問者】會都有一個共同的父類別 Visitor，方法們會 \u0026ldquo;升級\u0026rdquo; 成類別（PhysicalAttackVisitor 和 MagicAttackVisitor）並繼承 Visitor，Visitor 裡面會包含一個 visit() 方法，用來「訪問」元素。【元素】則是原本的實體物件，在這個例子下，就是【戰士】【弓箭手】【殭屍】\u0026hellip;等不同的角色類別。它們負責「接受」訪問者的訪問，因此它們身上會有一個名為 accept() 的方法，用來實例「【訪問者】如何進行訪問」這件事情，就像是下面程式的這個樣子：\nclass Visitor; class Character { public: virtual void accept(Visitor\u0026amp; visitor) { visitor.visit(*this); } }; class Role : public Character {}; class Monster : public Character {}; class Role : public Character {}; class Warrior : public Role {}; class Bowman : public Role {}; class Magician : public Role {}; class Thief : public Role {}; class Monster : public Character {}; class Zombie : public Monster {}; class Slime : public Monster {}; class Skeleton : public Monster {}; class Visitor { public: virtual void visit(Role\u0026amp; role) = 0; virtual void visit(Monster\u0026amp; monster) = 0; }; class PhysicalAttackVisitor : public Visitor { public: void visit(Role\u0026amp; role) override { // Monster deal physical damage to character. } void visit(Monster\u0026amp; monster) override { // Character deal physical damage to monster. } }; class CriticalAttackVisitor : public Visitor { public: void visit(Role\u0026amp; role) override { // Monster deal critical damage to character. } void visit(Monster\u0026amp; monster) override { // Character deal critical damage to monster. } }; class ElementalMagicAttackVisitor : public Visitor { public: string name; public: ElementalMagicAttackVisitor(string n) : name(n) {}; public: void visit(Role\u0026amp; role) override { // Monster deal magic damage to character. } void visit(Monster\u0026amp; monster) override { // Character deal magic damage to monster. } }; int main(void) { Character* magician = new Magician(); Visitor physicalAttack = new PhysicalAttackVisitor(); Visitor fireMagic = new ElementalMagicAttackVisitor(\u0026#34;fire\u0026#34;); Visitor earthMagic = new ElementalMagicAttackVisitor(\u0026#34;earth\u0026#34;); magician.accept(physicalAttack); magician.accept(fireMagic); magician.accept(earthMagic); } 向上述這樣，我們只要讓 Character 去進行 accept() 的方法，就可以達成「讓角色（或怪物）進行各種不同的攻擊」的程式了。而若如果我們需要再新增一些角色可以做的功能（例如逃跑？），我們也不需要重新對所有的 Character 類別實作 escape() 的方法，只需要新增一個 EscapeVisitor 的類別，並在該類別內寫出「不同的角色跟怪物該怎麼逃跑？」的程式，再讓 magician 做出類似 magician.accept(new EscapeVisitor()); 的動作，即可完成「讓角色進行逃跑」的這個行為了。\n透過將【角色】與【角色可以執行的動作】解耦，即可避免發生「如果要擴充角色可以執行的功能，就會需要重新打開角色的程式，對裏頭的程式進行修改」的這件事情。值得注意的事情是：訪問者模式因為會需要對於所有的「元素」進行動作的改寫。因此我們在做的事情比較像是「把『會更動的程式』從每個【角色】的程式裡頭，移動到『一個統一的類別』裡。」實際上需要修改的程式量提應該也是差不多的。因此這一種設計模式 並.不.適.合 使用在「資料結構不穩定」的程式上面。如果「元素」的底層邏輯可能會需要頻繁做修改（像是一直拿捏不定【角色】身上會有那些屬性，或者是抗性列表有時變多有時變少\u0026hellip;等），就不會建議使用訪問者模式對程式進行重構或撰寫。\n小結 訪問者模式的優點：\n可以將【角色】與【角色所執行的動作】解耦 讓方法的增添和修改變得更加容易 將方法統一管裡，避免了需要不同打開不同程式的問題 訪問者模式的缺點：\n增加了許多類別，會讓程式複雜度變高 破壞了元素的封裝性，類別的執行動作會在其餘類別被實現 "},{"id":27,"href":"/docs/computer_science/design_pattern/chain_of_responsibility_pattern/","title":"責任鏈模式（Chain of Responsibility Pattern）","section":"設計模式","content":"\r責任鏈模式（Chain of Responsibility Pattern）\r#\r說明 ChatGPT：責任鏈模式（Chain of Responsibility Pattern）是一種行為型設計模式，它允許多個物件依序處理請求，這些物件會被連成一條「鏈」（chain），每個物件都有可能處理請求，如果某個物件無法處理，則將請求傳遞給下一個物件來處理，直到有物件處理成功或者整個鏈都無法處理為止，責任鏈模式允許程式在運行時不確定哪個物件將處理這個請求。在責任鏈模式中，通常每個處理器（Handler）都會有一個指向下一個處理器的指標，從而形成了一條鏈。當一個請求進入這個鏈時，從第一個處理器開始依序檢查是否可以處理該請求？如果可以，則處理器會進行處理，但如果不行，則傳遞給下一個處理器，依此類推\u0026hellip;，直到找到能夠處理請求的處理器，或者整個鏈都無法處理為止。責任鏈模式可以將請求的發送者和接收者解耦，讓不同的處理器對請求進行獨立的處理，增加了系統的靈活性和可擴展性。同時也支持在運行時動態地組織「鏈」，方便新增或者移除處理器。責任鏈模式的主要角色有：處理器（Handler）：定義一個處理請求的接口，並且持有下一個處理器的指標，以便將請求傳遞給下一個處理器。具體處理器（Concrete Handler）：具體處理器會實現具體的【處理器】接口，並且能夠處理特定類型的請求，如果無法處理則將請求傳遞給下一個【具體處理器】。請求（Request）：定義需要處理的請求。在責任鏈模式中，【請求】將依序經過每個具體處理器，直到找到能夠處理的具體處理器為止。責任鏈模式可以達到動態組織處理器的目的，也提高了系統的靈活性和可維護性。\n維基百科：在物件導向程式設計中，責任鏈模式（Chain of Responsibility Pattern）是一種行為型設計模式，該模式由【命令對象】和一系列的【處理對象】所組成。每個【處理對象】都包含（與定義）它可以處理的命令類型；如果【命令】無法被該【處理對象】執行，【命令】則會被傳遞到責任鏈中的下一個【處理對象】。此外，該模式也存在一種「將新的【處理對象】添加到該鏈末尾」的機制或方法，可以對鏈做一些刪除或擴展。此外，對於責任鏈模型的變體中，一些處理程序可以充當調度程序，向多個方向發送命令，形成一顆責任樹。在某些狀況下，這可能會產生遞歸的情況：【處理對象】使用【命令】調用更高層的【處理對象】，試圖解決問題的較小部分這種模式提倡鬆散耦合的思想。責任鏈模式（Chain of Responsibility Pattern）在結構上與裝飾器模式（Decorator Pattern）幾乎相同，不同之處在於：對於裝飾器來說，所有的類別都會處理請求；可對於責任鏈來說，只有鏈中的一個類別（也就是【處理對象】）會處理請求。\n特點 aaa UML Graphic classDiagram\rclass Quest {\rvoid execute();\r}\rQuest \u003c|-- HuntingQuest\rQuest \u003c|-- GatheringQuest\rQuest \u003c|-- DungeonQuest\rclassDiagram\rclass Handler {\rHandler* next;\rvoid setNext(Handler* handeler);\r}\rHandler \u003c|-- MondayHandler\rHandler \u003c|-- TuesdayHandler\rHandler \u003c|-- WednesdayHandler\r內文 『責任鏈模式』可以用來解決客戶端「類別依賴」的問題。在一個普通的責任鏈模式中，總共會有是處理器（Handler）與客戶端（Client）兩種不同的角色，如果用 RPG 遊戲來做舉例的話，我們假設【玩家】可以依照不同的「星期」來進行不同的【活動任務】，分別是星期一的【魔物狩獵】（HuntingQuest）、星期二的【藥材採集】（GatheringQuest）、星期三的【地下城探險】（DungeonQuest）、星期四的【跑腿送信】（CourierQuest）、與星期五的【地下城探險】（DungeonQuest）\u0026hellip;，在不使用『責任鏈模式』的狀況下，程式可能會撰寫成以下的樣子：\nclass DailyQuest { public: virtual void execute() = 0; }; class HuntingQuest : public DailyQuest { public: void execute() override { // Monster hunting ... } }; class GatheringQuest : public DailyQuest { public: void execute() override { // Medicine gathering ... } }; class DungeonExplorationQuest : public DailyQuest { public: void execute() override { // Dungeon exploration ... } }; class CourierQuest : public DailyQuest { public: void execute() override { // Errand and delivery services ... } }; class DungeonRaidQuest : public DailyQuest { public: void execute() override { // Dungeon raid ... } }; int main() { DailyQuest* mondayQuest = new HuntingQuest(); DailyQuest* tuesdayQuest = new GatheringQuest(); DailyQuest* wednesdayQuest = new DungeonQuest(); DailyQuest* thursdayQuest = new CourierQuest(); DailyQuest* fridayQuest = new DungeonRaidQuest(); // 玩家每天的任務安排 std::string today = \u0026#34;Tuesday\u0026#34;; // 假設今天是星期二 if (today == \u0026#34;Monday\u0026#34;) { mondayQuest -\u0026gt; execute(); } else if (today == \u0026#34;Tuesday\u0026#34;) { tuesdayQuest -\u0026gt; execute(); } else if (today == \u0026#34;Wednesday\u0026#34;) { wednesdayQuest -\u0026gt; execute(); } else if (today == \u0026#34;Thursday\u0026#34;) { thursdayQuest -\u0026gt; execute(); } else if (today == \u0026#34;Friday\u0026#34;) { fridayQuest -\u0026gt; execute(); } } 在這個情況下，客戶端（Client，也就是 main）會需要依賴多個不同的任務細節，像是 HuntingQuest, GatheringQuest, 或 DungeonQuest \u0026hellip; 等。在可以預見的範圍內，如果我們今天想要增添或調整不同的每日任務，在一定的程度上，都可能會影響到 main 這支程式的撰寫方式，例如某些任務也許會需要一些額外的參數做調整，像是「根據『等級』決定狩獵的怪物數量」或「根據玩家的『陣營』，決定討伐哪一個副本，與該副本的難易度」\u0026hellip;等，在這個情況下，就會需要對 main 裡面的程式做出修改，除了高度依賴之外，也同時違反了「開放封閉原則」。\n因此，在『責任鏈模式』的程式撰寫方式上，我們會讓每一個「任務」都歸屬到不同的「負責人」（也就是【處理器】Handler）上面。並將這些 Handler 串接起來（負責人 1 有負責人 2 的聯絡方式，負責人 2 有負責人 3 的聯絡方式 \u0026hellip; 依此類推。）並讓「任務」統一交給這個 \u0026ldquo;負責人串列\u0026rdquo; 的最前端，如果該負責人（負責人 1）可以執行接收到的「任務」，就直接進行該任務，否則就將「任務」轉接到下一個「窗口」\u0026hellip;依此類推，直到「任務」被某一個人給解決，或者是所有人都無法執行該任務。也因此，程式可能會被修改成這個樣子：\nclass DailyQuest { public: virtual void execute() = 0; }; class HuntingQuest : public DailyQuest { public: void execute() override { // Monster hunting ... } }; class GatheringQuest : public DailyQuest { public: void execute() override { // Medicine gathering ... } }; class DungeonExplorationQuest : public DailyQuest { public: void execute() override { // Dungeon exploration ... } }; class CourierQuest : public DailyQuest { public: void execute() override { // Errand and delivery services ... } }; class DungeonRaidQuest : public DailyQuest { public: void execute() override { // Dungeon raid ... } }; class Handler { protected: QuestHandler* next; public: QuestHandler() : nextHandler(nullptr) {} public: void setNextHandler(QuestHandler* handler) { next = handler; } public: virtual void handleQuest(const std::string\u0026amp; today) = 0; }; class MondayHandler : public QuestHandler { public: void handleQuest(string today) override { if (today == \u0026#34;Monday\u0026#34;) { (new HuntingQuest()) -\u0026gt; execute(); } else if (nextHandler != nullptr) { nextHandler -\u0026gt; handleQuest(today); } } }; class TuesdayHandler : public QuestHandler { public: void handleQuest(string today) override { if (today == \u0026#34;Tuesday\u0026#34;) { (new GatheringQuest()) -\u0026gt; execute(); } else if (nextHandler != nullptr) { nextHandler -\u0026gt; handleQuest(today); } } }; class WednesdayHandler : public QuestHandler { public: void handleQuest(string today) override { if (today == \u0026#34;Wednesday\u0026#34;) { (new DungeonExplorationQuest()) -\u0026gt; execute(); } else if (nextHandler != nullptr) { nextHandler -\u0026gt; handleQuest(today); } } }; class ThursdayHandler : public QuestHandler { public: void handleQuest(string today) override { if (today == \u0026#34;Thursday\u0026#34;) { (new CourierQuest()) -\u0026gt; execute(); } else if (nextHandler != nullptr) { nextHandler -\u0026gt; handleQuest(today); } } }; class FridayHandler : public QuestHandler { public: void handleQuest(string today) override { if (today == \u0026#34;Friday\u0026#34;) { (new DungeonRaidQuest()) -\u0026gt; execute(); } else if (nextHandler != nullptr) { nextHandler -\u0026gt; handleQuest(today); } } }; int main(void) { QuestHandler* mondayHandler = new MondayHandler(); QuestHandler* tuesdayHandler = new TuesdayHandler(); QuestHandler* wednesdayHandler = new WednesdayHandler(); QuestHandler* thursdayHandler = new WednesdayHandler(); QuestHandler* fridayHandler = new WednesdayHandler(); mondayHandler -\u0026gt; setNextHandler(tuesdayHandler); tuesdayHandler -\u0026gt; setNextHandler(wednesdayHandler); wednesdayHandler -\u0026gt; setNextHandler(thursdayHandler); thursdayHandler -\u0026gt; setNextHandler(fridayHandler); string day = \u0026#34;Tuesday\u0026#34;; mondayHandler -\u0026gt; handleQuest(today); } 小結 責任鏈模式的優點：\n可以將請求的發送者和接收者解耦 提高系統的靈活性和可擴展性 鬆化耦合，簡化不同類別之間的耦合關係 責任鏈模式的缺點：\n如果模式設計不良，可能造成請求無法被處理的情況 增加更多的類別，因此系統的複雜性會變高 請求的處理變為冗長，會讓個別測試變得複雜 "},{"id":28,"href":"/docs/computer_science/design_pattern/iterator_pattern/","title":"迭代器模式（Iterator Pattern）","section":"設計模式","content":"\r迭代器模式（Iterator Pattern）\r#\r說明 ChatGPT：迭代器模式（Iterator Pattern）是一種行為型設計模式，它主要用於提供一種訪問集合元素（如列表、數組、樹等）的方法，而不需要暴露該集合的內部表示。通過迭代器模式，我們可以透過統一的接口來遍歷（iterate()）集合中的元素，無需關心底層的數據結構。「迭代器模式」的主要目標是「分離集合的『遍歷行為』與『程式實現』」。這樣可以提供更好的解耦和靈活性。該模式通常包含以下主要元素：【迭代器】（Iterator）：用於定義「訪問」和「遍歷」集合元素的介面。迭代器通常包含方法如 next()（返回下一個元素）、hasNext()（檢查是否還有下一個元素）等。【具體迭代器】（Concrete Iterator）：具體迭代器實現了【迭代器】的接口，並提供了對具體集合的元素遍歷實現。不同的集合可能需要不同的具體迭代器。【集合】（Collection）： 定義了管理元素的方法，如添加、刪除元素\u0026hellip;等。可以是列表、數組、樹\u0026hellip;等。【具體集合】（Concrete Collection）：實現了【集合】的接口，提供了實際的元素管理方式。不同的具體集合可能有不同的存儲結構。通過使用迭代器模式，客戶端的程式可以僅通過【迭代器】來訪問集合的元素，而無需關心程式的底層細節。這樣可以使程式更具可讀性、可維護性，並且支持在不改變客戶端程式的情況下更改集合的實現方式。\n維基百科：在物件導向程式設計中，「迭代器模式」是一種設計模式，其中使用【迭代器】來遍歷容器，並訪問容器的逐個元素。迭代器模式嘗試將「遍歷的演算法」與「容器」解耦；「迭代器模式能解決哪些問題？」該模式可以讓聚合物件（列表、數組\u0026hellip;等）的元素，在不暴露其表示資料結構的情況下，進行訪問和遍歷。同時也可以為聚合物件定義新的遍歷操作，而不改變其介面。在一般情況下，直接再聚合介面中定義「訪問」和「遍歷」操作是不靈活的，因為這樣的程式撰寫方式會使得聚合受限於特定的訪問和遍歷操作，且無法在不更改聚合介面的前提下添加新操作。「迭代器模式如何解決此問題方案？」迭代器模式會定義一個獨立的【迭代器】物件，並封裝「訪問」和「遍歷」的方法，讓聚合物件各自繼承並實例。客戶端使用可以直接使用【迭代器】來訪問方法和遍歷方法來檢視聚合物件，而不需要了解其物件內真實的資料結構。不同的迭代器可以以不同的方式訪問和遍歷聚合。可以通過定義新的迭代器來獨立地定義新的訪問和遍歷操作。\n特點 分離「集合」本身的資料結構與「迭代」的程式邏輯 可以隱藏集合的資料結構，使客戶端不須依賴特定的程式操作 提供統一的遍歷程式，提高程式的可重用性 UML Graphic classDiagram\rclass Iterator {\rbool hasNext();\rvoid next();\r}\rIterator \u003c|-- CharacterTeamIterator\rIterator \u003c|-- MonsterTeamIterator\rclass CharacterTeam {\rIterator* iterator\rCharacter teammate[]\r}\rclass MonsterTeam {\rIterator* iterator\rMonsterNode head\r}\rCharacterTeam \u003c|-- Character\rclass MonsterNode {\rMonster* monster\rMonsterNode* next\r}\rMonsterTeam --\u003e MonsterNode\rMonsterNode --\u003e Monster\r#\r內文 迭代器模式是個相對簡單的設計模式。該模式的用途是「讓所有不同的容器，都可以有一個統一的『遍歷』方法。」通常來說，一個迭代器模式裡面總共會包含著四種類別：【迭代器介面】【具體迭代器】【集合介面】和【具體集合】。讓我們用一個 RPG 遊戲來做舉例：假設再一個 RPG 的戰鬥中，總共分為「主角方」和「怪物方」兩方的陣容。在程式的撰寫上分別由工程師 A 和工程師 B 進行工作。工程師 A 在主角（Character）的地方，新增了一個 CharacterTeam 的類別，用以紀錄主角的隊伍成員，以及它們各自的資訊；工程師 B 則同樣使用了類似的做法，在怪物方（Monster）新增了一個 MonsterTeam 類別，同樣也是記錄怪物的編隊與各自的訊息，如下述的程式所示：\nclass Character { public: string name; int hp; int mana; int atk; int def; public: Character(string name) : name(name), hp(100), mana(50), atk(10), def(10) {}; }; class CharacterTeam { public: vector\u0026lt;Character*\u0026gt; teammate; public: CharacterTeam() : teammate(nullptr); public: void append(Character* character) { teammate.push_back(character); } }; class Monster { public: string name; int hp; int mana; int atk; int def; public: Monster(string name) : name(name), hp(70), mana(20), atk(30), def(3) {}; }; class MonsterNode { public: Monster* monster; MonsterNode* next; public: MonsterNode(Monster* monster) : monster(monster), next(nullptr); }; class MonsterTeam { public: MonsterNode teamHead; public: MonsterTeam() : teamHead(nullptr); public: void append(Monster* monster) { MonsterNode* node = new MonsterNode(monster); if(teamHead == nullptr) teamHead = node; else { MonsterNode* tmp = teamHead; while(tmp -\u0026gt; next != nullptr) { tmp = tmp -\u0026gt; next; } tmp -\u0026gt; next = node; } } }; 我們可以發現到：雖然都是實作類似的功能，但是工程師 A 和工程師 B 採用的卻是不一樣的資料結構，負責 Character 的工程師 A 利用了 vector 當成記錄隊伍的資料結構，負責 Monster 的工程師 B 則自己手刻了一個 Monster 的 linked-list。在這樣的情況下，如果我們有一個 BattleManager 的【戰鬥管理】類別，它需要先記錄雙方的陣容組成的話，如果不使用迭代器模式，程式就會變得比較「不彈性」，也就是說：BattleManager 會需要先知道 CharacterTeam 和 MonsterTeam 雙方的資料結構（vector 和 linked-list）才可以進行遍歷的程式，就如同下方所示：\nclass BattleManager { public: void getMemberInfo(vector\u0026lt;Character*\u0026gt; character_team, Monster* monster_node) { for(int i = 0; i \u0026lt; character_team.size(); i++) { getCharacterInfo(character_team[i]); } while(monster_node != nullptr) { getMonsterInfo(monster_node -\u0026gt; monster); monster_node = monster_node -\u0026gt; next; } } } 而如果在後續的版本迭代中，我們想要修改 CharacterTeam 或者是 MonsterTeam 的集合方式（都改為 vector 之類的？）那這樣就要重新把 BattleManager 的程式也重新改寫，進而違反了「開放封閉原則」。因此，「迭代器模式」在這樣的場景下就可以發揮功用了：迭代器模式提供了一個統一的接口（通常為 next() 和 hasNext()），允許各種不同的集合分別用不同的方式實作這兩項方法，進而使【客戶端】（在這邊指的是 BattleManager）在進行集合的遍歷的時候，不需要研究「實際的資料結構」長什麼樣子，就像是下面的這個樣子：\nclass Iterator { public: virtual bool hasNext() = 0; virtual void* next() = 0; } class CharacterTeamIterator : public Iterator { public: vector\u0026lt;CharacterTeam\u0026gt;* team; int index; public: CharacterTeamIterator(vector\u0026lt;CharacterTeam\u0026gt;* team) { team = team; index = -1; } public: bool hasNext() override { return (index \u0026lt; team.size()); } void* next() { index += 1; return team[index]; } } class MonsterTeamIterator : public Iterator { public: MonsterNode* node; public: MonsterTeamIterator(MonsterNode* node) : node(node) {}; public: bool hasNext() override { return (node -\u0026gt; next != nullptr); } void* next() { Monster* monster = node -\u0026gt; monster; node = node -\u0026gt; next; return monster; } } 在上述的程式中，我們新增了兩個分別名為 CharacterTeamIterator 和 MonsterTeamIterator 的類別，它們分別繼承並實作了 Iterator 中的兩個方法（hasNext() 和 next()）。因為兩個新的子迭代器都使用了相同的 Iterator 接口，因此在客戶端（也就是 BattleManager）的程式上，我們可以修改為以下的樣子：\nclass BattleManager { public: void getMemberInfo(CharacterTeamIterator* character_iterator, MonsterTeamIterator* monster_iterator) { while(character_iterator -\u0026gt; hasNext()) { getCharacterInfo((Character*)(character_iterator -\u0026gt; next())); } while(monster_iterator -\u0026gt; hasNext()) { getCharacterInfo((Monster*)(monster_iterator -\u0026gt; next())); } } } 在上面的程式中，因為 CharacterTeamIterator 和 MonsterTeamIterator 都有同樣的 hasNext() 方法與 next() 方法，因此無論這兩個集合物件的資料結構為何（不管是 vector, list, map, linked-list \u0026hellip;），我們都可以透過 Iteratoe 所提供的 hasNext() 與 next() 方法完成元素的遍歷，而無須細節地考慮它們分別為哪一種資料結構。此外，及遍之後我們修改了 CharacterTeam 或者是 MonsterTeam 的資料結構，因為 Iterator 仍是採用相同的接口進行遍歷，因此我們也不需要回頭修改 BattleManager 裡面的程式。而這種程式的撰寫方式，就是迭代器模式想要傳達的訊息。\n小結 解釋器模式的優點：\n利用統一的接口，將遍歷的邏輯封裝，簡化客戶端的程式 容易進行擴展，擁有良好的程式擴充性 只要使用同樣的接口，該模式支持各式各樣的資料結構 解釋器模式的缺點：\n增加了類別的數量，因此提高了系統的複雜度 會降低程式的性能，因為需要使用多個類別進行溝通 "},{"id":29,"href":"/docs/computer_science/design_pattern/adapter_pattern/","title":"適配器模式（Adapter Pattern）","section":"設計模式","content":"\r適配器模式（Adapter Pattern）\r#\r說明 ChatGPT：適配器模式（Adapter Pattern）是一種軟體設計模式，屬於結構型模式的一種。它主要用於「將一個類別的接口」轉換成另一個「客戶端所期望的接口」，從而使原本不兼容的類別能夠一起工作。在軟體設計中，有時候因為歷史原因、不同的介面設計或第三方庫的使用，可能會出現一些類別之間接口不匹配的情況。這時候就可以使用適配器模式來解決這種問題，而無需修改原有的類別。適配器模式的核心概念是引入一個適配器（Adapter）類別，這個類別負責將不兼容的接口轉換成目標接口，使得客戶端可以通過適配器使用原本不兼容的類別。適配器可分為類別適配器和物件適配器兩種：其中類別適配器使用「繼承」的方式來進行接口轉換，物件適配器則使用「組合」的方式來進行接口轉換，通過調用原始類別的方法來實現目標接口的方法。適配器模式的優點是能夠提高程式碼的重用性和靈活性，同時也能夠保護現有程式碼，無需修改原始類別。\n維基百科：在設計模式中，適配器模式（Adapter Pattern）有時候也稱包裝模式（Wrapper Pattern）。適配器模式用來將一個類別的介面轉接成使用者所期待的另一種介面。一個適配器可以讓「因程式不相容而不能在一起工作的類別」能在一起工作，其中的做法是將類別自己的介面包裹在一個已存在的類別中。適配器模式的結構通常分為兩種類型：「物件型適配器」（在適配器本身中包含一個呼叫對象的物件）和「類別型適配器」（新增一個適配器類別，繼承自原類別，並用擴增的方式使程式可以運作）。適配器模式（Adapter Pattern）是 23 個著名的設計模式之一，它通常用以解決以下的幾種問題：如何將以棄用（或很少使用）的舊型接口更新為一個新形態的程式接口、如何將原本不兼容的兩種接口相互兼容、如何為某個（或某些）類別提供替代接口、和如何將舊有的接口設計為客戶所要求的新型接口。\n特點 a bb ccccc UML Graphic classDiagram\rclass MonsterAttackAdapter {\rvoid attack();\r}\rclass Zombie {\rvoid bite();\r}\rclass ZombieAttackAdapter {\rZombie* zombie\rvoid attack();\r}\rZombieAttackAdapter --\u003e Zombie\rclass Goblin {\rvoid knock();\r}\rMonster \u003c|-- Zombie\rMonster \u003c|-- Goblin\rclass GoblinAttackAdapter {\rGoblin* goblin\rvoid attack();\r}\rGoblinAttackAdapter --\u003e Goblin\rMonsterAttackAdapter \u003c|-- ZombieAttackAdapter\rMonsterAttackAdapter \u003c|-- GoblinAttackAdapter\rclassDiagram\rclass CharacterAttackAdapter {\rvoid attack();\r}\rclass Warrior {\rvoid chop();\r}\rclass WarriorAttackAdapter {\rWarrior* warrior;\rvoid attack;\r}\rWarriorAttackAdapter --\u003e Warrior\rCharacter \u003c|-- Warrior\rclass Magician {\rvoid magic_attack();\r}\rclass MagicianAttackAdapter {\rMagician* magician;\rvoid attack();\r}\rMagicianAttackAdapter --\u003e Magician\rCharacter \u003c|-- Magician\rCharacterAttackAdapter \u003c|-- WarriorAttackAdapter\rCharacterAttackAdapter \u003c|-- MagicianAttackAdapter\r內文 如果要用一句話來作總結的話，適配器模式的用途就是用於「將兩組原本互不兼容的程式可以相互兼容」。我們用 RPG 遊戲來舉個例子：假設我們正在製作一個簡單 RPG 遊戲，在這個 RPG 遊戲中，我們將【戰鬥】的環節設計在一個 Battle 類別的靜態方法 battle() 中，其中 battle() 方法帶有兩個參數，分別是角色物件 Character 和怪物物件 Monster，如果用「主角與魔王要進行最後的決戰」作為例子，程式大致上會像是下面的這個樣子：\nvoid final_battle() { Character* hero = new Character(); Monster* boss = new Monster(); Battle::battle(hero, boss); } 接下來，為了將遊戲順利完成，我們聘請了不同的工程是來完成不同的程式環節，用以加速遊戲的開發，其中一個工程師Ａ負責【人物】的程式，他在人類（Character）與怪物（Monster）的兩種陣營中設計了幾個不同的職業與種類，人類方有戰士（Warrior）、法師（Magician）\u0026hellip;等不同的職業，怪物方則有殭屍（Zombie）、哥布林（Goblin）\u0026hellip;等不同的怪物種類。並且無論是人類方還是怪物方，每個生物都有著自己與眾不同的攻擊方式，例如戰士可以進行劈砍（chop）、法師可以用魔法攻擊（magic_attack()）、殭屍可以咬人（bite()）、用手中的武器敲擊敵人（knock()）就如同下面的這個例子：\nclass Character {}; class Warrior : public Character { public: void chop(); } class Magician : public Character { public: void magic_attack(); } class Monster {}; class Zombie : public Monster { public: void bite(); } class Goblin : public Monster { public: void knock(); } 另一個工程師Ｂ則負責【戰鬥】的程式的細節，他利用了 Character 和 Monster 這兩個類別實作出了一個簡單的回合制戰鬥遊戲的流程：讓 Character 和 Monster 這兩種類別都可以相互進行 attack() 的操作，同時用一些簡單的 pre_battle(), end_battle(), show_result() 方法來對遊戲的戰鬥環節進行一些設定，像是更改遊戲音效、動畫播放、計算戰鬥的傷害判定\u0026hellip;等，就如同下面程式的這個樣子：\nclass Battle { public: static void battle(Character* character, Monster* monster) { this -\u0026gt; set_character(character); this -\u0026gt; set_monster(monster); this -\u0026gt; pre_battle(); while(!end_battle()) { if(!end_battle()) { character -\u0026gt; attack(monster); monster -\u0026gt; hurt(); } if(!end_battle()) { monster -\u0026gt; attack(character); character -\u0026gt; hurt(); } } this -\u0026gt; show_result(); } } 同時，因為在溝通的過程中，雙方沒有事先討論出一個統一的方案，因此造成了【人物】和【戰鬥】兩邊的程式如果各自分開來測試，皆可以正常運行，但如果把這兩個程式套在一起，程式就會報錯死掉，因為 Character 與 Monster 都沒有 attack() 的方法。也因為一些原因（像是快要趕上架了、或者是兩邊的程式行數都不少\u0026hellip;等），使得無論修改任何一方的程式碼，都有可能衍生出很大的工作量。這個時候，擅長「把不兼容變成兼容」的適配器模式就發揮功能了！\n「適配器模式」可以通過一個適配器（Adapter）將兩組原本無法互相兼容的程式相互兼容，在日常生活中的例子就類似於「插座」之類的角色。在上述的情境中，Adapter 現在被賦予的重責大任就是「要讓【人物】與【怪物】可以進行【戰鬥】的操作」。同時因為「無法戰鬥」的根本原因是「雙方都沒有 attack() 方法」，因此，Adapter 現在就要想辦法生出 character.attack() 和 monster.attack() 這兩個方法。可以用類似於下面的程式來成功實現：\nclass CharacterAdapter { public: virtual void attack(Monster* monster) = 0; } class WarriorAttackAdapter : public CharacterAdapter { private: Warrior* warrior; public: WarriorAttackAdapter(Warrior* w) : warrior(w) {}; public: void attack(Monster* monster) override { warrior -\u0026gt; chop(); } } class MagicianAttackAdapter : public CharacterAdapter { private: Magician* magician; public: MagicianAttackAdapter(Magician* m) : magician(m) {}; public: void attack(Monster* monster) override { magician -\u0026gt; magic_attack(); } } class MonsterAdapter { public: virtual void attack(Character* character) = 0; } class ZombieAttackAdapter : public MonsterAdapter { private: Zombie* zombie; public: ZombieAttackAdapter(Zombie* z) : zombie(z) {}; public: void attack(Character* character) override { zombie -\u0026gt; bite(); } } class GoblinAttackAdapter : public MonsterAdapter { private: Goblin* goblin; public: GoblinAttackAdapter(Goblin* g) : goblin(g) {}; public: void attack(Character* character) override { magician -\u0026gt; knock(); } } 我們先定義了兩個新的類別 CharacterAdapter 和 MonsterAdapter 用來分別處理「人打怪物」與「怪物打人」的兩種情況，接下來再根據各自的不同細節，去實作出 WarriorAttackAdapter, GoblinAttackAdapter \u0026hellip; 等不同的適配器，這樣就可以在「『盡量』不更動原始程式」的情況下，完成程式的相互兼容了！只要在攻擊之前做出類似以下的事情就可以：\nint main() { Monster* zombie = new Zombie(); Character* warrior = new Warrior(); MonsterAdapter* monster = new ZombieAttackAdapter(zombie); CharacterAdapter* character = new WarriorAttackAdapter(warrior); Battle::battle(character, monster); } class Battle { public: static CharacterAdapter* character; static MonsterAdapter* monster; public: static void battle(CharacterAdapter* character, MonsterAdapter* monster) { // ... } } 會說『盡量』是因為：我們還是會修改到 battle() 方法中 character 和 monster 的類別，畢竟 CharacterAdapter 與 MonsterAdapter 並不屬於 Character 和 Monster 的子類別。而這種「將物件包裹在適配器本身，並微調原程式，使程式可以正常運行」的方法，就是所謂的「物件型適配器」進行的工作。但如果我們今天是純粹讓 WarriorAttackAdapter 去繼承 Warrior，就可以在不更動到 Battle 中的程式的情況下，完成程式的相互兼容，就像是以下的這個樣子：\nclass WarriorAttackAdapter : public Warrior { public: void attack(Character* character) override { this -\u0026gt; chop(); } } class GoblinAttackAdapter : public Goblin { public: void attack(Character* character) override { this -\u0026gt; knock(); } } class Battle { public: static void battle(Character* character, Monster* monster) { this -\u0026gt; set_character(character); this -\u0026gt; set_monster(monster); this -\u0026gt; pre_battle(); while(!end_battle()) { if(!end_battle()) { character -\u0026gt; attack(monster); monster -\u0026gt; hurt(); } if(!end_battle()) { monster -\u0026gt; attack(character); character -\u0026gt; hurt(); } } this -\u0026gt; show_result(); } } int main() { Character* warrior = new WarriorAttackAdapter(); Monster* goblin = new GoblinAttackAdapter(); Battle::battle(warrior, goblin); } 而這，也是【類別型適配器】在做的事情。\n小結 適配器模式的優點：\n可以在盡量不更新原程式的情況下，完成程式的兼容 提高程式的靈活性與重用性 可以根據不同的需求擴展不同的適配器，而不影響原程式 適配器模式的缺點：\n過多的類別容易使程式增加額外的負擔 會讓系統變得稍微複雜，不適用於小型程式或重構程式 增加程式的量提，因此也會增加程式的維護成本 "},{"id":30,"href":"/_docs/example/table-of-contents/without-toc/","title":"Without ToC","section":"Table of Contents","content":"\rAt me ipso nepotibus nunc celebratior genus\r#\rTanto oblite\r#\rLorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius\r#\rQuibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\nRemansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae\r#\rCredulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\nBaculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"id":31,"href":"/docs/computer_science/design_pattern/interface_segregation_principle/","title":"介面隔離原則（Interface Segregation Principle）","section":"設計模式","content":"\r介面隔離原則（Interface Segregation Principle）\r#\rChatGPT 的說明 介面隔離原則（ISP - Interface Segregation Principle）是 SOLID 原則中的一個，SOLID 是一個首字母縮略詞，代表著五個不同的設計原則：單一職責原則（Single Responsibility Principle，SRP）、開放封閉原則（Open/Closed Principle，OCP）、里氏替換原則（Liskov Substitution Principle，LSP）、介面隔離原則（Interface Segregation Principle，ISP）、依賴反轉原則（Dependency Inversion Principle，DIP）。介面隔離原則（ISP）主要關注在設計【介面】（interface）時的合理性和適切性。ISP 的核心理念是「【客戶端】不該被迫依賴它不需要的【介面】」，這意味著【介面】應該要被分割成小的、細微的、特定的部分，以便客戶端在依賴【介面】時，不會包含到那些他們不需要的方法。更具體地說，ISP 強調以下兩個信條：「介面應該小而精簡」以及「用多個特定介面替換一個通用介面」。\n【介面應該小而精簡】 在軟體開發中（特別是物件導向程式設計），設計一個適宜的【介面】是非常重要的。「介面應該小而精簡」是指一個介面應該只包含客戶端所需的要方法，不應該包含多餘的、繁冗的、不必要的方法。這條訊息鼓勵程式設計師在設計面時，將「大的、通用」的介面分割成「小的、特定的」的部分，從而使【客戶端】只需要實現（或使用）他們所需要的方法，以助於減少依賴性、提高程式的可讀性，同時也確保每個【介面】的方法都具有清晰的用途和職責。\n接下來我們使用一個例子來說明「介面應該小而精簡」的想法：想像一個 RPG（角色扮演遊戲）遊戲中，我們需要設計不同【角色】的能力介面。這些角色可以是【戰士】【法師】【弓箭手】\u0026hellip;等。每個【角色】都有一些共同的行動，比如攻擊（attack）、防禦（defend）等，但也有些角色特有的行動，例如法師的魔法攻擊（magicAttack）。一個不遵循「介面應該小而精簡」信條的設計可能會如下：\nclass Character { public: virtual void attack() = 0; virtual void defend() = 0; virtual void magicAttack() = 0; }; 在這種情況下，即使某些角色不具備魔法攻擊能力（比如戰士），它們仍然需要實現 magicAttack 方法，這對於這些角色來說是多餘的。但如果我們有遵循「介面應該小而精簡」的原則，我們便可以將原本的程式，改成下面這樣的設計：\nclass Character { public: virtual void attack() = 0; virtual void defend() = 0; }; class Mage : public Character { public: void attack() override {} void defend() override {} public: void magicAttack() {} }; 這樣的設計遵循了「介面應該小而精簡」的信條，因為每個【角色】都只需要實現他們所需的行動，而不需要實現多餘的方法。比如說：【戰士】角色在這樣的設計情況下，只需要實現 attack() 方法和 defend() 方法，而不需要去實現魔法攻擊相關的方法。而【法師】除了 attack() 方法和 defend() 方法之外，因為還擁有魔法攻擊相關的方法，因此多了一個 magicAttack() 的相關方法。\n【用多個特定介面替換一個通用介面】 第二個信條是「用多個特定介面替換一個通用介面」。該信條是指在設計【介面】時，相對於定義一個「大而通用」的介面，將該【介面】拆分成「多個」「小而特定」的部分【介面】更能夠滿足客戶端的特定需求。這個信條鼓勵將通用的功能分解成更加具體、更專業化的【介面】，以便【客戶端】只需要實現（或使用）他們真正所需要的方法，而不需要去考慮那些不會被使用到，但仍然被介面所包含的冗餘方法。\n接下來我們使用一個角色扮演遊戲（RPG）來說明該信條的應用方式：考慮一個 RPG 遊戲，我們需要處理【角色】的不同技能和特性。遊戲中可能會有各種不同的職業，如【戰士】【法師】【弓箭手】等。每個職業都有其獨特的技能和特性，但也有一些共同的屬性，如攻擊（attack）、防禦（defend）等。如果不遵循「用多個特定介面替換一個通用介面」的設計方式，我們可能會得到類似以下的設計：\nclass Character { public: virtual void attack() = 0; virtual void defend() = 0; virtual void castSpell() = 0; virtual void shootArrow() = 0; // ... other methids }; 這種情況下，即使某些職業並不需要這些所有的方法，例如【戰士】不需要 castSpell() 方法、【法師】無法理解什麼是 shootArrow() 方法\u0026hellip;等，它們（這些所有的職業）仍然會需要實現這些不必要的方法，從而增加了類別本身的複雜性。但相反地，如果我們遵循「用多個特定介面替換一個通用介面」的設計方式，我們可以將上述的程式改為以下這樣的設計：\nclass Character { public: virtual void attack() = 0; virtual void defend() = 0; }; class Spellcaster { public: virtual void castSpell() = 0; }; class Archer { public: virtual void shootArrow() = 0; }; class Warrior : public Character { public: void attack() override {} void defend() override {} }; class Mage : public Character, public Spellcaster { public: void attack() override {} void defend() override {} void castSpell() override {} }; class ArcherCharacter : public Character, public Archer { public: void attack() override {} void defend() override {} void shootArrow() override {} }; 透過將原本的 Character 介面切分成了更細小、更特定的 Character, Spellcaster, Archer 介面，這樣的設計即是遵循了「用多個特定介面替換一個通用介面」的原則。現在每個【職業】只需實現他們所需的方法，並且可以通過組合特定【介面】的方式來達到所需的特性。這使得設計更加模組化和可擴展，【客戶端】只需實現他們所需要的介面，減少了不必要的依賴和複雜性，同時也增加了程式的可讀性和維護性。\n"},{"id":32,"href":"/docs/computer_science/design_pattern/dependency_inversion_principle/","title":"依賴反轉原則（Dependency Inversion Principle）","section":"設計模式","content":"\r依賴反轉原則（Dependency Inversion Principle）\r#\rChatGPT 的說明 依賴反轉原則（Dependency Inversion Principle，簡稱DIP）眾多設計原則中的一個概念，它通過重新思考軟體設計中的「依賴」關係，提供了一種更具靈活性、擴展性、與可維護性的方式來組織程式碼。這個原則的核心思想在於「改變我們對依賴的看法」，將依賴關係的方向進行反轉，以減少耦合，增加彈性，並使系統更容易擴展和維護。在傳統的軟體設計中，\u0026ldquo;較低層級的模組\u0026rdquo; 通常依賴於 \u0026ldquo;較高層級的模組\u0026rdquo;。例如：如果你正在設計一個 RPG 遊戲，【技能】（低層模組）可能會依賴於【角色】（高層模組），因為【技能】需要知道它是被哪種類型的【角色】所使用。這種設計方式可能導致 \u0026ldquo;高層模組\u0026rdquo; 的變化影響到 \u0026ldquo;低層模組\u0026rdquo;，增加了系統的脆弱性和維護難度，並限制了系統的可擴展性。\nDIP的關鍵思想是：我們應.該.將.依.賴.關.係.的.方.向.反.過.來，使 \u0026ldquo;高層模組\u0026rdquo; 依賴於「\u0026ldquo;低層模組\u0026rdquo; 的抽象」，而不是依賴具體的低層細節。換句話說，我們要將控制權交給抽象類別，讓 \u0026ldquo;高層模組\u0026quot;依賴於【介面】【抽象類別】或其他抽象化的類型。這樣一來，可以帶來幾個好處是：首先是【減少耦合】：通過讓模組依賴於抽象，\u0026ldquo;高層模組\u0026rdquo; 和 \u0026ldquo;低層模組\u0026rdquo; 之間的耦合性便會降低。這意味著變更低層模組的實現不會影響高層模組的穩定性。\n此外，這樣做也可以【提升程式的可擴展性】：因為高層模組只依賴於抽象被別，所以低層模組可以更容易地被替換、被修改、或延展成新的低層類別，從而實現系統的擴展。此外，這樣的撰寫方式也有助於提升程式的【可測試性】：由於高層模組可以依賴於虛擬的、可測試的抽象，這將使得測試高層模組的難度變得更加容易。使高層依賴低層的抽象也可以【減少程式的細節】：因為通過依賴【抽象類別】或【介面】來實現功能，高層模組不再需要知道低層模組的具體實現細節，這有助於提高程式的可讀性和簡潔性。\n以下我們將透過一個 RPG 遊戲的情境，模擬「『低層模組』依賴『高層模組』」和「『高層模組』依賴『低層模組的抽象』」兩種程式的撰寫方式，在這個情境之下，低層模組指的是【技能】類別，而【高層】模組則是可以使用【技能】類別的其餘類別，也就是【角色】類別。首先，我們將低層模組【技能】依賴於高層模組【角色】。我們定義了【技能】的不同實現，而它們會根據【角色】的特性來調整技能的效果。\nclass Character; class Skill { public: void fireBall(Character\u0026amp; character) { // only the magician can use this skill if(character.type == \u0026#34;Magician\u0026#34;) cout \u0026lt;\u0026lt; character.name \u0026lt;\u0026lt; \u0026#34; uses the skill \u0026#39;fire ball\u0026#39;.\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; character.name \u0026lt;\u0026lt; \u0026#34; wanted to try something, but there was no response.\u0026#34; \u0026lt;\u0026lt; endl; } void heal(Character\u0026amp; character) { // some codes } // other skills code }; class Character { public: string name; string type; Skill* skill; public: Character(string name, string type) : name(name), type(type), skill(new Skill()) {}; public: void useSkill(string str) { if(str == \u0026#34;Fire ball\u0026#34;) skill.fireBall(*this); else if(str == \u0026#34;...\u0026#34;) { // ... other skills code } } }; 但如果我們將狀況顛倒過來：讓高層模組【角色】依賴一個低層模組【技能】的抽象類別，這樣【技能】將不再受限於各種不同的【角色】，只需要專心處理【技能】本身的程式（諸如動畫、音效、傷害計算\u0026hellip;等）即可。同時【角色】也不再需要知道【技能】的實際方法名稱，只需要調用一個統一的「抽象技能方法」即可使用技能，程式會變成類似於下面的撰寫方式：\nclass Skill { public: virtual void useSkill() = 0; }; class FireBallSkill : public Skill { public: void useSkill(string name) override { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; uses the skill \u0026#39;fire ball\u0026#39;.\u0026#34; \u0026lt;\u0026lt; endl; } }; class HealingSkill : public Skill { public: void useSkill(string name) override { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; uses the skill \u0026#39;healing\u0026#39;.\u0026#34; \u0026lt;\u0026lt; endl; } }; class Character { public: string name; Skill* skill; public: Character(string name) : name(name), skill(new FireBallSkill()) {}; public: void performSkill() { skill -\u0026gt; useSkill(name); } void setSkill(Skill* s) { skill = s; } }; "},{"id":33,"href":"/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/","title":"合成/聚合複用原則（Composite/Aggregate Reuse Principle）","section":"設計模式","content":"\r合成/聚合複用原則（Composite/Aggregate Reuse Principle）\r#\rChatGPT 的說明 合成/聚合複用原則（CARP）是一個軟體設計原則，旨在引導開發人員在設計類別之間的關係時，能更多地考慮「合成」和「聚合」關係，而不是過度依賴「繼承」。這個原則強調使用合成（Composition）和聚合（Aggregation）的關係來實現複用性和模組化，以增加程式碼的靈活性、可讀性和可維護性。\n【合成關係】（Composition）：合成關係表示「一個物件包含其他的物件作為其一部分，這些部分物件的生命週期也與包含物件相關聯。」如果該物件被銷毀，其部分物件也會被銷毀。合成關係建立了一種高強度的耦合，表示「部分物件」與「整體物件」之間的關係非常緊密，此外，部分物件不能獨立存在。例如在 RPG 遊戲中，一個【角色】Character 可能會包含【武器】Weapon、【盔甲】Armor 與【技能】Skill 作為其【角色】的一部分，這些部分物件隨著會【角色】的存在而存在，同時也會因為【角色】的消失而消失。\n【聚合關係】（Aggregation）：聚合關係表示一個「物件包含其他物件作為其部分，但這些部分物件的生命週期與包含物件無關。」即使完整物件被銷毀，其餘的部分物件仍然可以獨立存在。聚合建立了一種較為孱弱的鬆耦合，表示部分物件具有一定程度的獨立性。例如在一個 RPG 遊戲中，一個【公會】 Group 可以聚合多個【角色】Character 作為其部分，但如果【公會】消失了，【角色】仍然可以在公會之外繼續存在。\n「高層模組」應該儘量避免直接依賴於「低層模組」，而是通過合成或聚合的方式來使用低層模組。這種設計可以使撰寫出來的程式碼更富有彈性，也能相較容易地替換（或添加）新的低層模組。同時，低層模組也應該避免強依賴於高層模組，以確保模組之間的耦合度降低。在 RPG 遊戲的情境中，CARP 原則還可以這樣應用：假設遊戲中的【角色】是高層模組，而【裝備】是低層模組。【角色】可以包含多個【裝備】，這些【裝備】可以通過聚合關係與【角色】相關聯。同時，裝備也可以包含多個屬性（例如攻擊力、防禦力），這些屬性通過合成關係與【裝備】相關聯。\nclass Attribute { private: string name; int value; public: Attribute(string name, int value) : name(name), value(value) {} public: void display() { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; } }; class Equipment { private: string name; vector\u0026lt;Attribute*\u0026gt; attributes; public: Equipment(string name) : name(name) {} public: void addAttribute(Attribute* attribute) { attributes.push_back(attribute); } void displayAttributes() { cout \u0026lt;\u0026lt; \u0026#34;裝備名稱：\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;屬性列表：\u0026#34; \u0026lt;\u0026lt; endl; for (Attribute* attr : attributes) { attr -\u0026gt; display(); } cout \u0026lt;\u0026lt; endl; } }; class Character { private: string name; vector\u0026lt;Equipment*\u0026gt; equipments; public: Character(string name) : name(name) {} public: void addEquipment(Equipment* equipment) { equipments.push_back(equipment); } void displayEquipments() { cout \u0026lt;\u0026lt; \u0026#34;角色名稱：\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;裝備列表：\u0026#34; \u0026lt;\u0026lt; endl; for (Equipment* equip : equipments) { equip -\u0026gt; displayAttributes(); } cout \u0026lt;\u0026lt; endl; } }; int main() { Equipment* sword = new Equipment(\u0026#34;寶劍\u0026#34;); sword -\u0026gt; addAttribute(new Attribute(\u0026#34;攻擊力\u0026#34;, 100)); Equipment* armor = new Equipment(\u0026#34;鎧甲\u0026#34;); armor -\u0026gt; addAttribute(new Attribute(\u0026#34;防禦力\u0026#34;, 50)); Character player(\u0026#34;勇者\u0026#34;); player.addEquipment(sword); player.addEquipment(armor); player.displayEquipments(); } "},{"id":34,"href":"/docs/computer_science/design_pattern/single_responsibility_principle/","title":"單一職責原則（Single Responsibility Principle）","section":"設計模式","content":"\r單一職責原則（Single Responsibility Principle）\r#\rChatGPT 的說明 單一職責原則（Single Responsibility Principle，簡稱 SRP）是物件導向程式設計中的一個基本原則，它強調「每個類別（或方法）應該都只有一個職責」，意即「只有『一個』理由可以導致該類別或方法產生」。換句話說，一個類別或方法應該只具有一個主要的功能或職責，而不應該承擔過多的功能。這有助於使程式更容易理解、更容易維護和更容易擴展。SRP 的核心思想是「將不同的功能隔離到不同的位置」，從而實現高內聚（High Cohesion）和低耦合（Low Coupling）。這樣做可以使程式更加模組化，且當需求發生變化時，只需要負責該變化的部分，而不會影響到其他的程式與功能。\n違反 SRP 可能導致以下問題：首先是「複雜性增加」： 當一個類別承擔太多的職責時，會導致該類別的程式變得複雜、難以理解、和不易維護。再來，程式的「耦合程度也會變高」：將不同職責的程式混合在一起，會導致類別與類別的依賴加重，進而增加程式的耦合程度，這將使得當類別需要發生改變時，可能會連帶需要修改到其餘的類別，使影響範圍擴大。同時，違反單一職責也會使「程式的重用性下降」：與遵守單一職責的類別相比，具有當類別具有多重職責時，通常難以重用，因為其功能過於特定。此外，也可能發生多了類別具有相同或近似功能的重複性程式。最後，違反 SPR 的程式也會「增加程式變更的風險」： 當一個職責的變化，需要修改類別中的多個部分時，容易會發生撰寫的錯誤，進而引發程式的崩潰，此外也需要考慮是否存在「其他類別也擁有相同功能，因此需要一並修改」的可能性。簡而言之，單一職責原則有助於保持程式的清晰、可維護性和可擴展性，通過確保一個類別只有一個主要職責，可以使系統遍的更加靈活和易於改變。\n以下我們使用一個簡單的情境來解釋單一職責原則，我們假設在一個 RPG 遊戲中，角色可能會有「回復」「受到攻擊」與「升級」三種可能會發生的變化，如果我們使用 SRP 的程式原則，我們就會將這三種變化區別書寫成 takeDamage(), heal(), 和 levelUp() 三種方法。但如果不使用 SRP 的撰寫原則，程式就會全部擠在 update() 裡面，使得程式變得繁冗與複雜：\n// Adhering to SRP (Single Responsibility Principle) // Adhering to SRP (Single Responsibility Principle) // Adhering to SRP (Single Responsibility Principle) class Character { private: string name; int health; int level; public: Character(string name) : name(name), health(100), level(1) {} public: void takeDamage(int amount) { health -= amount; cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; takes \u0026#34; \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; \u0026#34; damage.\u0026#34; \u0026lt;\u0026lt; endl; } void heal(int amount) { health += amount; cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; heals \u0026#34; \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; \u0026#34; health.\u0026#34; \u0026lt;\u0026lt; endl; } void levelUp() { level++; cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; levels up to \u0026#34; \u0026lt;\u0026lt; level \u0026lt;\u0026lt; \u0026#34;!\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Character player(\u0026#34;Hero\u0026#34;); player.takeDamage(20); player.heal(10); player.levelUp(); } // Not adhering to SRP (Single Responsibility Principle) // Not adhering to SRP (Single Responsibility Principle) // Not adhering to SRP (Single Responsibility Principle) class Character { private: string name; int health; int level; public: Character(string name) : name(name), health(100), level(1) {} public: void update(int damageAmount, int healAmount, bool levelUp) { if (levelUp) { level++; cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; levels up to \u0026#34; \u0026lt;\u0026lt; level \u0026lt;\u0026lt; \u0026#34;!\u0026#34; \u0026lt;\u0026lt; endl; } else if (damageAmount \u0026gt; 0) { health -= damageAmount; cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; takes \u0026#34; \u0026lt;\u0026lt; damageAmount \u0026lt;\u0026lt; \u0026#34; damage.\u0026#34; \u0026lt;\u0026lt; endl; } else if (healAmount \u0026gt; 0) { health += healAmount; cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; heals \u0026#34; \u0026lt;\u0026lt; healAmount \u0026lt;\u0026lt; \u0026#34; health.\u0026#34; \u0026lt;\u0026lt; endl; } } }; int main() { Character player(\u0026#34;Hero\u0026#34;); player.update(20, 0, false); player.update(0, 10, false); player.update(0, 0, true); } "},{"id":35,"href":"/docs/computer_science/design_pattern/least_knowledge_principle/","title":"最少知識原則（Least Knowledge Principle）","section":"設計模式","content":"\r最少知識原則（Least Knowledge Principle）\r#\rChatGPT 的說明 最少知識原則（Principle of Least Knowledge，縮寫為 LKP），又稱作迪米特原則（Law of Demeter，縮寫為LoD），是一個軟體設計原則，該原則旨在「降低系統中各個組件之間的耦合度，從而提高系統的可讀性、可維護性和可擴展性」。最少知識原則的核心思想是「只與你直接的朋友通信」，意即「一個對象應該只認識它的直接朋友，不應該直接認識其他類別的內部結構。」這個原則強調了組件與組件之間的鬆耦合，避免了不必要的依賴關係，從而降低了系統的複雜度。最少知識原則可以透過以下幾個關鍵點來理解：\n只與直接朋友通信 在可允許的情況下，一個類別的方法，應該只可以調用以下的方法：「這個類別本身的方法」「被當作參數給傳遞進來的物件的方法」和「在該方法內，被創建（或被實例）的物件的方法。」一個類別的方法應該儘量只依賴於自己的內部實現，而不是去調用其他類別的內部方法。這樣可以確保當一個類別的實現變化時，其他類別不會因此受到影響。這也有助於隔離變化，使系統更加穩定\n此外「該方法的參數」可以被視為該方法的直接朋友。如果一個方法需要訪問另一個物件的方法，最好是將該物件作為參數傳遞給方法，而不是在方法內部直接訪問。這樣可以明確地傳遞相關資訊，並減少方法之間的隱含耦合；而當一個類別創建了（或實例化）另一個物件時，通常只應該調用該物件的公開介面方法（因為直接訪問該物件的內部方法，可能會導致類別之間的耦合增加）。透過只調用公開介面方法，可以保持類別之間的解耦。\n避免深層次的依賴 【類別】不應該調用【其他類別】的內部方法，特別是深層次的內部方法。因為這樣的依賴關係會使系統的耦合度增加，導致代碼難以維護。例如在以下的範例中，我們有一個名為 Ability 的基礎類別，並有兩個子類別（Fireball 和 Icebolt），它們繼承自 Ability。然後我們有一個 Character 類別，它包含一個 Ability* 的成員，並有一個 performAbility() 方法用於執行能力。\n進一步地 Mage 類別繼承自 Character ，並且在 Mage 的構造函數中創建了一個 Fireball 的能力。最後，我們有一個 Game 類別，該類別創建了一個 Mage 的實例，然後在 play() 方法中執行了法師的能力。這個範例中， Game 的 play() 方法就存在深層次的依賴關係。（Game \u0026gt; Mage \u0026gt; Ability \u0026gt; perform()）\nclass Ability { public: virtual void perform() { cout \u0026lt;\u0026lt; \u0026#34;Performing basic ability!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Fireball : public Ability { public: void perform() override { cout \u0026lt;\u0026lt; \u0026#34;Casting fireball!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Character { public: Ability* ability; Character() : ability(new Ability()); }; class Mage : public Character { public: Mage() : ability(new Fireball()); }; class Game { private: Mage* mage; public: Game() : mage(new Mage()); void play() { mage -\u0026gt; ability -\u0026gt; perform(); } }; int main() { Game game; game.play(); } 善用委託 善用委託指的是：當一個【物件】需要訪問【另一個物件】的方法時，不應該直接訪問該方法，而是委託給一個「中介者」來進行訪問。這個中介者可以是一個參數、該【物件】的其餘方法，或是【物件】內能夠創建的【其他物件】。這樣的訪問方式，有助於降低【物件】對【另一個物件】的直接依賴，保持較低的耦合度。通過使用委託，我們可以將類別之間的依賴關係限制在更小的範圍內，從而降低整體系統的耦合度。這樣在修改或擴展一個類別時，不會影響到其他的類別。此外，如果直接訪問【另一個物件】的方法，當【另一個物件】發生變化時，可能就會需要連帶修改【物件】本身的訪問程式。因此，使用「委託」可以將這個變化進行隔離，對【物件】本身的影響範圍更小。\n盡可能抽象 如果類別需要引用其他類別，儘量引用【介面】或【抽象類別】，而不是具體的實現類別。因為如果直接引用實體類別，當該類別有發生變化時，很可能就會連帶影響到原本的類別。引用【介面】可以避免這樣的問題產生，從而提供一個更具可讀性、可維護性、和可擴展性的程式邏輯。\n最少知識原則的遵循有助於降低類別之間的耦合度，使系統更具模組性、可維護性和可擴展性。同時，它可以減少不必要的訪問和依賴，使程式碼更易於理解和測試。在 RPG 遊戲中，最少知識原則的應用可以通過確保【角色】對於【其他角色】的交互以及對於【遊戲系統】的交互保持簡單。【角色】如果只與其直接相關的【遊戲系統】和【其他角色】進行交互（而不是直接調用【其他角色】的方法），便可以降低角色之間的耦合度，提高遊戲的模組性和可維護性。\n"},{"id":36,"href":"/docs/computer_science/design_pattern/liskov_substitution_principle/","title":"里式替換原則（Liskov Substitution Principle）","section":"設計模式","content":"\r里式替換原則（Liskov Substitution Principle）\r#\rChatGPT 的說明 里式替換原則（Liskov Substitution Principle，簡稱 LSP）是物件導向程式設計中的一個重要原則，由 [Barbara Liskov][1] 在 1987 年的一個會議 \u0026ldquo;[Data abstraction and hierarchy][2]\u0026rdquo; 所提出。該原則強調：「子類別應該能夠替換其父類別，並且同時保持原有程式的正確性。」里式替換原則告訴我們：一個衍生類別（也就是子類別）必須能夠完全替換其基底類別（父類別）而不影響原有的程序行為。換句話說，子類別應該具有與父類別相同的行為和參數，這樣才能保證其程式的正確性和穩定性。LSP 主要包含了的 2 個關鍵點：\n首先【子類別必須完全擁有父類別的屬性或行為】：子類別需要做的事情，應該是「重寫」或「擴展」父類別的方法，而不是修改其行為，例如當一個名為【角色】的類別擁有攻擊 attack()、防禦 defence()、和魔法攻擊 magicAttack() 三種方法時，所以繼承該【角色】類別的子類別，都必須完全擁有這些行為，這意味著不能完全執行這三項行為的類別不可以繼承【角色】（例如【戰士】不會使用魔法攻擊、【僧侶】沒有防禦手段\u0026hellip;等）。但我們可以透過「擴增」類別的行為，讓子類別保持與父類別一致的完整性。例如先移除【角色】中的 magicAttack(), 方法，再將【能使用魔法攻擊的角色】與【不能使用魔法攻擊的角色】分別繼承於【角色】，並將 magicAttack() 方法定義於【能使用魔法攻擊的角色】當中。這樣一來，【戰士】別即可以透過繼承【不能使用魔法攻擊的角色】成為【角色】的一員。\n接下來：【子類別應該完全遵循由父類所設計的邏輯】，意即保證父類別的行為在子類別中也能夠正確執行。子類不應該修改父類別所設計的邏輯、制定的規則、前提條件、或者是後置條件，也不應該引入新的前提條件或後置條件。例如：在名為【角色】的父類別中，如果有定義一個 defence() 方法，其實作的內容為「利用手中的武器進行防禦。」那麼所有繼承於【角色】的類別，即便是改寫或擴增 defence() 方法，也不可以違背「用武器防禦」這項原則。（這意味著不可以改寫【盜賊】的 defence() 為「透過閃躲防禦」）。透過保持規則的一致性，可以避免程式的不可預測性，例如原本【戰鬥】的攻防計算為「武器攻擊力 - 武器防禦力」，但因為我們將【盜賊】的防禦修改為「閃躲」，並沒有所謂的「武器防禦力」，在這樣的情況下可能就會造成不可預知的錯誤。\n以下我們使用一個簡單的情境來解釋里式替換原則和非里式替換原則的程式邏輯：我們需要製作一個 RPG 遊戲，其中有著一個【角色】類別，和【戰士】【法師】【盜賊】三種子類別。【角色】有攻擊（attack()） 和 防禦（defence()）兩種方法，有些角色也可以嘗試進行魔法攻擊（magicAttack()），此外，防禦（defence()）的程式邏輯為「受到的傷害 = 武器的攻擊力 - 自身的防禦力」。程式撰寫邏輯如下：\n// Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) class Character { protected: int attack; int defense; public: Character(int attack, int defense) : attack(attack), defense(defense) {} virtual void attack() { cout \u0026lt;\u0026lt; \u0026#34;Character attacks with attack power: \u0026#34; \u0026lt;\u0026lt; attack \u0026lt;\u0026lt; endl; } virtual void defense(int received_atk) { int received_dmg = received_atk - defense; received_dmg = (received_dmg \u0026lt; 0)? 0: received_dmg; cout \u0026lt;\u0026lt; \u0026#34;Character received damage: \u0026#34; \u0026lt;\u0026lt; received_dmg \u0026lt;\u0026lt; endl; } }; class Warrior : public Character { public: Warrior(int attack) : Character(attack, 20) {} }; class Mage : public Character { public: Mage(int attack) : Character(attack, 10) {} public: void magicAttack() { cout \u0026lt;\u0026lt; \u0026#34;Mage casts a powerful magic spell!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Thief : public Character { public: Thief(int attack) : Character(attack, 15) {} public: void dodge() { cout \u0026lt;\u0026lt; \u0026#34;Thief dodged the incoming damage.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Warrior warrior(50); Mage mage(40); Thief thief(40); warrior.attack(); warrior.defense(); mage.attack(); mage.defense(); mage.magicAttack(); thief.attack(); thief.dodge(); } // Not adhering to OCP (Open Closed Principle) // Not adhering to OCP (Open Closed Principle) // Not adhering to OCP (Open Closed Principle) class Character { protected: int attack; int defense; public: Character(int attack, int defense) : attack(attack), defense(defense) {} virtual void attack() const { cout \u0026lt;\u0026lt; \u0026#34;Character attacks with attack power: \u0026#34; \u0026lt;\u0026lt; attack \u0026lt;\u0026lt; endl; } virtual void defense() const { int actualDefense = attack - defense; cout \u0026lt;\u0026lt; \u0026#34;Character defends with defense value: \u0026#34; \u0026lt;\u0026lt; actualDefense \u0026lt;\u0026lt; endl; } virtual void magicAttack() const { cout \u0026lt;\u0026lt; \u0026#34;Character uses a magic attack!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Warrior : public Character { public: Warrior(int attack) : Character(attack, 20) {} public: // The subclass contains inaccessible methods from the parent class. void magicAttack() override {} }; class Mage : public Character { public: Mage(int attack) : Character(attack, 10) {} }; class Thief : public Character { public: Thief(int attack) : Character(attack, 15) {} public: // The logic defined in the subclass is inconsistent with that of the superclass. void defense() override { cout \u0026lt;\u0026lt; \u0026#34;Thief dodges the attack.\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Warrior warrior(50); Mage mage(40); Thief thief(40); warrior.attack(); warrior.defense(); mage.attack(); mage.defense(); mage.magicAttack(); thief.attack(); thief.defense(); } "},{"id":37,"href":"/docs/computer_science/design_pattern/open_closed_principle/","title":"開放封閉原則（Open Closed Principle）","section":"設計模式","content":"\r開放封閉原則（Open Closed Principle）\r#\rChatGPT 的說明 開放封閉原則（Open Closed Principle，簡稱 OCP）是物件導向程式設計中的一個重要原則，由著名的軟體工程師 Bertrand Meyer 在其著作《[物件、函數和C++]》中首次提出。該原則強調軟體實體（像是類別、模組、函數方法\u0026hellip;等）應該對擴展開放，對修改封閉。換句話說，程式應該可以在「不修改現有程式」的情況下，擴展其系統的功能，同時程式也應防止在改變功能時，對現有的程式進行修改。\n開放封閉原則的核心思想是：當系統需要引入新的功能或變化時，不應該修改已存在的程式，而是通過擴展（例如增添新的類別、新的方法\u0026hellip;等）來實現。這樣可以保證原有代碼的穩定性，同時在不影響現有功能的基礎上進行擴展。要遵守開放封閉原則，通常可以採取以下策略：【使用抽象類別或抽象接口】：通過使用抽象類別或抽象接口，我們可以建立起一個（或一些）泛用的方法和屬性，並在子別類中實現這些方法的具體功能。這樣，當系統需要擴展功能時，只需添加新的子類別即可完成功能，而不需要修改現有的程式。\n此外【使用多態性（polymorphism）】也可以使程式遵循開放封閉原則：通過使用 polymorphism 的程式，我們可以讓程式在運行時，根據具體的對象類別，調用不同的方法。這樣，即使新增了新的功能，只需創建新的對象與新的多態方法即可完成功能，而不需要修改原有的程式和邏輯。此外，【使用策略模式等設計模式】也可以有效地達成開放封閉原則。一些設計模式（例如策略模式）可以幫助我們實現開放封閉原則。這些模式將不同的行為封裝成獨立的策略類，並通過替換不同的策略類來實現功能的擴展。\n另外，如果不遵守「開放封閉原則」，可能會導致程式產生以下的問題：首先是【程式的修改風險增加】，當系統需要引入新的功能或新的變化時，如果原程式不遵守開放封閉原則，可能會產生「添增新的功能外，同時也需要修改既存的程式，才能完成功能升級」的情況，這可能導致現有的程式功能產生錯誤或影響。可能引入新的錯誤、增加更多的複雜度、提高耦合\u0026hellip;等，增加了整個系統的風險。\n此外，沒有遵守「開放封閉原則」的程式也可能會有【測試困難】的狀況發生：修改現有的程式，可能會需要重新測試整個系統，在這樣的情況下，因為程式的高度改變，可能會導致測試的困難、測試覆蓋率降低\u0026hellip;等負面影響。測試新的功能可能影響到現有的測試案例，也因此增加了測試的複雜性。此外，違反原則的程式也會使得「程式的耦合增加」：不遵守開放封閉原則的程式，可能會導致不同的功能、不同的方法、或不同的類別之間出現耦合，一旦其中一個功能發生變動，可能會連帶影響到其他功能（或類別）的正常運作。\n同時，不遵守開放封閉原則也可能導致【程式的複雜性增加】【可擴展性下降】【程式的重用性下降】\u0026hellip;等問題。因此建議程式在撰寫的時候，要遵守開放封閉原則規範，才能有助於降低這些問題的風險，保持程式的靈活性和可維護性。\n以下我們使用一個簡單的情境來解釋單一職責原則，我們假設在一個 RPG 遊戲中，角色（Character）可以使出「火球術 fireBallSkill」「冰錐術 iceShardSkill」和「治癒術 healSkill」三種不同的攻擊，在遵循 OCP（開放封閉原則）的情況下，角色在進行技能的選擇與擴充的時候，並不會影響到原 Character 的程式，只需要增添新的 Skill 即可，但在不遵守 OCP 的情況下，若有需要做【技能】的擴充與修改，則會連帶影響到【角色】原本的程式內容：\n// Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) class Skill { public: virtual void use() = 0; }; class FireballSkill : public Skill { public: void use() override { cout \u0026lt;\u0026lt; \u0026#34;Casting Fireball!\u0026#34; \u0026lt;\u0026lt; endl; } }; class HealSkill : public Skill { public: void use() override { cout \u0026lt;\u0026lt; \u0026#34;Using Healing Spell!\u0026#34; \u0026lt;\u0026lt; endl; } }; class IceShardSkill : public Skill { public: void use() override { cout \u0026lt;\u0026lt; \u0026#34;Casting Ice Shard!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Character { private: string name; vector\u0026lt;Skill*\u0026gt; skills; public: Character(string name) : name(name) {} public: void addSkill(Skill* skill) { skills.push_back(skill); } void useSkills() const { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; uses skills:\u0026#34; \u0026lt;\u0026lt; endl; for (Skill* skill : skills) { skill -\u0026gt; use(); } } }; int main() { Character player(\u0026#34;Hero\u0026#34;); player.addSkill(new FireballSkill()); player.addSkill(new HealSkill()); player.addSkill(new IceShardSkill()); player.useSkills(); } // Not adhering to OCP (Open Closed Principle) // Not adhering to OCP (Open Closed Principle) // Not adhering to OCP (Open Closed Principle) class Character { private: string name; int skill; public: enum Skill { FIREBALL, HEAL, ICESHARD } public: Character(string name) : name(name), skill(0) {} public: void addFireballSkill() { skill = Skill::FIREBALL; } void addHealSkill() { skill = Skill::HEAL; } void addIceShardSkill() { skill = Skill::ICESHARD; } void useSkills() const { switch(skill) { case Skill::FIREBALL: cout \u0026lt;\u0026lt; \u0026#34;Casting Fireball!\u0026#34; \u0026lt;\u0026lt; endl; break; case Skill::HEAL: cout \u0026lt;\u0026lt; \u0026#34;Using Healing Spell!\u0026#34; \u0026lt;\u0026lt; endl; break; case Skill::ICESHARD: cout \u0026lt;\u0026lt; \u0026#34;Casting Ice Shard!\u0026#34; \u0026lt;\u0026lt; endl; break; default: break; } } }; int main() { Character player(\u0026#34;Hero\u0026#34;); player.addFireballSkill(); player.useSkills(); player.addHealSkill(); player.useSkills(); player.addIceShardSkill(); player.useSkills(); } "},{"id":38,"href":"/_docs/example/table-of-contents/","title":"Table of Contents","section":"Example Site","content":"\rUbi loqui\r#\rMentem genus facietque salire tempus bracchia\r#\rLorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice\r#\rOra precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\rPlacabilis coactis nega ingemuit ignoscat nimia non\r#\rFrontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) {\rzif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive;\rgigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop),\rpanel_point_firmware);\rspyware_bash.statePopApplet = express_netbios_digital(\rinsertion_troubleshooting.brouter(recordFolderUs), 65);\r}\rrecursionCoreRay = -5;\rif (hub == non) {\rportBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard),\rfont_radcab, guidCmsScalable + reciprocalMatrixPim);\rleft.bug = screenshot;\r} else {\rtooltipOpacity = raw_process_permalink(webcamFontUser, -1);\rexecutable_router += tape;\r}\rif (tft) {\rbandwidthWeb *= social_page;\r} else {\rregular += 611883;\rthumbnail /= system_lag_keyboard;\r}\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":39,"href":"/docs/daily_life/nodes/masters_degree/","title":"碩士的畢業證書","section":"人生節點","content":"\r碩士的畢業證書\r#\r畢業證書\n"},{"id":40,"href":"/docs/daily_life/reading_experience/head_first_design_pattern/","title":"《深入淺出設計模式》","section":"閱讀心得","content":"\r《深入淺出設計模式》閱讀心得\r#\r2023-07-07\n背景 一直以來，我都對「設計模式」這個東西抱著若有似無的認知。具象一點說明的話，大概就是「知道『設計模式』是一種可以讓程式寫得更加漂亮、更有彈性的觀念和方法，但實際上這些觀念是什麼（我不知道），那些方法又該如和撰寫（我也不知道）」的狀況。然後在今年 5 月底左右吧？因為第二篇論文出現了一點卡關的狀況（文章的內容一直沒辦法寫成老師期望的那種感覺），也因為患有一點研究生症候群，就開始找手邊一些 \u0026ldquo;一直以來都有興趣，但又找不到合適的時間去了解\u0026rdquo; 的東西進行研究了。而這之中，【研究設計模式】剛好是其中之一。\n這邊的研究設計模式是指「閱讀《深入淺出設計模式》這本書」。並不是閱讀比較主流的 Design Patterns: Elements of Reusable（也就是四人幫著的那本），其中一個原因是：剛開始的我，並不知道這本設計模式的聖經本，另一個原因則是它是我最快速能找到比較完整的、系統性的跟設計模式有關的書籍，所以就\u0026hellip; 這樣開始了。\n內容 雖然在四人幫的著作中，共列舉了 23 種常見的設計模式，但本書並沒有包含這麼多的內容。書中的 13 個章節裡，扣掉最後一個章節在介紹 MVC 架構（Model, View, Controller），以及倒數第 2 章在介紹不同模式的合併用法之外，其餘的 11 個章節依序僅介紹了 Strategy（策略模式）、observer（觀察者）、decorator（裝飾器）、factory（工廠模式，包含簡單工廠、工廠方法、和抽象工廠）、singleton（單例模式）、Command（命令模式）、Adapter（配適器）、Facade（外觀）、Template method（模板方法）、Iterator（迭代器）、Composite（組合模式）、State（狀態模式）、Proxy pattern（代理）\u0026hellip;等。剩餘的模式則僅於書中的附錄稍作提及。但這並不代表這本書不是一本良好的教學素材。相反地，因為本書的撰寫方式有別於市面上大多數的教學書籍，採用了極大量的圖片、角色對話、與情境式的描述，為各種模式的優缺點、應用情境、特徵、使用方法做大量的說明，同時也附上了許多的觀念思考、練習題、與程式範本，因此在閱讀上，並不會出現常見的倦怠、疲憊、或單調的感覺。\n心得 整體而言，這本書帶給我很多新的啟發，無論是程式的撰寫方式，例如「多用組合、少用繼承」「單一類別、單一職責」「依賴通用接口，不要依賴特定類別」\u0026hellip;等，或者是各種不同模式的應用與架構「工廠模式可以讓物件的實例化延後至子類別中實現」「模板方法只關心演算法的骨幹，因此可以在不改變演算法結構的前提下，重新定義某些方法的執行細節」「單例模式可以讓類別只生成單一物件，以確保某些資源的分配不會遇到問題或錯誤」\u0026hellip;等，抑或是程式的語法觀念，像是「C++ 的物件繼承，菱形繼承的問題與解決」「虛函數, 純虛函數」\u0026hellip;等，都是在閱讀本書之後才有了一個更加明確與更加清晰的認識。雖然是在一個比較非主動的動機下，才開始閱讀本書，但整體而言，能夠「閱讀本書，並從書本當中學到了更多的知識」對我來說實在是一件很高興又很喜歡的事情。\n評分 閱讀難度：★★★☆☆ （需要有基本的物件導向程式觀念）\n推薦指數：★★★★★\n"},{"id":41,"href":"/docs/_trash/strategy/","title":"策略模式 (Strategy Pattern)","section":"Trash","content":"\r策略模式（Strategy Pattern）\r#\r2023-07-07\n前言 假設我們現在正在製作一個 RPG 遊戲，遊戲內有一個名為 Monster 的抽象類別，該類別預設有 void attack()（攻擊）、void evades()（迴避）、和 void walk()（行走）三種行為，並且分別有 Slime（史萊姆）、Skeleton（骷髏）、和 Zombie（殭屍）三種怪物繼承了 Monter 類別。根據目前的想法，我們可以畫出類似於下面的類別圖，並寫出下方的程式：\nclassDiagram\rclass Abstract_Monster {\r+void attack();\r+void evades();\r+void walk();\r}\rAbstract_Monster \u003c|-- Slime\rAbstract_Monster \u003c|-- Skeleton\rAbstract_Monster \u003c|-- Zombie\r// C++ code class Monster { public: int hp; int atk; int def; public: virtual void attack(); virtual void evades(); virtual void walk(); }; void Monster::attack() { cout \u0026lt;\u0026lt; \u0026#34;The monster unleashes a regular attack.\u0026#34; \u0026lt;\u0026lt; endl; } void Monster::evades() { cout \u0026lt;\u0026lt; \u0026#34;The monster evades your attack.\u0026#34; \u0026lt;\u0026lt; endl; } void Monster::walk() { cout \u0026lt;\u0026lt; \u0026#34;The monster moves a distance.\u0026#34; \u0026lt;\u0026lt; endl; } class Slime : public Monster {}; class Skeleton : public Monster {}; class Zombie : public Monster {}; 這樣的做法似乎很合理，因此在遊戲前期的開發上，這段程式並沒有造成什麼太大的問題。\n問題 但在後來，遊戲的規模越做越大。開發團隊決定新增一些怪物（蝙蝠、地痞、和幽靈），也打算讓怪物可以實施更多的行為（像是逃跑、飛行、穿透物件\u0026hellip; 等）因此修改了原本針對於【怪物】這個類別的類別圖：\nclassDiagram\rclass Abstract_Monster {\r+int hp;\r+int atk;\r+int def;\r+void attack();\r+void evades();\r+void walk();\r+void escape(); (new)\r+void fly(); (new)\r+void pass_through(); (new)\r}\rAbstract_Monster \u003c|-- Slime\rAbstract_Monster \u003c|-- Skeleton\rAbstract_Monster \u003c|-- Zombie\rAbstract_Monster \u003c|-- Bat : (new)\rAbstract_Monster \u003c|-- Thief : (new)\rAbstract_Monster \u003c|-- Ghost : (new)\r這.時.候.問.題.就.來.了，當我們把所有的額外行為（escape, fly, pass_through）放進 Monster 類別裡面的時候，就會讓 某些 怪物的動作顯得很不合邏輯，像是「骷髏並不會飛」，「殭屍並沒有辦法穿透物件」或者是「史萊姆不會逃跑(?)」之類的。如果讓所有怪物都統一繼承這些方法的話，不免俗的可能會在未來的某個時候發生一些遊戲上的問題。\n當然啦，我們也可以在怪物的類別中預設不進行任何的動作：\nclass Zombie { public: void fly() override {}; // no nothing. void pass_through() override {}; // no nothing. } 但這樣並不是個解決問題的好方法，因為每次都要用 override 對怪物的行為做改寫的話，可以預想在遊戲愈發龐大的同時，每增加「一種怪物」或者是「一種行為」，就會需要負擔龐大的改寫成本 (一個 Devil 的類別也許就會需要 override 5-10 種方法，每增加一種方法，就要重新檢查之前的所有怪物是否會對該方法出現什麼額外獲特殊的狀況\u0026hellip; )\nclassDiagram\rclass Abstract_Monster {\r+int hp;\r+int atk;\r+int def;\r+void attack();\r+void evades();\r+void walk();\r+void escape();\r+void fly();\r+void pass_through();\r+void self_duff();\r}\rAbstract_Monster \u003c|-- Slime\rAbstract_Monster \u003c|-- Skeleton\rAbstract_Monster \u003c|-- Zombie\rAbstract_Monster \u003c|-- Bat\rAbstract_Monster \u003c|-- Thief\rAbstract_Monster \u003c|-- Ghost\rAbstract_Monster \u003c|-- Vampire\rAbstract_Monster \u003c|-- Devil\rSlime: fly() cannot fly\rZombie: fly() cannot fly\rSkeleton: fly() cannot fly\rThief: fly() cannot fly\rGhost: fly() just floating\r更可怕的還在後頭，我們再假設幾種遊戲改版後的不同情節：\n新增怪物「黑暗法師」，可以施展魔法，使得原本無法飛行的怪物都能飛行 新增「重力魔法」，原本可以無限制飛行的怪物，現在都會受到一定程度的影響 新增怪物「食屍鬼」，可以藉由啃食不同的怪物，以獲得不同的特殊能力 現在高等級的惡魔會隨著血量的變化，可以強化自身例如飛行、幽靈化 \u0026hellip; 等不同屬性 因此，在這樣的環境下，策略模式就誕生了：\n雖然沒辦法給出很精確的定義，但策略模式的概念大致如下：\n策略模式 策略模式將某個「方法」定義成了一群「算法類別」 算法類別包含一個「基底類別」和許多個「衍生類別」 物件宣告該方法時，只需宣告基底類別 物件不需要知道該方法實際上是由哪一個衍生類別實作而成 可以根據不同的情況，抽換不同的衍生類別 classDiagram\rclass Monster {\rint hp\rFly* f;\rPassThrough* p;\rBuff* b;\r+void fly() call f\r+void passThrough() call p\r+void selfBuff() call b\r}\rclass Fly\rFly \u003c|-- CannotFly\rFly \u003c|-- JustFloating\rFly \u003c|-- FlyAlways\rMonster \u003c|-- Slime\rMonster \u003c|-- Ghost\rMonster \u003c|-- Devil\rSlime: *f = CannotFly\rSlime: *p = impenetrable\rSlime: *b = NoBuff\rGhost: *f = JustFloating\rGhost: *p = Penetrable\rGhost: *b = NoBuff\rDevil: *f = FlyAlways\rDevil: *p = impenetrable\rDevil: *b = NoBuff\rclassDiagram\rclass PassThrough\rPassThrough \u003c|-- Penetrable\rPassThrough \u003c|-- impenetrable\rclass Buff\rBuff \u003c|-- NoBuff\rBuff \u003c|-- AttackIncreace\rBuff \u003c|-- Flyable\r透過類似於上述 UML 圖的方法，我們可以先把怪物的不同行為（fly(), passThrough(), selfBuff()）定義成不同的基礎類別（class Fly, class PassThrough, class Buff），分別由不同的參數指向（f, p, b）。這樣一來，我們就做到了以下的幾點好處：\n降低程式的重複性 當今天我們遇到許多怪物都有著相同的行為時，例如史萊姆、骷髏、和殭屍都不會飛，我們不再需要將重複的程式碼寫入每一個怪物的身上，我們只需要讓所有不會飛的怪物去持有一個「無法飛行」的物件（Fly *f = new CannotFly()），就可以讓所有的怪物都達成一致的動作了。不再需要把大.筆.大.筆.的.行.為.塞進每.一.個.怪物的函數裡面。\n簡易的擴充與替換 因為現在所有的「飛行」類別都被包裝起來，怪物只需要「持有其中一種飛行的類別」就可以掌握類別中的飛行功能，因此如果我們要把「怪物的飛行行為改成【無法飛行】」，就只需要簡單的 monster -\u0026gt; f = new CannotFly() 就可以了，同時，這樣的寫法可以做到「先新增一些飛行的方法，但先不要把這些方法套用在任何怪物上面」這件事情。也就表示程式擁有著更大的彈性、擁有更多修補或調整的空間。\n鬆耦合 原本所有的怪物都會需要寫明各種函數（例如　fly()），因此如果我們要達成「被重力魔法打到之後，就會失去飛行能力」這件事情時，就需要先去檢查所有的怪物類別，並把所有原本會飛行的怪物都加上類似的判斷條件，才有辦法達成上述的行為。這也就代表「怪物」跟「控制能不能飛」這兩件事情是耦合在一起的。但我們現在只讓怪物拿著一個參數 f，並透過 f 去修改 fly() 的行為，這表示現在「怪物」跟「控制能不能飛」這兩件事情被分開來處理了，也意味著程式有著更鬆耦合的屬性。\n// Using the strategy pattern to control the flying behavior of the monster. monster.fly = new AlwaysFly(); ... while(in_battle(hero, monster)) { ... if(monster.being_attacked_by(gravity_magic)) { if(hero.tatus == week) monster.fly = new TemporarilyCannotFly(round: 3); else monster.fly = new CannotFly(); } } "},{"id":42,"href":"/docs/_trash/template_method_pattern/","title":"模板方法模式（Template Method Pattern）","section":"Trash","content":"\r模板方法模式（Template Method Pattern）\r#\r說明 ChatGPT：模板方法模式（Template Method Pattern）是一種行為型設計模式，該模式會定義一個「包含一個或多個抽象方法」的抽象類別，並定義一個操作這些方法的框架。該框架包含了一組預先定義的步驟，其中某些步驟由類別內部的原方法進行實作，其餘步驟則設定為允許重寫，並由繼承該類別的子類別負責實現步驟細節。模板方法將這些步驟按照特定的順序組合在一起，進而形成一個完整的操作流程。它提供了一種通用的模板，可以在不同的情境下重複使用，同時保持算法的一致性。這種模式可以幫助開發人員實現共享的行為和結構，同時提供了彈性和可定制性。\n維基百科：模板方法模式是一種行為設計模型和設計模式。模板方法（Template Method）是一個定義在父類別的方法，負責處理框架、流程、演算法的不變部分。模板方法會呼叫多個定義在父類別的其他工具方法（Helper Method），這些方法有些是演算法的可變部分（只是抽象方法並沒有實作），有些已經有一些預設的方法細節。模板方法僅決定這些工具方法的執行順序，但工具方法的執行細節不一定全由父類別實現，有些市由子類別負責實作，並且子類別不允許覆蓋模板方法（即不能重寫方法的執行順序）。\n定義了一個模板方法，用以定義一個完整步驟的執行順序 模板方法中會套用許多的工具方法 工具方法可由父類別實作 工具方法也可以由子類別改寫 子類別僅可改寫工具方法，不可以改寫模板方法 UML Graphic classDiagram\rclass Battle {\rRole[] players\rMonster[] enemies\rFINAL void figsht(); cannot override\rFINAL void initializeFight(); cannot override\rint attack();\rbool endFight();\r}\rnote \"FINAL void fight() {\\n　initializeFight();\\n　while(not endFight()) {\\n　players.attack(enemies);\\n　enemies.attack(players)\\n　}\\n}\"\rclass NormalBattle {\rbool endFight() can escape\r}\rclass SpecialBattle {\rvoid initializeFight() hp - 50%\rbool endFight() cannot escape\r}\rclass BossBattle {\rbool endFight() cannot ecsape\rint attack() boss can attack twice\r}\rBattle \u003c|-- NormalBattle\rBattle \u003c|-- SpecialBattle\rBattle \u003c|-- BossBattle\r舉例 假設我們需要實作一個回合制 RGP 遊戲的戰鬥流程，根據遭遇到的怪物不同，遊戲內分別會有普通戰鬥、特殊戰鬥、與 Boss 戰三種不同的戰鬥模式。模板模式方法告訴了我們「與其在所有的戰鬥裡面都寫上相同的程式，不如先定義一個【戰鬥】的類別，再在【戰鬥】內定義一個方法 fight()，並將其他戰鬥模式宣告成類別，繼承此【戰鬥】即可。」透過一個名為 fight() 的模板方法，讓其他的子類別，根據這個方法進行操作與細節呈現，就是模板方法模式想要訴說的內容。\nclass Battle { Role[] players Monster[] enemies final void fight() { initializeFight(); while(!endFight()) { players.attack(enemies); enemies.attack(players); } } }; 在這個例子裡，父類別就是 Battle（戰鬥類別），子類別就是 NormalBattle（普通戰鬥）, SpecialBattle（特殊戰鬥）,和 BossBattle（Boss 戰），父類別的模板方法就是 fight()，也就是大家要大致依循的規則。工具方法則是包含像 initializeFight(), attack(), endFight() \u0026hellip; 等不同的方法。由此可見，模板方法 fight() 它定義與在乎的，僅僅是「fight 的流程」，先做戰鬥初始化、接著進入戰鬥，然後戰鬥的方式是角色打怪物一次，怪物打角色一次，然後判斷戰鬥是否結束\u0026hellip;。\n至於如何初始化（背景、遊戲音效、過場動畫\u0026hellip;等）？戰鬥的細節是什麼（攻擊方式、傷害判定、迴避與否、屬性剋制\u0026hellip;等）？結束戰鬥的條件又是哪些（可不可以逃跑、允不允許降伏、一定要血量見底\u0026hellip;等）？就不是模板方法所考慮的範圍了。可以簡單一點，全部下放給子類別（普通戰鬥、Boss戰\u0026hellip;等）進行細節實作，也可以先在類別內部自己定義幾個工具方法，等子類對方法有意見的時候，再讓子類自己覆寫其工具方法即可。\n模板方法的核心想法是「控制某些程式的步驟，但不控制這些步驟實際的做法。」除了上述的 RPG 遊戲範例之外，如果我們今天有一個【工廠】的類別，裡面有一個【工作】的方法，我們可以先在這個【工作】寫上「選擇供應商、價格談判、進貨、庫存管理、物流安排、出貨運輸、交貨、更新庫存」至於要如何選擇供應商？如何談判？進或與庫存該怎麼配合？出貨到交貨的流程鑰怎麼檢查\u0026hellip; 等，就下放到子類別進行細節實作，或者先定義一個大概的工具方法，在讓比較特別的子類別，針對某些工具方法進行改寫。\n或者是我們有一個【選擇第 n 小的元素】的方法，裡面只寫上先【排序】、再【挑選】這兩個步驟，這樣【選擇第 n 小的元素】也算是一個模板方法。因為它同樣只定義了一個「演算法的框架與流程」，但沒有實際講明所有的細節該如何呈現，排序有選擇排序、插入排序、泡沫排序、快速排序\u0026hellip;等，挑選也可以順著挑、逆著挑、二分搜尋、或用其他方式挑選\u0026hellip;等。這種在一定的程度上給予子類一些規範，限制演算法的框架必須照著某些流程，但在另一方面又給予子類一些彈性，將演算法中的部分實作內容，下放給子類進行改寫，就是模板方法模式所要呈現的設計模式。\n小結 策略模式的優點：\n保持各種操作流程的一致 降低重複程式的撰寫 易擴展、方便程式重複使用 提高程式的彈性、可讀性、替換性 策略模式的缺點：\n限制了部分的程式創作彈性 增加程式的複雜性 在某些語言（ex. JAVA）可能會受到單一繼承的限制 "},{"id":43,"href":"/docs/_trash/flyweight_pattern/","title":"享元模式（Flyweight Pattern）","section":"Trash","content":"\r享元模式（Flyweight Pattern）\r#\r說明 ChatGPT：享元模式（Flyweight Pattern），也稱為輕量級模式，是一種結構型設計模式。它旨在最小化共享物件的數量，以減少記憶體佔用和提高性能。享元模式通過共享具有相同內部狀態的物件，將大量細粒度的物件轉換為少數可共用的共享物件。在享元模式中，每一個物件都分別擁有兩種狀態：內部狀態和外部狀態。內部狀態是物件的固定部分，它可以被多個物件共享。而外部狀態則是物件本身的變化部分，每個物件都有自己的外部狀態。享元模式的核心思想是將內部狀態和外部狀態分開處理，從而節省記憶體和其他資源。享元模式的主要目的是將具有相同內部狀態的物件共享，從而減少記憶體的使用和對象創建的開銷。\n維基百科：享元模式（英語：Flyweight Pattern）是一種軟體設計模式。它使用物件用來儘可能減少記憶體使用量；於相似物件中分享儘可能多的資訊。此法適用於大量物件近乎以重複方式存在，因而使用到大量記憶體的時候。通常物件中的部分狀態（state）能夠共享。常見做法是把它們放在資料結構外部，當需要使用時再將它們傳遞給享元。典型的享元模式的例子為文書處理器中以圖形結構來表示字符。一個做法是，每個字形有其字型外觀、顏色、和其它格式資訊，但這會使每個字符就耗用上千位元組。因此，取代的做法會是：將每個字符參照到一個共享的字形物件，此物件會被其它有共同特質的字符所分享；只有每個字符（文件中或頁面中）的位置才需要另外儲存。\n將一個物件的屬性區分為「內部狀態」和「外部狀態」 統一參照所有此物件的內部狀態 物件本身只需要儲存其外部狀態的資訊 用以減少大量記憶體和資源消耗 "},{"id":44,"href":"/docs/daily_life/notes/xinxinmota/","title":"新新魔塔 v2.6.6","section":"日常札記","content":"\r新新魔塔 v2.6.6\r#\r前言 印象中第一次接觸到「魔塔」系列的遊戲，大概是在小學三四年級左右吧？那時候我還蠻喜歡到玩一些 flash 小遊戲，那時候比較有名的平台大概有史萊姆的第一個家、遊戲桃、y8、遊戲天堂\u0026hellip;等等。玩過的遊戲不算少？比較有名的大概就是越南大戰、電眼美女、麻將系列 \u0026hellip;等等，還記得那時候第一次玩遊戲天堂裡面的三國麻將，不知道它是打清章的規則，一直想說「遊戲是不是出問題了？怎麼明明能『胡』的，但是遊戲就沒有辦法『胡』」XD。此外，魔塔系列也是我小時候裡面很喜歡玩得遊戲之一。\n第一次接觸到魔塔系列的遊戲，是某一天在遊戲天堂裡找到的瘋狂魔塔。總之就是一個爬塔遊戲，越上層怪物的攻擊、防禦、跟血量都會變多。但除了層數很多之外（有 50 層），遊戲的難度整體不大。除了怪物體質沒有到很極端之外，遊戲裡最大的特點是「打怪不會扣血量」這項設定，所以整個爬塔過程與其說是在「冒險解謎」，不如說它其實是一款「爬塔體驗、模組觀賞」的遊戲。整體來說，在第一次爬塔的過程蠻好玩的，但後續的體驗可能就會隨著通關次數的提升而有所下降了，畢竟爬塔的遊戲就是通關了再照同樣的公式走也能通關。\n難易度：★☆☆☆☆ 遊戲性：★★☆☆☆ （會隨著通關次數的增加而遞減） 後來，在遊戲天堂裡面出了一個新的魔塔遊戲，叫做新版魔塔，整體的難易度一下提昇了不少。除了血量需要精算之外，各種攻擊力、防禦力的數值也必須要把控的相當細膩，才有可能通關，有時候甚至要在某個時期存到 1000+ 以上的金錢，再一口氣做攻防的調配才有可能順利爬下去。跟上一版只要無腦加攻的瘋狂魔塔實在是有著完完全全地天壤之別。也因為有著複雜的攻防計算，加上遊戲中期以後有 3-4 條不同的分支玩法（後面會說），遊戲性一下子提升了不少，但也因為難度大幅上修的原因，小時候的我一次都沒有完全破關就是了。對於有自虐傾向挑戰精神的人，很適合至少玩過一次。也因為極高的難易度，小時候的我在嘗試了幾次之後，就沒有再點開這個遊戲了。\n難易度：★★★★★★★★★★★★★★★ 遊戲性：★★★★★ 之後過了好久好久，到了碩二口試前的大概\u0026hellip;一個月左右吧？在一次跟朋友的閒聊中，這個遊戲無意間又被其中一個人給提出來了。很意外地，研究室裡大部分的朋友都有玩過這個遊戲，而且清一色地都給出了「小時候覺得很好玩」「遊戲超級難」「從來都沒有破關過」這三條口供。因此，在碩士生症候群與好奇心的驅使下，我們就又重新地打開了這個遊戲\u0026hellip;\n我們玩的版本是再新一點的新新魔塔，除了因為是後幾年推出的版本，因此動畫、音效、與視覺感受都有著更新之外，基本上玩法，玩家的初始狀態，怪物的攻防、數量、和分佈\u0026hellip;等都是跟新版魔塔一樣的，唯一一個最大的差別是新版魔塔提供了「極速模式」，主要支援「一鍵到位（省去步行的動畫）」、「快速樓層移動（省去冗長的上下樓梯）」、與「即時戰鬥（用數學的方式直接計算傷害總量，省去單回合的戰鬥過程）」三種功能。算是大大地提升了遊戲的體驗和縮短遊玩時間。\n遊戲說明 《新新魔塔》，原名《魔塔》，被稱為 \u0026ldquo;三原塔\u0026quot;之一，是一款基於 Flash 製作的經典魔塔作品，由 cos105hk 於 2005 年製作完成並發布。《新新魔塔》的素材、核心玩法\u0026hellip;等都來自於原日文版魔塔《魔法の塔》（The Tower of Sorcerer）。與傳統魔塔相比，最大的特點是不具備 \u0026ldquo;完全重複性\u0026rdquo;（玩家和怪物的攻擊都有機率造成爆擊或被閃避），它也是 \u0026ldquo;三原塔\u0026rdquo; 中機制最複雜、最具有挑戰性的作品。其獨特的機制、優秀的戰鬥動畫\u0026hellip;等，都為後人創作魔塔作品留下了深遠的影響\u0026hellip; （出自《新新魔塔》中的 \u0026ldquo;遊戲說明\u0026rdquo;）\n遊戲劇情簡單來說，就是一個「勇者打敗魔王，救出公主」的故事。玩家要透過所扮演的角色（也就是勇者），在魔塔的各個樓層之間闖蕩、賺取金幣、獲得經驗、提升攻擊力與防禦力，一路過關斬將，最後打敗魔王，來完成整個遊戲。（然後，再來就是防雷警告了，接下來會有一點遊戲的劇透，如果想要自己嘗試看看的話，就不要再往下看了。劇透警告！）\n劇透警告 劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！\n遊戲階段 遊戲主要分為 2 個階段，第 1 個階段是『假公主階段』，主要的活動範圍會是在魔塔的 1-20 層。可以從一樓老人口中的「聽說魔塔不只 20 層，但最高只能到 20 層。」發現一些端倪。這時候勇者的目標，是要打敗 1-19 層的種種怪物，並嘗試走到 20 樓與「公主」見面。但等到勇者一與 20 樓的公主說話之後，便會發現她其實是怪物所變化而成的，玩家需要打敗這個怪物，並找到真正的公主。\n接下來會進入到一個小小的「過門」：玩家在打敗 20 層的假公主之後，會從假公主身上拿到一個小偷的十字稿。我們需要回到 2 樓與小偷對話，讓他去第 0 層打開「往下的門」向下探索。待走到地下 2 樓的時候，再跟精靈說話，祂會要你去打敗 15 層的大章魚，並從章魚後方的樓梯一路走到 17 樓，從 17 樓進入真正的『魔塔』。然後玩家要一路往上到魔塔 5 樓，領取其中一個『紋章』。再之後，打敗鏡像的自己，回到地下 2 樓與精靈對話，開啟更下層的空間，進入到「第二階段」，開始繼續爬塔 \u0026hellip;\n第二階段共有 25 層（也就是 B1 ~ B25），分為普通樓層、岩漿樓層、中毒虛弱樓層、和王關。普通樓層就跟前面的第 1 階段一樣，也是打打怪、拿拿錢、升升攻防、一路挑戰。岩漿樓層會從第 7-8 層開始。樓層的地面會出現溢出來的岩漿，如果玩家踩上去就會扣血。所以從這邊開始，數學的運算會更加複雜，跳樓層的工具不再變得無腦的有用（有時候重逛樓層，就會重新踩到岩漿）；中毒虛弱樓層則會在地下 20+ 的地方出現，玩家在打敗這些怪物之後，會分別獲得「中毒」與「虛弱」兩種屬性（不會疊加，會覆蓋。）「中毒」會讓玩家每走一步都扣血、「虛弱」則會讓玩家整體的攻防一一定的數值或比例降低。需要透過解藥才能回復正常。最後是王關，在 B25，但沒啥特別的，A 死他、救出真公主，遊戲就結束了。\n紋章 在「過門」的環節中，玩家在進入魔塔 5 樓的時候，會有 3 可選的不同紋章，由左至右分別是「賢者之紋」「霸者之紋」和「勇者之紋」。3 種紋章各自可以給主角不同的能力，但需要先去 14F 找左上角的老人鑑定後開啟。賢者之紋在鑑定之後，玩家會穿上黃色盔甲。它可以讓你在面對到 \u0026ldquo;怪的攻擊力，比你的防禦力還低\u0026rdquo; 也就是 monster.atk \u0026lt; you.def 的敵人的時候，有機率加血；霸者之紋在鑑定之後，玩家會穿上黑色盔甲。可以讓你在面對到 \u0026ldquo;非法師系的敵人\u0026rdquo; 的時候，反彈怪物給你的攻擊傷害；勇者之紋則是在鑑定之後，會讓玩家穿上紅色盔甲。勇者之紋可以提高玩家的爆擊機率（傷害 2 倍）、以及單回合進行多次攻擊。\n體感下來，紋章的破關難易度是：賢者 \u0026lt; 勇者 \u0026lt; \u0026lt; \u0026lt; 霸者之紋。賢者可以理解成近乎無腦地疊防禦力即可通關；勇者則是注意攻防的數字不要差太多，在 1120 之前防高攻一點點 (小於 5)， 1120 之後無腦疊攻就可以過；霸者則是到現在為止，都沒有找到一個可以用 1-2 句話就講完通關心法的一個紋章 \u0026hellip;，必須得說是真滴很難 \u0026hellip;。但霸者並不是最難通關的遊戲玩法。還有一種方法叫無章通關（或無證通關），指的是在拿到任一紋章之後，不要去找 14F 的老人鑑定和解鎖能力，就這樣直接一路打到遊戲通關，那個真的是百星的地獄難度，難到我現在就連一次都沒有嘗試過 XD。\n心得 總而言之，這款遊戲我個人還蠻推薦玩的，至少嘗試全破一次，不用每個能力都體會過，相信你也可以得到一些不錯的遊戲體驗。但還是得再說一次：遊戲的難度在「不看攻略」的前提下，是真的非常非常之大，建議遊玩時還是要有心理準備，不要讓自己太過抑鬱或者是太過沈迷 XD，除此之外，應該就沒什麼特別想講的了。\n最後，附上一個各紋章的通關結算來結束這回合：\n"},{"id":45,"href":"/docs/daily_life/notes/heart_sutra_beforehand/","title":"一千份的手抄心經","section":"日常札記","content":"\r一千份的手抄心經\r#\r前言 2020 年 10 月 24 日是我開始抄心經的第一天。那時候因為生活上遇到了一點困難，所以想要試著尋求一些神佛和心靈上的安慰。雖然在此之前，我就算是一個篇迷信的「宗教狂熱者」（畢竟身邊點的最歪但也點的最完整的技能樹是『算命』），平常有事沒空就會去拜拜（最密集的時候大概一個禮拜會去個 1-2 次吧？），平常沒事就看點宗教學的書、研究研究塔羅、八字、紫微斗數、古典占星\u0026hellip;等等。但一直以來其實並沒有抄經（或者是唸經）的習慣，一方面是那時候『抄經』對我來說很繁瑣也很花時間，另一方面是自己真的沒有什麼特別想要做這件事的緣由。也就沒有把這項技能給「點起來」了。\n不過後來生活上發生了點意外，說的細節一點是跟感情有關。這時候「會算命」倒也變成了一種比較麻煩的事情：因為你自己會透過一些占卜之類的方法，不斷地、不斷地、不斷地、不斷地、不斷地、不斷地、不斷地去尋求一些答案。雖然平常的時候總會把「迷信迷信，迷而不信」掛在嘴邊，但在那時候我反倒是便成了最迷的那一個。除此之外，我也嘗試過花一些錢，買一些傳聞中的開運產品、桃花手鍊\u0026hellip;等迷信小物。（一條手鍊可以賣到 5200 欸超扯），但想當然的，後來的功效如果不是「完全沒有」，就只能用「微乎其微」來形容了。\n也大概是在那個時候，我開始接觸到「經文」這一類的東西\n一開始是配合著開運手鍊賣家的建議，可以嘗試每天抄抄，抄完之後順便許願 + 迴向。據她所說，只要有穩定的在進行的話，大概 100 天左右之後就會有不錯的結果吧？抄的經文是最大眾的「般若波羅密多心經」，全文只有 260 字，加上標題跟標點符號大概 300 上下。一開始那個姊姊是說「抄完之後要在口唸（或默念）三次補闕真言才算完成。」但因為心經的部分我自己是用 400 字的稿紙抄寫，所以後來索性就直接把箴言給補在稿紙的後面了（畢竟空間夠）。然後傳聞中的 100 天有效嘛 \u0026hellip; 這個就見仁見智了，我猜我應該是不夠虔誠 XD\n抄經（馬步期） 最一開始的前兩個月，因為自己並沒有背誦過心經的全文，所以都是抄個 5-10 個字，就要看一次手機，然後再抄個 5-10 個字，再看一次手機，算是抄經的「馬步期」。老實說算是個挺特別的經歷。或許是心理因素？又或者是真有其事？我自己在反覆查閱跟書寫的過程中，是真的可以感受到那種「體悟心靈祥和」的感覺，準確來說，有點類似「煩惱在抄寫的當下都會被全部丟掉」的感覺，但就只有「抄寫的當下」就是了，抄前抄後不順的心情還是會有，哈哈哈哈！\n除此之外，我大概也是從這個時期開始，養成每天跑 3000 公尺的生活習慣（雖然這習慣在堅持近一年之後就斷掉了）。那時候的 3000 公尺成績，最好最好可以到大約 13:40 左右吧？以一個 \u0026ldquo;資工肥宅\u0026rdquo; 來說，我猜也是個很好的成績 XD。總而言之，這兩個習慣（抄經 + 跑步）的培養與維持，雖然沒有讓我「獲得桃花手鍊所期待的功效」，但也讓我對於之後「回歸平常」的心境起到了不小的功用。\n之後大概就是穩定的維持抄經的習慣，需要看手機的次數越來越少、背誦的熟練度也越來越高，每天 1 份、每週 7 份、每個月約 30 份，這種日復一日的工作（沒錯，在這時候對我來說已經算是工作了），大概也維持了 4-500 天有。這期間的心理開始不會感受到最純粹的「體悟心靈祥和」。我自己用科學上的解釋的話 \u0026hellip;因為一開始並不會背誦，所以心裡必須要一直「照見五蘊皆空，度一切苦厄 \u0026hellip;」之類的一直唸一直唸，心裡沒有辦法塞其他的東西進來。所以才會有那種極度專注真極度禪學的感覺。\n抄經（築基期） 但自從我開始熟稔了之後，就會開始想東想西了。但這邊也有挺神奇的事情：就是雖然在「築基期」（開始累積經文手本的時期）裡會有一些「雜念」，但這些唸投多半也是跟自己本身有關，像是「等等要吃什麼？」「等等程式要怎麼寫？」「畢業專題的那個進度可不可以用 xx 試試看？」\u0026hellip;等等的。「我在感情上有沒有辦法 \u0026hellip;」這樣的念頭可以說是完全沒有（或者有，但微乎其微到我忘記了）。這或許也是冥冥之中神明對我的引導吧？我不確定，但我自己是蠻樂意這樣解釋的，或單純思考成「運氣超好，從來都沒想過『感情』的事情」也行～\n在這段時期，我也會配合一些「白噪音」來進行抄經的活動，通常是 youtube 那種長時數的雨聲、燒柴、缽音，有時候也會是吉他、頻率音段，在那時候 podcast 也剛紅起來，我也有廳類似股癌、百靈果之類的節目來配合抄寫過。總之就不是那種最原汁原味的「全神貫注地抄經」了（這也是我開頭會說我不構虔誠的原因）。\n這段時間除了把「抄經」當作工作之外，因為會在抄經同時，接收到很多其他方面的資訊，像是股癌的節目是財經相關（所以在那之後也開始買了股票）、百靈果會找超多不同的人做專訪（所以會知道各方個面的冷知識），身心靈相關的 Ruowen Huang、Star seed soul，也會在抄經的途中，學點新的算命技巧，像是紫微斗數、八字 \u0026hellip;等等，總的來說，因為「抄經必須要坐在書桌前面一段時間」的這個原因，我算是半強迫的讓自己學了很多新的知識，築基期帶給我的幫助大概就在這裡吧。\n抄經（滑落期） 再後來的後來（莫約 1 年到 1 年半前）我斷掉每天抄經的工作了。主要的原因有兩個：第一個原因是『枯燥』。這蠻好理解的，畢竟就是日復一日地做著一模一樣的工作，在「耐煩、耐繁、耐凡」的三個步驟上，我還是在耐繁的地方上被擊倒了。第二個原因是我開始意識到『抄經沒辦法達成我所期望的感情』這件事情。其實到大概這個時期開始，這個原因比較像是次要的因素，或者是壓垮駱駝的小稻草。因為我畢竟還算是個稍微懂數學的人，「從某一天開始往後算 100 天」這件事情對我來說實在不算是個多年的事情，因此主要的原因還是在第一點身上。\n斷更（？）的那時候，老實說有稍微比較輕鬆，畢竟就是少掉一個「不做也不會扣錢的工作」，但比起這個久違的「舒適感」，「不安感」倒是在心中蔓延的更加快速。也許是「習慣」、也許是「被神明催更」、也或許是其他原因 \u0026hellip;我不知道？總之大概在斷更了 1 個月之後，「重新抄經吧」的念頭開始由下而上地席捲到我的全身，這次的「小斷更」僅僅維持 1-2 個月左右就結束了。\n後來還有一次「大斷更」。是在我剛升碩一的時候（也就是 2021/09 附近），忘記是什麼原因了？總之那時近乎 4-6 個月的時間，我連 1 次的提筆都沒有提起來過。與前一次的小斷更一樣，大斷更的時期並沒有讓我過得比較輕鬆、比較愜意。反倒是不安感在前 1-2 個月的浮現之後，在過後又慢慢地沉下去了。這也是為什麼這次的斷更我會「沉淪」得比較久的原因。後來又重新拾起這份工作的原因，主要應該可以歸功於兩位人物，分別是 龍德法師、和準提佛母。\n抄經（回復期） 龍德法師應該是我一個國中同學的\u0026hellip;師父？她從國中就開始吃素，所以我猜她在某種程度上應該也跟我一樣（甚至更甚於我？）算是個「宗教狂熱份子」。也許是她有看到我在經營算命的事業？又或許是其他的因緣或巧合？總之在碩一的某一天，她突然和我分享了關於這位法師的一些訊息，大多是 YouTube 的影片，有時候也會是一些活動或者是聚會之類的文宣與邀約。我也從她那裡拿到了一些相關的書籍（藏傳佛教的書ㄟ，讚啦）\n那個法師影響到最重要的地方是【抄經可以進行迴向給各種人】這件事情。老實說直到現在（2023/08）我還是不知道什麼是【迴向】？對我來說她大概就是一個祈禱跟許願之類的動作。在抄經的最一開始，其實我也會做迴向，但大部分都是迴向什麼\u0026hellip;「希望感情可以一帆風順」「希望可以開花結果」之類的東西。基本上主體都是以『我』做為出發點。但從我的解讀上（就是我看了一些該法師的 TY 影片得出來的結論），迴向除了跟祈禱和許願很像之外，它最有趣的功能是「可以幫『某個對象』累積福報。」\n這個「某個對象」可以是任何人，包含（但不限於）家人、同儕、師長、另一半、只見過幾次面的人、明星偶像、冤親債主\u0026hellip;等。但可以的話要「指定」，不要許願說「我要把福報回想給這世界上的所有人」這種比較空泛的話。這算是重新勾起我想要持續抄經的第一個引線。因為我說到底，也算是一個迷信的人，我的內心深處其實一直有一個「我的感情會不好，一定是我前幾輩子做了跟感情有關的壞事，現在才會這樣」的這種感覺。那在這個感覺的前提下，「抄經可以迴向」\u0026gt;「迴向可以迴向給之前乾我的感情有不好結果的人」\u0026gt;「我要抄經」這樣的線就被重新拉起來了。\n另外，準提佛母 則是拉起我的第二條引線。準提佛母據維基百科的說法，是一個類似於菩薩的角色。但細節我其實也不是很清楚，總之我就直接把祂視為是一個「神明」這樣。在我的宗教觀裡面，世界上應該是有很多準提佛母的（就像是大街小巷都有乩童可以讓濟公降駕的那種感覺），這點我之後可能也會寫一篇關於我的宗教觀的文章來做闡述。Anyway~ 總之！我遇到的準提佛母是一個可以問事的佛母，我找佛母預約過一次，可能是心理作祟的原因，但老實說挺有感的。\n這個「問事」的經歷重新讓我勾起了「我相信世界上有神明」和「人在做，天在看」這兩個我自己的信仰依據。「因為世上有神明」\u0026gt;「我要抄經，把福報迴向給更多人」\u0026gt;「善有善報，我會變得更好」\u0026gt;「我要抄經」這樣的順序，就重新勾起我想要抄經的慾望與動力了。也在這之後，我就開始重新進行每日一抄的工作了。\n抄經（趕進度） 重新抄經的工作主要有兩個，第一個是「穩定的在每天推一個進度」，另外一個是「把過去沒有補好的給補回來」。老實說『補回來』的工作真的是極度心累 \u0026hellip;。過程之中大概有不下 10 次（真的有超過 10 次）內心的自己跟自己說「算了喇，就從頭開始啦，中間的不要補了」的這種想法。也因此，大概在去年上半年（約 2022/04）開始？原本預期的「填補進度」是一天 2-3 篇，所以會在 2022 年 10 月左右完成補齊。但因為少的真的太多了 \u0026hellip;（近 200 篇的缺額），所以在後來一直都是保持著「最低最低 1 天要有 1 篇」的心理期待在填補。\n然後也有些日子有填、有些日子沒填、甚至有些日子繼續偷懶的生活著。預計的「完工時間」也從原本的「10 月」拖到「跨年前」，然後是「過年前」「5 月前」「放暑假前」到最近的「口試前」整整多了近 1 年的工作時間 XD。但最後還是很巧合地，在我口試的當天（2023/07/26）補齊了包含當天以前的全部經文，不過後來馬上幫自己排了一個 3 天的日本行啦，所以後來又有點小延宕，大概到 8/4 左右才算是真正的「一天不漏」。\n此外，預想到「今年年底打算服掉 4 個月的義務役」，現在的我則是開始了「預先抄寫」的工作了 XD。畢竟之後會有近 120 天無法書寫的日子，如果那些空缺全部要在當兵完之後再補的話，又會超級延宕的了。還是在現在趕快先補一些會比較好。但總之，從我第一天開始提筆之後，到了今天為止，已.經.寫.了. 1000. 份.的.經.文.了。這也算是一個人生中的小小成就吧？所以就寫了這篇文稍微記錄一下。\n後記（心得） 整體而言，「抄經」算是我的個蠻開心可以培養起來的興趣。雖然我上面是「工作」「工作」的稱呼著，但我相信我內心應該是有著「抄經可以幫到其他的人」這訊息，而在努力的「工作」著的。希望之後的我可以持續維持這一個「興趣」，也期待未來的我真的能夠因為「抄經」這件事情而幫助到別人，也幫助到我自己。那就這樣啦。以上～\n"},{"id":46,"href":"/docs/daily_life/notes/osaka_3_days/","title":"日本旅行 7 萬步","section":"日常札記","content":"\r日本旅行 7 萬步\r#\r前言 記得人生中，第 1 次出國旅遊大概是在上幼稚園的時候。那時候去了 10 天的中國，是跟阿公阿嬤還有其他的家族長輩一起去的。整體來說已經沒甚麼印象了，但隱約記得看過萬里長城、紫禁城（印象中超大的）、好像還有張家界？跟樂山大佛。第二次出國是在我小 2 的時候，那時候是暑假去了兩個月的菲律賓語言學校。算是表哥他們一起去的（表哥一家是台菲混血）。再後來的話\u0026hellip; 就沒有出國玩的印象了。一方面是因為後來主要都在拚學業，寒暑假都是補習班跑，另一方便自己也開始養成了「待在家好像也不錯？」的宅屬性，所以就一直待在台灣了。直到上個禮拜，近 20 年後的「出國旅遊」才又被我重新提起。\n這次的行程是去日本，總共 3 天，但是是第一天凌晨到日本，第三天 10 點的班機，所以嚴格來說，算是只有兩天半的遊玩時間。去的人只有我跟我妹兩個，算是很輕量的人數。此外，行程有 99% 以上都是我妹排的，基本上我算是負責當一個全肯定 + 工具人 + 陪玩陪聊天的旅伴這樣（挺沒有用的，老實說 XDDD）。主要的行程都在大阪，但第 3 天有京都的和服體驗。整體來說，這趟旅程滿分 100 及格 60 的話，我會給 98 或 99。\n首日 旅行的前一天，是搭桃園機場凌晨 2 點的飛機。我們大概 11:30 左右就開始排 check in 了，直到完全通關（等上機）的時候，大概是 1 點左右？所以有近一個小時的時間可以逛免稅。但我跟我妹那時候都在找休息區補眠 XD，畢竟行程是從一下飛機就馬上開始的，因此在出境的時候，我們是沒有逛多少東西的。\n後來 2 點左右上了班機，我們搭的是樂桃航空的飛機（代號 MM），去程的乘坐體驗如果滿分 100 及格 60 的話，我會給 20-30 分。其原因在於 \u0026ldquo;幾.乎.整.趟.航.班.都.是.在.劇.烈.的.搖.晃.中.度.過.的\u0026quot;。第一次感受到完全的無力，當你面對一個「覺得隨時可能都會突然發生意外」但只能坐在椅子上等待的時候，那個背後是真的會有毛骨悚然的感覺的！但好加在，飛機最後還是在 6:20 左右順利抵達日本的關西第二航廈。\n抵達航廈之後會先走一個近 400 公尺的入境審查。在這邊也發生了一點有趣的事情：因為語言不通，加上我身上拿了兩個大行李（一個揹著、一個拖著），所以在入境審查的時候，那個審查官有大概問了我一些事情，不過因為他講的超快、加上又是說日文、以及 \u0026ldquo;他.不.管.問.什.麼，我.一.路.都.是. YES. YES. 的.回.答\u0026rdquo; 所以我大概就被當成「可能有待一些違禁品入境的外國人」被多扣了一陣子了，幸好最後還是化解了這場誤會，哈哈哈！\n接下來就是正式開始 3 天的日本行。第一天主要的原定行程有兩大項：分別是上午的「天王寺動物園」和下午的「大阪城」。不過因為一些臨時的原因，像是預期周遊券的換票時間過早（我們 6:30 下飛機，但關西機場 9 點才能換），所以我們後來決定先去大阪（8 點換周遊券），再回到天王寺放行李，最後銜接動物園的行程。算是走了一趟版和線（深黃的Ｒ）之後，再繞了一圈大阪環狀線（紅色的Ｏ）才完成對一開始的換票跟放行李。\n整體評價：★★★★☆\n簡單感想：日本的鐵路真的好發達 \u0026hellip;\n然後是動物園的行程，整體而言可以用一句話來形容：「好熱。」這 3 天的日本行一直都有這個感覺，印象中後來我們回頭看了一下那三日的平均氣溫，大概有 36.2 或 36.3 那麼高。裡面的動物多半也都是比較避暑的狀態，大家都有氣無力、或者直接躺在陰影下面睡覺。但動物的種類蠻多的！從非洲草原、熱帶雨林、寒帶動物、爬蟲類、夜行動物、鳥類、獅子老虎 \u0026hellip;等一應俱全。其中我妹最喜歡的是裡面的小貓熊，現場看是真的超可愛的！！如果是非炎熱的時間去的話，我猜應該可以得到比我們更好的觀賞體驗。\n整體評價：★★★☆☆\n簡單感想：好熱 QQ 所以動物都沒有什麼精神\n"},{"id":47,"href":"/_docs/example/collapsed/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":"\r4th Level of Menu\r#\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":48,"href":"/_docs/example/collapsed/3rd-level/","title":"3rd Level","section":"Collapsed","content":"\r3rd Level of Menu\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\r"},{"id":49,"href":"/_docs/example/hidden/","title":"Hidden","section":"Example Site","content":"\rThis page is hidden in menu\r#\rQuondam non pater est dignior ille Eurotas\r#\rLatent te facies\r#\rLorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona\r#\rO fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer),\rpad.property_data_programming.sectorBrowserPpga(dataMask, 37,\rrecycleRup));\rintellectualVaporwareUser += -5 * 4;\rtraceroute_key_upnp /= lag_optical(android.smb(thyristorTftp));\rsurge_host_golden = mca_compact_device(dual_dpi_opengl, 33,\rcommerce_add_ppc);\rif (lun_ipv) {\rverticalExtranet(1, thumbnail_ttl, 3);\rbar_graphics_jpeg(chipset - sector_xmp_beta);\r}\rFronde cetera dextrae sequens pennis voce muneris\r#\rActa cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software;\rif (internic \u0026gt; disk) {\remoticonLockCron += 37 + bps - 4;\rwan_ansi_honeypot.cardGigaflops = artificialStorageCgi;\rsimplex -= downloadAccess;\r}\rvar volumeHardeningAndroid = pixel + tftp + onProcessorUnmount;\rsector(memory(firewire + interlaced, wired)); "},{"id":50,"href":"/_docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":"\rButtons\r#\rButtons are styled links that can lead to local page or external link.\nExample\r#\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home\rContribute\r"},{"id":51,"href":"/_docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":"\rColumns\r#\rColumns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example\r#\rLeft Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\rMid Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\rRight Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\r"},{"id":52,"href":"/_docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":"\rDetails\r#\rDetails shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample\r#\r{{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\r"},{"id":53,"href":"/_docs/shortcodes/expand/","title":"Expand","section":"Shortcodes","content":"\rExpand\r#\rExpand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample\r#\rDefault\r#\r{{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Expand\r↕\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\rWith Custom Label\r#\r{{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Custom Label\r...\rMarkdown content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\r"},{"id":54,"href":"/_docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":"\rHints\r#\rHint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example\r#\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\r"},{"id":55,"href":"/_docs/shortcodes/katex/","title":"Katex","section":"Shortcodes","content":"\rKaTeX\r#\rKaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample\r#\r{{\u0026lt;/* katex [display] [class=\u0026#34;text-center\u0026#34;] */\u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt;/* /katex */\u0026gt;}} Display Mode Example\r#\rHere is some inline example: \\(\\pi(x)\\)\r, rendered in the same line. And below is display example, having display: block \\[\rf(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\r\\]\rText continues here.\n"},{"id":56,"href":"/_docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":"\rMermaid Chart\r#\rMermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid Initialization Config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\nExample\r#\r{{\u0026lt;/* mermaid [class=\u0026#34;text-center\u0026#34;]*/\u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u0026gt; State2 note left of State2 : This is the note to the left. {{\u0026lt;/* /mermaid */\u0026gt;}} "},{"id":57,"href":"/_docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":"\rSection\r#\rSection renders pages in section as definition list, using title and description.\nExample\r#\r{{\u0026lt; section \u0026gt;}} First Page\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\rSecond Page\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\r"},{"id":58,"href":"/_docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":"\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":59,"href":"/_docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":"\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":60,"href":"/_docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":"\rTabs\r#\rTabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example\r#\rMacOS\rMacOS\r#\rThis is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux\rLinux\r#\rThis is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows\rWindows\r#\rThis is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":61,"href":"/docs/fortune_telling/tarot/daily_log/20230813/","title":"20230813th","section":"［置頂］每日一翻","content":"\r2023/08/13 每日一翻\r#\r抽牌：寶劍八（逆）\r#\r解析：\r#\r寶劍八是寶劍系列的第 8 張牌，風屬性，代表的關鍵字是「徬徨」「猶豫」「迷茫」或者是「不安」\u0026hellip;等。在膩味的情況下可以將牌意做「相反、過度、or 不足」的理解，也就是「堅定」「決心」「屏除一切」或者是「邁進」「向前」\u0026hellip;等意思。套用在今天的狀況的話，這一張寶劍八應該是指「重新前進」的意思。\n為什麼說是重新前進呢？因為大概在 7 的時候「不小心」讓自己放了一天的假，什麼都不做的完全休息，然後之後的每一天就都『沒關係啦明天再努力吧』『沒關係啦再給自己放一天吧』\u0026hellip;這樣的過了下去。就像是寶劍八的那個女生一樣，被劍陣圍繞著（也就是被一些困難、阻礙、或者是在我這邊比較像是『偷懶的藉口』）。即使劍陣沒有完全地封住去路 \u0026hellip;\n然後直到今天，終於「逆位」了，也就是「向前邁進了」，在我這邊的話，就是意指「終於不再利用『偷懶』之類的藉口，來讓自己通散的度過一天」這樣。（今天整理了 2502 的實驗室，修好一台電腦、整理了畢業之前的文件、圖書館還書、查勤了一下精裝論文的進度、同時也寫了兩篇的 blog 文章、順便複習了一下 Matlab 的語法和程式 \u0026hellip;等）。整體來說，相較於前一個禮拜左右的虛無飄渺、荒蕪度日，今天的確算是比較充實也比較努力的一天。\n"},{"id":62,"href":"/docs/fortune_telling/tarot/daily_log/20230814/","title":"20230814th","section":"［置頂］每日一翻","content":"\r2023/08/14 每日一翻\r#\r抽牌：聖杯侍者（逆）\r#\r解析：\r#\r做為聖杯系列的宮廷牌，聖杯侍者因為屬於風屬性的「侍者」，因此它也是 4 張宮廷牌（侍者、騎士、王后、國王）裡面最為「動態」的一張牌。聖杯侍者通常的涵義可以理解為好奇、期待、點子、思考、或者是多元的想法 \u0026hellip;等。與「水之水」的聖杯王后不同，「水之風」的聖杯侍者更有那種跳躍性的、靈活的、外向與活潑的、或者是忽然的、突發奇想的、靈光一現的想法跟點子在內。也因此，聖杯侍者在人物上可以理解成發明家、哲學家、創意與企劃人才 \u0026hellip;等。\n至於逆位的聖杯侍者，就有「相反」「不足」或者「過度」的意思了。通常可以理解成想的不夠多、稍微遲鈍、或者是想太多、太過跳躍\u0026hellip;等。那套用在今天的情況的話，我會覺得這張逆位的聖杯侍者比較像是「停止思考」的一張牌，有點類似想得不夠多。因為今天比較重要的事件應該就是「來回跑了 3-4 次的加恩影印」還有「試跑了一次離校程序」這兩件事情吧？\n無論是哪一件事情，都是急需身體力行的任務，也可能是因為我「想的不夠多」所以在一些流程上面做了許多重複的事情（像是加恩可以不用跑這麼多次，如果東西都有備妥的話；或者是離校程序其實不用拖那麼久，如果我有把東西一次問清楚的話\u0026hellip;）。總而言之，今天「逆位的聖杯侍者」我覺得比較像是我「因為對事情沒有想得太過周慮，因此在流程上面出現比較繁瑣的情況」來做解釋比較類似。\n"},{"id":63,"href":"/docs/fortune_telling/tarot/daily_log/20230815/","title":"20230815th","section":"［置頂］每日一翻","content":"\r2023/08/15 每日一翻\r#\r抽牌：權杖侍者（逆）\r#\r解析：\r#\r權杖侍者，屬性火之風，是一張同時具有火風兩種比較主動、比較富有熱情、和比較動態能量的一張牌。在我一般的理解上，因為相對於騎士、王后、和國王\u0026hellip;等，侍者是屬於比較低位階的職位，因此在職務的邏輯判斷上，我會把侍者思考成類似基層、工讀生、跑腿的人 \u0026hellip; 等比較初階的職位。那在牌意的理解上，扣除掉「想法」「展望」「熱忱」和「期待」\u0026hellip;等比較偏純牌面的牌意，這裡因為是每日運勢，所以也可以理解成「今天會比較忙」「今天會比較需要跑腿」「今天會需要一直走動，但整體而言還算帶有熱情、還算開心」的那種感覺或狀態。\n但，今天的權杖侍者可不是正的。\n權杖侍者的逆位，可以簡單地理解成「權杖侍者」+「逆位」這兩種狀態來解釋。用牌意理解的話，就是「想法、期待、行動、展望」配上「過度、不足、相反」所以就是「期待落空、事倍功半」或「錯誤的期待」\u0026hellip;等訊息。那套用在今天的情境下的話，有幾個狀態可以描述這一張牌具體的一些實現和心境：首先是 重新列印的論文文本不能用，因為一些程序上的原因，所以總計 200+ 張的 A4 指在今天直接變成一大疊的廢紙。\n再來是 學校的畢業流程繁瑣，這個比較像是行政體系本身的問題，今天為了跑離校，前前後後忙了大概快一天，大概跑了 4-6 個處室的行政手續，其中有一些還會被推走，或者是說資料不足不予處理，然後也被這之中的 3-5 個人說「文件不是他們所 規.定. 的那個樣子」但又找不到任何的規定或條文，有點像是「你們必須得跟著我們這個習慣成自然的規定走才可以」的那種感覺。整體來說，今天算是極度事倍功半、消磨心力、疲於奔命的一天。希望之後的流程可以再順利一點。我大概也會花一點時間幫之後的學弟妹寫一個「畢業前的教戰手則」之類的檔案留給他們吧？希望能夠平安落幕。\n"},{"id":64,"href":"/docs/fortune_telling/tarot/daily_log/20230816/","title":"20230816th","section":"［置頂］每日一翻","content":"\r2023/08/16 每日一翻\r#\r抽牌：正義（逆）\r#\r解析：\r#\r正義牌，大阿爾克納的編號 11，舊式的塔羅也有編號為 8 的版本。主要的意思為均衡、穩定、維持、準則、固定、規章、或者是流程。也因為是大牌的一員，因此在心靈層面可以去做延伸解讀，不過要怎麼解讀\u0026hellip;基本上還是得看配牌或當下的直覺來定，一般在每日抽牌上，除非翻開的當下有什麼比較連結到的感應，不然不會對心靈層面的解釋做過度的解讀。\n那逆位的正義，就可以從「不足」「過度」或「相反」解釋，可以理解成「違背原則」「違反善良風俗」「矯枉過正」或者是「差別待遇、雙重標準」之類的意涵在裡面，今天的話 \u0026hellip;比較像是「違反規則」吧？講的簡單一點是鴿子，講的複雜一點就是「因為某些原因，所以放了朋友鴿子。」至於是什麼原因嘛\u0026hellip;在趕隔天要做的論文報告 ppt。\n跟朋友的約是前幾天約的，原本說好【晚上 8 點要算牌】，但後來雲端出了點\u0026hellip;問題(?)，原本做好的 ppt 不知道為甚麼沒有被雲端儲存起來，它存起來的只有一開始的標題頁 \u0026amp; 後面的空白簡報，所以大概在下午 6,7 點左右，趕了 5 個小時（11:42 完成），最後才把原定的進度全部完成。也因此就直接放掉我朋友算命那邊的事情了（他明天還要上班，沒辦法等我這麼久）有點感到抱歉。\n"},{"id":65,"href":"/docs/fortune_telling/tarot/daily_log/20230818/","title":"20230818th","section":"［置頂］每日一翻","content":"\r2023/08/18 每日一翻\r#\r抽牌：聖杯王后（逆）\r#\r解析：\r#\r聖杯王后，元素水之水，是在 78 張塔羅牌裡面最為感性的一張牌。一般狀態理解為「沉澱」「思考」「冥想」或者是「期盼」等意涵，基本上，把這張牌當作一個「很感性的人」或者是「很善於思考的人」是一個蠻不錯的解牌方向。在行為上通常會理解成「跟女生有關」「跟細膩的人有關」，在事物上則是水、液體、流動性的、杯子、盛載的器皿，或者是化妝品。\n在每日占卜上，聖杯王后通常可以理解成「今天會是一個相對感性的一天」「今天是個比較容易有情緒起伏的一天」或者是「今天是個比較容易想很多的一天」以及「今天是一個比較容易被一個女生影響到的一天」等訊息。通常以吉來論，但在感情上不代表有突破的進展，比較像是那種慢慢升溫，或者是慢慢變好的感覺。工作上的話則是比較容易受到照顧、保護、或者是被呵護、被承擔。\n那在我自己的體感上的話\u0026hellip;因為抽到的是「逆位」的聖杯王后，所以比較情緒上、又比較負面或過度的狀態\u0026hellip;應該是「沒有辦法在今天交出畢業的審核」這件事情吧因為要交畢業審核表的話，需要附贈一個精裝本的論文文本，然後請託印製的印刷店跟我們說預計 4 點可以取件，可以取件的當下會打電話跟我們說（系辦今天 5 點停止收件），但我們等到 4:40 都還沒有等到電話。\n然後回撥之後才發現東.西.早.就.好.了.，只是不知道為什麼沒有打電話給我們，等我們過去取件、再回來學校的時候，已經是 5 點快半了，系辦想當然的也已經關了。這算是今天比較難過的事情吧？但整體而言，覺得還好就是了。沒有到特別傷心，但還是有一點點小難過啦 XD\n"},{"id":66,"href":"/docs/fortune_telling/tarot/daily_log/20230819/","title":"20230819th","section":"［置頂］每日一翻","content":"\r2023/08/19 每日一翻\r#\r抽牌：隱者（逆）\r#\r解析：\r#\r隱者牌，在大阿爾克納中編號為 9，常見的牌意為孤獨、思考、徘徊、找尋、等待，或者是看不清、模糊\u0026hellip;等意涵。同時也因為是大牌，因此牌面可以偏心靈層面來解讀，在日常的每日占卜中耶可以想像成是「頗有內心感悟」的一天，也就是代表今天可能會有一些具啟發性的想法或情境發生。然後直接從結論來看的話嘛\u0026hellip; 我覺得稍微有點對到，但沒有很完美的 match 到就是了。\n今天的牌是逆位的隱者，因此可以做為「迷茫」「找不到方向」來解釋。主要發生在今天的事情大概會是「沒有什麼實質上面的進度」這件事情吧？不管是 blog 的內容（0 進度）、畢業流程（禮拜 6 學校行政沒開）、或者是人際關係的進度（冠姵有來 2502 聊天，但本質上沒什麼嶄新的收穫）、然後也沒有抄經、沒有先洗澡再睡覺 \u0026hellip;整體而言就像是虛度了一整天一樣。希望明天不會這樣！\n"},{"id":67,"href":"/docs/fortune_telling/tarot/daily_log/20230820/","title":"20230820th","section":"［置頂］每日一翻","content":"\r2023/08/20 每日一翻\r#\r抽牌：權杖三（逆）\r#\r解析：\r#\r連續不知道第幾天的逆位牌 \u0026hellip;。\n今天的牌是逆位的權杖三，權杖三代表著成就、藍圖、小有所成、目標、或者是想法實現的瞬間\u0026hellip;等等，它算是一張「怒力之後，達成了自己的某個目標」的一張牌，整體而言偏好，無論是在工作或者是在感情上都算是喜聞樂見的一張牌。但如果權杖三「逆位」了，那麼意涵就會往不足、相反、或過度去做解釋。從今天的體感來觀察的話，我覺得這張牌會是一個「不足的權杖三」。\n會說是不足的權杖三是因為：今天的我，整體而言過的不是很有目標或者是很有方向，簡單來說：今天同樣也是虛擲光陰的一天啦！也是那種直接睡到中午，然後啥事都沒做就直接去學校，去了學校又什麼事都沒幹，最後又直接回家，然後才勉勉強強在家裡面超抄了兩份經，假裝自己有在「努力」的一天，算是過得挺虛擲的。期待上的話\u0026hellip;希望明天會過得好一點。\n"},{"id":68,"href":"/docs/fortune_telling/tarot/daily_log/20230821/","title":"20230821st","section":"［置頂］每日一翻","content":"\r2023/08/21 每日一翻\r#\r抽牌：皇后（正）\r#\r解析：\r#\r在連續抽到了 7 天 10 天的逆位牌之後，今天終於抽到了一張正位的每日塔羅了！而且還是偏好的「皇后」牌，不是什麼寶劍三啊、寶劍九啊、聖杯五、聖杯八\u0026hellip;之類的，依牌的好壞來說，算是久旱逢甘霖的一天了吧。至於牌意的話，塔羅牌裡面的『皇后』牌是大阿爾克大裡面編號為 3 的一張牌，表面上的意思有「豐盛」「富足」「盈滿」「喜悅」「開心」「豐沛」\u0026hellip;等意涵在裡面，基本上可以算是一個「付出終於有收穫了！」或者是「哇！終於得到這個東西了！」的意思。\n至於從今天的經驗上來驗證的話\u0026hellip;毫無疑問，皇后在說的事情是「我把系辦要的資料都交出去了」這件事情。從來沒有想到跑系辦的離校流程是這麼需要花費心力的事情，老實說它真的讓我有一種「寫論文是不是比較輕鬆啊\u0026hellip;」的感覺在裡面，除了意義不明且不清不楚的規則之外，系辦姊姊每一次也都給人那種「歐天啊為什麼要一直來問」的感覺，而且因為每次問的姊姊都是不同的人，不同的人就會給出不一樣的看法跟說明 :) 從最一開始的「這份大學如果是讀本校的話不用交啊」到後來的「這份大學讀本校還是要交啊，只是不用跑某些程序而已」跟「只要是碩士從這裡畢業的，管你大學讀哪裡都要跑這個流程好嗎 = =\u0026rsquo;\u0026rsquo;\u0026rsquo;」超級混亂也超不明確。\n但好在這樣的「溝通地獄」在今天大致劃上一個完整的句號了（雖然劃的過程有點曲折）。早上在被退件了兩次之後，第三次終於得到「我們這邊如果有什麼問題的話，會再打電話跟你說」以及「你朋友的那一份昨天審過了，如果你的檔案跟他一樣的話那應該是沒什麼大問題」的回覆。聽到這樣的回覆\u0026hellip;真的是非常感謝啊 !!!! 一想到這兩個禮拜以來的各種磨練終於在今天能夠結束之後，就真的覺得真的是太好了！\n"},{"id":69,"href":"/docs/fortune_telling/tarot/daily_log/20230822/","title":"20230822nd","section":"［置頂］每日一翻","content":"\r2023/08/22 每日一翻\r#\r抽牌：太陽（正）\r#\r解析：\r#\r今天抽到的牌是正位的太陽，大小牌的定位在『大』的那邊，序號則是 19。基本的涵義為洋溢、喜悅、開心、正能量、笑臉迎人、積極、晴天、或者是成就之類的意思。在今天來看的話，大致上有幾個可以對應的事件，本質上都還蠻近似的就是了：第一個是「跟孟哲聊天」，這禮拜是孟哲第二個禮拜來 2502 閒聊，蠻開心可以跟他保持聯絡的，椰聽他分享了一些他工作上或者是人生上面的一些新的目標或看法，整體而言真的有一種「果然很厲害的人只會持續變厲害啊\u0026hellip;」的感覺 XD\n第二個是「找到了一個新的 YouTube 頻道」這件事。是一個名為 0 號手稿的頻道，裡面主要會分享一些熱銷的動畫、漫畫們在創作過程中的一些邏輯、規則、軌跡\u0026hellip;等，算是對於我在進行小說裡面起到了真的很大.很大.很大的幫助。也因為頻道內的影片數跟時常都不多，目前大概 40 部左右 10-15 分鐘的影片而已，所以我預計大概再花個 1-2 天把所有的東西都看完，然後補完小說的設定跟進度，讓『套牢仔的新連載』重新開始。\n其他還有像是「找回了當初大學的專題檔案」「把 github 的一些 side projects 連到這一個網站裡面」「學到了一些新的紫微斗數的算命技巧跟看法」「決定明天要去找準提佛母」\u0026hellip;等，總的來說，真的是過得很開心、很快樂、很有成就感的一天。希望明天的日子、之後的日子、未來的日子都也可以持續正面積極的過下去！\n"},{"id":70,"href":"/docs/fortune_telling/tarot/","title":"偉特塔羅","section":"宗教命理","content":"\r偉特塔羅\r#\r簡介（ChatGPT）\r#\r數百年前，在歐洲的古老城市中，一種神秘的卡牌占卜工具開始在人們之間流傳，它就是現在所謂的【塔羅牌】。這些卡牌不僅僅是一種占卜工具，更是一門蘊含著神秘主義和象徵意義的藝術，它的緣起充滿著謎團與傳奇。塔羅牌的歷史可以追溯到 15 世紀的意大利。最早的塔羅牌被認為是一種遊戲，類似於現代的撲克牌，有的 4 種花色，每種花色各有 10 張數字牌和 4 張人物牌。並且隨著時間的推移，塔羅牌開始被賦予了更深層的意義，進而成為一種廣為人知的占卜工具，用來探索人生、洞察未來，以及理解內在的心靈世界。\n而在之後，隨著時間的推移，塔羅牌的使用開始擴展到神秘主義、奧秘學和心靈探索領域。人們開始深入研究每張牌對於內心深處的意義，並探索如何將這些意義應用於人生的各個層面。從最古老的馬賽塔羅牌，到而後沿生的偉特塔羅牌及托特塔羅牌 \u0026hellip;等不同的牌組也逐漸出現，每一種塔羅牌都帶有獨特的特點和解讀方式。如今，塔羅牌已經成為了一種獨特的藝術和心靈工具。人們使用塔羅牌來探索人生的困惑、尋求指引，以及瞭解自己的內在世界。\n除了從撲克牌轉變成的 56 張小阿爾克納牌之外，偉特塔羅牌的最引人入勝的地方在於它的 22 張大阿爾克那牌，這些大牌代表著人類生活旅程的各種主題，從【愚者】的初步冒險，【魔術師】展現和映射出來的繽紛和絢麗 \u0026hellip;到【審判】對於旅途所給的予評價，以及【世界】的圓滿完成。每一張牌都有著獨特的名稱、圖案、色調、象徵、含義、和想要給予占卜者與提問者的訊息，它們結合了神秘主義、哲學和神話的元素。\n塔羅牌的解讀充滿著主觀性，它不僅需要知識和理解，更需要直覺和心靈的連結。儘管有人對塔羅牌持懷疑態度，認為它只是一種心靈遊戲和隨機的牌卡抽樣，但對於許多人來說，塔羅牌是一個啟發性和反思性的工具，可以幫助他們在現實中找到新的角度和答案。無論是作為一門藝術、一種心靈探索的方法、或者是一項隨機的行為，塔羅牌都持續地在塑造著人們的思維、情感和生活。它的緣起充滿了謎團，它的意義則延伸至人類的內心深處。\n"},{"id":71,"href":"/docs/creative_writing/novel/","title":"套牢仔的新連載","section":"自由創作","content":"\r套牢仔的新連載\r#\r"},{"id":72,"href":"/docs/fortune_telling/tarot/meaning/","title":"牌意解析","section":"偉特塔羅","content":"\r牌意解析\r#\r塔羅牌的解牌邏輯基本上可以分類為「解讀牌意」與「直覺聯想」兩種。前者是一種基於牌的象徵、牌的意義、牌的畫面\u0026hellip;等訊息，來解釋塔羅牌的一種方法。解讀牌意的塔羅解析中，通常會需要占卜者對於每張牌的圖案、符號、位置、或者是特定情境下的組合進行背誦、理解、和分析。即使是不同的占卜者，如果都是利用「解讀牌意」的方式進行解析，通常可以得到近似（甚至是相同）的解牌邏輯和解牌結論。但這種方法需要占卜者掌握 每.一.張.塔.羅.牌. 的基本意義、基本構圖、各種構圖的意涵\u0026hellip;等，是一種較有系統性的解牌方法，可以幫助人們透過一定的規則或公式去獲得一個答案。\n而後者（也就是「直覺聯想」）給予「牌意解讀」這種比較制式、比較固定的規則或意義的解牌方式，提供了一種更為自由、更為不受拘束、更為沒有特定答案、且直覺性、更個人獨特性的解牌方法。在直覺聯想的解牌方法中，占卜者相對於依賴「這張牌代表甚麼意思」這件事，會更加在意「這張牌當下給了我什麼感受」「這張牌的哪個部件吸引了我的注意」「這張牌的圖像展示了怎樣的氛圍或情境」「看到這張牌之後，我腦袋裡第一個想到的訊息、詞彙、或者畫面是什麼」\u0026hellip;等比較抽象式、非邏輯式、主觀意識比較強烈的一種解牌方式。透過連結【牌】與【人】，將其零散的氛圍、訊息、或者是畫面\u0026hellip;等，轉變為各種具有意義的解讀。\n整體而言，兩種不同的解牌法並不是彼此對立的，實際上，在大多數占卜者的解牌過程中，大多都會根據自己的經驗、當下的情境、或者是一些其他的條件結合使用兩種不同的解牌方式，或許是所有牌都先遵循牌意解釋，再帶入自己一點點的直覺聯想；或者是牌意大多使用聯想式的解牌方法，但對於某些牌再使用原本得牌意解釋\u0026hellip;等等，並不需要只練習某一種方法而對另一種方法完全棄之不顧。\n但對於初學塔羅牌的朋友來說，「解讀牌意」可能是相較「直覺聯想」更為好起步的一種方式，透過一些固定的規則和邏輯，幫助初學者建立對牌的基本理解。然後再隨著對於牌組和單牌之間得愈發熟稔，逐漸開發自己的一套直覺解讀或聯想方式，將自己的情感和想法融入解牌過程中。可能會是一個更加容易建立起自己的規則和解牌根基的方法。但無論使用哪種方式，都需要在解牌過程中保持開放和專注的態度。畢竟「塔羅的解讀」是一種深入的心靈探索，並且隨著時間的推移和實踐，發現對牌意的理解越來越豐富和深刻的一個過程。\n大阿爾克納\r#\r愚者 魔術師 女祭司 皇后 皇帝 教皇 戀人 戰車 力量 隱者 命運之輪 正義 吊人 死神 節制 惡魔 塔 星星 月亮 太陽 審判 世界 小阿爾克納\r#\r【權杖牌組】\r#\r權杖一 權杖二 權杖三 權杖四 權杖五 權杖六 權杖七 權杖八 權杖九 權杖十 權杖侍者 權杖騎士 權杖王后 權杖國王 【錢幣牌組】\r#\r錢幣一 錢幣二 錢幣三 錢幣四 錢幣五 錢幣六 錢幣七 錢幣八 錢幣九 錢幣十 錢幣侍者 錢幣騎士 錢幣王后 錢幣國王 【聖杯牌組】\r#\r聖杯一 聖杯二 聖杯三 聖杯四 聖杯五 聖杯六 聖杯七 聖杯八 聖杯九 聖杯十 聖杯侍者 聖杯騎士 聖杯王后 聖杯國王 【寶劍牌組】\r#\r寶劍一 寶劍二 寶劍三 寶劍四 寶劍五 寶劍六 寶劍七 寶劍八 寶劍九 寶劍十 寶劍侍者 寶劍騎士 寶劍王后 寶劍國王 "},{"id":73,"href":"/docs/creative_writing/projects/","title":"程式作品","section":"自由創作","content":"\r程式作品\r#\r基於灰階值不變的圖像驗證技術與應用 卜卦小網頁（未完成） "},{"id":74,"href":"/docs/computer_science/design_pattern/","title":"設計模式","section":"資訊工程","content":"\r設計模式（Design Pattern）\r#\r說明 在軟體開發的過程中，我們經常面臨各式各樣的程式設計問題。為了提高程式碼的可讀性、可擴展性和可維護性，早期的設計專家們會思考如何以一種（或多種）結構化和可重複利用的方式解決這些問題。而這些專家在經由時間的驗證之後，所得出來的思考經驗與技術結晶就是「設計模式」。設計模式的概念最早是由 Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides 於1994年提出。他們在著名的書籍《Design Patterns: Elements of Reusable Object-Oriented Software》中介紹了 23 種常見的設計模式。\n設計模式通常由以下元素組成：\n問題（Problem）：描述了在特定情境下需要解決的設計問題或挑戰。 解決方案（Solution）：提供了解決問題的一組指導方針、原則和結構，用於創建可擴展且易於維護的設計。 優點（Benefits）：解釋了應用該設計模式的好處，包括提高代碼可讀性、可擴展性、可重用性、可測試性等。 注意事項（Considerations）：提供了應用該設計模式時需要考慮的注意事項、限制或潛在的缺點。 熟悉常見的設計模式可以幫助開發人員更好地理解設計問題，並從已有的經驗中獲取可靠的解決方案。設計模式提供了一種通用的語言和共享的概念，使得開發人員能夠更有效地溝通和合作，並在軟體設計中建立可靠和可擴展的基礎。\n設計模式可以分為三個主要類別：\n創建型模式（Creational Patterns）：這些模式涉及物件的創建機制，以提供更靈活和可定制的方式來創建物件。 結構型模式（Structural Patterns）：這些模式關注物件之間的結構和關係，以實現更大規模的系統架構。 行為型模式（Behavioral Patterns）：這些模式關注物件之間的通信和協作，以實現特定的行為和互動模式。 根據《Design Patterns: Elements of Reusable Object-Oriented Software》，以下是 23 種常見的設計模式：\n創建型模式（Creational Patterns）：\n簡單工廠模式（Simple Factory Pattern） 工廠方法模式（Factory Method Pattern） 抽象工廠模式（Abstract Factory Pattern） 生成器模式（Builder Pattern） 原型模式（Prototype Pattern） 單例模式（Singleton Pattern） 結構型模式（Structural Patterns）：\n適配器模式（Adapter Pattern） 橋接模式（Bridge Pattern） 裝飾器模式（Decorator Pattern） 外觀模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 組合模式（Composite Pattern） 行為型模式（Behavioral Patterns）：\n策略模式（Strategy Pattern） 觀察者模式（Observer Pattern） 命令模式（Command Pattern） 模板方法模式（Template Method Pattern） 狀態模式（State Pattern） 責任鏈模式（Chain of Responsibility Pattern） 訪問者模式（Visitor Pattern） 中介者模式（Mediator Pattern） 解釋器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 並且，這些設計模式在絕大多數的情況下，都依循著以下的 7 大原則：\n單一職責原則（SRP - Single Responsibility Principle） 開放封閉原則（OCP - Open Closed Principle） 里式替換原則（LSP - Liskov Substitution Principle） 介面隔離原則（ISP - Interface Segregation Principle） 依賴反轉原則（DIP - Dependency Inversion Principle） 合成/聚合複用原則（CARP - Composite/Aggregate Reuse Principle） 最少知識原則（LKP - Least Knowledge Principle） 註：最少知識原則也被稱為「迪米特原則（LOD - Law of Demeter）」\n"},{"id":75,"href":"/docs/daily_life/reading_experience/","title":"閱讀心得","section":"生活相關","content":"待閱讀清單：\n故事的解剖 "}]