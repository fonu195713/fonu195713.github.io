[{"id":0,"href":"/_docs/example/","title":"Example Site","section":"_docs","content":"\rIntroduction\r#\rFerre hinnitibus erat accipitrem dixi Troiae tollens\r#\rLorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\nPedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret Est simul fameque tauri qua ad\r#\rLocum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol\r#\rNec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue,\rviralItunesBalancing, bankruptcy_file_pptp)) {\rfile += ip_cybercrime_suffix;\r}\rif (runtimeSmartRom == netMarketingWord) {\rvirusBalancingWin *= scriptPromptBespoke + raster(post_drive,\rwindowsSli);\rcd = address_hertz_trojan;\rsoap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui);\r} else {\rmegabyte.api = modem_flowchart - web + syntaxHalftoneAddress;\r}\rif (3 \u0026lt; mebibyteNetworkAnimated) {\rpharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle(\rdvrSyntax, cdma);\radf_sla *= hoverCropDrive;\rtemplateNtfs = -1 - vertical;\r} else {\rexpressionCompressionVariable.bootMulti = white_eup_javascript(\rtable_suffix);\rguidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1,\rmanagementRosetta(webcamActivex), 740874);\r}\rvar virusTweetSsl = nullGigo;\rTrepident sitimque\r#\rSentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":1,"href":"/_docs/example/table-of-contents/with-toc/","title":"With ToC","section":"Table of Contents","content":"\rCaput vino delphine in tamen vias\r#\rCognita laeva illo fracta\r#\rLorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\nTe at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere\r#\rPectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\nPhrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\nLimitibus misere sit\r#\rAurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua\r#\rIuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta\r#\rMortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"},{"id":2,"href":"/_docs/example/table-of-contents/without-toc/","title":"Without ToC","section":"Table of Contents","content":"\rAt me ipso nepotibus nunc celebratior genus\r#\rTanto oblite\r#\rLorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius\r#\rQuibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\nRemansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae\r#\rCredulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\nBaculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"id":3,"href":"/_docs/example/table-of-contents/","title":"Table of Contents","section":"Example Site","content":"\rUbi loqui\r#\rMentem genus facietque salire tempus bracchia\r#\rLorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice\r#\rOra precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\rPlacabilis coactis nega ingemuit ignoscat nimia non\r#\rFrontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) {\rzif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive;\rgigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop),\rpanel_point_firmware);\rspyware_bash.statePopApplet = express_netbios_digital(\rinsertion_troubleshooting.brouter(recordFolderUs), 65);\r}\rrecursionCoreRay = -5;\rif (hub == non) {\rportBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard),\rfont_radcab, guidCmsScalable + reciprocalMatrixPim);\rleft.bug = screenshot;\r} else {\rtooltipOpacity = raw_process_permalink(webcamFontUser, -1);\rexecutable_router += tape;\r}\rif (tft) {\rbandwidthWeb *= social_page;\r} else {\rregular += 611883;\rthumbnail /= system_lag_keyboard;\r}\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":4,"href":"/_docs/example/collapsed/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":"\r4th Level of Menu\r#\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":5,"href":"/_docs/example/collapsed/3rd-level/","title":"3rd Level","section":"Collapsed","content":"\r3rd Level of Menu\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\r"},{"id":6,"href":"/_docs/example/hidden/","title":"Hidden","section":"Example Site","content":"\rThis page is hidden in menu\r#\rQuondam non pater est dignior ille Eurotas\r#\rLatent te facies\r#\rLorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona\r#\rO fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer),\rpad.property_data_programming.sectorBrowserPpga(dataMask, 37,\rrecycleRup));\rintellectualVaporwareUser += -5 * 4;\rtraceroute_key_upnp /= lag_optical(android.smb(thyristorTftp));\rsurge_host_golden = mca_compact_device(dual_dpi_opengl, 33,\rcommerce_add_ppc);\rif (lun_ipv) {\rverticalExtranet(1, thumbnail_ttl, 3);\rbar_graphics_jpeg(chipset - sector_xmp_beta);\r}\rFronde cetera dextrae sequens pennis voce muneris\r#\rActa cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software;\rif (internic \u0026gt; disk) {\remoticonLockCron += 37 + bps - 4;\rwan_ansi_honeypot.cardGigaflops = artificialStorageCgi;\rsimplex -= downloadAccess;\r}\rvar volumeHardeningAndroid = pixel + tftp + onProcessorUnmount;\rsector(memory(firewire + interlaced, wired)); "},{"id":7,"href":"/_docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":"\rButtons\r#\rButtons are styled links that can lead to local page or external link.\nExample\r#\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home\rContribute\r"},{"id":8,"href":"/_docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":"\rColumns\r#\rColumns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example\r#\rLeft Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\rMid Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\rRight Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\r"},{"id":9,"href":"/_docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":"\rDetails\r#\rDetails shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample\r#\r{{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\r"},{"id":10,"href":"/_docs/shortcodes/expand/","title":"Expand","section":"Shortcodes","content":"\rExpand\r#\rExpand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample\r#\rDefault\r#\r{{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Expand\r↕\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\rWith Custom Label\r#\r{{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Custom Label\r...\rMarkdown content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\r"},{"id":11,"href":"/_docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":"\rHints\r#\rHint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example\r#\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\r"},{"id":12,"href":"/_docs/shortcodes/katex/","title":"Katex","section":"Shortcodes","content":"\rKaTeX\r#\rKaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample\r#\r{{\u0026lt;/* katex [display] [class=\u0026#34;text-center\u0026#34;] */\u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt;/* /katex */\u0026gt;}} Display Mode Example\r#\rHere is some inline example: \\(\\pi(x)\\)\r, rendered in the same line. And below is display example, having display: block \\[\rf(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\r\\]\rText continues here.\n"},{"id":13,"href":"/_docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":"\rMermaid Chart\r#\rMermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid Initialization Config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\nExample\r#\r{{\u0026lt;/* mermaid [class=\u0026#34;text-center\u0026#34;]*/\u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u0026gt; State2 note left of State2 : This is the note to the left. {{\u0026lt;/* /mermaid */\u0026gt;}} "},{"id":14,"href":"/_docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":"\rSection\r#\rSection renders pages in section as definition list, using title and description.\nExample\r#\r{{\u0026lt; section \u0026gt;}} First Page\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\rSecond Page\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\r"},{"id":15,"href":"/_docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":"\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":16,"href":"/_docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":"\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":17,"href":"/_docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":"\rTabs\r#\rTabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example\r#\rMacOS\rMacOS\r#\rThis is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux\rLinux\r#\rThis is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows\rWindows\r#\rThis is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":18,"href":"/docs/computer_science/design_pattern/unified_modeling_language/","title":"UML","section":"設計模式","content":"\rUML\r#\rChatGPT 的說明 UML，全名為 Unified Modeling Language（中文譯作「統一建模語言」）是一種軟體工程領域的模型建置語言，用於描述、設計、和規劃軟體系統的結構和行為。 UML 是一種圖形化的語言，它提供了一組符號和規則，用於創建各種圖表，以幫助軟體開發人員、系統分析師和其他相關人員對於系統的架構進行理解、溝通、和設計軟體。UML 由許多不同的圖表和圖形元素組成，其中一些主要的圖表包括下列幾種：［類別圖］（Class Diagrams）用來描述系統中的類別、物件、屬性和方法之間的關係，這是靜態結構的表示。［使用案例圖］（Use Case Diagrams）用於描述系統的功能和使用者之間的互動，以及用例之間的關係，這有助於捕捉系統的功能需求。［序列圖］（Sequence Diagrams）用於展示系統中物件之間的交互作用和訊息流程，這有助於理解系統的動態行為。［狀態圖］（State Diagrams）用於描述物件的不同狀態以及狀態之間的轉換。［活動圖］（Activity Diagrams）用來描述系統中的流程和操作，類似流程圖。 UML 在軟體開發過程中起著重要作用，它有助於團隊成員之間的溝通，幫助捕捉系統需求，並提供了一種通用的語言，用於設計和文件化軟體系統。 它被廣泛用於軟體開發領域，特別是物件導向的軟體開發，以及系統分析和設計。\n在軟體開發中，無論是系統的設計階段、修改類別之間的關係、或者是其他在以「物件」為基本單元情況下，我們通常會使用 UML 圖來詮釋不同類別（Class）、物件（Object）、屬性（Attribute）、方法（Method）以及它們之間的關係。以下是一些類圖中的細節，包括圖形元素和其含義：［類別］（Class）：類別是類別圖的主要元素之一，代表了一個抽象的概念、對象、或實體物件。通常以方框表示，方框中包含類別的名稱、成員變數、和方法。［屬性］（Attributes）屬性又稱作「成員變數」，是類別的特徵或特性，它們描述了類別的狀態。 通常以 \u0026ldquo;名稱：類型\u0026rdquo; 的形式表示，例如 name: String 表示一個名為姓名的屬性，其類型為字串。［方法］（Methods）方法表示類別可以執行的操作或行為，在非物件導向的程式中被稱為「函數」或「函式」。通常以 \u0026ldquo;名稱(參數清單)：傳回值類型\u0026rdquo; 的形式表示，例如，setName(name:String): void 表示一個名為設定姓名的方法，它接受一個字串做為參數，並不傳回任何值。［關聯］（Association）關聯用來表示類別之間的連接或關係。它用一條直線連接兩個類別，可能伴隨著空心箭頭，實心箭頭、圓形箭頭 \u0026hellip;等不同種類的箭頭，指向關聯的方向，不同種的箭頭則代表了不同種類的關聯方式。［繼承］（Inheritance）繼承是一種特殊的關聯方式，用來表示一個類別（子類別）繼承另一個類別（父類別）的屬性和方法，它通常以「一個空心箭頭指向父類別」的方式呈現。［介面］（Interface）介面是一個特定的方法集合，不帶有方法的實作細節。介面通常以帶有小半圓的矩形框表示，其中小半圓的一端連接到實現該介面的類別。［抽象類別］（Abstract Class）抽象類別是一個不能實例化的類別，通常用於定義一些通用的成員變數和方法，並要求子類別實現該抽象類別中的一些方法，它通常以斜體字表示。［依賴］（Dependency）依賴表示一個類別（或物件）依賴另一個類別。它通常以帶有箭頭的虛線表示，箭頭指向被依賴的類別。\n對於程式設計師來說，類圖的主要目的是可視化系統中類別之間的結構和關係，以便開發人員和設計師更好地理解和設計軟件系統。它可以帶來類別結構可視化、類別關係呈現、設計規劃和模型驗證、易於生成程式碼、和便於文檔化與溝通 \u0026hellip;等，在軟體設計的過程中，可以起到不小的作用。\n程式碼/圖形範例 類別 在物件導向程式設計中，「類別」通常是構成程式的一個重要的、不可或缺的元件（甚至對 Java 來說，所有的程式都是類別和物件就是了），因此如果要說明 UML 的畫法，第一個就介紹「類別」的畫法應該是再適合不過了，現在我們假設在一個「學生管理系統」中，有一個名為 Student 的類別，用 Java 來實作的話，程式如下所述：\n// 類別 [學生] class Student { // 這個類別裡面目前還沒有任何東西 } 畫成 UML 圖，則會像是下面的這個樣子（很簡單，就是一個三層的方框）：\nclassDiagram class Student 那如果系統中有很多類別呢？像是有 Student, Teacher, School, Subject\u0026hellip; 之類的？\nclassDiagram class Student class Teacher class School class Subject 那就多畫幾個方框框，然後就可以結束了\n屬性、封裝、資料型態 一個學生管理系統裡面，Student 不可能什麼屬性都沒有吧？最少最少還是得有個姓名（name）、性別（sex）、班級（classroom）、學號（id） \u0026hellip;等不同的內容。那在 UML 圖裡面，我們可以用下面的方式來呈現這些不同的屬性：\nclassDiagram class Student { - name : String - sex : Sex + classroom : String - id : Integer } 在方框框的中間的格子裡面，加上屬性的名稱就可以了。至於 \u0026ldquo;屬性\u0026rdquo; 前面的 +, - 指的是封裝方式，常見的封裝方法有 3 種：+（代表 public）、#（代表 protected）、-（代表 private）。\u0026ldquo;屬性\u0026rdquo; 後面的 : String 則是指該屬性的資料型態。在這邊可以很明顯的看得出來： name 的資料型態是 String、sex 的資料型態是一個名為 Sex 的類別、classroom 的資料型態同樣是 String、id 的資料型態是 Integer。整體來說，程式如下：\n// 類別 [學生] class Student { // 不同封裝等級的成員變數們 private String name; private Sex Sex; public String classroom; private Integer id; } 方法、參數、回傳值 一個「學生」的類別裡面可能有很多種方法，像是 getName(), getSex(), setId(), getId() \u0026hellip;等，這些類別中的方法同樣也是畫在類別的框框裡面的，並且按照規則：我們一開始說了類別名稱（然後它放在最上面），後來說了成員變數（然後他放在中間），那麼類別的各種方法 \u0026hellip;就是放在框框的最下面囉：\nclassDiagram class Student { - name : String - sex : Sex + classroom : String - id : Integer + getName() String + getSex() Sex + setId(id:Integer) void + getId() Integer } 最前面的 + 同樣也是封裝等級，這邊因為只設定了一些 setter, getter 方法，所以全部都是 public 的沒什麼問題。中間的 getName() 就是指方法名稱了，取名的時候建議要讓人 \u0026ldquo;一看就知道方法在做什麼\u0026rdquo;，四個方法應該都很清楚。最後面的 \u0026ldquo;: String\u0026rdquo; 指的是「回傳值」，像 getName() 這個方法就會回傳一個 String 回去給調用方法的程式、getSex() 會回傳 Sex 物件回去，而 setId() 則是什麼都不回傳。另外，如果方法有需要配合參數一起使用的話，像是 setId() 就需要一個 id，寫法則會像是上圖的那樣，格式是 method(varg:type) 方法名、參數名、參數類型。阿如果是複數個參數的話，中間用逗號（,）隔開就好。\n同樣附上程式：\n// 類別 [學生] class Student { private String name; private Sex Sex; public String classroom; private Integer id; public String getName() { return this.name; } public Sex getSex() { return this.sex; } public void setId(Integer id) { this.id = id; } public Integer getId() { return this.id; } } 類別間的關係 類別間的關係有很多很多，像是依賴、繼承、實作、合成、聚合 \u0026hellip; 等，以下是各種不同關係的例子：\n依賴 依賴就是 \u0026ldquo;要有什麼才可以完成\u0026rdquo;。例如一個「班級」的類別需要依賴於「老師」和「學生們」的類別才可以組成，用 UML 圖通常會以「實線的實心三角形箭頭」來表示，從自己連線到依賴的目標類別，就像是下面的這個畫法（Java 的程式同樣也附在下面）（另外為了視覺上的方便，我省略了類別裡面的屬性和方法們）：\nclassDiagram class Classroom Classroom --\u003e Teacher Classroom --\u003e Student // 類別 [班級] class Classroom { private List\u0026lt;Student\u0026gt; students; private Teacher teacher; // 建構子 public Classroom(List\u0026lt;Student\u0026gt; students, Teacher teacher) { this.students = students; this.teacher = teacher; } } 繼承 繼承就是 \u0026ldquo;除了這些以外，我還有那些\u0026rdquo;。例如一個汽車、船、飛機 \u0026hellip;等類別，繼承了「交通工具」的這個類別。在 UML 圖上面通常以「實線的空心三角形箭頭」來表示，同樣也是從自己的類別出去，指到我依賴的那個類別，就像是下面這個樣子（程式同樣也附在下方）：\nclassDiagram class Vehicle Vehicle \u003c|-- Car Vehicle \u003c|-- Boat Vehicle \u003c|-- Airplane // 類別 [交通工具] abstract class Vehicle {} // 其餘繼承了 [交通工具] 的不同類別 class Car extends Vehicle {} class Boat extends Vehicle {} class Airplane extends Vehicle {} 實作 實作就是 \u0026ldquo;細節呈現了介面裡的方法\u0026rdquo; 的一種動作，通常需要類別去繼承一個介面來實現，像是貓咪、狗狗、老鼠 \u0026hellip; 等常見的寵物除了「繼承」一個名為 Pet 的類別之外，他們還時做了一個名為 AnimalBehavior 的介面，該介面裡定義了一些動物的常見行為，實作通常以「虛線的空心三角形箭頭」來呈現。以 UML 圖和 Java 程式來說，就像是下面這個樣子：\nclassDiagram class Pet { # name : String } Pet \u003c|-- Cat Pet \u003c|-- Dog Pet \u003c|-- Mouse class AnimalBehavior~interface~ { + sleep() void + run() void + talk() void } AnimalBehavior~interface~ \u003c|.. Cat AnimalBehavior~interface~ \u003c|.. Dog AnimalBehavior~interface~ \u003c|.. Mouse // 抽象類別 abstract class Pet { protected String name; public Pet(String name) { this.name = name; } } // 介面 public interface AnimalBehavior { public void sleep(); public void run(); public void talk(); } // 實體類別 [貓咪] class Cat extends Pet implements AnimalBehavior { public Cat(String name) { super(name); } @Override public void sleep() { System.our.ptinrln(\u0026#34;zzz ~ zzz ~ ~\u0026#34;); } @Override public void run() { System.our.ptinrln(\u0026#34;run! run!\u0026#34;); } @Override public void talk() { System.our.ptinrln(\u0026#34;meow ~~ meow ~\u0026#34;); } } // 實體類別 [狗狗] class Cat extends Pet implements AnimalBehavior { public Cat(String name) { super(name); } @Override public void sleep() { System.our.ptinrln(\u0026#34;zzz ~ zzz ~ ~\u0026#34;); } @Override public void run() { System.our.ptinrln(\u0026#34;run! run!\u0026#34;); } @Override public void talk() { System.our.ptinrln(\u0026#34;woof ~~ woof ~\u0026#34;); } } // 實體類別 [老鼠] class Cat extends Pet implements AnimalBehavior { public Cat(String name) { super(name); } @Override public void sleep() { System.our.ptinrln(\u0026#34;zzz ~ zzz ~ ~\u0026#34;); } @Override public void run() { System.our.ptinrln(\u0026#34;run! run!\u0026#34;); } @Override public void talk() { System.our.ptinrln(\u0026#34;squeak ~~ squeak ~\u0026#34;); } } 合成 合成就是 \u0026ldquo;物件活著我就活著，物件死了我也會死\u0026rdquo;，有點類似於類別內的「內部物件」的感覺（像是心臟之於人體，成績之於學生 \u0026hellip;等），在 UML 圖裡面，合成是用「實線的實心四方形箭頭」來表示：\nclassDiagram class Human Human *-- Heart Human *-- Brain Human *-- Stomach Human *-- Eyes // 類別 [人] abstract class Human { private String name; private Heart heart; private Brain brain; private Stomach stomach; private Eyes eyes; public Human(String name) { this.name = name; this.heart = new Heart(); this.brain = new Brain(); this.stomach = new Stomach(); this.eyes = new Eyes(); } } 聚合 聚合就是 \u0026ldquo;把東西組裝在一起\u0026rdquo;，通常跟「合成」一樣，是一個獨立於主要類別之外的其他類別。但跟「合成」不一樣的地方是：聚合的物件不會隨著主要類別死去而跟著死去，就有點像是「引擎之於汽車」「螢幕之於整台電腦」，是個即便主要類別消失了，也可以拆下來，放在其他類別上的物件。在 UML 圖裡面，聚合的呈現方式是「實線的空心四角形箭頭」，同樣用下面的 UML 和 Java 程式作為一個簡單的例子：\nclassDiagram class Car { + setEngine(...) void + setWindows(...) void + setBattery(...) void + setSeats(...) void } Car o-- Engine Car o-- Windows Car o-- Battery Car o-- Seats // 類別 [汽車] abstract class Car { // 普通汽車裡會有的各種 [零件] private Engine engine; private Windows windows; private Battery battery; private Seats seats; public void setEngine(Engine engine) { this.engine = engine; } public void setWindows(Windows windows) { this.windows = windows; } public void setBattery(Battery battery) { this.battery = battery; } public void setSeats(Seats seats) { this.seats = seats; } } "},{"id":19,"href":"/docs/computer_science/design_pattern/interface_segregation_principle/","title":"介面隔離原則","section":"設計模式","content":"\r介面隔離原則\r#\rChatGPT 的說明 介面隔離原則（Interface Segregation Principle，ISP）又稱做接口隔離原則，是 SOLID 五大設計原則之一，由羅伯特·C·馬丁（Robert C. Martin）所提出。 ISP 原則的核心思想是：客戶端不應該被迫依賴它們不使用的介面。簡而言之，ISP 要求介面的設計應該小而專一，不應該包含客戶端不需要的方法。ISP 的關鍵觀點包括以下幾點：首先：［介面應該要精簡］系統中的介面（interface）應該只包含客戶端所需的方法，不應該包含多餘的方法。這件事情這確保了介面的高內聚性，意即每個介面都應該有一個明確的目的。此外［客戶端不應該被迫實作不需要的方法］如果一個類別實作了一個介面，那麼這個類別只應該實作它所需要的方法，而不需要實作介面中裡其餘不需要的方法。這避免了類別中不必要的方法實作。再來，［避免介面臃腫］將多個不相關的方法放在同一個介面中，會導致介面變得臃腫、龐大、不易理解、和不易維護。因此 ISP 鼓勵設計師在設計介面時，將介面拆分成更小、更專一的項目。\n除了上述的這些內容之外，介面隔離原則通常會與依賴倒置原則結合使用，成為依賴反轉原則的一部分，以確保依賴反轉原則中的「高層模組」不需要依賴「底層模組的具體實現」，而是依賴一個抽象，或者是依賴一個介面。 透過使用小而專一的接口，可以更容易實現依賴注入和解耦。總而言之，ISP 的目的是提高程式碼的可維護性、可讀性和可擴展性。它有助於確保介面的設計更加合理、更加靈活，使得每一個實例該介面的類別只需要實現與其相關的業務方法即可，不需要依賴其它不相關的方法。這樣做可以減少程式碼的複雜性，提高程式碼的整體品質，並降低了引入錯誤、修正錯誤的風險。\n簡單整理 類別在引入介面的時候，介面的方法全部都要實例，不要不實例\n程式碼範例 讓我們以一個簡單的例子來做思考：假設我們現在正在一家「交通工具生產公司」中工作，我們現在需要為公司製作一個簡單的「產品介紹系統」，該系統需要呈現各式交通工具的基本訊息（像是id、型號、大小、油槽容量、主要顏色、價格 \u0026hellip;等），而公司的產品包含但不限於汽車、機車、腳踏車、公車、遊艇、郵輪、飛機、直升機 \u0026hellip;等。在最最直觀的情況下，我們可以很直接地將每一個公司的產品，都視做一個獨立的類別進行分類，也就是像下面的這個樣子：\n// 汽車類別 class Car { // id, 型號, 價格, 顏色, 座位數量 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer numOfSeats; // 汽車的移動方式 public void driving() { System.out.println(\u0026#34;車子可以利用 4 個輪子，在道路上行駛\u0026#34;); } // 其他關於 [汽車] 的相關方法 // 其他關於 [汽車] 的相關方法 } // 機車類別 class Motorcycle { // id, 型號, 價格, 顏色, 置物空間, 排氣量 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer storageSpace; private Integer engineSize; // 機車的移動方式 public void driving() { System.out.println(\u0026#34;機車可以利用 2 個輪子，在道路上行駛\u0026#34;); } // 其他關於 [機車] 的相關方法 // 其他關於 [機車] 的相關方法 } \u0026hellip; (其他各式各樣的交通工具類別)\n\u0026hellip; (其他各式各樣的交通工具類別)\n// 直升機類別 class Helicopter { // id, 型號, 價格, 顏色, 載客量, 旋翼類型 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer capacityLimit; private String typeOfRotor; // 直升機的移動方式 public void flight() { System.out.println(\u0026#34;直升機可以利用旋翼，在天空中飛行\u0026#34;); } // 其他關於 [直升機] 的相關方法 // 其他關於 [直升機] 的相關方法 } 不難想像，這會是一個很龐大的工程。\n那麼，關於這個程式，我們有沒有什麼可以優化的地方呢？當然是有的～其中一種最簡單的優化方式就是「把相同功能的東西整理在一起」。對於這些「交通工具」類別來說，它們理論上都會有一些共同的參數（像是 id, name, price, color \u0026hellip;等），理論上也會有一些相同的行為（像是發動、熄火、某些工具可以在路上跑、在海上航行、在天空飛 \u0026hellip;等），所以我們可以把這些東西抽取出來做統一整理：\n// 抽象類別[交通工具]，也就是大家的父類別 abstract class Vehicle { // 包含像是 id, 型號, 價格, 和顏色 ...等共有的變數 protected String id; protected String name; protected Double price; protected String color; @Override public String toString() { System.out.println(\u0026#34;交通工具 [\u0026#34; + this.name + \u0026#34;], 價格為 NTD.\u0026#34; + this.price + \u0026#34;。\u0026#34;); } } // 抽象介面 [交通工具的相關動作]，可以統一存放交通工具能做的事 abstract interface IVehicleActions { // 一些像是啟動、熄火、加油 發出喇叭聲、行駛方式 ...等共同行為 public void start(); public void turnOff(); public void refuel(); public void soundTheHorn(); public void driving(); public void sailing(); public void flight(); } 再讓其他交通工具去繼承與實作，以［汽車］和［直升機］作為舉例：\n// 交通工具：[汽車] 類別 class Car extends Vehicle implements IVehicleActions { // [汽車]獨有的變數 private Integer numOfSeats; // 建構子，用於初始化 Vehicle 和自己的所有的變數 public Car(String id, String name, Double price, String color, Integer numOfSeats) { this.id = id; this.name = name; this.price = price; this.color = color; this.numOfSeats = numOfSeats; } // 實例化一些 IVehicleActions 的方法 @Override protected void start() { System.our.println(\u0026#34;汽車發動引擎 ～\u0026#34;); } @Override protected void turnOff() { System.our.println(\u0026#34;汽車熄火 ...\u0026#34;); } // 其他 [汽車] 裡面的好多方法 ... // 其他 [汽車] 裡面的好多方法 ... } // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 // 交通工具：[直升機] 類別 class Helicopter extends Vehicle implements IVehicleActions { // [直升機]獨有的變數 private Integer capacityLimit; private String typeOfRotor; // 建構子，用於初始化 Vehicle 和自己的所有的變數 public Helicopter(String id, String name, Double price, String color, Integer capacityLimit, String typeOfRotor) { this.id = id; this.name = name; this.price = price; this.color = color; this.capacityLimit = capacityLimit; this.typeOfRotor = typeOfRotor; } // 實例化一些 IVehicleActions 的方法 @Override protected void start() { System.our.println(\u0026#34;直升機發動引擎 ～\u0026#34;); } @Override protected void turnOff() { System.our.println(\u0026#34;直升機熄火 ...\u0026#34;); } // 其他 [直升機] 裡面的好多方法 ... // 其他 [直升機] 裡面的好多方法 ... } 透過繼承和實作共同的類別與介面，我們成功地讓不同的交通工具類別產生了關聯，進而完整了程式的架構、提高了程式的可讀性，解決了原本「零散」的問題，同時，因為通過繼承和實作，在其他程式想要調用這些［交通工具］類別的時候，它們就可以用更加統一、更加一致的方式去進行呼叫，減少了其他程式的複雜性。整體來說，相對於版本 1 的程式，版本 2 的泛用程度得到了很大的提升。\n那麼，在這個版本 2 已經完成的情況下，我們的系統還有什麼更好的修改方式嗎？或者是說，它還有什麼美中不足的小缺點嗎？答案同樣是 \u0026hellip;有的。即便是經過了更新的版本 2 程式，它仍然還有著一些缺陷，其中一個缺陷便是「版本 2 的程式，沒有遵守『介面隔離原則』」。而這也就是我們從現在的版本 2，升級成等等的版本 3 之間，主要要關注的一個問題。\n在「介面隔離原則」的論述中有提到：「一個類別如果有需要實作的介面，那麼該類別必須實作介面中的所有方法。」這聽起來在 Java 似乎是很廢話的一段敘述，因為在 Java 的規則中，一個類別如果想要實例化一個介面，類別本來就會需要改寫所有介面中的方法。但一個重要的設計原則，不應該是一句廢話吧？所以這句話的真實意涵並不是表面上的那樣，事實上它在說的是：「類別如果要繼承一個介面，則該介面裡的『所有方法』都要對類別有用。」\n這是什麼意思呢？用版本 2 的交通工具程式舉例：在版本 2 中，汽車類別 Car 同時繼承了 Vehicle 的類別與實作 IVehicleActions 介面。其中 IVehicleActions 中包含著許多的方法，像是 start, turnOff, refuel \u0026hellip;等。而在這之中，IVehicleActions 定義的「交通工具行駛方式」並不是類似於單純的 move()，而是更加細節地分成了 driving(), sailing(), 和 flight() 3 種方法。\ndriving() 代表的是「在路上跑」。這對 Car 本身沒有什麼問題，改寫的方式也很簡單，加上「汽車可以在路上跑」之類的論述就可以了。重點在於後面的兩個方法：通常來說，一台普通的汽車並不能做到航行（sailing()）與飛行（flight()）這兩件事，也因此，當 Car 在嘗試作 IVehicleActions 的時候，便會發生「雖然我需要實作 sailing() 和 flight()，但我根本用不到它們啊！」的情況：\nclass Car extends Vehicle implements IVehicleActions { // 前面的一些程式內容 // 前面的一些程式內容 // 前面的一些程式內容 // [汽車]可以在路上行駛，因此沒問題 @Override protected void driving() { System.our.println(\u0026#34;車子可以利用 4 個輪子，在道路上行駛\u0026#34;); } // 但 [汽車] 不會在海上跑、在天上飛 // 所以出現了「實作了，但實際上完全沒有做事」的情況 @Override public void sailing() {} @Override public void flight() {} } 這樣一來，便會產生一些「無效的程式」，也就是在功能上，即便寫了也等於沒寫的一些程式。而這個問題不單單只有 Car 有，事實上，在版本 2 的設計架構下，無論是機車、腳踏車、船、飛機 \u0026hellip;等，只要該交通工具沒有辦法同時達成陸、海、空的行駛，類別的程式裡面就會出現這樣的問題。因此，我們可以針對這一點對程式作出改善，準確來說是對介面做改善，就像是下面的這個樣子：\n// 抽象類別[交通工具]，沒有任何改變 abstract class Vehicle { protected String id; protected String name; protected Double price; protected String color; @Override public String toString() { System.out.println(\u0026#34;交通工具 [\u0026#34; + this.name + \u0026#34;], 價格為 NTD.\u0026#34; + this.price + \u0026#34;。\u0026#34;); } } // 第 1 層抽象介面[交通工具]，用來定義所有交通工具都會的動作 abstract interface IVehicleActions { public void start(); public void turnOff(); public void refuel(); public void soundTheHorn(); } // 第 2 層抽象介面[交通工具]，用來定義不同陸海空交通工具的動作 // 抽象介面 [陸上交通工具] abstract interface ILandVehicleActions implements IVehicleActions { // 原本的方法維持抽象 public abstract void start(); public abstract void turnOff(); public abstract void refuel(); public abstract void soundTheHorn(); // 只有[陸上交通工具]可以「在路上行駛」 public void drining(); } // 抽象介面 [海上交通工具] abstract interface IWatercraftActions implements IVehicleActions { // 原本的方法維持抽象 public abstract void start(); public abstract void turnOff(); public abstract void refuel(); public abstract void soundTheHorn(); // 只有[海上交通工具]可以「在海上航行」 public void sailing(); } // 抽象介面 [空中交通工具] abstract interface IAircraftActions implements IVehicleActions { // 原本的方法維持抽象 public abstract void start(); public abstract void turnOff(); public abstract void refuel(); public abstract void soundTheHorn(); // 只有[空中交通工具]可以「在天上飛」 public void flight(); } // 實體類別，包含車子、船、飛機 ...等 class Car extends Vehicle implements ILandVehicleActions { // 前面的一些程式內容 // 前面的一些程式內容 // 前面的一些程式內容 // [汽車] 繼承 [陸上交通工具] // 所有的方法對於汽車來說都是有用的 (good~) @Override public abstract void start() { System.out.println(\u0026#34;啟動汽車引擎\u0026#34;); } @Override public abstract void turnOff() { System.out.println(\u0026#34;汽車熄火 ...\u0026#34;); } @Override public abstract void refuel() { System.out.println(\u0026#34;汽車加油 ~ 加油 ~\u0026#34;); } @Override public abstract void soundTheHorn() { System.out.println(\u0026#34;按喇叭：叭！！！叭！！！叭！！！\u0026#34;); } @Override public void drining() { System.out.println(\u0026#34;汽車可以在路上跑\u0026#34;); } } // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 其他類似的交通工具也可以透過實作不同的第 2 層介面，來達成它們的完整功能（像是 Boat 實作 IWatercraftActions，Airplane 實作 IAircraftActions \u0026hellip;等）。除此之外，如果系統有需要的話，我們其實還可以再切割出更多的介面來（像是油車、電動車、人力交通工具 \u0026hellip;等）。而這種「透過將介面拆分和隔離，讓實作的類別可以實現最為貼切的方法」的程式撰寫方式，就是介面隔離原則想要傳達的訊息。\n"},{"id":20,"href":"/docs/computer_science/design_pattern/dependency_inversion_principle/","title":"依賴反轉原則","section":"設計模式","content":"\r依賴反轉原則\r#\rChatGPT 的說明 依賴反轉原則（Dependency Inversion Principle，DIP）是 SOLID 原則中的一個重要原則，由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則的核心思想是：「高層模組不應該依賴低層模組，它們都應該依賴於抽象。」簡而言之，依賴從實例反轉至抽象，使系統更靈活、可維護和可擴展。依賴反轉原則包括了以下的幾個關鍵概念：［高層模組］高層模組通常是應用程式中，較高層級的模組（或元件），通常包括一些業務邏輯、應用程式的核心功能、或者其餘更加廣泛、更加抽象的概念。［低層模組］低層模組是應用程式中，較低層級的模組（或元件），通常包括一些與硬體、資料庫、外部服務 \u0026hellip;等實體類的互動。低層模組的實作細節可能會根據不同的交互對象，而發生各式各樣的變化，而但高層模組不應受到這些變化的影響。\n［抽象］抽象是一種介面、抽象類別、或抽象資料類型，它定義了「高層模組」和「低層模組」之間的通訊協定、互動規則、或契約。高層模組通常會依賴這個抽象，而不是依賴特定的低層模組，以實現更具彈性的程式邏輯。［具體實作］具體實作是低層模組的具體程式碼，它們實作了「抽象」中所定義的方法和行為。［依賴反轉］依賴反轉是指高層模組不直接依賴低層模組，而是依賴共享的抽象。這意味著高層模組和低層模組都依賴相同的抽象，而不是其餘的依賴情形，這種依賴方式這可以透過依賴注入、工廠模式、反射 \u0026hellip;等技術來實現。［依賴注入］依賴注入是一種常見的實現依賴反轉的方式，它透過將依賴物件傳遞給高層模組，而不是由高層模組自行創建依賴物件。這使得高層模組可以更靈活地切換不同的依賴物件。\n透過依賴反轉原則，我們可以提耕城市許多面向的性能，包含以下幾種：［減少耦合性］依賴反轉原則的主要目標是減少模組之間的耦合性，當高層模組依賴低層模組的具體實現時，它們之間的耦合性很高，任何對低層模組的變更都可能導致高層模組受到影響。但透過使用抽象和依賴反轉，可以減少這種耦合性，使得系統更容易維護和擴展。［增加可測試性］依賴反轉原則有助於提高程式碼的可測試性。透過將依賴關係從具體的實作中解耦，可以使用模擬物件（或虛擬物件）取代原本的依賴物件進行單元測試，從而更容易驗證高層模組的行為。\n簡單整理 透過讓高層模組和低層模組依賴相同的抽象類別，達到靈活且具彈性的程式\n程式碼範例 從純粹的程式碼上面來說，依賴反轉原則總共有三個重要的組成，分別是「低層模組」「高層模組」和「抽象類別」三種。其中，低層模組指的是「零件」，算是構成整個系統裡面，比較基礎、比較單純、比較不複雜的部分。如果拿一個 RPG 遊戲來做舉例的話，「低則模組」就有點像是刀、劍、弓、法杖、斧頭、藥水、衣服、靴子 \u0026hellip;等比較小塊、比較基本、物件本身比較不會有太多變化的東西。\n「高層模組」指的則是由數個（或數十個）低層模組所組合而成的一個複雜類別，通常可以執行一些相對低層模組來說，更為複雜的操作。同樣拿 RPG 遊戲來舉例的話，高層模組可以是一個角色、一支隊伍、一個公會、一座城市、或者是一組軍團\u0026hellip;等等。通常來講，高層模組和低層模組是一個「比較」的概念，如果視野是放在一個 角色 跟上，那麼角色就是高層模組、角色所攜帶的各種物品就是低層模組；如果視野是放在一支隊伍、更甚至於一組軍團上面，那麼 角色 在這裡可能就變成了低層模組。\n一般來說，在不使用「依賴反轉原則」的前提下，如果我們想要製作出一個高層模組（和它應有的功能）的話，我們通常會使用直接依賴的方式來完成，就如同下面的類別所示，一個角色與它身上的各種五花八門的配備：\n// 角色類別 class Character { // 一個角色可能擁有的所有屬性 // 這邊只包含血量、魔力、攻擊力、和防禦力 private Integer hp; private Integer mp; private Integer atk; private Integer def; // 一個角色可能擁有的各種武器 // 這邊包含了刀、劍、弓、法杖、斧頭、匕首、盾牌 ...等 private Blade blade; private Sword sword; private Bow bow; private Staff staff; private Axe axe; private Dagger dagger; private Shield shield; // 一個角色可能擁有的各種護具 // 這邊包含了頭盔、胸甲、護肘、護膝、鞋子 ...等 private Helmet helmet; private Breastplate breastplate; private ElbowGuard elbowGuard; private KneeGuard kneeGuard; private Footwear footwear; // 一個角色可能擁有的所有道具 // 這邊只列出一些藥水、食品類型的道具 // 藥水因為可以複數持有，所以是陣列 private HealthPotion[] healthPotion; private ManaPotion[] manaPotion; private AttackPotion[] attackPotion; private DefensePotion[] defensePotion; private Bread[] bread; private Water[] water; private Chicken[] chicken; private Beef[] beef; private Pork[] pork; // 還有其他好多好多角色可能可以持有的東西 ... // 還有其他好多好多角色可能可以持有的東西 ... } 可以看到，這個角色目前是以「只有最基本的幾種武器可以選擇」「只有最基本的防具可以選擇」「只有一些已經定義好的物品可以選擇」的狀況來做設計。此外，這些成員變數僅僅也只是「變數」而已，還不含各種武器的攻擊方法、各種防具的穿戴方式、各種物品的使用方式 \u0026hellip;等幾十種（甚至是幾百種）方法。而光是這樣，這個「角色」的高層模組就已經依賴了至少 20 種不同的低層模組了。現在讓我們想想：如果今天我們想要在 Blade 類別裡面新增幾種不同的攻擊方式、如果我們要在 Bow 類別新增一個「根據不同等級的箭矢有著不同的攻擊力」的小小功能、如果我們今天想要為各種防具進行不同屬性強化、如果我們今天想要讓法杖擁有不同屬性的攻擊方式、如果、如果、如果 \u0026hellip;\n很明顯地，這種「把所有具體的類別全部都塞在一個高層模組」的程式實現方式非常的可怕，對吧？因為高層模組（Character）對低層模組（所有東西）有著重度的依賴，因此只要任何一個模組發生了改變、細節上出了點變化、需要做點增刪查，那麼都有可能會影響到整個 Character 的程式內容。因此，在這樣的情況下，就很適合利用「依賴反轉原則」來對程式進行改寫：\n依賴反轉原則的做法主要有 3 步：\n首先是「建立一個介面、或一個抽象類別。」在實際的程式專案中，抽象類別或者是介面是一個鮮少會去做更動的程式部件。通常只有在專案需要大改，或者是程式架構需要重新調整的時候，才會進行一些編輯跟撰寫。這個樣的特性，很適合拿來放在這種「可以的話，勁量不要去做更動」的地方上面。因此我們首先要做的，就是要為這些角色所能擁有的所有東西，進行一個抽象類（或介面）的宣告：\n// 定義了名為 [武器][防具] 和 [道具] 的抽象類別 abstract class Weapon { public abstract void attack(); } abstract class Armor { public abstract void wear(); public abstract void takeOff(); } abstract class Item { public abstract void use(); } 接下來，我們要讓「低層模組」去依賴「抽象」。白話文來說，就是要讓這些裝備去繼承這些抽象類別，讓它們變得不再零散、不再紊亂，可以有一個大致上的秩序或分類，以便於其他類別（或介面）想要調用它們的時候，可以有一個整齊的、統一的收發通道，而不再是讓這些低層模組各自爲政，每個人有不同的方法、不同的名稱、不同的特性、不同的前置條件、或不同的後續效果 \u0026hellip;\n// 讓所有的 [低層模組] 去依賴剛剛生成的 [抽象] // Weapon 類型 class Blade extends Weapon {}; class Sword extends Weapon {}; class Bow extends Weapon {}; class Staff extends Weapon {}; class Axe extends Weapon {}; class Dagger extends Weapon {}; class Shield extends Weapon {}; // Armor 類型 class Helmet extends Armor {}; class Breastplate extends Armor {}; class ElbowGuard extends Armor {}; class KneeGuard extends Armor {}; class Footwear extends Armor {}; // Item 類型 class HealthPotion extends Item {}; class ManaPotion extends Item {}; class AttackPotion extends Item {}; class DefensePotion extends Item {}; class Bread extends Item {}; class Water extends Item {}; class Chicken extends Item {}; class Beef extends Item {}; class Pork extends Item {}; 當然啦，上面的例子並不完全，因為這些依賴的抽象之後的低層模組並沒有實際去覆寫原本抽象類別中的抽象方法（attack(), wear, takeOff, 和 use），但因為這邊只是一個小小的展示，沒有要實際上把程式給跑起來，所以就先省略掉這個步驟了。實際上各種不同的低層模組在依賴這些抽象類別或介面的時候，還是需要進行方法上面的改寫跟實作的，還是要稍微注意一下。\n最後，在做完前兩部之後，我們再來要做的，就是把高層模組所依賴的對象，從「特定的 xx 低層模組」切換成「抽象類別（或介面）」。透過依賴一個低層模組統一都有依賴到的抽象，我們可以很輕鬆且很有效率地改善原本高層模組中的重度依賴：現在 Character 只需要有三個不同的成員變數，就可以持有之前所涵蓋到的 20-30 種不同的具體類別了，程式的改善效率以指數的量級做提升：\n// 角色類別 class Character { // 角色所擁有的所有屬性（照舊） private Integer hp; private Integer mp; private Integer atk; private Integer def; // 現在不需要依賴各式各樣的具體類別來達成原本的功能 // 只要依賴一個統一的抽象類別就可以了 Weapon weapon; Armor[] armors; Item[] package; // 其他 [角色] 所擁有的方法 ... // 其他 [角色] 所擁有的方法 ... } 除了程式行數的大幅減低之外，這樣做還有另外一個好處：因為無論是 Weapon, Aromr 還是 Item，因為在這些抽象類別中，我們有定義一個統一的調用方法（像是 attack(), wear() \u0026hellip;等），所以我們可以很簡單地透過類似於 weapon.attack() 的程式寫法，來打成一個「攻擊」的功能，哪怕是任何的武器，哪怕不同的武器有著自己的攻擊方法，都可以用很簡潔且很容易閱讀的方式完成我們想要的功能。\n// 假設不同的 [低層模組] 因為各自的差異而有不同的方法名稱 // 但因為它們都有一個統一依賴的 [抽象類別] // 因此無論原本的攻擊叫什麼名字，它們還是要實作出統一的抽象方法 // 以部分 Weapon 類型舉例 class Blade extends Weapon { public void stab() { System.out.println(\u0026#34;用刀前刺\u0026#34;); } public void slash() { System.out.println(\u0026#34;用刀揮砍\u0026#34;); } public void chop() { System.out.println(\u0026#34;用刀劈斬\u0026#34;); } // 繼承自 Weapon 的 attack() 方法 @Override public void attak() { // 用一些判斷邏輯，決定要進行哪一種攻擊 } }; class Sword extends Weapon { // 繼承自 Weapon 的 attack() 方法 @Override public void attak() { // 單純攻擊 System.out.println(\u0026#34;利用手上的劍進行攻擊\u0026#34;); } } // 其他各種 [武器][防具] 和 [道具] 的程式細節 ... // 其他各種 [武器][防具] 和 [道具] 的程式細節 ... // 其他各種 [武器][防具] 和 [道具] 的程式細節 ... class Character { // 一些原本就有的成員變數 .. // 一些原本就有的成員變數 .. // 現在 [角色] 只需要進行 \u0026#39;攻擊\u0026#39; 方法 // 不需要知道武器實際的攻擊方法為何 // 反正只要透過 weapon 然後呼叫 attack()就行 public void attack() { weapon.attack(); } // 一些其他的 [角色] 方法 ... // 一些其他的 [角色] 方法 ... } 透過將依賴反轉過來（原本：高 \u0026gt; 低）（現在：高, 低 \u0026gt; 抽象），讓高層模組和低層模組都去依賴一個幾乎不會變動、且擁有多元方法的抽象類別（或介面），就可以讓程式變得更加靈活、更加簡潔。如果高層模組需要抽換其他的低層模組的時候，也只需要寫上類似 public void setWeapon(Weapon weapon) 之類的方法，就可以輕易地替換掉了。這就是依賴反轉原則所想要傳達的理念、與它所帶來的好處。\n"},{"id":21,"href":"/docs/finance/track_expenses/","title":"個人記帳","section":"理財規劃","content":"\r個人記帳\r#\r2023/08 2023/09 "},{"id":22,"href":"/docs/_trash/builder_pattern/","title":"創建者模式","section":"Docs","content":"\r創建者模式\r#\rChatGPT 的說明 創建者模式（Builder Pattern）是一種創建型設計模式，旨在透過將複雜物件的建置流程拆分為多個簡單物件的建置步驟，使得物件的建置流程更加靈活、可維護，同時提供更好的控制和自訂選項。創建者模式的主要想法是將一個複雜物件的建構與其表示分開。這使得客戶端程式碼可以更容易地配置和建立複雜對象，而無需了解對象的內部建置細節。創建者模式通常包括以下關鍵角色：［產品］（Product）：產品表示被建構的複雜物件。產品類別通常包含多個屬性或部分，這些部分的創建和組裝由創建者負責。［抽象創建者］（Abstract Builder）：抽象創建者定義了建構產品物件的抽象接口，包括各個部分的創建方法。抽象創建者通常包括一個獲取最終產品的方法。［具體創建者］（Concrete Builder）：具體創建者實現了「抽象創建者」的接口，負責構建產品的各個部分，同時提供了設置產品屬性的方法。每個特定創建者可以建立不同的產品變體。［指揮者］（Director）：指揮者負責依照客戶端的需求，按照一定順序呼叫特定創建者的方法來建構產品物件。指揮者不負責特定產品的創建，而是協調創建者完成建造。［客戶端］（Client）：客戶端程式碼透過指揮者來建立複雜對象，並可以根據需要選擇不同的特定創建者，來建構不同的產品變體。\n創建者模式的主要優點包括：分離建造過程和表示，允許更容易建造不同的產品變體；提供了更好的控制和客製化選項，客戶端可以自訂產品的建置流程；支援逐步建構複雜對象，使得建置過程更加靈活；提高了程式碼的可維護性，將複雜建置過程封裝在特定創建者中，使得客戶端不需要知道具體的創建細節；創建者模式在需要建立具有多個配置選項或參數的複雜物件時非常有用，例如建立圖形使用者介面中的視窗、建立文件物件、建立複雜的資料結構等情況。它幫助管理和組織複雜物件的建置過程，使程式碼更具可讀性和可維護性。\n簡單整理 問題描述：複雜物件往往由許多不同的必選/可選物件組成，使得建立起來非常複雜\n解決方案：封裝一系列的變數和設置，令創建複雜物件不再麻煩\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 所謂的複雜物件，在這邊指的是需要經由各個小物件進行合成（或聚合）之後，才可以被生成的物件。用現實生活來舉例的話，就像是一輛汽車（需要引擎、車輪、車殼、排氣管、油箱 \u0026hellip;等部件組成）一棟房子（需要大門、牆壁、屋頂、水電、床鋪、書櫃 \u0026hellip;等物件組成）或者是一台電腦（需要鍵盤、滑鼠、螢幕、主機板、CPU、記憶體、硬碟 \u0026hellip;等元件組成）。就拿電腦來舉例好了：假設我們在程式中需要模擬一台電腦被創建的過程，大概會像是下面的這個樣子：\nclass Main { public static void main(String args[]) { // 組成電腦的小物件們 MotherBoard motherBoard = new MotherBoard(); CPU cpu = new CPU(); Memory memory = new Memory(); Disk disk = new Disk(); Power power = new Power(); ComputerTower computerTower = new ComputerTower(motherBoard, cpu, memory, disk, power); Keyboard keyboard = new Keyboard(); Mouse mouse = new Mouse(); Monitor monitor = new Monitor(); // [電腦] 本身 Computer computer = new Computer(computerTower, keyboard, mouse, monitor); } } 接著我們繼續往下想：是全世界所有的電腦都不多不少，由這幾種元件所組成嗎？如果我今天只需要一台架站的伺服器電腦，那我是不是只需要主機就好？如果我今天是一個辦公室的文書機，我應該還要再加上一個印表機的連線吧？如果我今天是給阿公阿嬤用的電腦，他們會不會用到光碟機之類的元件？如果我今天是一個電競選手，是不是還需要 GPU 和幾個固態硬碟？如果我今天是一個實況主，那麼裝一個攝影機用來捕捉畫面應該很重要吧？如果\u0026hellip; 如果\u0026hellip; 如果\u0026hellip;。假設我們要把所有可能的狀況全部都定義出來的話，那麼 Computer 的程式很有可能會長得像是下面這個樣子：\nclass Computer { public Computer(ComputerTower computerTower) {}; public Computer(ComputerTower computerTower, Monitor monitor) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard) {}; public Computer(ComputerTower computerTower, Monitor monitor, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, GPU gpu) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, Printer printer) {}; public Computer(ComputerTower computerTower, Monitor monitor1, Monitor monitor2, Keyboard keyboard, Mouse mouse) {}; // 其他 100 種建構子 ... } 發現問題了嗎？我們根本定義不完所有可能的情況組合，對吧。這種「建構子過多」的情況在英文裡叫做 Telescoping constructor，中文可以譯成「伸縮式建構子」，是一個光聽名字感覺還好，但實際上非常令人頭疼的一種程式寫法。為什麼說它令人頭疼呢？主要有以下幾個原因：首先是［可讀性很差］，我們很難快速地看出創建出 Computer 的是哪一個建構子；其次是［低彈性］，因為我們必須要按照固定的參數順序填入，很難做比較動態的調整；再來是［null 的狀況］，因為不是所有的元件都需要被安裝到電腦上，因此在建構 Computer 的過程中，應該要允許部分參數可為 null 值，但這樣可能會導致建構子中有過多 null 的情況，更惡化可讀性的問題。因此，為了解決 Telescoping constructor 所帶來的問題，其中的一種方法是「把所有的參數都修改為可以透過 setter 設定」，就像是下面這樣：\nclass Computer { // 電腦的不同元件們 private ComputerTower computerTower; private Monitor monitor; private Keyboard keyboard; private Mouse mouse; private Printer printer; private GPU gpu; private Speaker speaker; private Webcam webcam; private Microphone microphone; // 現在不再需要那麼多的建構子了，只需要這個 public Computer() {}; // 所有元件的 setter() 方法 public void setComputerTower(ComputerTower computerTower) { this.computerTower = computerTower; } public void setMonitor(Monitor monitor) { this.monitor = monitor; } public void setKeyboard(Keyboard keyboard) { this.keyboard = keyboard; } public void setMouse(Mouse mouse) { this.mouse = mouse; } public void setPrinter(Printer printer) { this.printer = printer; } // 其他 setter() ... // 其他 setter() ... } class Main { public static void main(String ags[]) { // 創建一個 \u0026#34;空電腦\u0026#34; Computer computer = new Computer(); // 自己加想加的元件上去 computer.setComputerTower(new ComputerTower()); computer.setMonitor(new Monitor()); computer.setKeyboard(new Keyboard()); computer.setMouse(new Mouse()); } } 看上去挺不錯的，對吧？至少我們現在不用再先寫出 20-30 個不同的 Computer 的建構子。但這麼做還是有一點點小問題：我們沒有辦法保證所有使用到 Computer 的類別，都有把所有必要的元件給加上去。如果今天有一支程式在創建 Computer 的時候，忘記把主機板（MotherBoard）給加上去，程式就無法順利運行了，對吧？畢竟這世界上的所有電腦，都需要使用到主機板。因此，我們需要更「系統性地」解決 \u0026ldquo;創建物件\u0026rdquo; 的問題，就可以使用到創建者模式了：\n在物件導向程式設計中，伸縮式建構子（英文叫做 Telescoping constructor）是一種用來說明「提供多種不同參數組合的建構子，以利於物件生成」的詞彙。一般來說，伸縮式建構子只會在複雜物件的類別中出現，而所謂的複雜物件，指的則是經由不同子部件所組成的大型物件，用比較貼近生活的例子來說的話，複雜物件就像是一台汽車（由引擎、輪胎、車殼、窗戶、排氣管、方向盤 \u0026hellip;等物件組成）一棟房子（由牆壁、大門、窗戶、屋頂、床、書桌 \u0026hellip;等物件組成）或者是一台電腦（由鍵盤、滑鼠、螢幕、主機板、CPU、硬碟 \u0026hellip;等物件組成）之類的東西。\n"},{"id":23,"href":"/docs/computer_science/design_pattern/builder_pattern/","title":"創建者模式","section":"設計模式","content":"\r創建者模式\r#\rChatGPT 的說明 創建者模式（Builder Pattern）是一種創建型設計模式，旨在透過將複雜物件的建置流程拆分為多個簡單物件的建置步驟，使得物件的建置流程更加靈活、可維護，同時提供更好的控制和自訂選項。創建者模式的主要想法是將一個複雜物件的建構與其表示分開。這使得客戶端程式碼可以更容易地配置和建立複雜對象，而無需了解對象的內部建置細節。創建者模式通常包括以下關鍵角色：［產品］（Product）：產品表示被建構的複雜物件。產品類別通常包含多個屬性或部分，這些部分的創建和組裝由創建者負責。［抽象創建者］（Abstract Builder）：抽象創建者定義了建構產品物件的抽象接口，包括各個部分的創建方法。抽象創建者通常包括一個獲取最終產品的方法。［具體創建者］（Concrete Builder）：具體創建者實現了「抽象創建者」的接口，負責構建產品的各個部分，同時提供了設置產品屬性的方法。每個特定創建者可以建立不同的產品變體。［指揮者］（Director）：指揮者負責依照客戶端的需求，按照一定順序呼叫特定創建者的方法來建構產品物件。指揮者不負責特定產品的創建，而是協調創建者完成建造。［客戶端］（Client）：客戶端程式碼透過指揮者來建立複雜對象，並可以根據需要選擇不同的特定創建者，來建構不同的產品變體。\n創建者模式的主要優點包括：分離建造過程和表示，允許更容易建造不同的產品變體；提供了更好的控制和客製化選項，客戶端可以自訂產品的建置流程；支援逐步建構複雜對象，使得建置過程更加靈活；提高了程式碼的可維護性，將複雜建置過程封裝在特定創建者中，使得客戶端不需要知道具體的創建細節；創建者模式在需要建立具有多個配置選項或參數的複雜物件時非常有用，例如建立圖形使用者介面中的視窗、建立文件物件、建立複雜的資料結構等情況。它幫助管理和組織複雜物件的建置過程，使程式碼更具可讀性和可維護性。\n簡單整理 問題描述：複雜物件往往由許多不同的必選/可選物件組成，使得建立起來非常複雜\n解決方案：封裝一系列的變數和設置，令創建複雜物件不再麻煩\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在物件導向程式設計中，伸縮式建構子（英文叫做 Telescoping constructor）是一種用來說明「提供多種不同參數組合的建構子，以利於物件生成」的詞彙。一般來說，伸縮式建構子只會在複雜物件的類別中出現，而所謂的複雜物件，指的則是經由不同子部件所組成的大型物件，用比較貼近生活的例子來說的話，複雜物件就像是一台汽車（由引擎、輪胎、車殼、窗戶、排氣管、方向盤 \u0026hellip;等物件組成）一棟房子（由牆壁、大門、窗戶、屋頂、床、書桌 \u0026hellip;等物件組成）或者是一台電腦（由鍵盤、滑鼠、螢幕、主機板、CPU、硬碟 \u0026hellip;等物件組成）之類的東西。用程式的方式呈現大概會像這個樣子：\nclass Main { public static void main(String args[]) { // 組成電腦的小物件們 MotherBoard motherBoard = new MotherBoard(); CPU cpu = new CPU(); Memory memory = new Memory(); Disk disk = new Disk(); Power power = new Power(); ComputerTower computerTower = new ComputerTower(motherBoard, cpu, memory, disk, power); Monitor monitor = new Monitor(); Keyboard keyboard = new Keyboard(); Mouse mouse = new Mouse(); // [電腦] 本身 Computer computer = new Computer(computerTower, monitor, keyboard, mouse); } } class Computer { public Computer(ComputerTower computerTower) {}; public Computer(ComputerTower computerTower, Monitor monitor) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard) {}; public Computer(ComputerTower computerTower, Monitor monitor, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, GPU gpu) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, Printer printer) {}; public Computer(ComputerTower computerTower, Monitor monitor1, Monitor monitor2, Keyboard keyboard, Mouse mouse) {}; // 其他的建構子和方法 ... } 但 Telescoping constructor 就像是其他的設計模式一樣，並不是一個在任何情況下都很適合使用的程式撰寫技巧，至少從上面的這個例子來說，我們可以單純從 Computer 的建構子們觀察到幾個比較明顯的問題：首先是［程式的維護成本］，因為 Computer 類別存在著多個不同的建構子，當有程式想要實作 Computer 物件的時候，我們很難第一眼就看出程式使用的是哪一個建構子，這會使得程式的維護成本變得很高。其次是［程式的彈性很低］，因為建構子侷限了 Computer 物件需要怎麼樣被生成，子物件需要按照一定的數量與順序被放進建構子中，這會使得程式整體的彈性變低，且各類別對於 Computer 中子物件的依賴程度也會變高。\n但無論是「建構子的數量過多」，還是「生成複雜物件需要依賴一定數量的子部件」，都可以透過一種方式來解決：那就是 \u0026ldquo;讓建構子中的參數允許 null 的存在\u0026rdquo;。透過允許 null 的存在，可以建構子們通通歸納在一起，變成一個「包含了所有部件的建構子」。並透過 null 的方式，彈性地選擇不同類型的要用哪一些電腦中的子部件來生成 Computer 這個複雜物件，就像是下面的這個樣子：\nclass Computer { // 一個包含了所有電腦可以配置的物件的建構子 public Computer(ComputerTower computerTower, Monitor monitor1, Monitor monitor2, Keyboard keyboard, Mouse mouse, GPU gpu, Earphone earphone, Speaker speaker, Webcam webcam, Touchpad touchpad, Scanner scanner, Printer printer) { this.computerTower = computerTower; this.monitor1 = monitor1; this.monitor2 = monitor2; this.keyboard = keyboard; this.mouse = mouse; this.gpu = gpu; this.earphone = earphone; this.speaker = speaker; this.webcam = webcam; this.touchpad = touchpad; this.scanner = scanner; this.printer = printer; }; } // 某間公司的 [伺服器主機] 類別 class Server { // 生成一台電腦，並將該電腦當成伺服器主機 public Computer getServer() { // 假設這台伺服器只需要主機、GPU、跟印表機 ComputerTower computerTower = new new ComputerTower(); GPU gpu = new Gpu(); Printer printer = new Printer(); // 把電腦做出來 Computer computer = new Computer(computerTower, null, null, null, null, gpu, null, null, null, null, null, printer); return computer; } } 原本的問題得到了解決，但新的問題也應運而生：那就是［可讀性變差］。雖然在建構子裡面包含 null 並不是一件少見的事情，但在一個建構子裡面，有絕大多數的參數都是 null 就真的很少見了。這種程式在第一眼很容易會讓人有「阿放了那麼多 null，為什麼不乾脆再拉一個建構子出來啊？」的感覺（然後程式就會重新跳回上面的問題）。除此之外，一個更令人感到頭疼的問題是：如果我今天想要加一個子部件進去，我有辦法很快地知道哪個部件要放在哪裡嗎？或者說得簡單一點：你可以很快地告訴我建構子裡面， GPU 之後第 2 個 null 原本放的是什麼東西嗎？\n因此，為了解決「建構子的數量繁雜」「建構子會讓程式的彈性降低」與「建構子的可讀性真低」這三個交織在一起的問題，Builder pattern（創建者模式）的程式寫法就被發明出來了。它有點像是吸收了兩邊的優點所創造出來的模式：透過 Builder 生成複雜物件中的子部件，透過 Director 管理和執行需要生成的物件，使用者（Client）就只需要呼叫 Director 中的 getResult() 方法，就可以無痛得到預期中的複雜物件，就像是下面這樣：\n// 複雜物件 Computer 類別 class Computer { // 所有的子部件們 private ComputerTower computerTower; private Monitor monitor; private Keyboard keyboard; private Mouse mouse; private GPU gpu; private Earphone earphone; private Speaker speaker; private Webcam webcam; private Touchpad touchpad; private Scanner scanner; private Printer printer; // 現在 Computer 只有一個建構子，而且沒有任何內容 public Computer() {}; } // Builder 類別，用來創建各種不同的子部件 class ComputerComponentsBuilder { // 要生成的目標物件 private Computer computer; // Builder 的建構子，用以生成一台全新的電腦 public ComputerComponentsBuilder() { this.computer = new Computer(); } // Computer 中，所有部件的設定方法 // Computer 中，所有部件的設定方法 public void buildComputerTower() { this.computer.computerTower = new ComputerTower(); } public void buildMonitor() { this.computer.monitor = new ComputerTower(); } public void buildKeyboard() { this.computer.keyboard = new Keyboard(); } public void buildMouse() { this.computer.mouse = new Mouse(); } public void buildGPU() { this.computer.gpu = new GPU(); } public void buildEarphone() { this.computer.earphone = new Earphone(); } public void buildSpeaker() { this.computer.speaker = new Speaker(); } public void buildWebcam() { this.computer.webcam = new Webcam(); } public void buildTouchpad() { this.computer.touchpad = new Touchpad(); } public void buildScanner() { this.computer.scanner = new Scanner(); } public void buildPrinter() { this.computer.printer = new Printer(); } // 用來回傳最後結果的 getResult() 方法 public Computer getResult() { return this.computer; } } // Director 類別，用來控管 Computer 的建立、配置、和回傳 class ComputerDirector { public Computer getResult() { // Builder 物件 ComputerComponentsBuilder builder = new ComputerComponentsBuilder(); // 這邊同樣以「主機 + GPU + 印表機」的伺服器為例子 builder.buildComputerTower(); builder.buildGPU(); builder.buildPrinter(); // 回傳最後生成的結果 Computer computer = builder.getResult(); return computer; } } class Client { public static void main(String args[]) { ComputerDirector director = new ComputerDirector(); Computer computer = director.getResult(); } } 為了方便理解上面的程式架構，我們同樣用生活中的例子來做說明：Director 因為是負責管理和調度複雜物件 Computer 的建立過程，因此我們可以把它想像成類似 \u0026ldquo;原價屋\u0026rdquo; 的角色；而 Builder 因為是負責提供各式各樣不同實體子部件的角色，所以它類似於 \u0026ldquo;硬體供應商\u0026rdquo;，而 Client 不用多說，就是我們這些買電腦的客戶了。綜上所述：一個 Computer 的生產過程就可以被我們解剖成以下的描述：「當我們（Client）需要一台電腦的時候，我們會去找原價屋（Director），並跟他們說『我們需要一台電腦（getResult()）』，而原價屋在收到我們的需求之後，會去找硬體供應商（Builder），並從供應商那邊取得需要的電腦零件（build()），最後再把電腦給我們（return）」。而這，就是模式的運行邏輯。\n此外，在實際的案例中，因為『原價屋』可以跟很多不同的『硬體供應商』進行零件的調度，所以 Director 類別更像是一個 \u0026hellip;工廠？Direct 可以透過 Client 的不同需求（像是我要 ASUS 或 Acer 的電腦？我要筆電、文書機、還是電競電腦？）去調用不同的電腦創建邏輯、選擇不同的 Builder 進行子部件的創建 \u0026hellip;等。就像是下面這個樣子：\n// Director 類別，用來控管 Computer 的建立、配置、和回傳 class ComputerDirector { public Computer getResult(String brand, String level) { // Builder 物件 ComputerComponentsBuilder builder; // 選擇不同的『硬體供應商』 if(brand.equals(\u0026#34;ASUS\u0026#34;)) builder = new AsusComputerBuilder(); else if(brand.equals(\u0026#34;Acer\u0026#34;)) builder = new AcerComputerBuilder(); else throw new BrandNotExistException(); // 用來回傳的 Computer 物件 Computer computer; // 不同的 \u0026#34;電腦\u0026#34; if(level.equals(\u0026#34;notebook\u0026#34;)) computer = this.getNotebook(builder); else if(level.equals(\u0026#34;Low-End Computer\u0026#34;)) computer = this.getLowEndComputer(builder); else if(level.equals(\u0026#34;High-End Computer\u0026#34;)) computer = this.getHighEndComputer(builder); else throw new LevelNotExistException(); return computer; } // 其他不同的方法，像是配置不同等級的電腦 ... // 其他不同的方法，像是配置不同等級的電腦 ... } "},{"id":24,"href":"/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/","title":"合成/聚合複用原則","section":"設計模式","content":"\r合成/聚合複用原則\r#\rChatGPT 的說明 合成/聚合複用原則（Composition/Aggregation Reuse Principle）通常簡稱為 CARP，是物件導向設計中的一個原則，它與繼承有關，但專注於透過「組合」（也就是『合成』或『聚合』）的方式來實現程式碼的複用，而不是透過「繼承」的方式來複用程式碼。具體來說，CARP 強調了物件之間的關係應該是 \u0026ldquo;鬆耦合\u0026rdquo; 的，以便更容易進行維護和擴展。如果要使程式維持鬆耦合的狀態，比起利用「繼承」關係，更應該多使用「合成」關係或「聚合」關係：［合成］英文為 composition，指的是一個物件包含了另一個物件作為其一部分，從屬物件的生命週期通常受主要物件的生命週期限制。如果一個物件是另一個物件的一部分，並且當主要物件被銷毀時，從屬物件也會被銷毀。另一種關係是［聚合］聚合的英文稱作 aggregation，是指一個物件包含了另一個物件，但從屬物件的生命週期並不受限於主要物件的生命週期。\n與繼承相比，組合關係具有許多優勢，主要是因為它們提供了更靈活、低耦合和可維護的程式碼複用方式。主要的優勢如下：［靈活性］組合關係提供了更大的靈活性。透過使用組合關係的程式撰寫方式，使得程式可以在執行時動態地改變物件之間的關係，而不需要修改類別的結構。這允許系統更容易應對變化和需求的變更，而無需深度更改整個類別層次結構。［鬆耦合］繼承有時會導致緊密的耦合，因為子類別依賴父類別的實作細節，而組合關係則通常擁有 \u0026ldquo;鬆耦合\u0026rdquo; 的關係，因為父類別和子類別之間的依賴性較少。這降低了物件之間的耦合度，使得程式碼更容易理解、維護、和擴展。\n［避免繼承的限制］繼承有時後會引入一些程式上的限制，例如單一繼承限制（一個類別只能繼承一個父類別）和父類別的不穩定性（如果父類別的實作發生變化，所有子類別都會受到影響）。組合關係不受這些限制，使得類別可以輕鬆地組合多個類別的功能。［可維護性］組合關係有助於提高程式碼的可維護性。當需要程式修改或擴充功能時，你只需要專注於特定的類別或元件，而不需要涉及整個繼承層次結構。這簡化了程式碼的維護過程。［測試和調試］使用組合關係的程式編寫方式，通常更容易進行單元測試和調試，因為可以更容易地模擬和隔離組件，而不會受到繼承關係的複雜性的干擾。［程式碼可讀性］組合關係通常會使程式更加簡潔、更加清晰、和更加易於理解，因為它們強調了物件之間的協作關係，而不是混雜在一起的層次結構。\n簡單整理 多用組合、少用繼承\n程式碼範例 組合型程式碼，指的是在建立比較複雜的物件的時候，選擇使用不同類型的小物件相互結合，不使用繼承的方式來小物件一步步變成大物件。而在說明這樣做有什麼好處之前，我們先說明一下什麼樣的組合方式叫做「合成」？什麼樣的組合方式叫做「聚合」？簡單來說：成員變數會跟著主要物件一起死去的就叫做「合成」，而成魚變數可以在主要物件死去之後，還繼續存在的，就叫做「聚合」，就像是下面的這個範例：\n// 關於 \u0026#34;合成\u0026#34; (composition) 的範例 class Hmuan { // 私有變數 姓名 private String name; // 私有變數 人的各種器官（大腦、心臟、胃 ...等） private Brain brain; private Heart heart; private Stomach stomach; // 建構子 public Human(String name) { this.name = name; this.brain = new Brain(); this.heart = new Heart(); this.stomach = new Stomach(); } // 其他 Human 中的方法 ... // 其他 Human 中的方法 ... } // 關於 \u0026#34;聚合\u0026#34; (aggregation) 的範例 class Classroom { // 私有變數 包含班級名稱、老師、和學生們 ... private String className; private Teacher teacher; private List\u0026lt;Student\u0026gt; classmate; // 建構子 public Classroom(String name) { this.name = name; this.classmate = new ArrayList\u0026lt;\u0026gt;(); } // 新增班級導師 public setTeacher(Teacher teacher) { this.teacher = teacher; } // 新增班級學生 public void addStudent(Student student) { classmate.add(student); } // 其他 Classroom 中的方法 ... // 其他 Classroom 中的方法 ... } 在上面的兩個範例中，都是使用組合程式來達成複雜物件的生成。但它們兩個的不同之處在於：對於 Human類別來說，Brain, Heart 或者是 Stomach 都是「Human 在我在，Human 亡我亡」的狀況，這些器官物件的生命週期會跟隨著 Human 的生成一起被建立，也會隨著 Human 的死亡一起被抹去，這種狀況就叫做「合成」（composition）；而對於 Classroom 來說，雖然一個班級有 name, Student, Teacher \u0026hellip;等不同的成員變數，但除了 name 之外，其餘參數的生命週期都不會跟著 Classroom 的消逝而結束。即便一間學校的「班級」不見了，原本指導班級的「老師」也不會因此丟了工作，可以透過程式指派另一個 Classroom 重新工作，這便是「聚合」（aggragation）。\n而在實務情況上，根據系統或專案的規模，我們會遇到許多不同複雜物件的建立需求，這時候如果所有的物件都使用「繼承」的方式來做撰寫的話，很可能會導致程式產生非常嚴重的 \u0026ldquo;依賴\u0026quot;和 \u0026ldquo;冗余\u0026rdquo;。舉個例子來說：假設我們現在需要完成一個「二手車銷售系統」，裡面有一個「展示車型」的類別，裡面需要完整定義不同種類、不同大小、不同顏色的車子，如果我們全部都使用繼承的方式做實現的話，程式很有可能會變成下面這個樣子：\n// 第一層抽象 [車子] abstract class Car { protected String id; public Car(String id) { this.id = id; } } // 第二層抽象 [顏色] // 白色車 abstract class WhiteCar extends Car { private String color; public WhiteCar(String id) { super(id); this.color = \u0026#34;white\u0026#34;; } } // 黑色車 abstract class BlackCar extends Car { private String color; public BlackCar(String id) { super(id); this.color = \u0026#34;black\u0026#34;; } } // 第 3 層，實體車輛 [品牌 + 顏色 + 車] // 白色 Toyota class WhiteToyota extends WhiteCar { private String brand; public WhiteToyota(String id) { super(id, \u0026#34;white\u0026#34;); this.brand = \u0026#34;Toyota\u0026#34;; } } // 白色 Nissan class WhiteNissan extends WhiteCar { private String brand; public WhiteNissan(String id) { super(id, \u0026#34;white\u0026#34;); this.brand = \u0026#34;Nissan\u0026#34;; } } // 黑色 Toyota class BlackToyota extends BlackCar { private String brand; public BlackToyota(String id) { super(id, \u0026#34;black\u0026#34;); this.brand = \u0026#34;Toyota\u0026#34;; } } // 黑色 Nissan class BlackNissan extends BlackCar { private String brand; public BlackNissan(String id) { super(id, \u0026#34;black\u0026#34;); this.brand = \u0026#34;Nissan\u0026#34;; } } 我們可以看到：雖然我們的目標僅僅是生成四種不同種類、不同的車子，但前前後後我們一共生成了 7 個大大小小的類別，不難想像如果我們今天要再多加幾台「銀色的特斯拉」「黃色的計程車」「紅色的法拉利」「深藍色的藍寶堅尼」\u0026hellip;等，甚至再把所有的車子分成 2 人、5 人、7 人座 \u0026hellip;等，都會對程式帶來許多額外的負擔。大概還要再創建個 \u0026hellip; 20-30 個左右的類別，才可以滿足我們的所有需求吧？\n不僅如此，繼承帶來的壞處還有「對於父類別的依賴」，這個因素更是不建議在所有情況都使用繼承來完成程式的原因。我們可以想像一下這種情況：雖然我們要對所有的車子都新增「顯示共有幾個座位」這個功能，但我們不用真的去創建類似 WhiteToyotaWith_5_Seats, WhiteToyotaWith_7_Seats 這樣的類別，我們可以直接在最上面的 Car 裡面新增一個 int seat 就可以了，這樣就可以免去「超多類別」的困擾。\n但這種方式雖然可以避免「超多困擾」，卻無法避免「超多依賴」的情況：假設我們希望車子在一開始就決定好座位的數量，所以我們把建構子從 Car(String id) 修改成 Car(String id, int seats)。這樣一來，使用到 Car 建構子的 WhiteCar 和 BlackCar 就會需要一併修改 super() 的內容，然後繼承了 WhiteCar 和 BlackCar 的實體車輛又要繼續修改它們在建構子裡面的 super 內容 \u0026hellip;。可想而知，超級麻煩。\n因此，在這樣的情境之下，與其使用「繼承」來解決問題，我們更建議可以使用「組合」的方式，來創建一個實體的車輛類別。無論是使用「合成」還是使用「聚合」的方式，相對來說，不管是在程式的撰寫、還是其他的方面，都會比使用「繼承」還要好上許多，就像是下面的這個樣子：\n// 使用『合成』composition 來完成[車子] class Car { private String id; private Integer seats; private Color color; private Brand brand; // 建構子 public Car(String id) { this.id = id; this.seats = new Integer(7); this.color = new Black(); this.brand = new Toyota(); } @Override public String toString() { System.out.println(\u0026#34;Car[id:\u0026#34; + this.id + \u0026#34;, seats:\u0026#34; + this.seat + \u0026#34;, color:\u0026#34; + this.color + \u0026#34;, brand:\u0026#34; + this.brand + \u0026#34;]\u0026#34;); } } // 使用『聚合』aggregation 來完成[車子] class Car { private String id; private Integer seats; private Color color; private Brand brand; // 建構子 public Car(String id, Integer seats, Color color, Brand brand) { this.id = id; this.seats = seats; this.color = color; this.brand = brand; } @Override public String toString() { System.out.println(\u0026#34;Car[id:\u0026#34; + this.id + \u0026#34;, seats:\u0026#34; + this.seat + \u0026#34;, color:\u0026#34; + this.color + \u0026#34;, brand:\u0026#34; + this.brand + \u0026#34;]\u0026#34;); } } 可以發現到：透過使用「組合」的方式，無論是合成還是聚合，我們都可以在維持同樣需求（完成顯示不同車牌、不同座位數、不同顏色、不同品牌的車子）的情況下，達到更精簡的程式碼。而且使用這種方式來構成整個程式的話，它們的可讀性也會相對最一開始的「繼承」還要來得高。這便是合成/聚合複用原則所想要傳達的訊息：在某些情況下，比起使用「繼承」來完成所有的需求，有時候使用「合成」或「聚合」也許能夠達到更好的效果。\n"},{"id":25,"href":"/docs/computer_science/design_pattern/single_responsibility_principle/","title":"單一職責原則","section":"設計模式","content":"\r單一職責原則\r#\rChatGPT 的說明 單一職責原則（Single Responsibility Principle，簡稱 SRP）是物件導向程式設計和軟體設計的基本原則之一，該原則由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則強調一個類別（或一個模組）應該只有一個修改的理由。換句話說，一個類別應該只負責 個主要的功能或職責。SRP 的主要思想是將一個類別的職責限制在一個狹窄的範圍內，以確保類別的內部變化原因不會過多，從而提高程式的可維護性、可擴展性、和可讀性。當一個類別具有多個不同的職責時，它就會變得複雜、變得難以理解，並且容易因多個原因而需要修改，從而降低開發程式的效率。\n以下是 SRP 的主要目標：［每個類別應該都只負責一個主要職責］一個類別的 \u0026ldquo;主要職責\u0026rdquo; 即是它的核心任務，該類別應該專注於執行這份任務，而不需要干預（或處理）其他不關核心任務的事情。［分離不同的職責］如果一個類別的 \u0026ldquo;主要職責\u0026rdquo; 可能包含多項不同面向的 \u0026ldquo;子職責\u0026rdquo;，設計師應該考慮將這些職責分離為不同的類別或模組，以確保每個類別只處理一個不與它類重合的職責。 ［職責的改變，不應影響到其他的職責］在前 2 點成立的情況下，當我們需要修改一個類別的內容時，我們就是在針對「一個」「特定的」功能進行調整，因此在理論上來說，該功能不應與其他功能產生衝突或影響。SRP 有助於保持代碼的可讀性和可維護性，並促使開發人員設計更小、更簡單的類別，從而降低代碼的複雜性。它也是其他設計原則和設計模式的基礎之一，有助於建立高質量的軟體系統。\n簡單整理 簡單來說，SRP 在說的就是「一個類別，只負責一組類似的事情」\n程式碼範例 情境思考：假設我們受某校的教務處所委託，需要製作一個針對學生使用的「簡易學生管理系統」，裡面需要針對「學生」這一項身份完成以下幾個功能：學生資料管理（包含增刪改查學生的各種資料），課程管理（提供學生加退選課程，查看課程細節），成績查詢（包含歷年成績、當學期成績、生成成績單\u0026hellip;等），以及文件下載（包含各式各樣的學校文件，諸如學費繳費單、各式申請書、或者各處室的相關文件\u0026hellip;等）。在最最不推薦的狀況下，我們可以寫出類似於下面的程式碼：\npublic class StudentManagementSystem { public void registerStudent(Student student) { // 修改學生資料 // 記錄學生的最後的更新時間 // 向學生的家長發送通知 // 向學生的導師發送通知 } public void enrollCourse(Student student, int courseId) { // 獲得學生資料 // 查詢學生的所有修課記錄 // 添加新課程 } public Student getGrades(int studentId) { // 查詢學生資料 // 查詢學生的所有修課記錄 // 查詢學生的各式成績 } public void downloadFiles(String fileName) { // 查詢某一份學校文件 // 生成該份文件的 PDF 檔 // 匯出 PDF } // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 } 從程式的邏輯和功能來說，這份程式並沒有太大的問題。所有的功能都可以順利運行，且相關的程式邏輯都很正確。如果把這份程式直接提交給教務處的話，我想他們應該也不會有什麼太大的問題或者是意見才對。但是，雖然一切的一切都很順利，這份程式碼還是有著一點小小的改善空間：也就是它並沒有符合「單一職責原則」所規範的內容：意即「一個類別，只可以由一種『原因』而改變」。\n在這個 StudentManagementSystem 的類別中，我們同時實作了 updateStudent(), addCourse(), getGrades(), downloadFiles() \u0026hellip;等不同學生管理系統中的方法。可想而知，這會是一個非常龐大的類別，也許在這個類別裡，共有上百個不同的成員變數與方法也說不定。那在這樣的情況下，如果我們想要對程式進行一些操作或修改，就會顯得比較麻煩：因為所有的東西，都被放在同一個地方裡。就像是一間堆滿東西的倉庫一樣，剛整理倉庫的時候，或許還可以知道東西的正確位置，但日子久了、時間長了，或者是之後又對倉庫做了一些調整 \u0026hellip;，程式的維護成本就會逐漸提高。\n此外，可能導致 StudentManagementSystem 需要修改的原因也有很多，無論是對「學生」相關資料的編輯、對「成績」的計算方式需要修正、或者是「課程」有一些類別需要做添加或移除，抑或是「文件」的編輯或更改，都是能夠成 \u0026ldquo;影響到 StudentManagementSystem\u0026rdquo; 的原因（因為這個類別需要負責太多東西了），因此，在這樣的情況下，單一職責原則提供我們對這個「倉庫」做改善的方法：我們整理一下整份系統。系統中共有 4 大項不同的功能，分別與「學生」「課程」「成績」和「文件檔案」有關，因此在這裡，我們可以先對所有的方法進行一個分類：也就是「新增這 4 個類別，並將所屬的方法添加到類別裡面」。簡單來說，可以寫成下面的這個樣子：\npublic class StudentManager { // 學生註冊 public void register(Student student) {} // 修改資料 public void modify(Student student) {} // 註銷學生 public void cancel(Student student) {} // 其他和[學生]有關的相關方法 // 其他和[學生]有關的相關方法 } public class CourseManager { // 加選課程 public void enroll(Student student, int courseId) {} // 退選課程 public void drop(Student student, int courseId) {} // 修課列表 public void show(Student student) {} // 其他和[課程]有關的相關方法 // 其他和[課程]有關的相關方法 } public class GradeManager { // 單一課程成績 public void getSingle(Student student, int courseId) {} // 單一學期成績 public void getSemester(Student student, int semesterId) {} // 歷史修課成績 public void getAll(Student student) {} // 其他和[成績]有關的相關方法 // 其他和[成績]有關的相關方法 } public class FileManager { // 下載特定文件 public void download(Student fileName, int courseId) {} // 其他和[文件]有關的相關方法 // 其他和[文件]有關的相關方法 } public class StudentManagementSystem { StudentManager studentManager; GradeManager gradeManager; CourseManager courseManager; FileManager fileManager; // 建構子 public StudentManagementSystem(StudentManager studentManager, GradeManager gradeManager, CourseManager courseManager, FileManager fileManager) { this.studentManager = studentManager; this.gradeManager = gradeManager; this.courseManager = courseManager; this.fileManager = fileManager; } // 學生註冊 public void register(Student student) { studentManager.register(student); } // 加選課程 public void enroll(Student student, int courseId) { courseManager.enroll(student, courseId); } // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 } 透過將所有的功能分離出來，我們就算是「整理」了一次這個倉庫，比起之前的程式，現在的學生管理系統只需要負責監督和調用底下的 Manager 們即可，它的職責現在就只有「管理」。而其他業務呢？「學生」的工作有 StudentManaer 負責，「成績」的工作是 GradeManager 的強項，CourseManager 專注於任何跟「課程」有關的事物，FileManager 則準備好了跟文件有關的工作等著我們去使用。\n一個類別，只處理一種類型的工作。就是 SRP 想要說明的內容。\n"},{"id":26,"href":"/docs/_trash/factory_method_pattern/","title":"工廠方法模式","section":"Docs","content":"\r工廠方法模式\r#\rChatGPT 的說明 工廠方法模式（Factory Method Pattern）是一種創建型設計模式，它提供了一種創建物件的介面，但允許子類別決定要實例化的類別。這種模式的核心思想是「將物件的創建過程延遲到子類別中去實現。」從而達到物件的 \u0026ldquo;創建\u0026rdquo; 與 \u0026ldquo;使用\u0026rdquo; 分離，使得系統更加靈活和可擴展。工廠方法模式的主要組成部分包括以下角色：［抽象工廠］（Abstract Factory）：抽象工廠定義了一個抽象的工廠介面，包含一個用於建立產品物件的抽象方法。通常情況下，抽象工廠中可能會包含多個建立產品的方法，每個方法用於建立不同類型的產品。［具體工廠］（Concrete Factory）：具體工廠是實現抽象工廠介面的類別，負責創建具體產品。每個具體工廠對應於一種具體產品（或一組相關的特定產品）。［抽象產品］（Abstract Product）：抽象產品定義一個抽象的產品介面，通常包含了產品的通用方法或通用屬性。［具體產品］（Concrete Product）：具體產品是實現抽象產品介面的具體類別，用以表示不同類型的產品。\n工廠方法模式的關鍵點是「透過將物件的創建委託給子類的具體工廠來實現。」這樣客戶端程式碼不需要直接依賴特定的工廠類型，而只需要依賴抽象工廠和抽象產品介面。這種方式使得系統更容易擴展，可以輕鬆添加新的工廠類型或變體，而無需修改現有的客戶端程式碼。以下是工廠方法模式的一些優點：［可擴充性］：使用工廠方法模式，可以透過建立新的特定工廠類別，來新增新的產品類型，而不影響現有的程式碼。［封裝性］：客戶端程式碼與特定的工廠類別解耦，只依賴抽象工廠和抽象產品接口，隱藏了具體產品的實作細節。［靈活性］：不同的具體工廠可以選擇不同的產品實現方式，以適應不同的需求和不同的環境。\n簡單整理 問題描述：使用唯一的 Factory 可能會使該類別變得龐大\n解決方案：透過建立 AbstractFactory 類別，讓 Factory 變得更加靈活\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 貼心提醒：建議先看過簡單工廠模式會比較好。\n工廠方法模式，算是比簡單工廠模式再更複雜一點的程式。那也因為這個模式跟簡單工廠很類似，所以我們就用同樣的例子繼續做解釋：在簡單工廠模式中，我們假設正在製作一個「資料庫操作程式系統」，並且有著幾個比較重要的類別：分別是代表使用者的 User、代表資料庫的 Database、以及代表工廠的 QueryFactory。User 可以透過 Database 裡面的方法（通常為靜態？），進行像是 INSERT, SELECT ..等不同的資料庫操作，而 Database 在接收到 User 的 query 之後，會再轉手交給 QueryFactory 負責解析，而 factory 則會根據 query 的不同，回傳不同的結果。\nclass User { public QueryResult query(String query) { QueryResult queryResult = Database.getQueryResult(query); return queryResult; } } class Database { public static QueryResult query(String query) { QueryResult queryResult = QueryFactory.parseQuery(query); return queryResult; } } class QueryFactory { private enum QueryOperation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } public static QueryResult parseQuery(String query) { QueryOperation operation = this.parse(query); QueryResult queryResult = null; switch(operation) { case QueryOperation.INSERT: queryResult = new InsertResult(query); break; case QueryOperation.SELECT: queryResult = new SelectResult(query); break; case QueryOperation.DELETE: queryResult = new UpdateResult(query); break; case QueryOperation.DELETE: queryResult = new DeleteResult(query); break; default: throw new OperationIsNotExistException(); } return queryResult; } } abstract class QueryResult(); class InsertResult extends QueryResult {}; class SelectResult extends QueryResult {}; class UpdateResult extends QueryResult {}; class DeleteResult extends QueryResult {}; 接下來我們把情境變得複雜一點：假設我們的這個「系統」因為一些原因（像是上級交代、或者是一些商業規劃之類的？），除了需要能夠針對不同的 query 進行操作之外，它的底層還要兼容不同的資料庫系統（像是 MySQL, MariaDB, MongoDB, Redis, SQLite \u0026hellip;等），那在這樣的情況下，如果我們打算維持使用原本簡單工廠模式的程式邏輯的話，情況可能就會變成下面的這個樣子：\nclass User { // 現在多了一個參數，代表哪種 DBMS public QueryResult query(String db_type, String query) { QueryResult queryResult = Database.getQueryResult(db_type, query); return queryResult; } } class Database { // 同樣多了一個 db_type 的參數 public static QueryResult query(String db_type, String query) { QueryResult queryResult = QueryFactory.parseQuery(db_type, query); return queryResult; } } class QueryFactory { public static QueryResult parseQuery(String db_type, String query) { QueryOperation operation = this.parse(query); QueryResult queryResult = null; // 可怕的 if... else... 程式邏輯出現了 ... switch(operation) { case QueryOperation.INSERT: if(db_type.equals(\u0026#34;MySQL\u0026#34;)) queryResult = new MySQL_InsertQuery(query); else if(db_type.equals(\u0026#34;MariaDB\u0026#34;)) queryResult = new MariaDB_InsertQuery(query); else if(db_type.equals(\u0026#34;MongoDB\u0026#34;)) queryResult = new MongoDB_InsertQuery(query); else if(db_type.equals(\u0026#34;Redis\u0026#34;)) queryResult = new Redis_InsertQuery(query); else if(db_type.equals(\u0026#34;SQLite\u0026#34;)) queryResult = new SQLite_InsertQuery(query); break; case QueryOperation.SELECT: if(db_type.equals(\u0026#34;MySQL\u0026#34;)) queryResult = new MySQL_SelectQuery(query); else if(db_type.equals(\u0026#34;MariaDB\u0026#34;)) queryResult = new MariaDB_SelectQuery(query); // 剩下的一些 switch case, if else } return queryResult; } } 可以很明顯的發現到：這個 QueryFactory 類別的程式已經逐漸往很可怕的地方靠攏了。除了這個現象之外，我們還可以另外觀察到一個關於簡單工廠模式的結構缺陷：該模式並沒有符合開放封閉原則，每當我們需要增加（或修改）QueryFactory 工廠中的某一項產品時，都需要對 QueryFactory 類別中的 parseQuery() 方法重新編輯，這不僅會加大該方法的複雜性，這樣的架構也容易讓之後的程式閱讀、改寫、或重構變得困難。\n因此，為了解決上述的問題，我們可以把原本的程式架構從簡單工廠模式換成工廠方法模式：也就是先利用一個「抽象工廠」類別，組織各「實體工廠」應該要實作的方法集合，後續再由繼承該抽象類別的「實體工廠」進行程式的細節邏輯編織。這種將工廠拆分成抽象的方式，不僅可以讓系統程式變得更具有彈性，還可以讓原本簡單工廠裡高度耦合的程式碼進行拆分、解耦，這便是「工廠方法模式」的核心理念。\n// 系統中的 [使用者] 類別 class User { public QueryResult query(String query) { QueryResult queryResult = Database.getQueryResult(query); return queryResult; } } class Database { public static QueryResult query(String db_type, String query) { // 這邊直接針對 factory 進行賦值，我們假設系統現在使用的是 MySQL 的資料庫 QueryFactory factory = new MySQL_Factory(); QueryResult queryResult = factory.parseQuery(query); return queryResult; } } // 將 [工廠] 抽象化 abstract class QueryFactory { // 定義一系列實例化 [工廠] 所需要實現的抽象方法 public QueryResult InsertQuery(String query); public QueryResult SelectQuery(String query); public QueryResult UpdateQuery(String query); public QueryResult DeleteQuery(String query); } // 實體工廠 \u0026#34;MySQL Query Factory\u0026#34; class MySQL_Query_Factory { @Override public QueryResult InsertQuery(String query) { // 實作 MySQL 中的 insert ... } @Override public QueryResult SelectQuery(String query) { // 實作 MySQL 中的 select ... } @Override public QueryResult UpdateQuery(String query) { // 實作 MySQL 中的 update ... } @Override public QueryResult DeleteQuery(String query) { // 實作 MySQL 中的 delete ... } } // 實體工廠 \u0026#34;MariaDB Query Factory\u0026#34; class MariaDB_Query_Factory { @Override public QueryResult InsertQuery(String query) { // 實作 MariaDB 中的 insert ... } @Override public QueryResult SelectQuery(String query) { // 實作 MariaDB 中的 select ... } @Override public QueryResult UpdateQuery(String query) { // 實作 MariaDB 中的 update ... } @Override public QueryResult DeleteQuery(String query) { // 實作 MariaDB 中的 delete ... } } // 其他的 [實體工廠] 類別 ... // 其他的 [實體工廠] 類別 ... // 其他的 [實體工廠] 類別 ... 透過上面的程式，不難看出工廠方法模式相較於簡單工廠模式有著過高的可讀性和靈活性。透過將工廠從原本的單一實體類別轉變為抽象，讓原本存在於簡單工廠中的「各方法」解耦，工廠方法模式更加適合用在體積較為龐大的產品內容上。從現在的程式碼來看，如果我們想要更換系統的底層資料庫（例如：從 MySQL 換到 MariaDB），我們需要讓 Database 的 QueryFactory 更換成另一個資料庫工廠的實體類別（從 MySQL_Query_Factory 換成 MariaDB_Query_Factory），這個過程雖然還是會稍微調整到原本的程式碼，但相較於簡單工廠的紊亂，這種修改或許是個還可以接受的程度？\n"},{"id":27,"href":"/docs/computer_science/design_pattern/factory_method_pattern/","title":"工廠方法模式","section":"設計模式","content":"\r工廠方法模式\r#\rChatGPT 的說明 工廠方法模式（Factory Method Pattern）是一種創建型設計模式，它提供了一種創建物件的介面，但允許子類別決定要實例化的類別。這種模式的核心思想是「將物件的創建過程延遲到子類別中去實現。」從而達到物件的 \u0026ldquo;創建\u0026rdquo; 與 \u0026ldquo;使用\u0026rdquo; 分離，使得系統更加靈活和可擴展。工廠方法模式的主要組成部分包括以下角色：［抽象工廠］（Abstract Factory）：抽象工廠定義了一個抽象的工廠介面，包含一個用於建立產品物件的抽象方法。通常情況下，抽象工廠中可能會包含多個建立產品的方法，每個方法用於建立不同類型的產品。［具體工廠］（Concrete Factory）：具體工廠是實現抽象工廠介面的類別，負責創建具體產品。每個具體工廠對應於一種具體產品（或一組相關的特定產品）。［抽象產品］（Abstract Product）：抽象產品定義一個抽象的產品介面，通常包含了產品的通用方法或通用屬性。［具體產品］（Concrete Product）：具體產品是實現抽象產品介面的具體類別，用以表示不同類型的產品。\n工廠方法模式的關鍵點是「透過將物件的創建委託給子類的具體工廠來實現。」這樣客戶端程式碼不需要直接依賴特定的工廠類型，而只需要依賴抽象工廠和抽象產品介面。這種方式使得系統更容易擴展，可以輕鬆添加新的工廠類型或變體，而無需修改現有的客戶端程式碼。以下是工廠方法模式的一些優點：［可擴充性］：使用工廠方法模式，可以透過建立新的特定工廠類別，來新增新的產品類型，而不影響現有的程式碼。［封裝性］：客戶端程式碼與特定的工廠類別解耦，只依賴抽象工廠和抽象產品接口，隱藏了具體產品的實作細節。［靈活性］：不同的具體工廠可以選擇不同的產品實現方式，以適應不同的需求和不同的環境。\n簡單整理 問題描述：使用唯一的 Factory 可能會使該類別變得龐大\n解決方案：透過建立 AbstractFactory 類別，讓 Factory 變得更加靈活\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 工廠方法模式，是比[簡單工廠]模式還要再複雜一點點的設計模式。主要的使用情境是「當單的 simple Factory 變得過於龐大」的時候。同樣拿簡單工廠模式中的「傢俱系統」作為例子：假設我們的家俱利統中，除了可以展示各種不同類別的傢俱之外，它可以針對不同的傢俱分類（像是金屬製、實木製、塑膠製 \u0026hellip;等）展示出更加細節的傢俱種類（像是實木桌、橡木桌、組合木桌、大理石桌、塑膠桌 \u0026hellip;等），此外每個傢俱都有自己的材質組合（衣櫃不會有玻璃的、床架只有木頭跟金屬的 \u0026hellip;等），如果我們還是用原本的簡單工廠模式來實作這項功能的話，可能會變成下面這個樣子：\nclass FurnutireFactory { // 靜態的 createFurniture() 方法 // 現在多了一個 [材質] 的參數 public static Furniture createFurniture(String material, String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) { if(material.equals(\u0026#34;Wooden\u0026#34;)) furniture = new WoodenChair(); else if(material.equals(\u0026#34;plastic\u0026#34;)) furniture = new PlasticChair(); else if(material.equals(\u0026#34;metal\u0026#34;)) furniture = new MetalChair(); else throw FurnitureIsNotExistException(); } else if(name.equals(\u0026#34;desk\u0026#34;)) { if(material.equals(\u0026#34;Wooden\u0026#34;)) furniture = new WoodenDesk(); else throw FurnitureIsNotExistException(); } else if(name.equals(\u0026#34;sofa\u0026#34;)) { // 各種不同材質的沙發 } // 其他的 if else ... // 其他的 if else ... return furniture; } } 可以發現到：雖然這樣的程式仍然可以幫我們達成系統的需求，但程式本身已經開始變得有點可怕，createFurniture() 不僅出現了對於龐大類別的高度依賴，這也會對於往後對於系統的維護變得更加困難。因此，相對於使用「簡單工廠模式」來達成需求，一個更好的做法是使用「工廠方法模式」來完成我們所需要的各種功能：透過先定義一個抽象的「工廠」類別，並在工廠裡面定義不同種類的「產品」，再讓客戶根據不同的實際狀況，去依賴不同的「實體工廠」，便是工廠方法模式的核心想法：\n// 抽象類別 [傢俱工廠] abstract class FurnitureFactory { public abstract Furniture createFurniture(String name); } // 繼承 [傢俱工廠] 的 [木製傢俱工廠] class WoodenFurnitureFactory extends FurnitureFactory { @Override public Furniture createFurniture(String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new WoodenChair(); else if(name.equals(\u0026#34;desk\u0026#34;)) furniture = new WoodenDesk(); else if(name.equals(\u0026#34;Bookshelf\u0026#34;)) furniture = new WoodenBookshelf(); else throw new FurnitureIsNotExistException(); return furniture; } } // 繼承 [傢俱工廠] 的 [金屬傢俱工廠] class MetalFurnitureFactory extends FurnitureFactory { @Override public Furniture createFurniture(String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new MetalChair(); else if(name.equals(\u0026#34;table\u0026#34;)) furniture = new MetalTable(); else throw new FurnitureIsNotExistException(); return furniture; } } // 系統中的 [顧客] 類別 class Customer { // 新增一個 [傢俱工廠] private FurnutireFactory factory; private String account; private String password; // 將不同材質的傢俱拆分成不同方法 public Furniture getWoodenFurniture(String name) { this.factory = new WoodenFurnitureFactory(); Furniture furniture = factory.createFurniture(name); return furniture; } public Furniture getMetalFurniture(String name) { this.factory = new MetalFurnitureFactory(); Furniture furniture = factory.createFurniture(name); return furniture; } public Furniture getPlasticFurniture(String name) { this.factory = new PlasticFurnitureFactory(); Furniture furniture = factory.createFurniture(name); return furniture; } public Furniture getMarbleFurniture(String name) { this.factory = new MarbleFurnitureFactory(); Furniture furniture = factory.createFurniture(name); return furniture; } } 透過父類別 FurnitureFactory 中的共同方法，現在我們無論是使用木製傢俱工廠（WoodenFurnitureFactory）、金屬傢俱工廠（MetalFurnitureFactory）、塑膠傢俱工廠（PlasticFurnitureFactory）或者是大理石制傢俱工廠（MarbleFurnitureFactory），都可以透過統一的一個 createFurniture() 方法來完成「獲得傢俱」的功能。此外，如果對於上述的程式感到「各種類型的傢俱還要分開來寫，好麻煩 \u0026hellip;」的話，也可以合在一起寫：\n// 系統中的 [顧客] 類別 class Customer { // 新增一個 [傢俱工廠] private FurnutireFactory factory; private String account; private String password; // 將不同材質的傢俱拆分成不同方法 public Furniture getWoodenFurniture(String material, String name) { if(material.equals(\u0026#34;wooden\u0026#34;)) this.factory = new WoodenFurnitureFactory(); else if(material.equals(\u0026#34;metal\u0026#34;)) this.factory = new MetalFurnitureFactory(); else if(material.equals(\u0026#34;plastic\u0026#34;)) this.factory = new PlasticFurnitureFactory(); else if(material.equals(\u0026#34;marble\u0026#34;)) this.factory = new MarbleFurnitureFactory(); else throw new FactoryNotExistException(); Furniture furniture = factory.createFurniture(name); return furniture; } } 雖然這樣做會稍微違反單一職責原則的想法，意即一個類別應該只負責一組相關的事物（畢竟 Customer 是負責處理「顧客」相關的程式邏輯，getWoodenFurniture() 方法現在還包含了一些「該怎麼創建不同的傢俱工廠」），但設計原則跟設計模式本來就不是得一定遵守的，它們只是提供了一個「便於寫程式」的方法而已，在這個情況下，雖然違反原則，但的確減少了 Customer 的方法數。但嚴格來說哪種方式好？可能就因人而異了。\n"},{"id":28,"href":"/docs/computer_science/design_pattern/abstract_factory_pattern/","title":"抽象工廠模式","section":"設計模式","content":"\r抽象工廠模式\r#\rChatGPT 的說明\n簡單整理\n問題描述：當系統變得愈發龐大，即使將工廠進行抽象，也會導致程式高度耦合\n解決方案：對 Factory 和 Product 同時進行抽象\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 抽象工廠模式，是三個與「工廠」有關的設計模式中（簡單工廠模式、工廠方法模式、和抽象工廠模式），最為複雜的一個模式。也因此，在這三種設計模式當中，抽象工廠模式是使用在最為複雜的情境之中。我們同樣承接前兩個「工廠」中的情境，以一個傢俱系統作為例子：假設現在我們的系統除了需要呈現不同材質的傢俱之外，各種傢俱也有一些更微細項的分類，像是「床」有單人床、雙人床、單人床加大 \u0026hellip;等，書櫃有三層櫃、四層櫃 \u0026hellip;等，桌子也有分無抽屜、一個抽屜、兩個抽屜 \u0026hellip;等，如果同樣用工廠方法來處理的話，可能會變成下面這樣：\n// 抽象類別 [傢俱工廠] abstract class FurnitureFactory { // 在 createProduct() 方法中加入一個 \u0026#34;description\u0026#34; 的參數 public abstract Furniture createFurniture(String name, String description); } // 繼承 [傢俱工廠] 的 [木製傢俱工廠] class WoodenFurnitureFactory extends FurnitureFactory { @Override public Furniture createFurniture(String name, String description) { Furniture furniture = null; if(name.equal(\u0026#34;bed\u0026#34;)) { if(description.equals(\u0026#34;single bed\u0026#34;)) furniture = new SingleBed(); else if(description.equals(\u0026#34;full-size bed\u0026#34;)) furniture = new FullSizeBed(); else if(description.equals(\u0026#34;twin XL bed\u0026#34;)) furniture = new TwinXlBed(); else throw new BedIsNotExistException(); } else if(name.equals(\u0026#34;cabinet\u0026#34;)) { if(description.equals(\u0026#34;three-tier cabinet\u0026#34;)) furniture = new ThreeTierCabinet(); else if(description.equals(\u0026#34;four-tier cabinet\u0026#34;)) furniture = new FourTierCabinet(); else throw new CabinetIsNotExistException(); } else if(name.equals(\u0026#34;table\u0026#34;)) { if(description.equals(\u0026#34;0\u0026#34;)) furniture = new ZeroDrawersTable(); else if(description.equals(\u0026#34;1\u0026#34;)) furniture = new OneDrawerTable(); else if(description.equals(\u0026#34;2\u0026#34;)) furniture = new TwoDrawersTable(); else throw new TableIsNotExistException(); } else { throw new FurnitureIsNotExistException(); } return furniture; } } 可以發現到，跟工廠方法中一開始出現的情況一樣，抽象工廠中的 createFurniture() 方法又變得有點可怕了。因此，我們同樣需要對當前程式稍做修改，而其中一種修改方式，便是使用「抽象工廠模式」進行改寫：抽象工廠模式相對於簡單工廠和工廠方法，除了對於「工廠」類別進行抽象化之外，也同時會對「產品」進行一定程度的抽象化，也就是說，在這個例子裡面，我們除了原本根據傢俱的「材質」進行分類之外，也要把傢俱的「種類」進行分類。除此之外，為了避免單一方法中的 if.else 變得龐大複雜，我們也必須將取得各種不同傢俱的方法（getFurniture()）寫成更加細緻的形式（getTable(), getChair \u0026hellip;等），整體而言，就像是下面這樣：\n// 系統中的 [顧客] 類別 class Customer { // 新增一個 [傢俱工廠] private FurnutireFactory factory; private String account; private String password; // 將不同材質的傢俱拆分成不同方法 // ex1. 木製的桌子 public Furniture getWoodenTable(String description) { this.factory = new WoodenFurnitureFactory(); Furniture furniture = factory.createTable(description); return furniture; } // ex2. 金屬製的床 public Furniture getMetalBed(String description) { this.factory = new MetalFurnitureFactory(); Furniture furniture = factory.createBed(description); return furniture; } // 其他獲得不同材質、傢俱種類、和傢俱細節的方法 ... } // 抽象類別 [傢俱工廠] abstract class FurnitureFactory { // 將不同的傢俱分別寫成不同的方法 public abstract Furniture createBed(String description); public abstract Furniture createCabinet(String description); public abstract Furniture createTable(String description); } // 繼承 [傢俱工廠] 的 [木製傢俱工廠] class WoodenFurnitureFactory extends FurnitureFactory { // 製作不同 [木製床] 的方法 @Override public Furniture createBed(String description) { Furniture bed = null; if(description.equals(\u0026#34;single bed\u0026#34;)) bed = new WoodenSingleBed(); else if(description.equals(\u0026#34;full-size bed\u0026#34;)) bed = new WoodenFullSizeBed(); else if(description.equals(\u0026#34;twin XL bed\u0026#34;)) bed = new WoodenTwinXlBed(); else throw new BedIsNotExistException(); return bed; } // 製作不同 [木製書櫃] 的方法 @Override public Furniture createCabinet(String description) { Furniture cabinet = null; if(description.equals(\u0026#34;three-tier cabinet\u0026#34;)) cabinet = new WoodenThreeTierCabinet(); else if(description.equals(\u0026#34;four-tier cabinet\u0026#34;)) cabinet = new WoodenFourTierCabinet(); else throw new CabinetIsNotExistException(); return bed; } // 其他製作不同木製傢俱的方法 ... } // 其他不同材質的傢俱的類別與方法 ... 像這樣透過抽象工廠模式，對各種不同的產品做拆分，便可以緩解系統中，類別與類別間的高度耦合，這也是該模式所闡述的核心理念之一。總而言之，做個小結論：對於三種不同的工廠模式來說：如果程式架構沒有太過龐大，對工廠或對產品都沒有抽象化的需要，那就可以用簡單工廠模式解決；如果程式的複雜程度大致是在中等，需要對「工廠」或對「產品」的其中一個部分做抽象化的處理，那麼推薦使用工廠方法模式；而對於比較複雜的系統架構來說，如果我們同時需要對「工廠」和「產品」進行抽象化處理，那麼抽象工廠便是不錯的選擇。\n但如果程式又變得更加複雜呢？假設今天我們的「櫃子」類別除了有不同的層數之外，還有不同寬高、不同深度 \u0026hellip;等細節，而「桌子」的類別還可以分得更細，像是橡木桌、桃木桌、組合目的小桌子 \u0026hellip;等，那該怎麼辦？其中一種方法是「繼續拆分」，有幾種不同的變數，就拆分成幾種不同的層級，把工廠變成子工廠、子子工廠，產品變成子產品、子子產品 \u0026hellip;等。另外一種較為推薦的方法是放棄使用「工廠」模式，遵循合成/聚合複用原則，或者是其他不同的創建方式進行物件的生成，會比較合適。\n"},{"id":29,"href":"/docs/_trash/least_knowledge_principle/","title":"最少知識原則","section":"Docs","content":"\r最少知識原則\r#\rChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 \u0026ldquo;朋友\u0026rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 \u0026ldquo;封裝\u0026rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。\n此外在物件導向程式設計中，一個物件的 \u0026ldquo;朋友\u0026rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 \u0026ldquo;朋友\u0026rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 \u0026ldquo;朋友\u0026rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 \u0026ldquo;朋友\u0026rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 \u0026ldquo;朋友\u0026rdquo;。 需要注意的是，儘管可以與這些 \u0026ldquo;朋友\u0026rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。\n簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。\n程式碼範例 迪米特法則的核心是「盡量保持鬆耦合」的設計思想：當一個物件（或一個方法）需要透過很 \u0026ldquo;遠\u0026rdquo; 的呼叫，才可以完成某項功能時，就代表該物件對於呼叫中的所有東西都保持著依賴關係，那這時候，只要這一條依賴關係的任一截點出現問題，就都有可能導致功能的毀損，進而影響整個程式的運作。舉個例子：我們假設在一間上市公司中，從公司最大的「老闆」一路到最基層的「員工」有以下的這幾個階層：老闆（Boss）\u0026gt; 各部門的部處長（DepartmentDirector）\u0026gt; 專案經理（ProjectManager）\u0026gt; 員工（Staff）。然後今天老闆想要讓自己的公司網頁新增一項功能，他將這件事情告訴了 IT 部門的部處長，處長為此成立了一個「網站專案團隊」，並指派一位資深員工為專案經理讓他挑選幾位處理該專案的員工（Staff）來完成老闆所需的工作。如果在這樣的情況下，老闆想要追蹤一下這個網頁功能的更新，那可能會發生這樣的問題：\nLog websiteInfo = boss.getDepartmentDirector(\u0026#34;IT\u0026#34;).getProjectManager(\u0026#34;web\u0026#34;).getStaff().getTaskLog(); 我們可以看到：光是 Boss 想要拿到一條「網站的更新紀錄」，就需要經過至少 3 ~ 4 個人的手，除了在實務的情況下，這麼做的效率可能有點低下之外，對於程式的撰寫來說，這種寫法也是挺有風險的，畢竟我們沒有辦法保證「呼叫上的所有方法即使產生了細節上的改變，程式也能完整運行」（例如 getProjectManager() 突然不用 \u0026ldquo;專案名稱\u0026rdquo; 做為參數，改用 \u0026ldquo;專案代號\u0026rdquo; 之類的），因此，迪米特法則告訴了我們「不要跟這麼多人講話」，也就是不要依賴過多的 \u0026ldquo;陌生人\u0026rdquo;。盡可能只透過，跟身邊的「朋友」聊天，就能拿到必要的資訊。降低方法間的相互調用，也就降低了「依賴於 \u0026lsquo;方法\u0026rsquo; 的一致性」，進而提升程式整體的品質，就是迪米特法則想要告訴我們的事情。\nLog websiteInfo = boss.getInfo(\u0026#34;WebsiteUpdate\u0026#34;); 朋友 知道了法則想要傳遞的訊息之後，接下來就可以往下一步走了：哪些人、哪些東西、哪些物件、哪些方法才是所謂的「朋友」？一般來說，常見對於「朋友」的定義有以下四種：「類別本身的成員變數」「類別本身的方法」「父類別的所有成員與方法」「傳入方法中的所有參數」以及「在方法中建立的任何物件」。可以發現到朋友的類型可以根據是類別還是方法有所不同，這也是該原則比較特別的一個地方：不僅適用於類別的角度，也適用於方法的角度。\n類別本身的成員變數 這個應該蠻好理解的？畢竟是「自己本身就有的東西」。「類別本身的成員變數」可以視為是一個自己的親近朋友，無論是 \u0026ldquo;基本資料型態\u0026rdquo;（像是 int, float, long, double \u0026hellip;等），或者是 \u0026ldquo;參考資料型態\u0026rdquo;（各種類別：諸如 Object, System, Boss, Staff, Library \u0026hellip;等），只要是類別自己有的東西，都可以視為自己的朋友，這點也包含所有的父類別、父父類別、父父父類別 \u0026hellip;等。\n此外，成員變數如果是參考資料型態的話，那麼它的方法也算是「朋友」。但這些方法僅限於可訪問的那些（也就是帶有 public 關鍵字的那些），如果成員變數的方法全部都是用 private 或 pritected\n類別本身的方法 同理於 1.，類別本身的方法也算是「自己本身就有的東西」，所以類別裡面的所有方法無論是哪一種封裝等級（public, pritected, private）無論是哪一種回傳型態（int, String, Object, Book \u0026hellip;等），無論該方法需不需要參數 \u0026hellip;等，它們都可以視為是自己的朋友。因此在進行這類的呼叫時上不用太過擔心，雖說不上是肆無忌憚，但大體而言，還是可以放心使用。\n傳入方法中的所有參數 接下來從方法的角度去做切入，在方法的程式細節中，除了可以利用到上述的兩種朋友（所屬類別的成員變數、所屬類別的其他方法）之外，還可以將「傳入方法中的所有參數」都視為是自己的朋友，也跟 1 同理，無論是 int, float \u0026hellip;等基本資料型態，還是 Object, String \u0026hellip;等參考資料型態，只要是傳進來的參數，都可以視為是方法本身的「朋友」，此外，同樣也跟 1 一樣，傳入方法的參數如果是某一個物件的話，該物件的方法也可以被視為「朋友」。\n在方法中建立的任何物件 這算是對於類別或方法來說，最為彈性的一個「朋友」。建立物件的方式有兩種：第一種是透過最簡單的 new 關鍵字建立，像是使用 Staff staff = new Staff(\u0026quot;小明\u0026quot;) 這類的語句來生成新物件。另一種方式是透過方法的回傳所建立：像是利用類別裡，成員變數的方法、類別本身的方法、或者是當作參數傳入方法中的物件的方法 \u0026hellip;等，透過這些方式所獲得的物件同樣也算是「朋友」，就像這樣： DepartmentDirector dd = boss.getDD(\u0026quot;IT\u0026quot;) 讓 Boss 透過自己本身的 getDD() 來獲得 IT 部門的部處長。\n還有一個很容易搞混的問題：鏈式呼叫\n"},{"id":30,"href":"/docs/computer_science/design_pattern/least_knowledge_principle/","title":"最少知識原則","section":"設計模式","content":"\r最少知識原則\r#\rChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 \u0026ldquo;朋友\u0026rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 \u0026ldquo;封裝\u0026rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。\n此外在物件導向程式設計中，一個物件的 \u0026ldquo;朋友\u0026rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 \u0026ldquo;朋友\u0026rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 \u0026ldquo;朋友\u0026rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 \u0026ldquo;朋友\u0026rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 \u0026ldquo;朋友\u0026rdquo;。 需要注意的是，儘管可以與這些 \u0026ldquo;朋友\u0026rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。\n簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。\n程式碼範例 「最少知識原則」又稱作「迪米特法則」（後面統一用『迪米特法則』稱呼～），該原則的核心思想是「盡可能地減少需要依賴的類別和方法」，它透過定義「朋友」與「非朋友」這兩種不同的關係，將類別與類別、方法與方法、或類別與方法之間的調用加以分類，進而減少對於過量類別和過量方法的嚴重依賴。我們一個簡單的例子來做說明：假設我們正在製作一個「資料庫管理系統」，裡面的其中一項功能是「Customer 可以修改 x 資料庫中， y 資料表的內容」簡單來說就是一個 UPDATE 方法，程式的實作方式如下：\n// [使用者] 類別 class User { // 私有變數 system, 用來獲取 \u0026#39;資料庫系統\u0026#39; private DatabaseManagementSystem system; // update 方法，用來更新資料庫中的資料 public State update(String db_name, String table_name, String query) { // 首先利用 connectToSystem() 與資料庫系統建立連線 this.system.connectToSystem(this); // 接著利用 getDatabase() 來取得想要操作的資料庫 // 然後利用 getPermission() 取得資料庫得操作權限 // 再來利用 getTable() 獲取想要操作的資料表 // 最後利用 setQuery() 進行資料上的修改 return this.system.getDatabase(db_name).getPermission(this).getTable(table_name).putQuery(query); } } 我們可以看到：雖然只是一個簡單的 User.update() 方法，裡面卻至少依賴了 4-5 種不同的物件方法（像是 getDatabase(), getPermission(), getTable(), setQuery() \u0026hellip;等）。在這樣的程式邏輯下，應該不難想像：如果這一串呼叫中的其中一個環節出了狀況（例如 getTable() 這個方法突然壞掉了？），那麼整個 User.update() 就沒有無法正確地回應預期的結果。這就是沒有使用到「迪米特原則」可能會對程式帶來的潛在風險。\n朋友 知道了違反原則可能會造成的問題之後，接下來就可以來說明迪米特原則的程式風格了。但在直接進入到程式範例之前，我們要先來解決另外一個問題：因為迪米特原則的核心是「應該只與你自己的『朋友』建立依賴」，所以我們要先解釋所謂的「朋友」到底是什麼？一般來說，常見對於「朋友」的定義有以下四種：「類別本身的成員變數」「類別本身的方法」「父類別的所有成員與方法」「傳入方法中的所有參數」以及「在方法中建立的任何物件」。可以發現到朋友的類型能夠根據是類別還是方法有所不同，這也是該原則比較特別的一個地方：不僅適用於類別的角度，也適用於方法的角度。\n類別本身的成員變數 這個應該蠻好理解的？畢竟是「自己本身就有的東西」。「類別本身的成員變數」可以視為是一個自己的親近朋友，無論是 \u0026ldquo;基本資料型態\u0026rdquo;（像是 int, float, long, double \u0026hellip;等），或者是 \u0026ldquo;參考資料型態\u0026rdquo;（各種類別：諸如 Object, System, Database, Table \u0026hellip;等），只要是自己持有的成員變數，都可以視為自己的朋友，這點也包含類別本身的父類別、父父類別、父父父類別 \u0026hellip;等。此外，成員變數如果是 \u0026ldquo;參考資料型態\u0026rdquo; 的話，那麼它封裝成 public 的方法也可以算是「朋友」。\n類別本身的方法 同理於 1.，類別本身的方法也算是「自己本身就有的東西」，所以類別裡面的所有方法無論是哪一種封裝等級（public, pritected, private）無論是哪一種回傳型態（int, String, Object, Book \u0026hellip;等），無論該方法需不需要參數 \u0026hellip;等，它們都可以視為是自己的朋友。因此在進行這類的呼叫時上不用太過擔心，雖說不上是肆無忌憚，但大體而言，還是可以放心使用。\n傳入方法中的所有參數 接下來從方法的角度去做切入：在 \u0026ldquo;方法\u0026rdquo; 的程式細節中，除了可以利用到上述的兩種朋友（所屬類別的成員變數、所屬類別的其他方法）之外，還可以將「傳入方法中的所有參數」都視為是自己的朋友，也跟 1 同理，無論是 int, float \u0026hellip;等基本資料型態，還是 Object, String \u0026hellip;等參考資料型態，只要是傳進來的參數，都可以視為是方法本身的「朋友」，此外，邏輯同樣也跟 1 一樣，傳入方法的參數如果是某一個物件的話，該物件封裝成 public 的方法也可以被視為「朋友」。\n在方法中建立的任何物件 這算是對於類別或方法來說，最為彈性的一個「朋友」。建立物件的方式有兩種：第一種是透過最簡單的 new 關鍵字建立，像是在方法內直接使用 Database db = new Database() 這類的語句來生成新物件。另一種方式是透過回傳值建立起來的物件：可以透過類別本身建立物件、透過成員變數建立物件、或者是物件參數建立物件 \u0026hellip;等，透過這些方式所獲得的物件，同樣可以也算是方法的「朋友」。\n綜上所述，程式的更新可以改寫成以下的樣子：\n// [使用者] 類別 class User { private DatabaseManagementSystem system; public State update(String db_name, String query) { this.system.connectToSystem(this); State State = this.system.update(db_name, query); return State; } // 其他 User 中的方法 ... // 其他 User 中的方法 ... // 其他 User 中的方法 ... } // [資料庫系統] 類別 class DatabaseManagementSystem { private Map\u0026lt;String, Database\u0026gt; databases; public void connectToSystem(User user) { // 一些連接資料庫的程式 ... } public State update(String db_name, String query) { Database db = this.getDatabase(db_name); State state = db.putQuery(query); return state; } private Database getDatabase(String db_name) { // 一些取得資料庫的程式 ... } // 其他 DatabaseManagementSystem 中的方法 ... // 其他 DatabaseManagementSystem 中的方法 ... // 其他 DatabaseManagementSystem 中的方法 ... } // [資料庫] 類別 class Database { public State putQuery(String query) { // 一些執行 query 的操作 } // 其他 Database 中的方法 ... // 其他 Database 中的方法 ... // 其他 Database 中的方法 ... } 現在， User 的 update 方法只跟 system 這個變數，以及 system.update() 這個方法保持依賴，如果程式中的其他部分（例：Database.putQuery()）發生問題，雖然就結果而言，還是會使得 User.update() 無法順利運行，但是因為現在 User 已經沒有再依賴 Database 的相關方法了，因此即便 putQuery() 有需要修改細節上的程式內容、或者是修改傳入的參數 \u0026hellip;等，都不會對 User.update() 方法造成影響。這就是「降低方法依賴」所帶來的好處，也是迪米特原則倡導的一個程式撰寫方法。\n鏈式呼叫 最後，還有一個在該原則上很容易搞混的問題：鏈式呼叫。雖然在大部分的情況下，當我們想要看 Java 內的程式是否符合迪米特原則時，對直觀的方法會是「數一行程式上存在著多少個 .」，但不是所有「超過 1 個 . 的程式」就是需要修改、不符合迪米特法則的程式。一個最常見的例子是：System.out.println()，雖然程式裡面包含了兩個 .，但這句話本質上就是一個單純的輸出指令，不需要做任何的修改。\n還有一種常見情況是 return this 的時候，例如當一個 Database 需要創建一個新的 Table 時，他會不停地對某一個 Table 物件做修改和操作，雖然在視覺上，這個 Database 呼叫了很多不同種類的方法，但追根結底，對於這個 Database 來說，它所依賴的物件易始至終並沒有發生任何的變化，那這樣得情況下，即使呼叫了很多不同種類的方法，也還是可以視為一個「與朋友溝通」的操作，就像是下面這樣：\nclass Database { // 一些 Database 的成員變數 // 一些 Database 的成員變數 public createTable() { Table table = new Table(\u0026#34;Student\u0026#34;); table.charSet(\u0026#34;UTF-8\u0026#34;) .addColumn(\u0026#34;id\u0026#34;, Integer.getClass()); .setUnique(\u0026#34;id\u0026#34;); .setAutoIncrement(\u0026#34;id\u0026#34;); .addColumn(\u0026#34;name\u0026#34;, String.getClass()); .addColumn(\u0026#34;age\u0026#34;, Integer.getClass()); .addColumn(\u0026#34;sex\u0026#34;, String.getClass()); .addColumn(\u0026#34;teacher\u0026#34;, Teacher.getClass()); .addColumn(\u0026#34;parents\u0026#34;, Person.getClass()); .addColumn(\u0026#34;contact\u0026#34;, String.getClass()); } } 對於 createTable() 這個方法來說，雖然在方法裡面出現了「一行程式裡面出現多個 .」的情況，但自始至終，這些方法在執行和操作的過程，都只會影響到最一開始那個被建立的 table 物件，而 table 物件是「方法中被建立的物件」，也就是法則裡面所定義的「朋友」，因此，即便這行程式裡面出現了許多方法間的呼叫，但就本質上而言，這個 createTable() 仍是沒有違反迪米特法則的。\n"},{"id":31,"href":"/docs/_trash/simple_factory_pattern_1/","title":"簡單工廠模式","section":"Docs","content":"\r簡單工廠模式\r#\rChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。\n簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。\n簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 \u0026hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。\n簡單整理 問題描述：Client 對於 Product 有著高度的依賴\n解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在常見的設計模式裡面，跟「工廠」有關的設計模式共有三種，分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過一個工廠，來簡單地改寫程式碼的一種設計模式。讓我們來想像一種情境：假設我們正在製作一個「繪製不同圖型」的程式，裡面有一個一個用來繪製圖形的畫布 Canvas，以及一些預設的可繪製圖形 Circle, Square, Rectangle, Triangle, 和 Polygon \u0026hellip;等。我們首先假設所有的圖形都繼承於 Shape 類別，我們也假設只要呼叫 Canvas 裡面的 addShape() 方法，並透過傳入的 String 參數，該方法就會幫我們繪製圖形，如下所示：\n// 抽象父類別 [形狀] abstract class Shape {} // 各種繼承 [形狀] 的子類別們 class Circle extends Shape {} class Square extends Shape {} class Rectangle extends Shape {} class Triangle extends Shape {} class Polygon extends Shape {} // 繪圖類別 `Canvas` class Canvas { public void addShape(String shape) { // 建立圖形變數 \u0026#39;shape\u0026#39; Shape shape = null; // 把 \u0026#39;shape\u0026#39; 變成我們預設的其中一種形狀 if(shape.equals(\u0026#34;Circle\u0026#34;)) { shape = new Circle(); } else if(shape.equals(\u0026#34;Square\u0026#34;)) { shape = new Square(); } else if(shape.equals(\u0026#34;Rectangle\u0026#34;)) { shape = new Rectangle(); } else if(shape.equals(\u0026#34;Triangle\u0026#34;)) { shape = new Triangle(); } else if(shape.equals(\u0026#34;Polygon\u0026#34;)) { shape = new Polygon(); } // 檢查 shape 是否為 null ? if(shape == null) { throw new ShapeIsNotExistException(); } // 畫圖 this.draw(shape); } private void draw(Shape shape) { // 繪製圓形的方法 } // 其他 Canvas 中的方法 ... // 其他 Canvas 中的方法 ... // 其他 Canvas 中的方法 ... } 從執行的角度來說，這支本身並沒有問題，基本上我們只要給定正確的參數（像是 canvas.addShape(\u0026quot;Circle\u0026quot;) 之類的），該繪製軟體就會正確地幫我們把圖形呈現在畫布上面。但從「設計原則」的角度來說，它其實已經違反單一職責原則了：因為現在 Canvas 類別不僅要管理「繪圖時的相關資訊」（像是設定繪圖板大小、長寬、設定各種背景參數 \u0026hellip;等），它同時也需要管理「如何生成各種不同的圖形」（圓形怎麼畫？正方形多大？長方形要什麼顏色 \u0026hellip;等）。\n因此，一個比較好的改寫方式是：先透過一個「形狀工廠」（ShapeFactory）來生產不同的形狀，並設定不同形狀的參數、顏色 \u0026hellip;等。再將 ShapeFactory 製作好的形狀回傳給Canvas，讓 Canvas 透過類別裡面的 draw() 方法，直接將該工廠所生產的圖形放到使用者的畫布上面。這樣一來，就可以完成「ShapeFactory 負責生產圖形」「Canvas 類別負責設定畫布的相關資訊」的分工：\n// [圖形] 類別，和剛剛一樣 abstract class Shape {} class Circle extends Shape {} class Square extends Shape {} class Rectangle extends Shape {} class Triangle extends Shape {} class Polygon extends Shape {} // [圖形工廠] 類別，用來生產不同的形狀 class ShapeFactory { public Shape createShape(String shape) { Shape shape = null; if(shape.equals(\u0026#34;Circle\u0026#34;)) { shape = new Circle(); } else if(shape.equals(\u0026#34;Square\u0026#34;)) { shape = new Square(); } else if(shape.equals(\u0026#34;Rectangle\u0026#34;)) { shape = new Rectangle(); } else if(shape.equals(\u0026#34;Triangle\u0026#34;)) { shape = new Triangle(); } else if(shape.equals(\u0026#34;Polygon\u0026#34;)) { shape = new Polygon(); } if(shape == null) { throw new ShapeIsNotExistException(); } return shape; } } // [畫布] 類別，用來管理跟 \u0026#34;畫布\u0026#34; 有關的各種資訊 class Canvas { private ShapeFactory shapeFactory; public Shape addShape(String shape) { Shape shape = shapeFactory.createShape(shape); this.draw(shape); } } 透過簡單工廠模式，將不同類型的工作分離，進而讓程式達到單一職責原則的規範，就是簡單工廠模式最常見的使用情境。另外，因為簡單工廠模式通常都不會有什麼太過複雜的內容，因此相對於在不同的類別裡生成不同的 SimpleFactory 物件，如果是對於程式效率很注重的人，會將工廠裡面的方法直接加上一個 static 關鍵字，讓整個方法變成一個靜態方法，如下所示：\nclass ShapeFactory { public static Shape createShape(String shape) { // 生成圖型的程式細節 ... } } class Canvas { public Shape addShape(String shape) { // 不需要生成 factory 物件 // 直接通過類別呼叫方法 // 可以節省一些 `Canvas` 所需的記憶體空間 Shape shape = ShapeFactory.createShape(shape); this.draw(shape); } } 透過將方法宣告成 static，使得其餘程式在調用 createShape() 方法時，不需要先創建一個 ShapeFactory 的物件，以節省更多的記憶體空間，就是這類作法的其中一個原因。而這種「透過工廠中的靜態方法，生成工廠中的產品」的程式撰寫方式，也可以被稱作「靜態工廠」。但需要注意的事情是：靜態工廠只是一種工廠模式的「優化方法」，而不是一種「設計模式」，工廠類型的設計模式只有簡單工廠、工廠方法、和抽象工廠三種。\n"},{"id":32,"href":"/docs/_trash/simple_factory_pattern_2/","title":"簡單工廠模式","section":"Docs","content":"\r簡單工廠模式\r#\rChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。\n簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。\n簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 \u0026hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。\n簡單整理 問題描述：Client 對於 Product 有著高度的依賴\n解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在常見的設計模式裡，跟「工廠」有關的設計模式共有三種。它們從簡單到複雜分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過生成一個「簡單的」工廠，來分離不同職責的程式碼，讓程式可以達到更好的靈活性、可讀性，和良好的封裝性。讓我們用一個簡單的例子來做說明：假設我們現在正在撰寫一個「資料庫操作程式系統」，該系統需要包含一些使用者對於資料庫的簡單操作，像是 SELECT, UPDATE\u0026hellip;等，在不使用簡單工廠模式的情況下，程式可能會寫成像是下面的這個樣子：\n// 資料庫系統中的 [使用者] 類別 class User { private Database database; private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } public QueryResult query(Database.operation operation, String query) { this.database = this.connectToSystem(this.account, this.password); QueryResult queryResult = null; switch(operation) { case Database.operation.INSERT: queryResult = database.insertQuery(query); // C - create break; case Database.operation.SELECT: queryResult = database.selectQuery(query); // R - read break; case Database.operation.UPDATE: queryResult = database.updateQuery(query); // U - update break; case Database.operation.DELETE: queryResult = database.deleteQuery(query); // D - delete break; default: throw new OperationIsNotExistException(); break; } return queryResult; } // 其他 [使用者] 的方法 ... // 其他 [使用者] 的方法 ... } 透過不同的 operation 區別不同的 query 指令，並透過 queryResult 接收 database 的各種回傳。在這樣的情況下 User.query() 方法是可以正常運行的。但話雖如此，這個 query() 方法還是有著可以優化的空間：User 類別的主要職責應該是「管理所有跟 User 相關的事物」，例如修改密碼、查看使用者基本資料、或者是一些其他主體為「使用者」的操作 \u0026hellip;等。但這個 query() 的程式細節明顯是跟「如何對資料庫進行查詢」有關，不是 User 的工作。違反了設計原則中的單一職責原則，因此，我們可以針對這一項缺失，進行一點調整：\n// 資料庫系統中的 [使用者] 類別 class User { private Database database; private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } public QueryResult query(String query) { this.database = this.connectToSystem(this.account, this.password); // 封裝『如何對資料庫進行查詢』這件事情 // 現在 User 可以不用關心 query 的程式細節 // 只要知道『這樣就可以得到資料』就行 QueryResult queryResult = database.getQueryResult(query); return queryResult; } // 其他 [使用者] 的方法 ... // 其他 [使用者] 的方法 ... } // 資料庫系統中的 [資料庫] 類別 class Database { private enum Operation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } // 將『如何對資料庫進行查詢』寫在類別 `Database` 裡面 public QueryResult getQueryResult(String query) { Operation operation = this.getOperation(query); QueryResult queryResult = null; switch(operation) { case operation.INSERT: queryResult = database.insertQuery(query); // C - create break; case operation.SELECT: queryResult = database.selectQuery(query); // R - read break; case operation.UPDATE: queryResult = database.updateQuery(query); // U - update break; case operation.DELETE: queryResult = database.deleteQuery(query); // D - delete break; default: throw new OperationIsNotExistException(); } return queryResult; } // 其他 [資料庫] 的方法 ... // 其他 [資料庫] 的方法 ... } 像這樣區隔不同職責的程式碼，就是一種「簡單工廠模式」的撰寫邏輯。此外，值得一提的是：在某些工廠類型的方法中（不是只有「簡單工廠」），為了一些程式效率（或其他）的需求，我們可以把「工廠」中的方法定義成靜態的，這樣在進行呼叫的時候，就可以不用先創建一個 Factory 物件，再透過該物件去呼叫我們想要使用的方法了——直接將方法宣告成靜態的，並透過類別直接呼叫即可。而這種透過靜態的方式，呼叫工廠中的方法的行為，就叫做「靜態工廠」方法：\n// 資料庫系統中的 [使用者] 類別 class User { private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } public QueryResult query(String query) { // 現在 `User` 不需要依賴一個 `Database` 的物件 // 只需要利用 `Database` 的靜態方法 // 同樣可以達到 `User` 預期想要做到的事情 QueryResult queryResult = Database.getQueryResult(query); return queryResult; } // 其他 [使用者] 的方法 ... // 其他 [使用者] 的方法 ... } class Database { // 一些 [資料庫] 中的成員變數 // 一些 [資料庫] 中的成員變數 // 將 getQueryResult() 宣告成靜態的 // 這樣就可以免去其餘類別需要「先創物件、在調方法」的過程 // 一方面可以簡化程式碼 // 另一方面也可以減少其餘類別本身的依賴與負擔 public static QueryResult getQueryResult(String query) { Operation operation = this.getOperation(query); QueryResult queryResult = null; switch(operation) { case operation.INSERT: queryResult = database.insertQuery(query); // C - create break; case operation.SELECT: queryResult = database.selectQuery(query); // R - read break; case operation.UPDATE: queryResult = database.updateQuery(query); // U - update break; case operation.DELETE: queryResult = database.deleteQuery(query); // D - delete break; default: throw new OperationIsNotExistException(); } return queryResult; } // 其他 [資料庫] 的方法 ... // 其他 [資料庫] 的方法 ... } 最後，簡單工廠還有一個東西可以說：在剛剛的例子下，我們無論是在 User 的方法內進行資料庫查詢，還是在工廠（也就是 Database）內進行資料庫查詢，都是讓它們回傳一個真正的 Data 物件，這樣做可能還是有點看不出「簡單工廠」的有趣之處，而也這個 Database 與其說是「工廠」，更像是一個真正的資料庫類別。因此，我們可以再～對這個程式進行一點改寫，沒有麼特別的原因，只是想要單純的改寫它：\n// 資料庫系統中的 [使用者] 類別 class User { private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } // 透過直接呼叫 Database 中的靜態方法 getQueryResult() // 可以省去一點建立 User 所需要的記憶體空間 public QueryResult query(String query) { QueryResult queryResult = Database.getQueryResult(query); return queryResult; } // 其他 [使用者] 的方法 ... // 其他 [使用者] 的方法 ... } // 資料庫系統中的 [資料庫] 類別 class Database { // 一個 \u0026#34;工廠\u0026#34; 物件 private QueryFactory factory; // 靜態方法 getQueryResult public static QueryResult query(String query) { // 呼叫一個 factory 的方法 QueryResult queryResult = factory.parseQuery(query); return queryResult; } } // 資料庫系統中的 [Query 工廠] 類別 class QueryFactory { private enum QueryOperation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } public QueryResult parseQuery(String query) { QueryOperation operation = this.parse(query); QueryResult queryResult = null; switch(operation) { case QueryOperation.INSERT: queryResult = new InsertQuery(query); break; case QueryOperation.SELECT: queryResult = new SelectQuery(query); break; case QueryOperation.DELETE: queryResult = new UpdateQuery(query); break; case QueryOperation.DELETE: queryResult = new DeleteQuery(query); break; default: throw new OperationIsNotExistException(); } return queryResult; } } // 資料庫系統中的 [Query] 類別們 abstract class QueryResult(); class InsertQuery extends QueryResult {}; class SelectQuery extends QueryResult {}; class UpdateQuery extends QueryResult {}; class DeleteQuery extends QueryResult {}; 透過讓 User 和 Database 都只依賴一個共同的「產品」父類別 Data，並且在「工廠」類別（QueryFactory）中根據不同的情況，創建出不同種類的產品子類別（例：InsertResult, SelectResult, UpdateResult, DeleteResult \u0026hellip;等），也是簡單工廠模式建議的程式撰寫方式：畢竟如果只是回傳同樣資料型態的物件，那麼就跟「單純把程式碼換地方擺」沒有兩樣了～\n"},{"id":33,"href":"/docs/_trash/simple_factory_pattern_3/","title":"簡單工廠模式","section":"Docs","content":"\r簡單工廠模式\r#\rChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。\n簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。\n簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 \u0026hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。\n簡單整理 問題描述：Client 對於 Product 有著高度的依賴\n解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在常見的設計模式當中，跟「工廠」有關的設計模式共有三種，它們從簡單到複雜分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過一個結構「簡單」的工廠，來將程式碼拆分，以提高程式系統的可讀性、靈活性、和可擴展性。讓我們以一個簡單的例子來做說明：假設我們現在需要製作一個「網站架設系統」，該系統需要包含一些關於前後端的程式內容，而其中一項功能的描述如下：「使用者可以透過輸入不同的 SQL 語句，來取得不同的資料庫內容。」用程式來呈現的話，可能會像這個樣子：\n// 架站系統中的 [客戶端] 類別 class Client { private String account; private String password; public Object getDatabaseData(String query) { Database database = this.getDatabaseConnection(account, password); Object data = null; Database.Operation operation = database.getOperation(query); switch(operation) { case Database.Operation.INSERT: data = database.insertQuery(query); break; case Database.Operation.SELECT: data = database.selectQuery(query); break; case Database.Operation.UPDATE: data = database.updateQuery(query); break; case Database.Operation.DELETE: data = database.deleteQuery(query); break; default: throw new QueryUndefinedException(); } return data; } } class Database { public enum Operation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } public Object insertQuery(String query) { // 一些 insert 的程式細節 } public Object selectQuery(String query) { // 一些 select 的程式細節 } public Object updateQuery(String query) { // 一些 update 的程式細節 } public Object deleteQuery(String query) { // 一些 delete 的程式細節 } } 透過上面的程式架構，客戶端如果想要進行一些 SQL 的操作，只要使用到 Client.getDatabaseData() 就可以完成需求了。看起來挺正常的，程式沒什麼問題，功能上也完全正確，但這樣的程式的確還有改善的空間，其中一個問題是它違反了單一職責原則：根據單一職責原則的說法，一個類別應該只處理一組相似的工作，而在類別 Client 中，它所負責的應該是一些「與客戶端有關的程式邏輯」才對，像是基本資料設定、修改密碼、或者是一些與客戶端相關的功能。\n但 getDatabaseData() 方法很明顯地就是在「調用資料庫、對資料庫進行操作、並返回結果。」這個方法從頭到尾都不與「客戶」有關，應該與「資料庫」更甚至是「SQL 操作」有關才對吧？因此，針對這一個問題，我們可以對上述的程式進行修改：把 Client.getDatabaseData() 的程式細節從 Client 中搬走，改放到 Database 的類別之中，以保證單一職責原則，提高程式的可讀性與靈活性。\n此外，為了預防「把程式全部往 Database 裡面塞之後，Database 會變得非常龐大」的狀況，我們新增了一個 Query 的抽象類別，並額外創建了 InsertQuery, SelectQuery, UpdateQuery, 和 DeleteQuery 等四個繼承自 Query 的子類別，用來分工不同的 SQL 工作內容，進而減少 Database 中的方法數量，讓分工變得更為明確。簡單來說，程式可以被我們改寫成下面的這個樣子。\n// 架站系統中的 [客戶端] 類別 class Client { private String account; private String password; public Object getDatabaseData(String query) { Database database = this.getDatabaseConnection(account, password); Object data = database.getResult(query); return data; } } // 架站系統中的 [資料庫] 類別 class Database { private enum Operation { INSERT, SELECT, UPDATE, DELETE, UNDEFINED } public Object getResult(String query) { Query queryObj = null; Operation operation = this.getOperation(query); switch(operation) { case Operation.INSERT: queryObj = new InsertQuery(); break; case Operation.SELECT: queryObj = new SelectQuery(); break; case Operation.UPDATE: queryObj = new UpdateQuery(); break; case Operation.DELETE: queryObj = new DeleteQuery(); break; default: throw new QueryUndefinedException(); } Object result = queryObj.getResult(query); return result; } } // 新增的 Query 抽象類別 // 裡面宣告了一個需要實作的 getResult 抽象方法 abstract class Query { public abstract Object getResult(String query); } // 繼承 Query 的所有子類別 class InsertQuery { @Override public Object getResult (String query) { // 一些 insert 的程式細節 } } class SelectQuery { @Override public Object getResult (String query) { // 一些 select 的程式細節 } } class UpdateQuery { @Override public Object getResult (String query) { // 一些 update 的程式細節 } } class DeleteQuery { @Override public Object getResult (String query) { // 一些 delete 的程式細節 } } 這就是透過「簡單工廠模式」的一種實現了。透過 Database 中的 getResult() 方法，讓原本寫在 Client 中的程式，得以拆分出來。現在對於 Client 來說，它不再需要知道關於 query 相關的程式細節（像是要 new 哪一種類型的 Query 物件？之後又要調用哪些分法？ \u0026hellip;等）， Client 只要知道「調用 getResult()，我就可以拿到 Database 裡面的程式」就可以了，這便是一種簡單工廠模式的程式範例。\n"},{"id":34,"href":"/docs/computer_science/design_pattern/simple_factory_pattern/","title":"簡單工廠模式","section":"設計模式","content":"\r簡單工廠模式\r#\rChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。\n簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。\n簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 \u0026hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。\n簡單整理 問題描述：Client 對於 Product 有著高度的依賴\n解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴\n程式細節：參照下面的段落\nUML 圖：\n程式碼範例 在常見的設計模式當中，與「工廠」有關的設計模式共有三種，它們由間單到複雜依序是簡單工廠模式、工廠方法模式、以及抽象工廠模式。簡單工廠模式顧名思義，就是透過一個「工廠」類別，將比較「簡單的」程次區域給獨立出來，通常會配合單一職責原則進行程式碼的檢查，如果某一段程式不符合單一職責原則的話，就可以考慮用簡單工廠將程式給區分出來。讓我們用一個簡單的範例來做說明：假設我們正在開發一個「線上傢俱閱覽系統」，使用者可以根據不同的需要來瀏覽、比較、或購買傢俱，程式片段大致如下所述：\n// 系統中的 [顧客] 類別 class Customer { private String account; private String password; // 透過不同的關鍵字，取得不同傢俱 public Furniture getFurniture(String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new Chair(); else if(name.equals(\u0026#34;desk\u0026#34;)) furniture = new Desk(); else if(name.equals(\u0026#34;sofa\u0026#34;)) furniture = new Sofa(); else if(name.equals(\u0026#34;bed\u0026#34;)) furniture = new Bed(); else if(name.equals(\u0026#34;television\u0026#34;)) furniture = new Television(); else throw new FurnitureIsNotExistException(); return furniture; } } 上圖的程式邏輯本身沒什麼問題，透過 getFurniture() 方法，我們的確可以讓顧客在系統中正確地看到他們想要留懶的不同傢俱。但從設計原則上，這樣的寫法就有可以改進的空間了，因為這支程式並不符合單一職責原則。白話文的來說： Customer 類別所負責的職責，應該僅限於跟「顧客」有關的東西才對，像是修改密碼、檢視帳戶資料、升級成 VIP 會員、儲值、訂閱相關資訊或取消訂閱 \u0026hellip;等。但這個 getFurniture() 方法很明顯是在「創建一個傢俱，並回傳給使用者。」比起顧客，更像是「傢俱」類別的工作，因此針對這個部分，我們可以利用簡單工廠模式對程式進行改寫：\n// 系統中的 [顧客] 類別 class Customer { // 新增一個 [傢俱工廠] private FurnutireFactory factory; private String account; private String password; public Furniture getFurniture(String name) { // 將「獲得傢俱」的程式封裝起來 Furniture furniture = factory.createFurniture(name); return furniture; } } // 系統中的 [傢俱工廠] 類別 class FurnutireFactory { public Furniture createFurniture(String name) { Furniture furniture = null; // 把「獲得傢俱」的程式邏輯擺放在 [傢俱工廠] 裡面 if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new Chair(); else if(name.equals(\u0026#34;desk\u0026#34;)) furniture = new Desk(); else if(name.equals(\u0026#34;sofa\u0026#34;)) furniture = new Sofa(); else if(name.equals(\u0026#34;bed\u0026#34;)) furniture = new Bed(); else if(name.equals(\u0026#34;television\u0026#34;)) furniture = new Television(); else throw new FurnitureIsNotExistException(); return furniture; } } // 系統中的 [傢俱] 類別（抽象的） abstract class Furnutire { protected String name; public Furnutire(String name) { this.name = name; } } // 其他繼承了 [傢俱] 的不同真實傢俱 class Chair { public Chair(String name) { super(name); } } class Table { public Table(String name) { super(name); } } class Lamp { public Lamp(String name) { super(name); } } class Computer { public Computer(String name) { super(name); } } 這就是簡單工廠的具體範例了。\n執得一提的是，因為簡單工廠真的很簡單，因此在一些程式設計上，我們更傾向於把簡單工廠的方法（或方法們）宣告成靜態的（也就是加上 static 關鍵字）。因為如果將方法宣告成靜態方法，其他類別（例如 Customer）在調用工廠中的方法時，就不需要再額外 new 一個工廠的物件出來，算是一種節省記憶體空間的操作。而這種把方法宣告成靜態的撰寫方式也可以稱為「靜態工廠」。但需要注意的是：靜態工廠並不是一種模式，僅僅是一種工廠模式的優化方法而已：\nclass FurnutireFactory { // 加入 static 關鍵字，使其成為靜態方法 public static Furniture createFurniture(String name) { Furniture furniture = null; if(name.equal(\u0026#34;chair\u0026#34;)) furniture = new Chair(); else if(name.equals(\u0026#34;desk\u0026#34;)) furniture = new Desk(); else if(name.equals(\u0026#34;sofa\u0026#34;)) furniture = new Sofa(); else if(name.equals(\u0026#34;bed\u0026#34;)) furniture = new Bed(); else if(name.equals(\u0026#34;television\u0026#34;)) furniture = new Television(); else throw new FurnitureIsNotExistException(); return furniture; } } // 系統中的 [顧客] 類別 class Customer { private String account; private String password; public Furniture getFurniture(String name) { // 透過 [傢俱工廠] 直接獲得傢俱 // 省去了建立物件的過程 Furniture furniture = FurnutireFactory.createFurniture(name); return furniture; } } "},{"id":35,"href":"/docs/finance/track_expenses/202308/","title":"記帳 2023/08","section":"個人記帳","content":"\r記帳 2023/08\r#\r各方面金流\n台幣活存：4098 台股股票淨值：19278 借貸狀況： 借出共 143,500 + 50,000 元 貸款共 0 元 保險： 儲蓄型保單收到了 2 元的回饋 備註\n因為信用卡還沒開辦的原因，所以個人的信用評分應該還算是很低很低。加上現在還是處在比較高利的情況，所以我不打算去做一些跟信貸有關的相關操作。因此貸款的數字是 0。另外借出約 20 萬左右的金額，主要是由兩個人所組成，預計會在近 1-2 年內回收完畢吧？如果到時候還沒回收的話，可能就會採取比較激進一點的行動方針。\n活存的部分 \u0026hellip;只能說相當可怕啦。下個月的花錢必須要非常拮据與謹慎，不然一不小心就會直接死給大家看了。台股的淨值大約是 20k，它是我 4 個月定期應額 006208 的小小成果，基本上台股的部分不會有太多的更動，它就會是一個每個月固定 5000, 5000 投入的狀況。不打算做一點短線的投機，次要原因是目前沒有甚麼了解的標的在低檔位的股價，主要原因是沒有多餘的閒錢 （哭）\n大概是這樣，目前看來沒什麼大問題，除了活存的數字真的是有夠少之外 \u0026hellip;。整體而言，自評的話大概會給 57-58 左右吧？滿分是 100 分。不及格的部分是活存水位過低、沒有緊急預備金。但剩下的 \u0026hellip; 我覺得基本上沒有大問題，但這　1-2　個月要好好調整自己的用錢習慣就是，畢竟已經沒有研究室的研究補貼了，算命的收入要想辦法拉高一點。\n"},{"id":36,"href":"/docs/finance/track_expenses/202309/","title":"記帳 2023/09","section":"個人記帳","content":"\r記帳 2023/09\r#\r各方面金流\n資產的部分 台幣活存 31,222 元 台股股票淨值：28,964 元 借出共 143,500 元 負債的部分 貸款共 157,000 元 備註\n這禮拜活存大概暴增了 3-4 萬有，是因為上個月有一筆的 5 萬的借款拿回來了。股票淨值多了大約 10k，是因為這個月多買了一次 5000 的零股，但台股的錢基本上不會去動啦，畢竟是 006208 的定期定額 \u0026hellip;。另外有一筆借出約 15 萬左右的款項被我劃掉了，因為那筆借貸目前在法院的訴訟中，但我覺得有高機率拿不回來 XDD，所以就先當沒這筆錢，因此目前的總資產大約落在 55-60 k 左右。\n負債的部分 \u0026hellip; 最近妹妹不小心被人騙錢了 XD 大概被騙了 15 萬左右，身為哥哥，當然就是全扛下來啦～雖然寫是寫「負債」，但比較像是「這筆錢妳就當我先跟妳借的，我再慢慢還妳」的那種感覺，所以比較像是無期限(? 的 0 利率貸款，超划算對吧～哈哈哈哈，不過之後還是要慢慢還就是了。\n"},{"id":37,"href":"/docs/computer_science/design_pattern/","title":"設計模式","section":"資工相關","content":"\r設計模式\r#\rChatGPT 的說明 【設計模式】（Design Patterns）是一種軟體工程中的概念，它描述了一種解決特定問題的通用方法或解決方案。設計模式是一種被廣泛接受和應用的軟體設計指南，它們有助於提高程式碼的可讀性、可維護性和可擴展性。通常來說，一個設計模式通常包括下面的 3 種元素：［問題描述］問題描述用來描述該模式被用來解決的問題，或便於使用此模式的情境，通常來說，問題描述可能會涉及到關於程式的複雜性、耦合性、或可讀性\u0026hellip;等不同方面的問題。［解決方案］解決方案可以為我們提供一個關於「問題」的解決方法，通常來說，解決方案會包括含一個設計結構和一個（或多個）設計原則，以便應用在特定的問題或情境中。［程式細節］程式細節用來具體示範如何在程式碼中實現這個 \u0026ldquo;解決方案\u0026rdquo;，包括扮不限於類別的結構、方法、和關係。\n設計模式的主要目標是促進程式碼的重用性、減少程式的冗餘，提高程式的可維護性、可讀性、或可擴展性。通過使用設計模式，程式的開發人員可以借鑒已經證明有效的解決方法對專案中的程式進行撰寫，而不必重新尋找解決方案、重新發明輪子、重新測試方法的可靠性。設計模式也有助於提高程式碼的可讀性，因為這些模式通常都會提供一些通用的語言和程式結構，使得程式的開發人員更容易理解和操作。一些常見的設計模式包括單例模式、工廠模式、觀察者模式、策略模式、適配器模式等。每種設計模式都針對不同的問題和情境提供了一個優雅且經過驗證的解決方案。開發人員可以根據特定的需求選擇適當的設計模式，以改善其軟體設計。\n設計模式通常可以分為創建型模式、結構型模式、和行為型模式 \u0026hellip; 等 3 種類別，每個類別都包含一組相關的設計模式，用於解決特定類型的問題：［創建型模式］創建型模式的重點在於如何創建物件，以及如何管理物件的實例化過程。創建型模式的主要目標是隱藏實例的創建過程，從而使程式更具靈活性和可維護性，同時降低類別對魚特定物件的依賴性。［結構型模式］結構型設計模式關注如何組合類別和物件，以使程式可以形成更大的結構，以解決更高層次的問題。結構型模式的主要目標是改進系統的組織與結構，使其更具有靈活性和可擴展性，同時降低系統中各個部分的耦合程度。［行為型模式］行為型關注主要研究的內容是如何進行物件之間的相互通信和合作，以實現更好的交互作用與職責分工。行為型模式的主要目標是改進類別之間的溝通方式，使系統更容易理解和維護。\n以下是一些設計原則，與常見的設計模式：\n預備知識\nUML（Unified Modeling Language） 設計原則\n單一職責原則（Single Responsibility Principle） 開放封閉原則（Open Closed Principle） 里氏替換原則（Liskov Substitution Principle） 介面隔離原則（Interface Segregation Principle） 依賴反轉原則（Dependency Inversion Principle） 最少知識原則（Least Knowledge Principle） 合成/聚合複用原則（Composite/Aggregate Reuse Principle） 創建型模式\n簡單工廠模式（Simple Factory Pattern） 工廠方法模式（Factory Method Pattern） 抽象工廠模式（Abstract Factory Pattern） 單例模式（Singleton Pattern） 創建者模式（Builder Pattern） 原型模式（Prototype Pattern） 結構型模式\n適配器模式（Adapter Pattern） 裝飾器模式（Decorator Pattern） 橋接模式（Bridge Pattern） 代理模式（Proxy Pattern） 外觀模式（Facade Pattern） 組合模式（Composite Pattern） 享元模式（Flyweight Pattern） 行為型模式\n策略模式（Strategy Pattern） 模版模式（Template Pattern） 觀察者模式（Observer Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 狀態模式（State Pattern） 職責鏈模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 備忘錄模式（Memento Pattern） 解譯器模式（Interpreter Pattern） 訪客模式（Visitor Pattern） "},{"id":38,"href":"/docs/_trash/liskov_substitution_principle/","title":"里氏替換原則","section":"Docs","content":"\r里氏替換原則\r#\rChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。\nLSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。\n這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。\n簡單整理 簡單來說：父類別沒有的，子別類不一定要有，但是父類別有的，子類別都一定要有\n程式碼範例 里氏替換原則討論的是關於類別（或介面）發生繼承時，應該遵守或者是留意一個規範或想法。大致上的重點在於「子類別應該完全實現父類別的想法」「子類別可以對付類別的想法作出補充」以及「子類別應該遵循與父類別一致的規則」這句話上面。簡單來說就是「父類別的擁有和要求，子類別都要做到」但「父類別沒有要求的，子類別可以不用做到」這兩句話上。\n自己稍微唸了一下，感覺還是有點饒口，直接用一個範例程式碼來做舉例好了：假設我們現在受到了某某大型運輸公司的委託，需要製作一個該公司的「交通工具查閱系統」，裡面需要包含一些常見的交通工具的相關資訊，像是汽車、船、機車、公車、腳踏車、直升機、飛機 \u0026hellip;等，在最最直觀的情況下，我們可以把所有的交通工具都寫成互不相關的獨立類別，就像是下面的這個樣子：\nclass Car { String id; String type; public void driving() { System.out.println(\u0026#34;在馬路上行駛\u0026#34;); } // 其他跟[汽車]有關的方法 // 其他跟[汽車]有關的方法 } class Boat { String id; String type; public void sailing() { System.out.println(\u0026#34;在河道或海中航行\u0026#34;); } // 其他跟[船]有關的方法 // 其他跟[船]有關的方法 } \u0026hellip;（還有其他好多類型的交通工具）\nclass Helicopter { String id; String type; public void flight() { System.out.println(\u0026#34;在天空中飛行\u0026#34;); } // 其他跟[直升機]有關的方法 // 其他跟[直升機]有關的方法 } 但因為不同的交通工具之間，多少還是會有類似的一些屬性或方法，像是大家都有 id, type，陸上交通工具都有 driving() 方法、船型工具都可以 sailing()、飛機跟直升機都可以flight() \u0026hellip;等，因此，一個更好的寫法可能是「把相同的部份提出來，作為一個共用的父類別，以提高程式的重用性，並減少程式的冗余。」就像是下面的這個樣子：先定義一個共同的 Vehicle 類別，然後把所有的變數和方法進行統一的定義跟宣告，再讓其餘的類別（Car, Boat \u0026hellip;等）進行實例化。\nabstract class Vehicle { protected String id; protected String type; public abstract void driving(); public abstract void sailing(); public abstract void flight(); } class Car extends Vehicle { // 實作關於 Vehicle 類別中的方法 }; class Boat extends Vehicle { // 實作關於 Vehicle 類別中的方法 }; // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... class Helicopter { // 實作關於 Vehicle 類別中的方法 }; 不過，這樣改寫的話，一個可能的問題就出現了：我們都知道，Car 這個類別就是一個單純的汽車，它的運輸方式就是普通的「在路上跑」，並不會什麼在海上跑啊、在天上飛啊 \u0026hellip;這類的方法。但因為我們在父類別 Vehicle 裡定義了 sailing() 和 flight() 的方法，理論上來說，我們還是得實利化這一些父類別所定義的抽象方法，所以就有可能會寫出像這樣的程式來：\nclass Car extends Vehicle { // 建構子，用於設定型號及車牌 public Car(String type, String id) { this.type = type; this.id = id; } // 改寫「在路上跑」的方法 @Override public void driving() { System.out.println(\u0026#34;車子利用 4 個輪子在道路上行駛\u0026#34;); }; // 雖然不會用到，但還是得進行改寫的其餘方法 @Override public void sailing() {}; @Override public void flight() {}; }; // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... 同樣的狀況，也會發生在所有無法陸海空三棲的交通工具上。\n所以，如果利用這種方式對原本的系統進行改寫的話，雖然不會產生邏輯上的問題（畢竟車子真的就不會在天上飛，所以車子的 flight() 就什麼都不寫），但這樣的寫法就不遵循里氏替換原則了。因為「子類別 Car 沒有辦法完整的實現父類別 Vehicle 所定義的所有方法。」比較好的改善方式有兩種：第一種是把所有的交通工具運行方式統一定義成像是 move() 這類的方法，再透過各子類進行更加細節的描述：\n// 父類別 Vehicle 用以涵蓋所有交通工具 abstract class Vehicle { protected String id; protected String type; // 抽象方法 move() 用來表示「交通工具都可以『行進』」 public abstract void move(); } // 子類別 Car 用來實現一種「真正的交通工具」 class Car extends Vehicle { // 建構子 public Car(String type, String id) { this.type = type; this.id = id; } // 改寫『行進』這個方法，並作更細節的描述 @Override public void move() { System.out.println(\u0026#34;車子利用 4 個輪子在道路上行駛\u0026#34;); }; }; // 子類別 Airplane 用來實現一種「真正的交通工具」 class Airplane extends Vehicle { // 建構子 public Airplane(String type, String id) { this.type = type; this.id = id; } // 改寫『行進』這個方法，並作更細節的描述 @Override public void move() { System.out.println(\u0026#34;飛機利用機翼在天空中飛行\u0026#34;); }; }; // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... 另一種更加符合「里氏替換原則」的思考模式的改寫方式，則是利用更加細緻的不同類別，來分別對不同的交通工具進行擴充：像是原本只有一個 Vehicle 類別作為父類，其餘子類別則直接實現 Vehicle 類別。現在我們可以修改成「有一個最高類別 Vehicle，中間有三個子類『陸上交通工具』『海上交通工具』和『空中交通工具 』，最最下面才有 Car, Airplane \u0026hellip;等不同的類別」，就像是下面這樣：\n// 父類別 Vehicle，現在只定義了「型號」與「車牌」 abstract class Vehicle { protected String id; protected String type; } // 陸上交通工具，包含了 Vehicle 與『陸上』專有的一些行為 abstract class LandVehicle extends Vehicle { public abstract void driving(); } // 海上交通工具，包含了 Vehicle 與『海上』專有的一些行為 abstract class Watercraft extends Vehicle { public abstract void sailing(); } // 空中交通工具，包含了 Vehicle 與『天上』專有的一些行為 abstract class Aircraft extends Vehicle { public abstract void flight(); } // 實體的交通工具 Car class Car extends LandVehicle { public Car(String type, String id) { this.type = type; this.id = id; } // 因為只繼承『陸上』交通工具 // 因此 Car 不具有海上和天上的行為 @Override public void driving() { System.out.println(\u0026#34;車子利用 4 個輪子在道路上行駛\u0026#34;); }; } // 實體的交通工具 Boat class Boat extends Watercraft { public Boat(String type, String id) { this.type = type; this.id = id; } // 因為只繼承『海上』交通工具 // 因此 Car 不具有陸上與空中的行為 @Override public void sailing() { System.out.println(\u0026#34;船可以在河道或海上航行\u0026#34;); }; } // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... 這樣一來，就保證了子類別會保留（和實現）父類別的所有行為，也就達成了里氏替換原則所想要傳達的訊息。\n值得一提的是：因為 Java 語言不允許多重繼承（也就是同時繼承 1 個以上的類別），所以在這樣的情況下，如果出現了一個「水路兩棲車」的類別，它就沒辦法同時繼承 LandVehicle 和 Watercraft。一個比較好的調整方式是把所有的父類調整成介面（Interface）的形式，再讓多棲的交通工具進行多種介面的實例化，像是下面這個樣子：\n// 父類別 Vehicle，只定義一些相關的成員變數 abstract class Vehicle { protected String id; protected String type; } // 陸上交通工具，宣告陸上的專有行為 abstract interface LandVehicle { public abstract void driving(); } // 海上交通工具，宣告海上的專有行為 abstract class Watercraft { public abstract void sailing(); } // 空中交通工具，宣告天上的專有行為 abstract class Aircraft { public abstract void flight(); } class SuperVehicle implements LandVehicle, Watercraft, Aircraft { public SuperVehicle(String id, String type) { this.id = id; this.type = type; } @Override public void driving() { System.out.println(\u0026#34;超級交通工具可以在『路上』行駛\u0026#34;); } @Override public void sailing() { System.out.println(\u0026#34;超級交通工具可以在『海上』航行\u0026#34;); } @Override public void flight() { System.out.println(\u0026#34;超級交通工具可以在『空中』飛行\u0026#34;); } } 同樣也可以完成里氏替換原則的規範。\n"},{"id":39,"href":"/docs/computer_science/design_pattern/liskov_substitution_principle/","title":"里氏替換原則","section":"設計模式","content":"\r里氏替換原則\r#\rChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。\nLSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。\n這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。\n簡單整理 父類別的方法，如果換成子類別來做，應該要得出一樣的結果\n程式碼範例 在所有的設計原則中，里氏替換原則應該是最難懂的（至少在我自己理解的過程中 XD），作為設計原則中的其中一項原則，里氏替換原則所討論，是關於類別與類別間的繼承（inherit）和改寫（override）的問題。里氏替換原則的核心，就是在確保簡單整理中的那句話：「父類別的方法，如果換成子類別來做，應該要得出一樣的結果。」也就是說，如果在一個程式裡面我們看到了 Parent.method(arg) 這樣的語句。里氏替換原則要求的，就是希望如果我們寫成 Child.method(arg) 時，程式同樣也可以呈現出原本的結果，不應該換了一個子類別執行，程式的結果就發生改變。\n更仔細一點的說，雖然我們在學習的過程中，被告知了「『繼承』即是包含了 is-a 的概念的兩個類別」，但該原則告訴了我們：嚴格一點來說，我們並不能夠單純地因為 A is-a B，就讓 A 跟 B 使用繼承（像是正方形 is-a 矩形，企鵝 is-a 鳥類 \u0026hellip;等），在使用繼承的時候，應該要更加嚴謹，更加小心。里氏替換原則包含以下幾個想法：子類別的參數數量和順序應該與父類別完全相同、子類別的前置條件不應該比父類別嚴格、子類別的後續條件不應該比父類別寬鬆、以及在父類別中沒有被改變的參數，子類別也應該對其保持不變。\n我們用一個簡單的例子，快速了解這之中的差別：在數學的定義上，我們可以知道「矩形」是四個角都是直角的四邊形，「正方形」是四個角都是直角、且四個邊都有相同長度的四邊形。因此，在數學的分類上，我們可以說「正方形是一種矩形」也就是「Sruare is a Rectangle」，那在程式上，我們同樣也能說出「Sruare is a Rectangle」嗎？讓我們用程式來觀察觀察，我們先假設正方形是長方形的一種：\n// 長方形 class Rectangle { protected int width; protected int height; // 建構子 public Rectangle() {} // 長方形的 setter (getter 就先省略了) public void setWidth(int width) { this.width = width; } public void setHeight(int height) { this.height = height; } // 長方形中的一些方法（以面積為例子） public int getArea() { return width * height; } } class Square extends Rectangle { // 建構子 public Square() {} // 描述一下正方形裡更嚴格的定義 ... // 改寫一下原來的方法 // 設定「寬」就等於設定「高」 @Override public void setWidth(int width) { this.width = width; this.height = width; } // 改寫一下原來的方法 // 設定「高」就等於設定「寬」 @Override public void setHeight(int height) { this.width = height; this.height = height; } // 方法 \u0026#39;getArea()\u0026#39; 可以不用改，畢竟也是長 x 寬沒錯 // public int getArea() { // return width * height; // } } 看起來沒什麼問題？我們試著執行一次：\nclass Test { public static void main(String[] args) { Rectangle rectangle = new Rectangle(); rectangle.setHeight(3); rectangle.setWidth(7); System.out.println(\u0026#34;area: \u0026#34; + rectangle.getArea()); Square square = new Square(); square.setHeight(5); System.out.println(\u0026#34;area: \u0026#34; + square.getArea()); } } area: 21 area: 25 結果也很符合預期，那麼應該就沒有什麼問題了吧？的確，如果單純從「程式本身的執行邏輯」還有「繼承的特性」去做切入的話，這支程式無論是在設定還是在執行上面，都沒有什麼需要挑惕的地方，但重點就在於「它在某些情況下『人的預期』和『實際的程式』會不一樣」，什麼意思呢？意思是如果我們之後寫了一組「設定/測試矩形的相關係數」的程式，人的預期和實際的程式就會產生誤差，就像是下面的這個樣子：\n// 測試程式 class Test { public static void main(String args[]) { Test obj = new Test(); obj.testRectangle(new Rectangle()); obj.testRectangle(new Square()); } public void testRectangle(Rectangle rectangle) { System.out.println(\u0026#34;測試類別 \u0026#34; + rectangle.getClass()); rectangle.setHeight(7); rectangle.setWidth(13); if(rectangle.getArea() != 91) { String message = r.getClass() + \u0026#34;area != 91\u0026#34;; throw new AreaCalculationException(message); } } } 測試類別 class Rectangle 測試類別 class Square Exception in thread \u0026#34;main\u0026#34; AreaCalculationException: class Squarearea != 91 at Test.testRectangle(Test.java:71) at Test.main(Test.java:57) 到這邊為止，可能有一部分的人會有「這\u0026hellip;好啦它是有一點問題沒錯，但不就只是一個 Square 或者是一個 Rectangle 的面積嗎？事情是能夠嚴重到哪裡去？」的想法，那讓我們再舉一個比較實際一點的例子：我們假設現在在做一個公司的登入系統，預設密碼不能為空的，然後我們想要讓不同的人（ex. 員工、經理、老闆、客戶 \u0026hellip;等）有各自的類別，於是工程師寫成了以下的樣子：\n// 類別 [系統] class LogInSystem { // 負責登入的主要函數 \u0026#39;logIn()\u0026#39; public boolean logIn(String account, String password) { // pseudo code 用來假設一個獲取資料的情境 Database database = Database.getDatabase(\u0026#34;company_members\u0026#34;); // 假設 table 會回傳像是 \u0026#34;老闆\u0026#34; \u0026#34;經理\u0026#34; \u0026#34;員工\u0026#34; \u0026#34;客戶\u0026#34;... 等不同種類的資料表 // 這邊同樣假設了不同表之間的帳號不會重複 // 所以 \u0026#39;getTable()\u0026#39; 可以依照帳號去判斷要回傳哪個表格 Table table = database.getTable(\u0026#34;position\u0026#34;, account); // 回傳登入的結果，但 \u0026#39;要怎麼判斷能不能登入\u0026#39; 則依照表格自己的方法決定 return table.loginTest(account, password); } } // 抽象類別 [資料表] abstract class Table { // 資料表名稱 protected String name; // 驗證登入的方法 boolean loginTest(String account, String password) { // 密碼想當然不可以是空的 if(password.equals(\u0026#34;\u0026#34;)) { return false; } // 拿到 account 對應的 password String sql = \u0026#34;SELECT `password` from \u0026#34; + name + \u0026#34; where `account` = \u0026#34; account; // 檢查密碼是否一致 String result = Table.getResult(sql); // 回傳結果 return (password == result); } } 現在，公司聘用了好幾個工程師，分別負責不同資料表的登入功能（也許員工登入之前，需要主管給予權限？也許客戶在登入的時候，只允許某些時段 \u0026hellip;等），然後，負責 BossTable 的工程師其實是老闆的兒子，他爸爸跟他說「我就不設密碼了，反正看到是我的帳號，就直接讓我登入就好」所以 BossTable 的程式就變成了類似下面的樣子：\nclass BossTable extends Table { @Override public boolean loginTest(String account, String password) { return true; } } 然後 Boss 的資料表實際上長這個樣子\n+-------+--------+ |account|password| +-------+--------+ | boss| NULL| +-------+--------+ 到這裡為止，如果單看程式邏輯的話，一切都還在很合理的範疇，但接下來問題出現了：公司在原來執行「撤銷離職員工的帳密」的操作的時候，因為一些原因，他們決定「撤銷」這個動作，並不是直接把員工資料刪掉，而是直接把離職員工的密碼刷成 NULL。然後再在 table.loginTest() 裡面寫上一個「如果密碼是 NULL，則直接回傳登入失敗」的語句（畢竟在正常情況下，沒有會把密碼設成 NULL，而且 Table 原本的判斷也防止了有人想要把密碼設成 NULL 的狀況）。\n然後又過了 3-5 年，負責資料庫的主管發現「誒？最近離職員工的資料好像越來越佔空間了欸」所以他就在主管開會的時候，提議了「把離職員工的資料從資料庫中清除」的提案，想當然提案毫無阻礙地通過了。所以他就跟下面的工程師說「幫我寫個程式，檢查一下所有的表格，把離職的員工資料都刪一刪。」然後，因為該員工很直覺的理解成「哦？離職員工，密碼是 NULL 的那些嘛～」，所以 \u0026hellip;沒錯 \u0026hellip;你們想像中的事情就發生了 \u0026hellip;，\nclass Database { // 上面有一些 `getDatabase`, `getTable()` 之類的方法 // 上面有一些 `getDatabase`, `getTable()` 之類的方法 // 上面有一些 `getDatabase`, `getTable()` 之類的方法 public static void deleteDepartedEmployeeData() { // 取出所有資料表 List\u0026lt;Table\u0026gt; tables = Database.getAllTables(); // 對所有的資料表逐一進行操作 for(Table table: tables) { // 取出資料表內所有的帳號和密碼 List\u0026lt;Data\u0026gt; data = table.getAllData(\u0026#34;account\u0026#34;, \u0026#34;password\u0026#34;); // 逐一檢查資料表內的內容 for(Data row_data: data) { // 判斷資料中的密碼欄位是否為 \u0026#39;NULL\u0026#39; if(row_data.get(\u0026#34;password\u0026#34;).isNull()) { // 刪除資料 String account = row_data.get(\u0026#34;account\u0026#34;); String sql = \u0026#34;delete from \u0026#34; + table.name + \u0026#34; where `account` = \u0026#34; account; table.update(sql); } } } } } 嗯\u0026hellip; 或許接下來我們就可以探討「老闆在發現自己的資料都消失後，會有怎樣的反應」以及「誰該負責這件事情」的問題，但在那之前，我們或許可以從程式上的角度上來思考，為什麼這樣的問題會發生？這跟最一開始的長方形、正方形又有什麼關係？可能有些人覺得沒有關係，可能有些人會有自己的解釋或說法，不過在這邊呢，畢竟文章還是跟設計原則有關，所以我會給出的答案是：「它們都沒有達成『父類別的方法，如果換成子類別來做，應該要得出一樣的結果』。」也就是「它們都沒有遵守『里氏替換原則』」。\n說得仔細一點，矩形的案例犯的錯是「明明 Rectangle 的 setWidth() 和 setHeight() 都只有對特定變數行操作，但在 Square() 裡面，無論是 setWidth() 還是 setHeight() 都還有對其他變數進行操作。」而老闆密碼的案例則是「明明 Table 都已經先說了『密碼不可以是 NULL』，但是在 BossTable 那邊卻還是讓 NULL 通過。」\n那麼，如果要系統化一點的說，既然我們知道了他們的錯是「沒有遵守『父類別的方法，如果 \u0026hellip; 的結果』」，那怎麼樣寫才能避免這種事情呢？畢竟在正常思考下，「正方形 is a 長方形」跟「老闆説他不要設密碼，我們就放 NULL 在密碼裡面」都是很人性化也很直覺的邏輯。也因此，里氏替換原則為了讓我們能快速搞懂哪些東西是「乍看之下很有邏輯，實際上在程式裡面會出問題」的寫法，它列舉了好幾項大注意事項。\n而簡單來說，我們只要遵循以下的幾個條件，就可以確保我們的程式能遵守里氏替換原則了，它們分別是「參數的數量跟順序要保持一致」「子類別的輸入，不能減去原本可以的選擇」「子類別的輸出，不能多出原本沒有的選擇」以及「父類別在方法中沒有修改的變數，子類別也不要修改。」聽起來可能有點饒口？直接用一個例子來做說明可能會更好一點，下面我們用一個簡單的計算機父類別（Calculator）來做舉例：\nabstract class Calculator { // 自定義的數字類別 protected RationalNumber add(NaturalNumber x, PrimeNumber y) { if(x \u0026gt; 100 || y \u0026gt; 100) { throw new NumberOverflowException(); } RationalNumber result = x + y; return result; } } 參數的數量跟順序要保持一致 這個沒什麼好說的，很直觀、很好懂。數量要相同、順序不能換。\n子類別的輸入，不能減去原本可以的選擇 用字面上的例子理解：在 Calculator.add() 中，參數可以進到程式主體的條件有三個：分別是 x 為自然數、 y 為質數、以及 x, y 都要小於等於 100。所以如果有一個Calculator 的子類別想要改寫 add() 方法，那這個 add() 的輸入，就不可以少掉原本的這些，像是設定 x 成奇數（讓原本的偶數不見了）、設定 y 成孿生質數（讓原本的非孿生質數不見了）、或者是限制 x,y 都得小於等於 70（讓原本 70-100 的選擇不見了）\u0026hellip;等。\n子類別的輸出，不能多出原本沒有的選擇 理解 2 之後，3 應該就會比較好懂了：輸出選擇一般指的是回傳，或執行回傳的條件。在 Calculator.add() 中，該方法實際上有兩個回傳：分別是比較直觀的 return result 以及例外處理中的 Exception。先從一般的 return 來看，result 的回傳是一個有理數（RationalNumber），所以在想要改寫 add() 的子類別中，我們可以輸出的東西，最多最多就是原定的那些有理數的範圍，因此像無理數、實數、複數\u0026hellip;等，就不可以拿來被回傳。\n但是輸出的選擇可以維持原樣（或者變得更少），所以回傳有理數、整數、自然數、或質數 \u0026hellip;等都是可以的。此外 Exception 的情況是「只要 x 或 y 大於 100，就輸出例外」，因此如果子類別想要改寫這個條件的話，就至少要維持 if 內的判斷可以包含所有 100 以上的數字（因此 x \u0026gt; 101 之類的就不允許）。此外，這一點也是老闆密碼案例裡違反的項目：父類別中並不允許遇到 NULL 可以回傳 true，但這句話 BossTable 那邊被修改了。\n父類別在有修改的變數，子類別也不要修改 這個「變數」指的是父類別和子類別共同擁有的變數，像是在 Rectangle 和 Square 中共有的 width, height \u0026hellip;等。在父類別中，如果我們沒在方法裡對參數進行修改，那麼在子類別的改寫方法中，就不可以對那些沒動的參數進行修改。而這也是矩形案例裡違反原則的原因：在 Rectenglr.setWidth() 中，我們只有對 width 這個變數進行修改，沒有對 height 做操作，但 Square.setWidth() 就犯規了。\n因此，如果我們想要寫出一的類別，讓它繼承 Calculator，並改寫 add() 方法，就可以寫成：\n// 繼承了 [計算機] 類別的 [子計算機] class SubCalculator extends Calculator { @Override public PosisiveInteger add(NaturalNumber x, PositiveNumber y) { if(x \u0026gt; 100 || y \u0026gt; 100) { throw new NumberOverflowException(); } PosisiveInteger result = x + y; return result; } } 稍微檢查一下：［參數的數量跟順序要保持一致］沒什麼問題，都是 2 個參數、都是數字類型。［子類別的輸入，不能減去原本可以的選擇］沒有問題，x 維持在自然數沒有調整，而 y 從質數變成了任何大於 0 的正數，也沒有變少（反而還變多！）。［子類別的輸出，不能多出原本沒有的選擇］同樣成立～原本輸出的類型是任意實數，現在我們把它變成了正整數，雖然減去了一些，但正整數原本就有包含在實數裡面。［父類別在有修改的變數，子類別也不要修改］兩個類別都沒有修改變數，自然就沒有違反囉。\n"},{"id":40,"href":"/docs/computer_science/design_pattern/open_closed_principle/","title":"開放封閉原則","section":"設計模式","content":"\r開放封閉原則\r#\rChatGPT 的說明 開放封閉原則（Open-Closed Principle，OCP）是物件導向程式設計中的一個重要原則，由著名的軟體工程師貝瑞·波 (Bertrand Meyer) 在他的著作《Object-Oriented Software Construction》中首次提出。該原則強調軟體實體（例如類別、模組、函數 \u0026hellip;等）應該對擴展保持開放，對修改保持封閉。這樣做可以實現程式碼的可擴展性和可維護性。具體來說，開放封閉原則有以下兩個重要概念：首先是［開放性］：開放性表示軟體應該在不需要修改現有程式碼的前提下，允許新增新的功能或新的特性。當系統需要新增功能時，應該通過擴展現有的實體，而不是修改原有的程式來完成。這有助於防止對現有程式碼的不必要修改，降低了引入錯誤的風險。其次是［封閉性］：封閉性說明程式實現某一功能後，程式本身應該被封閉，即不應該再對其內容進行修改。當一個實體達到預期的功能時，應該停止對它的修改，而是應該通過擴展或建立新的實體來添加新功能。\n開放封閉原則的優勢包括下列幾項：首先是可擴展性，當需要新增功能時，開發人員可以通過創建新的子類別、新的模組或擴展介面來實現，而不需要修改原有的程式碼，這有助於降低風險，並維護程式碼的穩定性。其次是可維護性，因為不需要經常修改原有的程式碼，所以程式碼變得更容易維護。每個功能都位於獨立的模組、類別、或者介面之中，使得錯誤的追蹤與修復能變得更加容易。此外程式的重用性也會被提高，因為功能被分割成獨立的實體，我們可以更容易地重用這些已經撰寫完成的程式碼，這有助於提高程式的效率和一致性。\n簡單整理 OCP 在說的就是：寫好的程式需要有『容易擴展』和『不再需要更改』兩種特性\n程式碼範例 開放封閉原則算是一個蠻好理解的設計原則，基本上就是「寫好的程式碼，盡量保持在不需要頻繁編輯的狀態」跟「寫好的程式碼，要容易被後來的程式碼飲用或擴充」這兩句話。用一個比較常見的舉例方式來解釋的話，讓我們考慮以下的情境：假設我們需要撰寫一支程式，該程式需要能夠透過不同參數，生成不同的圖形（圓形、正方形、長方形 \u0026hellip;等），並且程式也要能夠計算該圖形的面積。如果不使用開放封閉原則的話，可能會寫出以下的程式：\n// 定義各種不同的圖形 class Circle { Double radius; public Circle(Double radius) { this.radius = radius; } } class Square { Double sideLength; public Square(Double sideLength) { this.sideLength = sideLength; } } class Rectangle { Double width; Double height; public Rectangle(Double width, Double height) { this.width = width; this.height = height; } } // 定義一個用來計算圖形面積的類別 class AreaCalculator { public Double getArea(Object shape) { if(shape instanceof Circle) return ((Circle)shape).radius * ((Circle)shape).radius * Math.PI; else if(shape instanceof Square) return ((Square)shape).sideLength * ((Square)shape).sideLength; else if(shape instanceof Rectangle) return ((Rectangle)shape).width * ((Rectangle)shape).height; else throw new ShapeAreaCalculationException(); } } 程式在邏輯上本身沒有什麼問題，但在可擴展性和可讀性上就有可以著墨的地方了：雖然對於各種不同的圖形（Circle, Square, 或 Rectanle \u0026hellip;等）我們都可以利用 AreaCalculator 類別中的 getArea() 方法進行面積計算，同時這個方法也幫我們寫好了非圖形類別時的例外處理，但 getArea() 本身的內容卻重度依賴著各種不同的圖形。在可預想的範圍內，我們不難思考出：之後每在程式裡面新增一個圖形，getArea() 這個方法就會需要重新被修改一次。因此，對於 getArea() 這個方法來說，就沒有很好地遵守「開放封閉原則」了。\n修改的方法其實很簡單，在類似於上述的狀況下，我們通常會使用「共同的介面」或者是「繼承同一個父類別」來做改進：先在共同的介面（或父類別）裡面定義一個所有子類別都可以使用的方法，再讓其繼承的類別去改寫該方法，就能夠避免其他調用者需要重複調整程式的情況了，就像是下面的這個樣子：\n// 定義一個所有圖形都共同繼承的父類別 abstract class Shape { // 定義父類別中的共同方法 \u0026#39;getArea()\u0026#39; public Double getArea() { throw new ShapeAreaCalculationException(); } } // 定義各種不同的圖形 class Circle extends Shape { Double radius; public Circle(Double radius) { this.radius = radius; } // 改寫父類別的 getArea() 方法 @Override public Double getArea() { return this.radius * this.radius * Math.PI; } } class Square extends Shape { Double sideLength; public Square(Double sideLength) { this.sideLength = sideLength; } // 改寫父類別的 getArea() 方法 @Override public Double getArea() { return this.sideLength * this.sideLength; } } class Rectangle extends Shape { Double width; Double height; public Rectangle(Double width, Double height) { this.width = width; this.height = height; } // 改寫父類別的 getArea() 方法 @Overrie public Double getArea() { return this.width * this.height; } } // 定義一個用來計算圖形面積的類別 class AreaCalculator { public Double getArea(Object obj) { if(obj instanceof Shape) return ((Shape) obj).getArea(); else throw new ObjectIsNotInheritedFromShapeException(); } } 透過定義一個共同的父類別 Shape，並在各個子類別中改寫原父類別的 getArea() 方法，往後如果我們需要再創建其他不同的形狀（像是三角形、橢圓形 \u0026hellip;等），我們只需要讓該形狀繼承 Shape 類別，然後重寫一次類別中的 getArea()，就可以保證能夠被 AreaCalculator 正確地計算面積，也就達成了程式裡「便於擴展」的需求了（開放性(v)）；此外，往後無論我們再增加哪怕是數十種、甚至是數百種不同的形狀，只要那個形狀記得繼承 Shape 類別，AreaCalculator 裡面的 getArea() 都不再需要進行任何的調整，也能夠正確計算出該圖形的面積。也就達到了「寫完程式之後，就不需要再更動這個程式」的需求（封閉性(v)）。\n"}]