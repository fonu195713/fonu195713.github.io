<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Fonu Site</title>
    <link>https://fonu195713.github.io/</link>
    <description>Recent content in Introduction on Fonu Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://fonu195713.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>With ToC</title>
      <link>https://fonu195713.github.io/_docs/example/table-of-contents/with-toc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/table-of-contents/with-toc/</guid>
      <description>Caput vino delphine in tamen vias#Cognita laeva illo fracta#Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere#Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
    <item>
      <title>Without ToC</title>
      <link>https://fonu195713.github.io/_docs/example/table-of-contents/without-toc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/table-of-contents/without-toc/</guid>
      <description>At me ipso nepotibus nunc celebratior genus#Tanto oblite#Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.
Quam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/example/collapsed/3rd-level/4th-level/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/collapsed/3rd-level/4th-level/</guid>
      <description>4th Level of Menu#Caesorum illa tu sentit micat vestes papyriferi#Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.
Venasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/example/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/hidden/</guid>
      <description>This page is hidden in menu#Quondam non pater est dignior ille Eurotas#Latent te facies#Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona#O fallor in sustinui iussorum equidem.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/buttons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/buttons/</guid>
      <description>Buttons#Buttons are styled links that can lead to local page or external link.
Example#{{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}} Get HomeContribute</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/columns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/columns/</guid>
      <description>Columns#Columns help organize shorter pieces of content horizontally for readability.
{{&amp;lt; columns &amp;gt;}} &amp;lt;!-- begin columns block --&amp;gt; # Left Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Mid Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Right Content Lorem markdownum insigne... {{&amp;lt; /columns &amp;gt;}} Example#Left Content#Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/details/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/details/</guid>
      <description>Details#Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.
Example#{{&amp;lt; details &amp;#34;Title&amp;#34; [open] &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} {{&amp;lt; details title=&amp;#34;Title&amp;#34; open=true &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} TitleMarkdown content#Lorem markdownum insigne&amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/expand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/expand/</guid>
      <description>Expand#Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.
Example#Default#{{&amp;lt; expand &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Expand↕Markdown content#Lorem markdownum insigne&amp;hellip;With Custom Label#{{&amp;lt; expand &amp;#34;Custom Label&amp;#34; &amp;#34;...&amp;#34; &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Custom Label...Markdown content#Lorem markdownum insigne.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/hints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/hints/</guid>
      <description>Hints#Hint shortcode can be used as hint/alerts/notification block.
There are 3 colors to choose: info, warning and danger.
{{&amp;lt; hint [info|warning|danger] &amp;gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{&amp;lt; /hint &amp;gt;}} Example#Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus TelethusaMarkdown content</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/katex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/katex/</guid>
      <description>KaTeX#KaTeX shortcode let you render math typesetting in markdown document. See KaTeX
Example#{{&amp;lt;/* katex [display] [class=&amp;#34;text-center&amp;#34;] */&amp;gt;}} f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi {{&amp;lt;/* /katex */&amp;gt;}} Display Mode Example#Here is some inline example: \(\pi(x)\), rendered in the same line. And below is display example, having display: block \[f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi\]Text continues here.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/mermaid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/mermaid/</guid>
      <description>Mermaid Chart#MermaidJS is library for generating svg charts and diagrams from text.
Override Mermaid Initialization Config
To override the initialization config for Mermaid, create a mermaid.json file in your assets folder!
Example#{{&amp;lt;/* mermaid [class=&amp;#34;text-center&amp;#34;]*/&amp;gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --&amp;gt; State2 note left of State2 : This is the note to the left.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/section/first-page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/section/first-page/</guid>
      <description>First page#Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/section/second-page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/section/second-page/</guid>
      <description>Second Page#Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/tabs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/tabs/</guid>
      <description>Tabs#Tabs let you organize content by context, for example installation instructions for each supported platform.
{{&amp;lt; tabs &amp;#34;uniqueid&amp;#34; &amp;gt;}} {{&amp;lt; tab &amp;#34;MacOS&amp;#34; &amp;gt;}} # MacOS Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Linux&amp;#34; &amp;gt;}} # Linux Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Windows&amp;#34; &amp;gt;}} # Windows Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; /tabs &amp;gt;}} Example#MacOSMacOS#This is tab MacOS content.
Lorem markdownum insigne. Olympo signis Delphis!</description>
    </item>
    
    <item>
      <title>UML</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/unified_modeling_language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/unified_modeling_language/</guid>
      <description>UML#ChatGPT 的說明 UML，全名為 Unified Modeling Language（中文譯作「統一建模語言」）是一種軟體工程領域的模型建置語言，用於描述、設計、和規劃軟體系統的結構和行為。 UML 是一種圖形化的語言，它提供了一組符號和規則，用於創建各種圖表，以幫助軟體開發人員、系統分析師和其他相關人員對於系統的架構進行理解、溝通、和設計軟體。UML 由許多不同的圖表和圖形元素組成，其中一些主要的圖表包括下列幾種：［類別圖］（Class Diagrams）用來描述系統中的類別、物件、屬性和方法之間的關係，這是靜態結構的表示。［使用案例圖］（Use Case Diagrams）用於描述系統的功能和使用者之間的互動，以及用例之間的關係，這有助於捕捉系統的功能需求。［序列圖］（Sequence Diagrams）用於展示系統中物件之間的交互作用和訊息流程，這有助於理解系統的動態行為。［狀態圖］（State Diagrams）用於描述物件的不同狀態以及狀態之間的轉換。［活動圖］（Activity Diagrams）用來描述系統中的流程和操作，類似流程圖。 UML 在軟體開發過程中起著重要作用，它有助於團隊成員之間的溝通，幫助捕捉系統需求，並提供了一種通用的語言，用於設計和文件化軟體系統。 它被廣泛用於軟體開發領域，特別是物件導向的軟體開發，以及系統分析和設計。
在軟體開發中，無論是系統的設計階段、修改類別之間的關係、或者是其他在以「物件」為基本單元情況下，我們通常會使用 UML 圖來詮釋不同類別（Class）、物件（Object）、屬性（Attribute）、方法（Method）以及它們之間的關係。以下是一些類圖中的細節，包括圖形元素和其含義：［類別］（Class）：類別是類別圖的主要元素之一，代表了一個抽象的概念、對象、或實體物件。通常以方框表示，方框中包含類別的名稱、成員變數、和方法。［屬性］（Attributes）屬性又稱作「成員變數」，是類別的特徵或特性，它們描述了類別的狀態。 通常以 &amp;ldquo;名稱：類型&amp;rdquo; 的形式表示，例如 name: String 表示一個名為姓名的屬性，其類型為字串。［方法］（Methods）方法表示類別可以執行的操作或行為，在非物件導向的程式中被稱為「函數」或「函式」。通常以 &amp;ldquo;名稱(參數清單)：傳回值類型&amp;rdquo; 的形式表示，例如，setName(name:String): void 表示一個名為設定姓名的方法，它接受一個字串做為參數，並不傳回任何值。［關聯］（Association）關聯用來表示類別之間的連接或關係。它用一條直線連接兩個類別，可能伴隨著空心箭頭，實心箭頭、圓形箭頭 &amp;hellip;等不同種類的箭頭，指向關聯的方向，不同種的箭頭則代表了不同種類的關聯方式。［繼承］（Inheritance）繼承是一種特殊的關聯方式，用來表示一個類別（子類別）繼承另一個類別（父類別）的屬性和方法，它通常以「一個空心箭頭指向父類別」的方式呈現。［介面］（Interface）介面是一個特定的方法集合，不帶有方法的實作細節。介面通常以帶有小半圓的矩形框表示，其中小半圓的一端連接到實現該介面的類別。［抽象類別］（Abstract Class）抽象類別是一個不能實例化的類別，通常用於定義一些通用的成員變數和方法，並要求子類別實現該抽象類別中的一些方法，它通常以斜體字表示。［依賴］（Dependency）依賴表示一個類別（或物件）依賴另一個類別。它通常以帶有箭頭的虛線表示，箭頭指向被依賴的類別。
對於程式設計師來說，類圖的主要目的是可視化系統中類別之間的結構和關係，以便開發人員和設計師更好地理解和設計軟件系統。它可以帶來類別結構可視化、類別關係呈現、設計規劃和模型驗證、易於生成程式碼、和便於文檔化與溝通 &amp;hellip;等，在軟體設計的過程中，可以起到不小的作用。
程式碼/圖形範例 類別 在物件導向程式設計中，「類別」通常是構成程式的一個重要的、不可或缺的元件（甚至對 Java 來說，所有的程式都是類別和物件就是了），因此如果要說明 UML 的畫法，第一個就介紹「類別」的畫法應該是再適合不過了，現在我們假設在一個「學生管理系統」中，有一個名為 Student 的類別，用 Java 來實作的話，程式如下所述：
// 類別 [學生] class Student { // 這個類別裡面目前還沒有任何東西 } 畫成 UML 圖，則會像是下面的這個樣子（很簡單，就是一個三層的方框）：
classDiagram class Student 那如果系統中有很多類別呢？像是有 Student, Teacher, School, Subject&amp;hellip; 之類的？</description>
    </item>
    
    <item>
      <title>介面隔離原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/interface_segregation_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/interface_segregation_principle/</guid>
      <description>介面隔離原則#ChatGPT 的說明 介面隔離原則（Interface Segregation Principle，ISP）又稱做接口隔離原則，是 SOLID 五大設計原則之一，由羅伯特·C·馬丁（Robert C. Martin）所提出。 ISP 原則的核心思想是：客戶端不應該被迫依賴它們不使用的介面。簡而言之，ISP 要求介面的設計應該小而專一，不應該包含客戶端不需要的方法。ISP 的關鍵觀點包括以下幾點：首先：［介面應該要精簡］系統中的介面（interface）應該只包含客戶端所需的方法，不應該包含多餘的方法。這件事情這確保了介面的高內聚性，意即每個介面都應該有一個明確的目的。此外［客戶端不應該被迫實作不需要的方法］如果一個類別實作了一個介面，那麼這個類別只應該實作它所需要的方法，而不需要實作介面中裡其餘不需要的方法。這避免了類別中不必要的方法實作。再來，［避免介面臃腫］將多個不相關的方法放在同一個介面中，會導致介面變得臃腫、龐大、不易理解、和不易維護。因此 ISP 鼓勵設計師在設計介面時，將介面拆分成更小、更專一的項目。
除了上述的這些內容之外，介面隔離原則通常會與依賴倒置原則結合使用，成為依賴反轉原則的一部分，以確保依賴反轉原則中的「高層模組」不需要依賴「底層模組的具體實現」，而是依賴一個抽象，或者是依賴一個介面。 透過使用小而專一的接口，可以更容易實現依賴注入和解耦。總而言之，ISP 的目的是提高程式碼的可維護性、可讀性和可擴展性。它有助於確保介面的設計更加合理、更加靈活，使得每一個實例該介面的類別只需要實現與其相關的業務方法即可，不需要依賴其它不相關的方法。這樣做可以減少程式碼的複雜性，提高程式碼的整體品質，並降低了引入錯誤、修正錯誤的風險。
簡單整理 類別在引入介面的時候，介面的方法全部都要實例，不要不實例
程式碼範例 讓我們以一個簡單的例子來做思考：假設我們現在正在一家「交通工具生產公司」中工作，我們現在需要為公司製作一個簡單的「產品介紹系統」，該系統需要呈現各式交通工具的基本訊息（像是id、型號、大小、油槽容量、主要顏色、價格 &amp;hellip;等），而公司的產品包含但不限於汽車、機車、腳踏車、公車、遊艇、郵輪、飛機、直升機 &amp;hellip;等。在最最直觀的情況下，我們可以很直接地將每一個公司的產品，都視做一個獨立的類別進行分類，也就是像下面的這個樣子：
// 汽車類別 class Car { // id, 型號, 價格, 顏色, 座位數量 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer numOfSeats; // 汽車的移動方式 public void driving() { System.out.println(&amp;#34;車子可以利用 4 個輪子，在道路上行駛&amp;#34;); } // 其他關於 [汽車] 的相關方法 // 其他關於 [汽車] 的相關方法 } // 機車類別 class Motorcycle { // id, 型號, 價格, 顏色, 置物空間, 排氣量 .</description>
    </item>
    
    <item>
      <title>依賴反轉原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/dependency_inversion_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/dependency_inversion_principle/</guid>
      <description>依賴反轉原則#ChatGPT 的說明 依賴反轉原則（Dependency Inversion Principle，DIP）是 SOLID 原則中的一個重要原則，由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則的核心思想是：「高層模組不應該依賴低層模組，它們都應該依賴於抽象。」簡而言之，依賴從實例反轉至抽象，使系統更靈活、可維護和可擴展。依賴反轉原則包括了以下的幾個關鍵概念：［高層模組］高層模組通常是應用程式中，較高層級的模組（或元件），通常包括一些業務邏輯、應用程式的核心功能、或者其餘更加廣泛、更加抽象的概念。［低層模組］低層模組是應用程式中，較低層級的模組（或元件），通常包括一些與硬體、資料庫、外部服務 &amp;hellip;等實體類的互動。低層模組的實作細節可能會根據不同的交互對象，而發生各式各樣的變化，而但高層模組不應受到這些變化的影響。
［抽象］抽象是一種介面、抽象類別、或抽象資料類型，它定義了「高層模組」和「低層模組」之間的通訊協定、互動規則、或契約。高層模組通常會依賴這個抽象，而不是依賴特定的低層模組，以實現更具彈性的程式邏輯。［具體實作］具體實作是低層模組的具體程式碼，它們實作了「抽象」中所定義的方法和行為。［依賴反轉］依賴反轉是指高層模組不直接依賴低層模組，而是依賴共享的抽象。這意味著高層模組和低層模組都依賴相同的抽象，而不是其餘的依賴情形，這種依賴方式這可以透過依賴注入、工廠模式、反射 &amp;hellip;等技術來實現。［依賴注入］依賴注入是一種常見的實現依賴反轉的方式，它透過將依賴物件傳遞給高層模組，而不是由高層模組自行創建依賴物件。這使得高層模組可以更靈活地切換不同的依賴物件。
透過依賴反轉原則，我們可以提耕城市許多面向的性能，包含以下幾種：［減少耦合性］依賴反轉原則的主要目標是減少模組之間的耦合性，當高層模組依賴低層模組的具體實現時，它們之間的耦合性很高，任何對低層模組的變更都可能導致高層模組受到影響。但透過使用抽象和依賴反轉，可以減少這種耦合性，使得系統更容易維護和擴展。［增加可測試性］依賴反轉原則有助於提高程式碼的可測試性。透過將依賴關係從具體的實作中解耦，可以使用模擬物件（或虛擬物件）取代原本的依賴物件進行單元測試，從而更容易驗證高層模組的行為。
簡單整理 透過讓高層模組和低層模組依賴相同的抽象類別，達到靈活且具彈性的程式
程式碼範例 從純粹的程式碼上面來說，依賴反轉原則總共有三個重要的組成，分別是「低層模組」「高層模組」和「抽象類別」三種。其中，低層模組指的是「零件」，算是構成整個系統裡面，比較基礎、比較單純、比較不複雜的部分。如果拿一個 RPG 遊戲來做舉例的話，「低則模組」就有點像是刀、劍、弓、法杖、斧頭、藥水、衣服、靴子 &amp;hellip;等比較小塊、比較基本、物件本身比較不會有太多變化的東西。
「高層模組」指的則是由數個（或數十個）低層模組所組合而成的一個複雜類別，通常可以執行一些相對低層模組來說，更為複雜的操作。同樣拿 RPG 遊戲來舉例的話，高層模組可以是一個角色、一支隊伍、一個公會、一座城市、或者是一組軍團&amp;hellip;等等。通常來講，高層模組和低層模組是一個「比較」的概念，如果視野是放在一個 角色 跟上，那麼角色就是高層模組、角色所攜帶的各種物品就是低層模組；如果視野是放在一支隊伍、更甚至於一組軍團上面，那麼 角色 在這裡可能就變成了低層模組。
一般來說，在不使用「依賴反轉原則」的前提下，如果我們想要製作出一個高層模組（和它應有的功能）的話，我們通常會使用直接依賴的方式來完成，就如同下面的類別所示，一個角色與它身上的各種五花八門的配備：
// 角色類別 class Character { // 一個角色可能擁有的所有屬性 // 這邊只包含血量、魔力、攻擊力、和防禦力 private Integer hp; private Integer mp; private Integer atk; private Integer def; // 一個角色可能擁有的各種武器 // 這邊包含了刀、劍、弓、法杖、斧頭、匕首、盾牌 ...等 private Blade blade; private Sword sword; private Bow bow; private Staff staff; private Axe axe; private Dagger dagger; private Shield shield; // 一個角色可能擁有的各種護具 // 這邊包含了頭盔、胸甲、護肘、護膝、鞋子 .</description>
    </item>
    
    <item>
      <title>創建者模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/builder_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/builder_pattern/</guid>
      <description>創建者模式#ChatGPT 的說明 創建者模式（Builder Pattern）是一種創建型設計模式，旨在透過將複雜物件的建置流程拆分為多個簡單物件的建置步驟，使得物件的建置流程更加靈活、可維護，同時提供更好的控制和自訂選項。創建者模式的主要想法是將一個複雜物件的建構與其表示分開。這使得客戶端程式碼可以更容易地配置和建立複雜對象，而無需了解對象的內部建置細節。創建者模式通常包括以下關鍵角色：［產品］（Product）：產品表示被建構的複雜物件。產品類別通常包含多個屬性或部分，這些部分的創建和組裝由創建者負責。［抽象創建者］（Abstract Builder）：抽象創建者定義了建構產品物件的抽象接口，包括各個部分的創建方法。抽象創建者通常包括一個獲取最終產品的方法。［具體創建者］（Concrete Builder）：具體創建者實現了「抽象創建者」的接口，負責構建產品的各個部分，同時提供了設置產品屬性的方法。每個特定創建者可以建立不同的產品變體。［指揮者］（Director）：指揮者負責依照「客戶端」的需求依照一定順序呼叫特定「創建者」的方法來建構產品物件。指揮者不負責特定產品的創建，而是協調創建者完成建造。［客戶端］（Client）：客戶端程式碼透過「指揮者」來建立複雜對象，客戶端可以根據需要選擇不同的特定創建者來建構不同的產品變體。
創建者模式的主要優點包括：分離建造過程和表示，允許更容易建造不同的產品變體；提供了更好的控制和客製化選項，客戶端可以自訂產品的建置流程；支援逐步建構複雜對象，使得建置過程更加靈活；提高了程式碼的可維護性，將複雜建置過程封裝在特定創建者中，使得客戶端不需要知道具體的創建細節；創建者模式在需要建立具有多個配置選項或參數的複雜物件時非常有用，例如建立圖形使用者介面中的視窗、建立文件物件、建立複雜的資料結構等情況。它幫助管理和組織複雜物件的建置過程，使程式碼更具可讀性和可維護性。
簡單整理 問題描述：複雜物件往往由許多不同的變因構成，使得建立起來非常複雜
解決方案：封裝一系列的變因和設置，使得創建複雜物件不再麻煩
程式細節：參照下面的段落
UML 圖：
程式碼範例 創建者模式是一種用來建立複雜物件的設計模式。</description>
    </item>
    
    <item>
      <title>合成/聚合複用原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/</guid>
      <description>合成/聚合複用原則#ChatGPT 的說明 合成/聚合複用原則（Composition/Aggregation Reuse Principle）通常簡稱為 CARP，是物件導向設計中的一個原則，它與繼承有關，但專注於透過「組合」（也就是『合成』或『聚合』）的方式來實現程式碼的複用，而不是透過「繼承」的方式來複用程式碼。具體來說，CARP 強調了物件之間的關係應該是 &amp;ldquo;鬆耦合&amp;rdquo; 的，以便更容易進行維護和擴展。如果要使程式維持鬆耦合的狀態，比起利用「繼承」關係，更應該多使用「合成」關係或「聚合」關係：［合成］英文為 composition，指的是一個物件包含了另一個物件作為其一部分，從屬物件的生命週期通常受主要物件的生命週期限制。如果一個物件是另一個物件的一部分，並且當主要物件被銷毀時，從屬物件也會被銷毀。另一種關係是［聚合］聚合的英文稱作 aggregation，是指一個物件包含了另一個物件，但從屬物件的生命週期並不受限於主要物件的生命週期。
與繼承相比，組合關係具有許多優勢，主要是因為它們提供了更靈活、低耦合和可維護的程式碼複用方式。主要的優勢如下：［靈活性］組合關係提供了更大的靈活性。透過使用組合關係的程式撰寫方式，使得程式可以在執行時動態地改變物件之間的關係，而不需要修改類別的結構。這允許系統更容易應對變化和需求的變更，而無需深度更改整個類別層次結構。［鬆耦合］繼承有時會導致緊密的耦合，因為子類別依賴父類別的實作細節，而組合關係則通常擁有 &amp;ldquo;鬆耦合&amp;rdquo; 的關係，因為父類別和子類別之間的依賴性較少。這降低了物件之間的耦合度，使得程式碼更容易理解、維護、和擴展。
［避免繼承的限制］繼承有時後會引入一些程式上的限制，例如單一繼承限制（一個類別只能繼承一個父類別）和父類別的不穩定性（如果父類別的實作發生變化，所有子類別都會受到影響）。組合關係不受這些限制，使得類別可以輕鬆地組合多個類別的功能。［可維護性］組合關係有助於提高程式碼的可維護性。當需要程式修改或擴充功能時，你只需要專注於特定的類別或元件，而不需要涉及整個繼承層次結構。這簡化了程式碼的維護過程。［測試和調試］使用組合關係的程式編寫方式，通常更容易進行單元測試和調試，因為可以更容易地模擬和隔離組件，而不會受到繼承關係的複雜性的干擾。［程式碼可讀性］組合關係通常會使程式更加簡潔、更加清晰、和更加易於理解，因為它們強調了物件之間的協作關係，而不是混雜在一起的層次結構。
簡單整理 多用組合、少用繼承
程式碼範例 組合型程式碼，指的是在建立比較複雜的物件的時候，選擇使用不同類型的小物件相互結合，不使用繼承的方式來小物件一步步變成大物件。而在說明這樣做有什麼好處之前，我們先說明一下什麼樣的組合方式叫做「合成」？什麼樣的組合方式叫做「聚合」？簡單來說：成員變數會跟著主要物件一起死去的就叫做「合成」，而成魚變數可以在主要物件死去之後，還繼續存在的，就叫做「聚合」，就像是下面的這個範例：
// 關於 &amp;#34;合成&amp;#34; (composition) 的範例 class Hmuan { // 私有變數 姓名 private String name; // 私有變數 人的各種器官（大腦、心臟、胃 ...等） private Brain brain; private Heart heart; private Stomach stomach; // 建構子 public Human(String name) { this.name = name; this.brain = new Brain(); this.heart = new Heart(); this.stomach = new Stomach(); } // 其他 Human 中的方法 .</description>
    </item>
    
    <item>
      <title>單一職責原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/single_responsibility_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/single_responsibility_principle/</guid>
      <description>單一職責原則#ChatGPT 的說明 單一職責原則（Single Responsibility Principle，簡稱 SRP）是物件導向程式設計和軟體設計的基本原則之一，該原則由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則強調一個類別（或一個模組）應該只有一個修改的理由。換句話說，一個類別應該只負責 個主要的功能或職責。SRP 的主要思想是將一個類別的職責限制在一個狹窄的範圍內，以確保類別的內部變化原因不會過多，從而提高程式的可維護性、可擴展性、和可讀性。當一個類別具有多個不同的職責時，它就會變得複雜、變得難以理解，並且容易因多個原因而需要修改，從而降低開發程式的效率。
以下是 SRP 的主要目標：［每個類別應該都只負責一個主要職責］一個類別的 &amp;ldquo;主要職責&amp;rdquo; 即是它的核心任務，該類別應該專注於執行這份任務，而不需要干預（或處理）其他不關核心任務的事情。［分離不同的職責］如果一個類別的 &amp;ldquo;主要職責&amp;rdquo; 可能包含多項不同面向的 &amp;ldquo;子職責&amp;rdquo;，設計師應該考慮將這些職責分離為不同的類別或模組，以確保每個類別只處理一個不與它類重合的職責。 ［職責的改變，不應影響到其他的職責］在前 2 點成立的情況下，當我們需要修改一個類別的內容時，我們就是在針對「一個」「特定的」功能進行調整，因此在理論上來說，該功能不應與其他功能產生衝突或影響。SRP 有助於保持代碼的可讀性和可維護性，並促使開發人員設計更小、更簡單的類別，從而降低代碼的複雜性。它也是其他設計原則和設計模式的基礎之一，有助於建立高質量的軟體系統。
簡單整理 簡單來說，SRP 在說的就是「一個類別，只負責一組類似的事情」
程式碼範例 情境思考：假設我們受某校的教務處所委託，需要製作一個針對學生使用的「簡易學生管理系統」，裡面需要針對「學生」這一項身份完成以下幾個功能：學生資料管理（包含增刪改查學生的各種資料），課程管理（提供學生加退選課程，查看課程細節），成績查詢（包含歷年成績、當學期成績、生成成績單&amp;hellip;等），以及文件下載（包含各式各樣的學校文件，諸如學費繳費單、各式申請書、或者各處室的相關文件&amp;hellip;等）。在最最不推薦的狀況下，我們可以寫出類似於下面的程式碼：
public class StudentManagementSystem { public void registerStudent(Student student) { // 修改學生資料 // 記錄學生的最後的更新時間 // 向學生的家長發送通知 // 向學生的導師發送通知 } public void enrollCourse(Student student, int courseId) { // 獲得學生資料 // 查詢學生的所有修課記錄 // 添加新課程 } public Student getGrades(int studentId) { // 查詢學生資料 // 查詢學生的所有修課記錄 // 查詢學生的各式成績 } public void downloadFiles(String fileName) { // 查詢某一份學校文件 // 生成該份文件的 PDF 檔 // 匯出 PDF } // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 } 從程式的邏輯和功能來說，這份程式並沒有太大的問題。所有的功能都可以順利運行，且相關的程式邏輯都很正確。如果把這份程式直接提交給教務處的話，我想他們應該也不會有什麼太大的問題或者是意見才對。但是，雖然一切的一切都很順利，這份程式碼還是有著一點小小的改善空間：也就是它並沒有符合「單一職責原則」所規範的內容：意即「一個類別，只可以由一種『原因』而改變」。</description>
    </item>
    
    <item>
      <title>工廠方法模式</title>
      <link>https://fonu195713.github.io/docs/_trash/factory_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/factory_method_pattern/</guid>
      <description>工廠方法模式#ChatGPT 的說明 工廠方法模式（Factory Method Pattern）是一種創建型設計模式，它提供了一種創建物件的介面，但允許子類別決定要實例化的類別。這種模式的核心思想是「將物件的創建過程延遲到子類別中去實現。」從而達到物件的 &amp;ldquo;創建&amp;rdquo; 與 &amp;ldquo;使用&amp;rdquo; 分離，使得系統更加靈活和可擴展。工廠方法模式的主要組成部分包括以下角色：［抽象工廠］（Abstract Factory）：抽象工廠定義了一個抽象的工廠介面，包含一個用於建立產品物件的抽象方法。通常情況下，抽象工廠中可能會包含多個建立產品的方法，每個方法用於建立不同類型的產品。［具體工廠］（Concrete Factory）：具體工廠是實現抽象工廠介面的類別，負責創建具體產品。每個具體工廠對應於一種具體產品（或一組相關的特定產品）。［抽象產品］（Abstract Product）：抽象產品定義一個抽象的產品介面，通常包含了產品的通用方法或通用屬性。［具體產品］（Concrete Product）：具體產品是實現抽象產品介面的具體類別，用以表示不同類型的產品。
工廠方法模式的關鍵點是「透過將物件的創建委託給子類的具體工廠來實現。」這樣客戶端程式碼不需要直接依賴特定的工廠類型，而只需要依賴抽象工廠和抽象產品介面。這種方式使得系統更容易擴展，可以輕鬆添加新的工廠類型或變體，而無需修改現有的客戶端程式碼。以下是工廠方法模式的一些優點：［可擴充性］：使用工廠方法模式，可以透過建立新的特定工廠類別，來新增新的產品類型，而不影響現有的程式碼。［封裝性］：客戶端程式碼與特定的工廠類別解耦，只依賴抽象工廠和抽象產品接口，隱藏了具體產品的實作細節。［靈活性］：不同的具體工廠可以選擇不同的產品實現方式，以適應不同的需求和不同的環境。
簡單整理 問題描述：使用唯一的 Factory 可能會使該類別變得龐大
解決方案：透過建立 AbstractFactory 類別，讓 Factory 變得更加靈活
程式細節：參照下面的段落
UML 圖：
程式碼範例 貼心提醒：建議先看過簡單工廠模式會比較好。
工廠方法模式，算是比簡單工廠模式再更複雜一點的程式。那也因為這個模式跟簡單工廠很類似，所以我們就用同樣的例子繼續做解釋：在簡單工廠模式中，我們假設正在製作一個「資料庫操作程式系統」，並且有著幾個比較重要的類別：分別是代表使用者的 User、代表資料庫的 Database、以及代表工廠的 QueryFactory。User 可以透過 Database 裡面的方法（通常為靜態？），進行像是 INSERT, SELECT ..等不同的資料庫操作，而 Database 在接收到 User 的 query 之後，會再轉手交給 QueryFactory 負責解析，而 factory 則會根據 query 的不同，回傳不同的結果。
class User { public QueryResult query(String query) { QueryResult queryResult = Database.getQueryResult(query); return queryResult; } } class Database { public static QueryResult query(String query) { QueryResult queryResult = QueryFactory.</description>
    </item>
    
    <item>
      <title>工廠方法模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/factory_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/factory_method_pattern/</guid>
      <description>工廠方法模式#ChatGPT 的說明 工廠方法模式（Factory Method Pattern）是一種創建型設計模式，它提供了一種創建物件的介面，但允許子類別決定要實例化的類別。這種模式的核心思想是「將物件的創建過程延遲到子類別中去實現。」從而達到物件的 &amp;ldquo;創建&amp;rdquo; 與 &amp;ldquo;使用&amp;rdquo; 分離，使得系統更加靈活和可擴展。工廠方法模式的主要組成部分包括以下角色：［抽象工廠］（Abstract Factory）：抽象工廠定義了一個抽象的工廠介面，包含一個用於建立產品物件的抽象方法。通常情況下，抽象工廠中可能會包含多個建立產品的方法，每個方法用於建立不同類型的產品。［具體工廠］（Concrete Factory）：具體工廠是實現抽象工廠介面的類別，負責創建具體產品。每個具體工廠對應於一種具體產品（或一組相關的特定產品）。［抽象產品］（Abstract Product）：抽象產品定義一個抽象的產品介面，通常包含了產品的通用方法或通用屬性。［具體產品］（Concrete Product）：具體產品是實現抽象產品介面的具體類別，用以表示不同類型的產品。
工廠方法模式的關鍵點是「透過將物件的創建委託給子類的具體工廠來實現。」這樣客戶端程式碼不需要直接依賴特定的工廠類型，而只需要依賴抽象工廠和抽象產品介面。這種方式使得系統更容易擴展，可以輕鬆添加新的工廠類型或變體，而無需修改現有的客戶端程式碼。以下是工廠方法模式的一些優點：［可擴充性］：使用工廠方法模式，可以透過建立新的特定工廠類別，來新增新的產品類型，而不影響現有的程式碼。［封裝性］：客戶端程式碼與特定的工廠類別解耦，只依賴抽象工廠和抽象產品接口，隱藏了具體產品的實作細節。［靈活性］：不同的具體工廠可以選擇不同的產品實現方式，以適應不同的需求和不同的環境。
簡單整理 問題描述：使用唯一的 Factory 可能會使該類別變得龐大
解決方案：透過建立 AbstractFactory 類別，讓 Factory 變得更加靈活
程式細節：參照下面的段落
UML 圖：
程式碼範例 工廠方法模式，是比[簡單工廠]模式還要再複雜一點點的設計模式。主要的使用情境是「當單的 simple Factory 變得過於龐大」的時候。同樣拿簡單工廠模式中的「傢俱系統」作為例子：假設我們的家俱利統中，除了可以展示各種不同類別的傢俱之外，它可以針對不同的傢俱分類（像是金屬製、實木製、塑膠製 &amp;hellip;等）展示出更加細節的傢俱種類（像是實木桌、橡木桌、組合木桌、大理石桌、塑膠桌 &amp;hellip;等），此外每個傢俱都有自己的材質組合（衣櫃不會有玻璃的、床架只有木頭跟金屬的 &amp;hellip;等），如果我們還是用原本的簡單工廠模式來實作這項功能的話，可能會變成下面這個樣子：
class FurnutireFactory { // 靜態的 createFurniture() 方法 // 現在多了一個 [材質] 的參數 public static Furniture createFurniture(String material, String name) { Furniture furniture = null; if(name.equal(&amp;#34;chair&amp;#34;)) { if(material.equals(&amp;#34;Wooden&amp;#34;)) furniture = new WoodenChair(); else if(material.equals(&amp;#34;plastic&amp;#34;)) furniture = new PlasticChair(); else if(material.</description>
    </item>
    
    <item>
      <title>抽象工廠模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/abstract_factory_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/abstract_factory_pattern/</guid>
      <description>抽象工廠模式#ChatGPT 的說明
簡單整理
問題描述：當系統變得愈發龐大，即使將工廠進行抽象，也會導致程式高度耦合
解決方案：對 Factory 和 Product 同時進行抽象
程式細節：參照下面的段落
UML 圖：
程式碼範例 抽象工廠模式，是三個與「工廠」有關的設計模式中（簡單工廠模式、工廠方法模式、和抽象工廠模式），最為複雜的一個模式。也因此，在這三種設計模式當中，抽象工廠模式是使用在最為複雜的情境之中。我們同樣承接前兩個「工廠」中的情境，以一個傢俱系統作為例子：假設現在我們的系統除了需要呈現不同材質的傢俱之外，各種傢俱也有一些更微細項的分類，像是「床」有單人床、雙人床、單人床加大 &amp;hellip;等，書櫃有三層櫃、四層櫃 &amp;hellip;等，桌子也有分無抽屜、一個抽屜、兩個抽屜 &amp;hellip;等，如果同樣用工廠方法來處理的話，可能會變成下面這樣：
// 抽象類別 [傢俱工廠] abstract class FurnitureFactory { // 在 createProduct() 方法中加入一個 &amp;#34;description&amp;#34; 的參數 public abstract Furniture createFurniture(String name, String description); } // 繼承 [傢俱工廠] 的 [木製傢俱工廠] class WoodenFurnitureFactory extends FurnitureFactory { @Override public Furniture createFurniture(String name, String description) { Furniture furniture = null; if(name.equal(&amp;#34;bed&amp;#34;)) { if(description.equals(&amp;#34;single bed&amp;#34;)) furniture = new SingleBed(); else if(description.</description>
    </item>
    
    <item>
      <title>最少知識原則</title>
      <link>https://fonu195713.github.io/docs/_trash/least_knowledge_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/least_knowledge_principle/</guid>
      <description>最少知識原則#ChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 &amp;ldquo;朋友&amp;rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 &amp;ldquo;封裝&amp;rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。
此外在物件導向程式設計中，一個物件的 &amp;ldquo;朋友&amp;rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 &amp;ldquo;朋友&amp;rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 &amp;ldquo;朋友&amp;rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 &amp;ldquo;朋友&amp;rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 &amp;ldquo;朋友&amp;rdquo;。 需要注意的是，儘管可以與這些 &amp;ldquo;朋友&amp;rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。
簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。
程式碼範例 迪米特法則的核心是「盡量保持鬆耦合」的設計思想：當一個物件（或一個方法）需要透過很 &amp;ldquo;遠&amp;rdquo; 的呼叫，才可以完成某項功能時，就代表該物件對於呼叫中的所有東西都保持著依賴關係，那這時候，只要這一條依賴關係的任一截點出現問題，就都有可能導致功能的毀損，進而影響整個程式的運作。舉個例子：我們假設在一間上市公司中，從公司最大的「老闆」一路到最基層的「員工」有以下的這幾個階層：老闆（Boss）&amp;gt; 各部門的部處長（DepartmentDirector）&amp;gt; 專案經理（ProjectManager）&amp;gt; 員工（Staff）。然後今天老闆想要讓自己的公司網頁新增一項功能，他將這件事情告訴了 IT 部門的部處長，處長為此成立了一個「網站專案團隊」，並指派一位資深員工為專案經理讓他挑選幾位處理該專案的員工（Staff）來完成老闆所需的工作。如果在這樣的情況下，老闆想要追蹤一下這個網頁功能的更新，那可能會發生這樣的問題：
Log websiteInfo = boss.getDepartmentDirector(&amp;#34;IT&amp;#34;).getProjectManager(&amp;#34;web&amp;#34;).getStaff().getTaskLog(); 我們可以看到：光是 Boss 想要拿到一條「網站的更新紀錄」，就需要經過至少 3 ~ 4 個人的手，除了在實務的情況下，這麼做的效率可能有點低下之外，對於程式的撰寫來說，這種寫法也是挺有風險的，畢竟我們沒有辦法保證「呼叫上的所有方法即使產生了細節上的改變，程式也能完整運行」（例如 getProjectManager() 突然不用 &amp;ldquo;專案名稱&amp;rdquo; 做為參數，改用 &amp;ldquo;專案代號&amp;rdquo; 之類的），因此，迪米特法則告訴了我們「不要跟這麼多人講話」，也就是不要依賴過多的 &amp;ldquo;陌生人&amp;rdquo;。盡可能只透過，跟身邊的「朋友」聊天，就能拿到必要的資訊。降低方法間的相互調用，也就降低了「依賴於 &amp;lsquo;方法&amp;rsquo; 的一致性」，進而提升程式整體的品質，就是迪米特法則想要告訴我們的事情。
Log websiteInfo = boss.getInfo(&amp;#34;WebsiteUpdate&amp;#34;); 朋友 知道了法則想要傳遞的訊息之後，接下來就可以往下一步走了：哪些人、哪些東西、哪些物件、哪些方法才是所謂的「朋友」？一般來說，常見對於「朋友」的定義有以下四種：「類別本身的成員變數」「類別本身的方法」「父類別的所有成員與方法」「傳入方法中的所有參數」以及「在方法中建立的任何物件」。可以發現到朋友的類型可以根據是類別還是方法有所不同，這也是該原則比較特別的一個地方：不僅適用於類別的角度，也適用於方法的角度。
類別本身的成員變數 這個應該蠻好理解的？畢竟是「自己本身就有的東西」。「類別本身的成員變數」可以視為是一個自己的親近朋友，無論是 &amp;ldquo;基本資料型態&amp;rdquo;（像是 int, float, long, double &amp;hellip;等），或者是 &amp;ldquo;參考資料型態&amp;rdquo;（各種類別：諸如 Object, System, Boss, Staff, Library &amp;hellip;等），只要是類別自己有的東西，都可以視為自己的朋友，這點也包含所有的父類別、父父類別、父父父類別 &amp;hellip;等。</description>
    </item>
    
    <item>
      <title>最少知識原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/least_knowledge_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/least_knowledge_principle/</guid>
      <description>最少知識原則#ChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 &amp;ldquo;朋友&amp;rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 &amp;ldquo;封裝&amp;rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。
此外在物件導向程式設計中，一個物件的 &amp;ldquo;朋友&amp;rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 &amp;ldquo;朋友&amp;rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 &amp;ldquo;朋友&amp;rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 &amp;ldquo;朋友&amp;rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 &amp;ldquo;朋友&amp;rdquo;。 需要注意的是，儘管可以與這些 &amp;ldquo;朋友&amp;rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。
簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。
程式碼範例 「最少知識原則」又稱作「迪米特法則」（後面統一用『迪米特法則』稱呼～），該原則的核心思想是「盡可能地減少需要依賴的類別和方法」，它透過定義「朋友」與「非朋友」這兩種不同的關係，將類別與類別、方法與方法、或類別與方法之間的調用加以分類，進而減少對於過量類別和過量方法的嚴重依賴。我們一個簡單的例子來做說明：假設我們正在製作一個「資料庫管理系統」，裡面的其中一項功能是「Customer 可以修改 x 資料庫中， y 資料表的內容」簡單來說就是一個 UPDATE 方法，程式的實作方式如下：
// [使用者] 類別 class User { // 私有變數 system, 用來獲取 &amp;#39;資料庫系統&amp;#39; private DatabaseManagementSystem system; // update 方法，用來更新資料庫中的資料 public State update(String db_name, String table_name, String query) { // 首先利用 connectToSystem() 與資料庫系統建立連線 this.system.connectToSystem(this); // 接著利用 getDatabase() 來取得想要操作的資料庫 // 然後利用 getPermission() 取得資料庫得操作權限 // 再來利用 getTable() 獲取想要操作的資料表 // 最後利用 setQuery() 進行資料上的修改 return this.</description>
    </item>
    
    <item>
      <title>簡單工廠模式</title>
      <link>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_1/</guid>
      <description>簡單工廠模式#ChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。
簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。
簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 &amp;hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。
簡單整理 問題描述：Client 對於 Product 有著高度的依賴
解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴
程式細節：參照下面的段落
UML 圖：
程式碼範例 在常見的設計模式裡面，跟「工廠」有關的設計模式共有三種，分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過一個工廠，來簡單地改寫程式碼的一種設計模式。讓我們來想像一種情境：假設我們正在製作一個「繪製不同圖型」的程式，裡面有一個一個用來繪製圖形的畫布 Canvas，以及一些預設的可繪製圖形 Circle, Square, Rectangle, Triangle, 和 Polygon &amp;hellip;等。我們首先假設所有的圖形都繼承於 Shape 類別，我們也假設只要呼叫 Canvas 裡面的 addShape() 方法，並透過傳入的 String 參數，該方法就會幫我們繪製圖形，如下所示：
// 抽象父類別 [形狀] abstract class Shape {} // 各種繼承 [形狀] 的子類別們 class Circle extends Shape {} class Square extends Shape {} class Rectangle extends Shape {} class Triangle extends Shape {} class Polygon extends Shape {} // 繪圖類別 `Canvas` class Canvas { public void addShape(String shape) { // 建立圖形變數 &amp;#39;shape&amp;#39; Shape shape = null; // 把 &amp;#39;shape&amp;#39; 變成我們預設的其中一種形狀 if(shape.</description>
    </item>
    
    <item>
      <title>簡單工廠模式</title>
      <link>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_2/</guid>
      <description>簡單工廠模式#ChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。
簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。
簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 &amp;hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。
簡單整理 問題描述：Client 對於 Product 有著高度的依賴
解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴
程式細節：參照下面的段落
UML 圖：
程式碼範例 在常見的設計模式裡，跟「工廠」有關的設計模式共有三種。它們從簡單到複雜分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過生成一個「簡單的」工廠，來分離不同職責的程式碼，讓程式可以達到更好的靈活性、可讀性，和良好的封裝性。讓我們用一個簡單的例子來做說明：假設我們現在正在撰寫一個「資料庫操作程式系統」，該系統需要包含一些使用者對於資料庫的簡單操作，像是 SELECT, UPDATE&amp;hellip;等，在不使用簡單工廠模式的情況下，程式可能會寫成像是下面的這個樣子：
// 資料庫系統中的 [使用者] 類別 class User { private Database database; private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } public QueryResult query(Database.operation operation, String query) { this.database = this.</description>
    </item>
    
    <item>
      <title>簡單工廠模式</title>
      <link>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_3/</guid>
      <description>簡單工廠模式#ChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。
簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。
簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 &amp;hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。
簡單整理 問題描述：Client 對於 Product 有著高度的依賴
解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴
程式細節：參照下面的段落
UML 圖：
程式碼範例 在常見的設計模式當中，跟「工廠」有關的設計模式共有三種，它們從簡單到複雜分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過一個結構「簡單」的工廠，來將程式碼拆分，以提高程式系統的可讀性、靈活性、和可擴展性。讓我們以一個簡單的例子來做說明：假設我們現在需要製作一個「網站架設系統」，該系統需要包含一些關於前後端的程式內容，而其中一項功能的描述如下：「使用者可以透過輸入不同的 SQL 語句，來取得不同的資料庫內容。」用程式來呈現的話，可能會像這個樣子：
// 架站系統中的 [客戶端] 類別 class Client { private String account; private String password; public Object getDatabaseData(String query) { Database database = this.getDatabaseConnection(account, password); Object data = null; Database.Operation operation = database.getOperation(query); switch(operation) { case Database.Operation.INSERT: data = database.insertQuery(query); break; case Database.</description>
    </item>
    
    <item>
      <title>簡單工廠模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/simple_factory_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/simple_factory_pattern/</guid>
      <description>簡單工廠模式#ChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。
簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。
簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 &amp;hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。
簡單整理 問題描述：Client 對於 Product 有著高度的依賴
解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴
程式細節：參照下面的段落
UML 圖：
程式碼範例 在常見的設計模式當中，與「工廠」有關的設計模式共有三種，它們由間單到複雜依序是簡單工廠模式、工廠方法模式、以及抽象工廠模式。簡單工廠模式顧名思義，就是透過一個「工廠」類別，將比較「簡單的」程次區域給獨立出來，通常會配合單一職責原則進行程式碼的檢查，如果某一段程式不符合單一職責原則的話，就可以考慮用簡單工廠將程式給區分出來。讓我們用一個簡單的範例來做說明：假設我們正在開發一個「線上傢俱閱覽系統」，使用者可以根據不同的需要來瀏覽、比較、或購買傢俱，程式片段大致如下所述：
// 系統中的 [顧客] 類別 class Customer { private String account; private String password; // 透過不同的關鍵字，取得不同傢俱 public Furniture getFurniture(String name) { Furniture furniture = null; if(name.equal(&amp;#34;chair&amp;#34;)) furniture = new Chair(); else if(name.equals(&amp;#34;desk&amp;#34;)) furniture = new Desk(); else if(name.equals(&amp;#34;sofa&amp;#34;)) furniture = new Sofa(); else if(name.</description>
    </item>
    
    <item>
      <title>記帳 2023/08</title>
      <link>https://fonu195713.github.io/docs/finance/track_expenses/202308/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/finance/track_expenses/202308/</guid>
      <description>記帳 2023/08#各方面金流
台幣活存：4098 台股股票淨值：19278 借貸狀況： 借出共 143,500 + 50,000 元 貸款共 0 元 保險： 儲蓄型保單收到了 2 元的回饋 備註
因為信用卡還沒開辦的原因，所以個人的信用評分應該還算是很低很低。加上現在還是處在比較高利的情況，所以我不打算去做一些跟信貸有關的相關操作。因此貸款的數字是 0。另外借出約 20 萬左右的金額，主要是由兩個人所組成，預計會在近 1-2 年內回收完畢吧？如果到時候還沒回收的話，可能就會採取比較激進一點的行動方針。
活存的部分 &amp;hellip;只能說相當可怕啦。下個月的花錢必須要非常拮据與謹慎，不然一不小心就會直接死給大家看了。台股的淨值大約是 20k，它是我 4 個月定期應額 006208 的小小成果，基本上台股的部分不會有太多的更動，它就會是一個每個月固定 5000, 5000 投入的狀況。不打算做一點短線的投機，次要原因是目前沒有甚麼了解的標的在低檔位的股價，主要原因是沒有多餘的閒錢 （哭）
大概是這樣，目前看來沒什麼大問題，除了活存的數字真的是有夠少之外 &amp;hellip;。整體而言，自評的話大概會給 57-58 左右吧？滿分是 100 分。不及格的部分是活存水位過低、沒有緊急預備金。但剩下的 &amp;hellip; 我覺得基本上沒有大問題，但這　1-2　個月要好好調整自己的用錢習慣就是，畢竟已經沒有研究室的研究補貼了，算命的收入要想辦法拉高一點。</description>
    </item>
    
    <item>
      <title>記帳 2023/09</title>
      <link>https://fonu195713.github.io/docs/finance/track_expenses/202309/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/finance/track_expenses/202309/</guid>
      <description>記帳 2023/09#各方面金流
資產的部分 台幣活存 31,222 元 台股股票淨值：28,964 元 借出共 143,500 元 負債的部分 貸款共 157,000 元 備註
這禮拜活存大概暴增了 3-4 萬有，是因為上個月有一筆的 5 萬的借款拿回來了。股票淨值多了大約 10k，是因為這個月多買了一次 5000 的零股，但台股的錢基本上不會去動啦，畢竟是 006208 的定期定額 &amp;hellip;。另外有一筆借出約 15 萬左右的款項被我劃掉了，因為那筆借貸目前在法院的訴訟中，但我覺得有高機率拿不回來 XDD，所以就先當沒這筆錢，因此目前的總資產大約落在 55-60 k 左右。
負債的部分 &amp;hellip; 最近妹妹不小心被人騙錢了 XD 大概被騙了 15 萬左右，身為哥哥，當然就是全扛下來啦～雖然寫是寫「負債」，但比較像是「這筆錢妳就當我先跟妳借的，我再慢慢還妳」的那種感覺，所以比較像是無期限(? 的 0 利率貸款，超划算對吧～哈哈哈哈，不過之後還是要慢慢還就是了。</description>
    </item>
    
    <item>
      <title>里氏替換原則</title>
      <link>https://fonu195713.github.io/docs/_trash/liskov_substitution_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/liskov_substitution_principle/</guid>
      <description>里氏替換原則#ChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。
LSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。
這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。
簡單整理 簡單來說：父類別沒有的，子別類不一定要有，但是父類別有的，子類別都一定要有
程式碼範例 里氏替換原則討論的是關於類別（或介面）發生繼承時，應該遵守或者是留意一個規範或想法。大致上的重點在於「子類別應該完全實現父類別的想法」「子類別可以對付類別的想法作出補充」以及「子類別應該遵循與父類別一致的規則」這句話上面。簡單來說就是「父類別的擁有和要求，子類別都要做到」但「父類別沒有要求的，子類別可以不用做到」這兩句話上。
自己稍微唸了一下，感覺還是有點饒口，直接用一個範例程式碼來做舉例好了：假設我們現在受到了某某大型運輸公司的委託，需要製作一個該公司的「交通工具查閱系統」，裡面需要包含一些常見的交通工具的相關資訊，像是汽車、船、機車、公車、腳踏車、直升機、飛機 &amp;hellip;等，在最最直觀的情況下，我們可以把所有的交通工具都寫成互不相關的獨立類別，就像是下面的這個樣子：
class Car { String id; String type; public void driving() { System.out.println(&amp;#34;在馬路上行駛&amp;#34;); } // 其他跟[汽車]有關的方法 // 其他跟[汽車]有關的方法 } class Boat { String id; String type; public void sailing() { System.out.println(&amp;#34;在河道或海中航行&amp;#34;); } // 其他跟[船]有關的方法 // 其他跟[船]有關的方法 } &amp;hellip;（還有其他好多類型的交通工具）
class Helicopter { String id; String type; public void flight() { System.</description>
    </item>
    
    <item>
      <title>里氏替換原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/liskov_substitution_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/liskov_substitution_principle/</guid>
      <description>里氏替換原則#ChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。
LSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。
這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。
簡單整理 父類別的方法，如果換成子類別來做，應該要得出一樣的結果
程式碼範例 在所有的設計原則中，里氏替換原則應該是最難懂的（至少在我自己理解的過程中 XD），作為設計原則中的其中一項原則，里氏替換原則所討論，是關於類別與類別間的繼承（inherit）和改寫（override）的問題。里氏替換原則的核心，就是在確保簡單整理中的那句話：「父類別的方法，如果換成子類別來做，應該要得出一樣的結果。」也就是說，如果在一個程式裡面我們看到了 Parent.method(arg) 這樣的語句。里氏替換原則要求的，就是希望如果我們寫成 Child.method(arg) 時，程式同樣也可以呈現出原本的結果，不應該換了一個子類別執行，程式的結果就發生改變。
更仔細一點的說，雖然我們在學習的過程中，被告知了「『繼承』即是包含了 is-a 的概念的兩個類別」，但該原則告訴了我們：嚴格一點來說，我們並不能夠單純地因為 A is-a B，就讓 A 跟 B 使用繼承（像是正方形 is-a 矩形，企鵝 is-a 鳥類 &amp;hellip;等），在使用繼承的時候，應該要更加嚴謹，更加小心。里氏替換原則包含以下幾個想法：子類別的參數數量和順序應該與父類別完全相同、子類別的前置條件不應該比父類別嚴格、子類別的後續條件不應該比父類別寬鬆、以及在父類別中沒有被改變的參數，子類別也應該對其保持不變。
我們用一個簡單的例子，快速了解這之中的差別：在數學的定義上，我們可以知道「矩形」是四個角都是直角的四邊形，「正方形」是四個角都是直角、且四個邊都有相同長度的四邊形。因此，在數學的分類上，我們可以說「正方形是一種矩形」也就是「Sruare is a Rectangle」，那在程式上，我們同樣也能說出「Sruare is a Rectangle」嗎？讓我們用程式來觀察觀察，我們先假設正方形是長方形的一種：
// 長方形 class Rectangle { protected int width; protected int height; // 建構子 public Rectangle() {} // 長方形的 setter (getter 就先省略了) public void setWidth(int width) { this.</description>
    </item>
    
    <item>
      <title>開放封閉原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/open_closed_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/open_closed_principle/</guid>
      <description>開放封閉原則#ChatGPT 的說明 開放封閉原則（Open-Closed Principle，OCP）是物件導向程式設計中的一個重要原則，由著名的軟體工程師貝瑞·波 (Bertrand Meyer) 在他的著作《Object-Oriented Software Construction》中首次提出。該原則強調軟體實體（例如類別、模組、函數 &amp;hellip;等）應該對擴展保持開放，對修改保持封閉。這樣做可以實現程式碼的可擴展性和可維護性。具體來說，開放封閉原則有以下兩個重要概念：首先是［開放性］：開放性表示軟體應該在不需要修改現有程式碼的前提下，允許新增新的功能或新的特性。當系統需要新增功能時，應該通過擴展現有的實體，而不是修改原有的程式來完成。這有助於防止對現有程式碼的不必要修改，降低了引入錯誤的風險。其次是［封閉性］：封閉性說明程式實現某一功能後，程式本身應該被封閉，即不應該再對其內容進行修改。當一個實體達到預期的功能時，應該停止對它的修改，而是應該通過擴展或建立新的實體來添加新功能。
開放封閉原則的優勢包括下列幾項：首先是可擴展性，當需要新增功能時，開發人員可以通過創建新的子類別、新的模組或擴展介面來實現，而不需要修改原有的程式碼，這有助於降低風險，並維護程式碼的穩定性。其次是可維護性，因為不需要經常修改原有的程式碼，所以程式碼變得更容易維護。每個功能都位於獨立的模組、類別、或者介面之中，使得錯誤的追蹤與修復能變得更加容易。此外程式的重用性也會被提高，因為功能被分割成獨立的實體，我們可以更容易地重用這些已經撰寫完成的程式碼，這有助於提高程式的效率和一致性。
簡單整理 OCP 在說的就是：寫好的程式需要有『容易擴展』和『不再需要更改』兩種特性
程式碼範例 開放封閉原則算是一個蠻好理解的設計原則，基本上就是「寫好的程式碼，盡量保持在不需要頻繁編輯的狀態」跟「寫好的程式碼，要容易被後來的程式碼飲用或擴充」這兩句話。用一個比較常見的舉例方式來解釋的話，讓我們考慮以下的情境：假設我們需要撰寫一支程式，該程式需要能夠透過不同參數，生成不同的圖形（圓形、正方形、長方形 &amp;hellip;等），並且程式也要能夠計算該圖形的面積。如果不使用開放封閉原則的話，可能會寫出以下的程式：
// 定義各種不同的圖形 class Circle { Double radius; public Circle(Double radius) { this.radius = radius; } } class Square { Double sideLength; public Square(Double sideLength) { this.sideLength = sideLength; } } class Rectangle { Double width; Double height; public Rectangle(Double width, Double height) { this.width = width; this.height = height; } } // 定義一個用來計算圖形面積的類別 class AreaCalculator { public Double getArea(Object shape) { if(shape instanceof Circle) return ((Circle)shape).</description>
    </item>
    
  </channel>
</rss>
