<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Fonu Site</title>
    <link>https://fonu195713.github.io/</link>
    <description>Recent content in Introduction on Fonu Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://fonu195713.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>［置頂］工作日誌</title>
      <link>https://fonu195713.github.io/docs/daily_life/working_log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/working_log/</guid>
      <description>［置頂］工作日誌#2023, 7 月...2023-07 工作日誌#日期 標題 分類 備註 07-07 《深入淺出設計模式》 心得 . 07-08 設計模式 分類 . 07-09 策略模式 內容 . 07-10 模板方法模式 內容 . 07-11 享元模式 內容 . 07-12 狀態模式 內容 . 07-13 單例模式 內容 . 07-14 簡單工廠模式 內容 . 07-14 工作日誌 內容 . 07-14 文章留言板 功能 . 07-15 工廠方法模式 內容 . 07-16 抽象工廠模式 內容 . 07-17 生成器模式 內容 . 07-18 原型模式 內容 . 07-21 適配器模式 內容 .</description>
    </item>
    
    <item>
      <title>［置頂］待辦事項</title>
      <link>https://fonu195713.github.io/docs/daily_life/to_do_list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/to_do_list/</guid>
      <description>［置頂］待辦事項#完成日本的心得文 動工小說 寫一篇心經的感想 </description>
    </item>
    
    <item>
      <title>With ToC</title>
      <link>https://fonu195713.github.io/_docs/example/table-of-contents/with-toc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/table-of-contents/with-toc/</guid>
      <description>Caput vino delphine in tamen vias#Cognita laeva illo fracta#Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere#Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
    <item>
      <title>中介者模式（Mediator Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/mediator_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/mediator_pattern/</guid>
      <description>中介者模式（Mediator Pattern）#說明 ChatGPT：中介者模式（Mediator Pattern）是一種行為型設計模式，用於降低多個物件之間的直接溝通。物件會透過一個名為【中介者】的物件來進行通信。中介者模式有助於減少物件之間的耦合性，使得物件之間的交互更加靈活和可維護。在中介者模式中，多個物件（也稱為同事物件）不再直接相互溝通，而是通過【中介者】進行間接通訊。當其中一個物件需要與其他物件進行交互時，它不會直接調用其他物件的方法，而是通過中介者的方法來進行調用請求，然後中介者再將請求訊息傳遞給該物件。這樣一來，各個物件之間的相互依賴關係就減少了，它們只需要依賴於【中介者】這個抽象介面，而不需要知道彼此的存在。這樣不僅降低了物件之間的耦合性，同時也使得程式的結構更加清晰，易於維護和擴展。中介者模式適用於以下情況：「當多個物件之間的交互複雜且互相依賴時，使用中介者模式可以簡化物件之間的耦和與依賴，使得物件之間的關係更加清晰。」；「當物件之間的耦合性過高，導致修改一個物件可能影響到其他物件時，可以使用中介者模式將這些物件的交互集中在中介者中，從而降低耦合性」；「當一個物件需要和多個其他物件進行通信時，使用中介者模式可以避免物件之間建立大量的相互引用關係，從而提高程式的可讀性和可維護性。」
維基百科：在軟體工程中，中介者模式定義了一個「封裝了一組物件互動方式」的物件。由於這種模式可以改變程式的運行行為，因此被認為是一種行為型設計模式。在物件導向程式設計中，程序通常會由許多的類別組成，各種邏輯和計算會在這些類別之間分散和互相調用。然而，隨著在程式中添加更多的類別或方法，在維護或重構程式期間，因為類別之間相互的高度耦和，使得維護與重構程式需要耗費巨大的時間成本。此外，由於任何更改都可能影響到其他幾個類別中的程式邏輯，因此更改程式會變得更為困難。因此中介者模式會將物件之間的通信，封裝在一個【中介者】物件中。讓其餘物件不再直接通信，而是通過【中介者】進行通信。這減少了物件之間的相依性，從而減少了耦合。中介者模式是 23 種著名的設計模式之一，該模式可以解決的問題有：「對高度耦和的物件進行解耦的動作」「讓物件彼此的行為各自獨立，而不依賴於其餘類別。」中介者模式描述的解決方案是：定義一個單獨的【中介者】物件，讓該物件封裝「物件之間的互動」。其餘物件將其互動的請求委派給【中介者】，而不是直接物件進行互動。物件通過一個 &amp;ldquo;控制&amp;rdquo; 和 &amp;ldquo;協調互動&amp;rdquo; 的種介者物件間接地與彼此互動。使得物件之間可以維持鬆散地耦合。
特點 封裝物件的互動，讓物件只透過【中介者】進行溝通與調節 將物件的行為集中控制，從而避免混亂的調用 減少物件與物件之間的耦和，降低程式的維護成本 UML Graphic classDiagramclass Mid內文 中介者模式的用途就是「在多個物件之中提供一個協調的『管道』或『平台』」，透過一個【中介者】類別，【物件】可以直接將所需要的請求託付給【中介者】處理，或者是經由【中介者】取得其他【物件】所回傳過來的回應或參數。我們可以用一個 RPG 遊戲來解釋「中介者模式」的運作方式：假設在一個 RPG 遊戲中，我們要實作一個回合制的戰鬥場景。戰鬥總共分為兩方陣營（主角方與怪物方），如果沒有使用中介者模式的話，程式有可能會像是下面的這個樣子：
class Character { public: string name; int hp; int atk; public: Character(string name, int hp, int atk) : name(name), hp(hp), atk(atk) {} public: string getName() { return name; } public: virtual void attack(Character* target) = 0; virtual void takeDamage(int atk) = 0; }; class Player : public Character { public: Player(string name) : name(name) {} public: void attack(Character* target) override { cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; attacked &amp;#34; &amp;lt;&amp;lt; (targrt -&amp;gt; name) &amp;lt;&amp;lt; &amp;#34;.</description>
    </item>
    
    <item>
      <title>享元模式（Flyweight Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/flyweight_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/flyweight_pattern/</guid>
      <description>享元模式（Flyweight Pattern）#說明 ChatGPT：享元模式（Flyweight Pattern）是一種結構型設計模式，旨在通過共享對象来最大程度地减少資源消耗和提高性能。該模式適用於存在大量相同或近似對象的情况，通過共享對象的方式，減少對象的創建和記憶體開銷。在享元模式中，對象共分為兩種類型：共享對象（Flyweight）：是可以被共享的對象，包含內部狀態和外部狀態。內部狀態是不變的，因此可以被多個相同的對象共享；外部狀態是可變的，需要在使用時傳遞给共享對象。非共享對象（Unshared Flyweight）：是不可共享的對象，每個對象都是獨立的。通過將對象的狀態分為內部狀態和外部狀態，享元模式可以實現共享內部狀態，減少對象的數量，並通過傳遞外部狀態來保持對象的獨立性。
維基百科：享元模式（英語：Flyweight Pattern）是一種軟體設計模式。它使用物件用來儘可能減少記憶體使用量；於相似物件中分享儘可能多的資訊，共享數據結構的概念稱為「哈希共享」。當大量物件近乎重複方式存在，因而使用大量記憶體時，此法適用。通常物件中的部分狀態（state）能夠共享。常見做法是把它們放在資料結構外部，當需要使用時再將它們傳遞給享元。典型的享元模式的例子為文書處理器中以圖形結構來表示字符：每個字形有其字型外觀、字模、和其它格式資訊，如果要全部儲存，會使每個字符就耗用掉上千位元組。因此，我們會使用享元模式，將每個字符參照到一個【共享字形】物件，此物件會被其它有共同特質的字符所分享和使用；只有每個字符的獨特資訊（例如位置訊息）才需要另外儲存。享元模式（Flyweight Pattern）指的是通過與其他相似對象共享一部分數據，來最小化記憶體使用的一種程式設計模式。
特點 將物件定義為「內部狀態」與外部狀態 同一物件的內部狀態會完全相同，外部狀態會因物件而異 物件的內部狀態可以被定義為一個共同的參照 減少大量的記憶體消耗 通常會與「工廠模式」一併使用 UML Graphic classDiagramclass Map {TreeFactory* tree_factory;Tree[] tree_arycreateMap() : create tree and buildingcreateTree() : tree_factory.createTree()}class TreeFactory {Tree* tree_records[]createTree();}Map --&gt; TreeFactorynote &#34;Tree* createTree() {\n　Tree tree = Rnd.tree(name)\n　if(tree in tree_records) {\n　return tree;\n　}else{\n　Tree* t = new Tree(name);\n　tree_records.add(t);\n　return t;\n　}\n}&#34;</description>
    </item>
    
    <item>
      <title>代理模式（Proxy Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/proxy_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/proxy_pattern/</guid>
      <description>代理模式（Proxy Pattern）#說明 ChatGPT：代理模式（Proxy Pattern）是一種結構型設計模式，它允許通過使用一個「代理對象」來代表真實對象，從而控制對真實對象的訪問。代理模式提供了一個額外的層次，用於處理對真實對象的訪問，並可以在不改變真實對象的情況下，為其添加一些額外的功能。代理模式的核心思想是：「在【客戶端】和【真實對象】之間引入一個【代理對象】」，這個代理對象充當了客戶端和真實對象之間的中間人。當客戶端想要訪問真實對象時，它不直接與真實對象進行交互，而是通過代理對象來進行訪問。代理對象在接收到客戶端的訪問請求後，可以選擇是否轉發請求給真實對象，並可以在轉發請求前後執行一些額外的操作。代理模式主要包含以下幾個角色：Subject（主題）：主題定義了真實對象和代理對象之間的共同接口，這樣在任何使用真實對象的地方都可以使用代理對象。RealSubject（真實主題）：真實對象實現了 Subject 定義的接口，也就是真實對象，客戶端並不直接與它進行交互。Proxy（代理）：代理同樣也實現了 Subject 定義的接口，內部包含一個真實對象的引用，客戶端通過訪問該對象來代替訪問真實對象。
維基百科：代理模式（英語：Proxy Pattern）是軟體工程中的一種設計模式。所謂的【代理者】是指一個類別可以作為其它東西的介面。【代理者】可以作任何東西的介面：例如網路連接、記憶體中的大物件、某些特定檔案、或其它昂貴或無法複製的資源。著名的代理模式例子為參照計數（英語：reference counting）指標物件。此外，當一個複雜物件的多份副本須存在時，代理模式可以結合享元模式以減少記憶體用量，典型的作法是建立一個複雜物件及多個代理者，每個代理者都會參照到原本的複雜物件，而作用在代理者的運算會轉送到原本物件，而一旦所有的代理者都不存在時，該複雜物件將會被移除。
特點 通過代理者減少對於實體對象的依賴 能夠保持真實對象的穩定與獨立 可以客製化地提供真實對象的擴充功能 UML Graphic classDiagramclass Serverclass ProxyServer &lt;|-- Proxyclass User {Proxy* proxyvoid call_server()}User --&gt; Proxynote &#34;void call_server() {\n　proxy.request();\n}&#34;內文 類似於「霧運算」或者是「邊緣計算」的概念，代理模式的功能是透過一個【代理者】類別，將【真實對象】的工作給區分出去，讓【客戶】有需要進行一些對於【真實對象】的存取時，可以透過【代理者】來進行，從而減少對【真實對象】的依賴或負擔。例如在一個 RPG 遊戲中，我們每次在創建線上遊戲的角色的時候，都會需要做一個「確認 ID 是否重複」的事情，在程式的撰寫上可能會有向下面這樣的例子：
class GameServer { public: std::vector&amp;lt;string&amp;gt; id_vector; public: bool name_duplicated(string str) { auto it = std::find(id_vector.begin(), id_vector.end(), str); if(it != id_vector.end()) return true; else return false; } }; class Character { private: std::string name; public: void set_user_name() { GameServer server = new GameServer(); std::string tmp_name; std::cin &amp;gt;&amp;gt; tmp_name; while(server.</description>
    </item>
    
    <item>
      <title>原型模式（Prototype Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/prototype_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/prototype_pattern/</guid>
      <description>原型模式（Prototype Pattern）#說明 ChatGPT：原型模式（Prototype Pattern）是一種軟體設計模式，屬於創建型模式的一種。它的主要目的是「通過複製現有的物件」來創建新的物件，而不需要知道具體的建構過程。這種方式可以避免重複性的建構過程，特別是當物件建構較為複雜或耗時的時候。在原型模式中，每個物件都是一個原型（prototype），可以通過複製（clone）來創建新的物件。這裡的「複製」不僅僅是複製物件的內容，而是將整個物件的狀態複製一份給新建的物件，新物件與原物件是相互獨立的，對其中一個物件的修改不會影響另一個。原型模式的核心概念是基於現有物件（原型）來創建新物件，而不是從頭開始創建。這樣可以節省建構時間和資源，同時提高程式碼的效率和可讀性。原型模式通常需要實現一個拷貝方法（Clone Method），用於複製物件。這個拷貝方法可以是淺拷貝（Shallow Copy）或深拷貝（Deep Copy），具體取決於物件的需求和關聯性。
維基百科：原型模式是一種創建型設計模式。當要創建的物件類型由原型實例確定時，可以通過拷貝（clone）該原型來產生新的物件。該模式的使用可以避免在客戶端應用程式中對物件創建者進行子類別化，就像工廠方法模式所做的那樣，並且可以避免以標準方式（例如使用 &amp;ldquo;new&amp;rdquo; 關鍵字）創建新物件時所帶來的固有成本，尤其是對於某些應用程式來說這樣做代價過高的情況。要實現這種模式，客戶端先聲明一個原型基類，其中定義了一個 clone() 方法。任何需要具備「多型建構子」功能的類別都要繼承該類別，並實作 clone() 方法。客戶端不再直接在程式中使用 new 來建立物件，而是呼叫原型的 clone() 方法，一個常見的原型模式的例子是細胞的有絲分裂，一個細胞可以產生兩個相同的細胞，彼此相同，但彼此並不相關聯，就是原型模式的一個例子。
特點 通過複製物件快速得到新物件，而不需重新執行建構的過程 將物件的建構細節隱藏在物件內部。 動態地增減物件，通過複製不同類型的原型來創建物件 UML Graphic classDiagramclass World {string nameMap* maps[]void add_map();}class Map {Item* items[]}class Monster {Monster* clone();}World &lt;|-- MapMap &lt;|-- BuildingMap &lt;|-- NPCMap &lt;|-- MonsterMonster &lt;|-- ZombieMonster &lt;|-- Skeleton內文 簡單來說，原型模式就是透過 clone() 函數來代替用 new 的方法創立物件。這麼做有幾種好處，同樣用製作一個 RPG 遊戲來做舉例：首先是「快速初始化」，如果我們想要快速地創建多個相同類別的怪物物件的時候，雖然用 new 是一個不錯的方法，但如果考慮到怪物也許在某些地方會有某些加成，像是殭屍在靠近墓地的時候，會比一般殭屍高出一點點攻擊、防禦、和血量。這時候相對於「用 new 新增一個原本的殭屍，再微調每一個殭屍的所有數值。」，用 clone() 的方法複製第一個已經調整好參數的殭屍會來的更加簡潔。</description>
    </item>
    
    <item>
      <title>命令模式（Command Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/command_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/command_pattern/</guid>
      <description>命令模式（Command Pattern）#說明 ChatGPT：命令模式（Command Pattern）是一種行為型設計模式，它將請求（request）或操作封裝成一個獨立的對象，使得能夠將客戶端的請求參數化、延遲執行或者將請求排入佇列中。這樣可以使請求的發送者和接收者解耦。在命令模式中，主要包含以下角色：【命令】（Command）：它是一個抽象類或接口，聲明了執行請求的方法 execute()。【具體命令】（Concrete Command）：具體命令實現了命令接口，包含了具體的操作和接收者。通常會持有接收者的實例，用來執行實際的請求。【接收者】（Receiver）：接收者知道如何執行真正的操作，接收者會被具體命令所調用。【調用者】（Invoker）：調用者持有命令對象，並在需要的時候調用命令的 execute() 方法。【客戶端】（Client）：創建具體命令對象，設置命令的接收者，並將命令對象設置給調用者。命令模式的核心思想是將「操作」和「操作的執行」解耦，將它們封裝成對象，從而實現請求的發送者和接收者之間的解耦。這使得我們可以輕鬆地增加新的請求類型，或進行撤銷、重做等功能，，對於實現複雜的交互操作和請求發送的場景非常有用。
維基百科：在物件導向程式設計中，命令模式是一種行為型設計模式，它使用一個物件來封裝所有執行動作或稍後觸發事件所需的資訊。這些資訊包括方法名稱、擁有該方法的物件和該方法的參數值。命令模式通常與四個術語相關，它們是命令（Command）、接收者（Receiver）、調用者（Invoker）和客戶端（Client）。一個【命令】了解接收者並調用接收者的方法，該方法的參數值會存儲在命令中。【接收者】用於執行這些方法。當調用【命令】中的 execute() 方法時，【接收者】便開始執行工作。【調用者】物件知道如何執行一個命令，並可以選擇性地進行有關命令執行的記錄。【調用者】不知道具體的命令，只知道【命令】的介面。【客戶端】持有【調用者】、【命令】和【接收者】。【客戶端】決定將哪些【接收者】指派給【命令】，以及將哪些【命令】指派給【調用者】。【客戶端】決定在何時執行哪些命令。為了執行一個命令，它將【命令】傳遞給【調用者】。使用【命令】可以更容易地構建通用元件，這些元件需要在它們選擇的時間點委派、序列化、或執行方法的呼叫，而無需了解方法的類別或方法的參數。這個設計模式的核心思想與「函數式程式設計」中的「一等函數」和「高階函數」的語義非常相似，具體來說，【調用者】是高階函數，而【命令】是一等參數。
特點 將請求封裝成【命令】，使得命令可以參數化 可以將【調用者】和【接收者】解耦 容易進行擴展操作，且支持命令的延遲執行 UML Graphic classDiagramclass Command~Interface~ {Character* charactervoid execute();void undo();}Command &lt;|-- AttackCommandCommand &lt;|-- DefenceCommandclass AttackCommand {void execute() : character.attack();void undo() : character.cancelAttack();}class DefenceCommand {void execute() : character.defence();void undo() : character.cancelDefence();}classDiagramclass Character~Interace~Character &lt;|-- WarriorCharacter &lt;|-- BowmanCharacter &lt;|-- MagicianCharacter &lt;|-- Thiefclass Character {void attack();void cancelAttack();void defence();void cancelDefence();}class CommandInvoker {Command* commandvoid setCommand(Command* cmd);void execute() : cmd.</description>
    </item>
    
    <item>
      <title>單例模式（Singleton Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/singleton_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/singleton_pattern/</guid>
      <description>單例模式（Singleton Pattern）#說明 ChatGPT：單例模式（Singleton Pattern）是一種創建型設計模式，它確保一個類別只有一個唯一的實例，並提供一個全局的訪問點來訪問該實例。單例模式確保一個類別只有一個實例，並且提供全局的訪問點來訪問該實例。實現單例模式的一種常見方式是使用一個私有的靜態成員變量來存儲類別的唯一實例，並提供一個公共的靜態方法來獲取這個實例。在這個方法中，方法首先會檢查實例是否已經存在？如果存在，則返回該實例，否則創建一個新的實例並返回。此外，為了防止通過其他途徑創建額外的實例。單例模式會將類別的構造函數設為私有。
維基百科：單例模式（Singleton Pattern）也叫單子模式，是一種常用的軟體設計模式，屬於創建型模式的一種。在應用這個模式時，單例對象的類必須保證只有一個實例存在。實現單例模式的思路是：一個類僅能返回對象一個引用（永遠是同一個）和一個獲得該實例的方法（必須是靜態方法，通常使用 getInstance() 這個名稱）；當我們調用這個方法時，如果類持有的引用不為空就返回這個引用，如果類保持的引用為空就創建該類的實例，並將實例的引用賦予該類保持的引用；同時我們還將該類的構造函數定義為私有方法，這樣其他處的代碼就無法通過調用該類的構造函數來實例化該類的對象，只有通過該類提供的靜態方法來得到該類的唯一實例。
特點 可以確保一個類別只會生成一個物件 提供簡易的接口，讓程式對實例的訪問與操作更為簡單 可以延遲實例，僅在需要時才創建，節省資源使用 UML Graphic classDiagramclass Singleton {static Singleton obj;static Singleton* getInstance();}內文 單例模式是一個很簡單的概念，就是「單一類別，只會生成單一物件（也就是單一實例）的一種設計模式。」雖說概念很簡單，但實作起來，還是有點眉角在裡面的。在直覺上的想法中，「透過私有的建構子，讓生成物件的權限只限制給類別本身」「『靜態變數』是讓類別中所有物件共用的一個變數」這兩個想法，就可以生成一個簡單的單例模式的程式了，就如下方所示：
class Singleton { static Singleton* obj; private: Singleton() {} public: static Singleton* getInstance() { if(obj == nullptr) { obj = new Singleton(); } return obj; } }; Singleton::obj = nullptr; 在上方的程式中，透過將 Singleton() 建構子宣告成私有的方式，來讓「生成物件」這項工作只有 Singleton 類本身能夠做到，接著讓 obj 初始化成 nullptr，並在 getInstance() 中做一個 obj 的判斷，如果 obj == nullptr，那就生成一個 obj，否則就直接回傳 obj 的記憶體位址。透過這樣的寫法，可以保證 obj 只要一被生成，那麼 obj = new Singleton(); 這件事情就不會被執行，也就代表了一定程度上的「單一類別只會有單一實例」的任務。</description>
    </item>
    
    <item>
      <title>外觀模式（Facade Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/facade_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/facade_pattern/</guid>
      <description>外觀模式（Facade Pattern）#說明 ChatGPT：外觀模式（Facade Pattern）是一種結構型設計模式，它提供了一個簡單的介面（外觀），用於封裝一組複雜的子系統，使得客戶端可以通過這個簡單的介面來訪問子系統的功能，而不需要直接與子系統的細節互動。外觀模式的目的是「簡化客戶端和子系統之間的交互」，降低客戶端對於子系統的依賴程度，同時提供了一個高層次的介面來統一訪問子系統的功能。這樣的設計有助於降低整個系統的複雜性，提高程式的可讀性和可維護性。在外觀模式中，通常有以下兩個角色：Facade（外觀）：這是外觀模式的核心類別，它負責提供了一個簡單的介面，用於封裝子系統的複雜操作。客戶端通常只與外觀類進行交互，而不需要直接訪問子系統。Subsystem（子系統）：這是一組相互關聯的類別或功能，它們共同實現了一個（或一些）複雜的功能。外觀模式將這些子系統封裝起來，使得客戶端不需要了解子系統的細節，只需通過外觀類來使用子系統的功能。
維基百科：外觀模式（Facade pattern），是軟體工程中常用的一種軟體設計模式，它為子系統中的一組介面提供一個統一的高層介面，使得子系統更容易使用。外觀模式是一個物件導向程式設計中常用的設計模式。類似於一個建築學中的立面，該立面作為一個前端接口，來屏蔽更複雜的底層或結構代碼。外觀模式可以提供以下功能：「通用簡化的 API 屏蔽與更複雜的內部組件和結構，以提高 Software library 的可讀性和可用性」「為更通用的功能提供上下文特定的接口」「為 Monolithic System 或 Tight coupling 的軟體系統提供一個簡化的啟動點，更有利於更多的鬆耦合程式」。當一個系統非常複雜或難以理解時，開發人員通常會使用外觀模式，因為原系統通常有許多相互依賴的類別，或者因為其它的原因，使得直接調用原始程式碼會耗費極大的成本。Facade pattern 隱藏了更大系統的複雜性，為客戶端提供了一個更簡單的接口。
特點 定義了一個算法族 封裝算法族中的每一個算法 不同的算法可以互相替換 UML Graphic classDiagramclass SkillFacade {void show();}class Swordman {void chop();void hack();void parry();}class Magician {void fire_magic_attack();void earth_magic_attack();void wind_magic_attack();void water_magic_attack();void heal();}class Bowman {void aim();void throw();void toss();void shoot();}class Thief {void poke();void kick();void evade();void counter_attack();void ninjutsu();}SkillFacade --&gt; SwordmanSkillFacade --&gt; MagicianSkillFacade --&gt; BowmanSkillFacade --&gt; Thiefnote &#34;</description>
    </item>
    
    <item>
      <title>工廠方法模式（Factory Method Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/factory_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/factory_method_pattern/</guid>
      <description>工廠方法模式（Factory Method Pattern）#說明 ChatGPT：工廠方法模式（Factory Method Pattern）是一種軟體設計模式，屬於創建型模式之一。它提供了一種「分離物件的創建與使用」的方式，通過使用工廠類別內的方法來創建物件，而不是直接在客戶端代碼中使用 new 關鍵字。 在工廠方法模式中，工廠會定義了一個接口（或抽象類別），其中包含了創建產品物件的抽象方法，具體的物件創建則由實現該接口的具體工廠類別來實現。這樣一來，客戶端代碼只需要和工廠接口進行交互，而不需要知道具體的物件創建細節。工廠方法模式的核心思想是：「將物件的創建延遲到子類別中」，使得客戶端的程式與具體的物件創建解耦。這樣做的好處是，當需要新增一種具體的產品時，只需要擴展相應的具體工廠類別即可，不需要額外修改客戶端代碼，因此符合設計原則中的「開放封閉原則」。
維基百科：在物件導向程式設計中，工廠方法模式（Factory Method Pattern）是一種創建型模式，它使用工廠方法來處理創建物件的問題，而不需要明確指定將要創建的物件的確切類別。這是通過調用工廠中的方法來創建物件來實現的，而不是通過調用構造函數來實現。其中，工廠中的方法可以在介面中抽象化，並由子類實現，或者在類別本身中實現，並由子類別選擇性地覆蓋。創建物件通常會擁有一個複雜的流程，該流程並不適合再複合類別中實現。物件的創建可能導致代碼的重複、可能需要組合物件無法訪問的資訊、可能無法提供足夠的抽象層次、或者可能與組合物件的關注點無關。因此，工廠方法模式通過「定義一個獨立的方法來創建物件」來解決這些問題，子類可以覆蓋該方法以指定將要創建的衍生類型。
特點 將物件的「創建」與「使用」分離 可以輕易擴展 符合開放封閉原則 UML Graphic classDiagramclass EnchantingFactory~Interface~ {Sword* createSword();}class KnockbackFactory {Sword* createSword() return KnockbackSword();}class FireAspectFactory {Sword* createSword() return FireAspectSword();}EnchantingFactory~Interface~ &lt;|-- KnockbackFactoryEnchantingFactory~Interface~ &lt;|-- FireAspectFactory內文 小建議：可以先看過簡單工廠模式，再回來看這個「工廠方法模式」會比較好。
如同簡單工廠模式所述：在四人幫的著作裡面，工廠模式共分為簡單工廠模式、工廠方法模式、和抽象工廠模式這三種。相對於「在【工廠】中直接建立【產品】」的簡單工廠模式，工廠方法模式更在乎「其他的『工廠』有沒有依循著同樣的『方法』」來建立物件。通常來說，工廠方法會先定義出一個『工廠介面』，再讓其他的【工廠】去繼承這個工廠介面，從而確保所有的【工廠】都有類似或相同的產品製造方法。用另外一個 RPG 遊戲來做舉例，假設在一個遊戲中，我們想要實作出不同附魔類別的劍，簡單工廠的方法可能會像是下面的樣子：
class SimpleFactory { public: static Sword* enchantSword(Enchantments enchantments) { Sword* sword = nullptr; switch(enchantments) { case Knockback: sword = new KnockbackSword(); break; case FireAspect: sword = new FireAspectSword(); break; // other codes .</description>
    </item>
    
    <item>
      <title>抽象工廠模式（Abstract Factory Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/abstract_factory_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/abstract_factory_pattern/</guid>
      <description>抽象工廠模式（Abstract Factory Pattern）#說明 ChatGPT：抽象工廠模式（Abstract Factory Pattern）是一種創建型設計模式，它提供了一種「創建一系列相關或相互依賴對象」的接口，而無需指定具體的類別。該模式允許客戶端使用抽象接口來創建一組相關的對象，而不必關心實際的對象實現細節。抽象工廠模式的目標是實現產品族的創建，其中產品族是指「一組相互關聯的產品」，這些產品之間有共同的約束或邏輯關係。抽象工廠模式使得系統更具靈活性，易於切換產品族，而不需要修改客戶端程式。總的來說，抽象工廠魔是總共由四個核心部分組成：抽象工廠（Abstract Factory）：定義創建產品族的接口，通常由一個抽像類或接口來表示。該接口包含多個抽象方法，每個方法用於創建一個具體產品。具體工廠（Concrete Factory）：實現【抽象工廠】中的接口，負責創建具體的產品對象。抽象產品（Abstract Product）：定義產品族中的某類產品的接口，可以是抽象類別或接口。具體產品（Concrete Product）：實現【抽象產品】中的接口，負責定義實際產品的樣貌與屬性，【具體工廠】會創建這些產品的實例。
維基百科：抽象工廠模式（Abstract factory pattern）是一種軟體開發設計模式。抽象工廠模式提供了一種方式，可以將一組具有同一主題的單獨的工廠封裝起來。在正常使用中，客戶端程式需要建立抽象工廠的具體實現，然後使用抽象工廠作為介面來建立這一主題的具體對象。客戶端程式不需要知道（也不需要關心）它從這些內部的工廠方法中獲得對象的具體類型，因為客戶端程式僅使用這些對象的通用介面。抽象工廠模式將「一組對象的實現細節」與「它們的使用」分離開來。【工廠】類別是建立產品的地方，其目的是將產品的建立與產品的使用分離。抽象工廠模式的目的，是將若干抽象產品的介面，與不同主題產品的具體實現分離開。這樣就能在增加新的具體工廠的時候，不用修改參照抽象工廠的客戶端代碼。使用抽象工廠模式，能夠在具體工廠變化的時候，不用修改使用工廠的客戶端代碼，甚至是在執行時。然而，使用這種模式或者相似的設計模式，可能給編寫代碼帶來不必要的複雜性和額外的工作。
特點 將物件的「創建」與「使用」分離 可以輕易擴展 符合開放封閉原則 UML Graphic classDiagramclass MonsterMonster &lt;|-- ZombieMonster &lt;|-- GoblinMonster &lt;|-- Skeletonclass WeaopnWeaopn &lt;|-- SwordWeaopn &lt;|-- AxeWeaopn &lt;|-- BowclassDiagramclass MonsterFactory {Monster* create();}class ZombieFactory {Monster* create() new Zombie()}class GoblinFactory {Monster* create() new Goblin()}class SkeletonFactory {Monster* create() new Skeleton()}MonsterFactory &lt;|-- ZombieFactoryMonsterFactory &lt;|-- GoblinFactoryMonsterFactory &lt;|-- SkeletonFactoryclassDiagramclass WeaponFactory {Weapon* create();}class SwordFactory {Weapon* create() new Sword()}class AxeFactory {Weapon* create() new Axe()}class BowFactory {Weapon* create() new Bow()}WeaponFactory &lt;|-- SwordFactoryWeaponFactory &lt;|-- AxeFactoryWeaponFactory &lt;|-- BowFactoryclassDiagramclass AdvancedMonster {Monster* createAdvancedMonster();}note &#34;</description>
    </item>
    
    <item>
      <title>模板方法模式（Template Method Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/template_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/template_method_pattern/</guid>
      <description>模板方法模式（Template Method Pattern）#說明 ChatGPT：模板方法模式（Template Method Pattern）是一種行為設計模式，它定義了一个演算法的「框架」，並將該演算法的細節程式延遲到子類中進行實現。在模板方法模式中，一個抽象類別會公開定義一個（或多個）方法的骨架，而將一些方法中的具體細節推遲稻子類別中。這樣可以确保方法的整體結構不會改變，但允許子類別根據需要，重新定義某些步骤。在模板方法模式中，主要有三種類型的方法：模板方法（Template Methods）：模板方法會在方法內部定義一系列該方法的執行步驟。抽象方法（Abstract Methods）：抽象方法由抽象類別聲明，它們没有具體的程式細節，在模板方法模式中，子類必須實作這些方法。鉤子方法（Hook Methods）：鉤子方法有一個預設的程式實作，但子類別可以選擇性地呼叫或重寫它們，鉤子方法可以在模板方法中的不同步骤中，插入自定義的行為。
維基百科：模板方法模式是一種行為設計模型和設計模式。模板方法（template method）是一個定義在父類別的方法，負責處理流程和演算法的不變部分。模板方法會呼叫多個定義在父類別的其他工具方法（helper method），這些方法是演算法的可變部分，有的工具方法可能只是抽象方法，並沒有實作，也有的工具方法已經有一些實作的程式，但仍允許子類改寫。模板方法僅決定這些抽象方法的執行順序，這些抽象方法由子類別負責實作。此外，子類別不允許覆蓋模板方法（意即不能重寫處理流程）。這種設計模式是一種控制反轉的實現方式。因為高層級的程式不再需要控制演算法的細節實作，而僅需在意演算法的框與流程。
特點 定義了一個算法流程 將各流程的實際實作延遲至子類進行實踐 子類的實作方式各不同，但流程相同 UML Graphic classDiagramclass CharacterCreator {Race* race;Appearance* appearance;Attribute* attribute;void createCharacter(); : cannot overridevoid selectRace();void selectAttributes();void customizeAppearance();bool hasUniqueAbility();void customizeUniqueAbility();void saveCharacter();}note &#34;void createCharacter() {\n　selectRace()\n　selectAttributes()\n　customizeAppearance()\n　if(hasUniqueAbility()) {\n　customizeUniqueAbility()\n　}\n　saveCharacter()\n}&#34;class Orcish {selectRace(): &#34;orcish&#34;}class NightElf {selectRace(): &#34;</description>
    </item>
    
    <item>
      <title>橋接模式（Bridge Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/bridge_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/bridge_pattern/</guid>
      <description>橋接模式（Bridge Pattern）#說明 ChatGPT：橋接模式（Bridge Pattern）是軟體設計模式的一種，它屬於結構型模式之一。橋接模式的主要目的是「將『抽象部分』與『實現部分』分離」，使它們可以獨立地變化，從而降低了它們之間的耦合性。在軟體開發中，常常會遇到「類之間的耦合」和「功能之間的耦合」。類之間的耦合指的是一個類與另一個類之間的相依關係，而功能之間的耦合則是指一個類內部不同功能模塊之間的相依關係。當類之間的耦合度過高時，一個類的變化可能會影響到其他相關的類，這樣的系統就會變得脆弱且難以擴展。橋接模式通過使用抽象和實現之間的分離，解決了這些耦合性問題。在橋接模式中，『抽象部分』和『實現部分』分別由兩個獨立的類層次結構來表示。抽象部分包含高層次的抽象介面，而實現部分則包含具體的實現細節。這樣，抽象部分和實現部分可以獨立擴展，互不影響。
維基百科：橋接模式（Bridge Pattern）是軟體工程中使用的一種設計模式，它旨在「將抽象與其實現分離，以便兩者可以獨立變化」，是由四人幫引入的一種設計模式。橋接模式使用封裝、聚合，並且可以使用繼承將職責分離到不同的類中。當類別經常變化時，物件導向程式設計的功能就變得非常有用，因為即使對程式有很少的先驗知識，也可以輕鬆地更改程式代碼。當類別及其功能經常變化時，橋接模式會顯得非常有用。類別本身可以被視為抽象，而類別可以做的行為則被視為實例。橋接模式也可以被認為是兩層抽象。
特點 分離抽象介面與實例創建的程式邏輯 可將抽象類別與實例類別獨立開來 採用「組合」的方式減少「繼承」的大量使用 UML Graphic classDiagramclass Character~Interface~ {Weapon* weaponArmor* armor;void equip();void attack()virtual void weild();virtual void swing();virtual void unweild();}note &#34;void equip() {\n　print(equip weapon.name);\n　print(equip armor.name);\n}&#34;note &#34;void attack() {\n　weapon.waild();\n　weapon.swing();\n　weapon.unweild();\n}&#34;Character~Interface~ &lt;|-- KnightCharacter~Interface~ &lt;|-- WarriorCharacter~Interface~ &lt;|-- ThiefclassDiagramWeapon~Interface~ &lt;|-- SwordWeapon~Interface~ &lt;|-- AxeWeapon~Interface~ &lt;|-- DaggerArmor~Interface~ &lt;|-- AlloyArmorArmor~Interface~ &lt;|-- IronArmorArmor~Interface~ &lt;|-- LeatherArmor內文 橋接模式的核心觀念是「多用組合、少用繼承」。也就是合成/聚合複用原則（CARP - Composite/Aggregate Reuse Principle）所提倡的概念。橋接模式的用途在於「將二維（或多維）的程式邏輯轉變為兩個（或多個）一維的狀態」讓我們用一個 RPG 遊戲來做舉例：假設我們這在撰寫一個 RPG 遊戲，遊戲裡面提供了「騎士、戰士、和盜賊」3 種不同的職業類別。遊戲裡面也定義了「劍、斧頭、和匕首」3 種不同的武器選項，以及「皮製護具、鐵製鎧甲、與合金盔甲」3 種不同的防禦性裝備。因為我們允許不同的職業做不同的武器防具組合（『騎士 + 劍 + 鐵製鎧甲』，或者『盜賊 + 斧頭 + 皮製護具』&amp;hellip;等），因此在當前的情況下，總共會有 \(3 \times 3 \times 3 = 27\)種不同的組合。那如果我們單純用 Character 類別 + 繼承來實現這組遊戲腳色的程式的話，可能就會像下面這個樣子：</description>
    </item>
    
    <item>
      <title>狀態模式（State Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/state_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/state_pattern/</guid>
      <description>狀態模式（State Pattern）#說明 ChatGPT：狀態模式（State Pattern）是一種行為型設計模式，它允許物件在相異的狀態下展現不同的行為，並讓使用者看起來好像改變了它的類別。這種模式可以將物件的狀態封裝在不同的類別中，並且使物件能夠在運行時根據狀態的改變而改變其行為。狀態模式的主要目的是將複雜的條件判斷轉換成一組一組相關的狀態類別，從而使代碼更具可讀性、可維護性和可擴展性。它遵循開放-封閉原則，因為可以通過添加新的狀態類別來擴展系統的行為，而無需修改現有的代碼。使用狀態模式，可以將每個狀態實現為一個具體狀態類別，並將狀態相關的行為封裝在這些類別中。上下文類別（VendingMachine）持有當前狀態的引用，並將相應的請求委派給當前狀態對象。當狀態發生改變時，上下文物件將切換到新的狀態，並且行為也隨之改變。透過狀態模式，可以實現狀態機進行狀態轉換和行為管理的解耦，使得系統更靈活、可擴展且易於維護。
維基百科：狀態模式是一種行為型設計模式，它允許對象在内部狀態改變時，改變其行為。該模式與有限狀態機的概念密切相關。狀態模式可以解释為一種策略模式，通過調用模式接口中定義的方法來切換策略。狀態模式在軟體工程中用於封裝同一對象的不同行為，基於其內部狀態。這可以是對象在運行時改變行為的一種清晰呈現，而無需使用大量的 if else 語句，從而提高可維護姓。狀態模式旨在解决兩個主要問題：「對象在何時改變其狀態與行為」「不同的狀態與行為該如何定義」。也就是說，在狀態模式下，增添新的狀態並不會影響原有的狀態與各自的行為。此外，因為直接在一個類別中實特定狀態的行為是不靈活的因此該模式會為每個狀態定義一個單獨的狀態接口，並定義單獨的狀態對象，封装每個狀態的特定行為。並於類別中切換與調用。
特點 將每一種「狀態」各自定義成一個類別 透過委託的方式，讓各狀態分別實現不同的行為 通常會配合枚舉（enum）一同使用 State Graphic stateDiagramStand --&gt; SquatDownStand --&gt; WalkStand --&gt; JumpStand --&gt; AttackSquatDown --&gt; StandSquatDown --&gt; AttackWalk --&gt; StandWalk --&gt; RunWalk --&gt; JumpWalk --&gt; AttackRun --&gt; StandRun --&gt; RollRun --&gt; JumpRun --&gt; AttackRoll --&gt; StandRoll --&gt; AttackJump --&gt; StandJump --&gt; WalkJump --&gt; AttackAttack --&gt; Stand內文 假設我們正在製作一款 2D 橫向卷軸的 RPG 遊戲，玩家可以透過不同的按鍵操縱遊戲中的角色。在不使用狀態模式的程式撰寫方法下，我們可能會需要利用一些的條件判斷語句來完成「角色移動」的這個概念，就如下面的程式所示：</description>
    </item>
    
    <item>
      <title>生成器模式（Builder Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/builder_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/builder_pattern/</guid>
      <description>生成器模式（Builder Pattern）#說明 ChatGPT：生成器模式（Builder Pattern）是一種軟體設計模式，用於創建複雜物件時，將建構過程和表示分離，使得同樣的建構過程可以創建不同的表示。這種模式通常用於創建具有多個可選屬性的物件，以及具有多個步驟或配置過程的物件。通常來說，一個創建者模式裡面，主要包含以下幾個元素：產品（Product）：這是要建構的複雜物件，通常包含多個屬性。它可以是一個複雜的類別或結構。建構者（Builder）：建構者通常是一個介面（或抽象類別），它定義了建構產品的各個步驟，並且可能包含設置屬性的方法。具體建構者（Concrete Builder）：實現建構者介面的類別，負責實際建構物件並設置其屬性。指揮官（Director）：可選元素，對於複雜的建構過程，可以使用指揮者來將建構過程進行組織和管理，以確保生成符合需求的物件。
維基百科：生成器模式（Builder Pattern）是一種設計模式，又名：建造者模式、創建者模式，是一種對象構建模式。它可以將對象的建造過程，利用一系列抽象的步驟提取出來，使這個抽象過程的不同實現方法可以構造出不同表現（屬性）的對象。生成器模式解決了以下的幾問題：一個類別如何擁有類似的建構過程，但又可以創建出具有不同屬性的物件？一個類別如果包含大量的屬性，它該如何簡化包含建構複雜物件的類別？生成器設計模式描述了如何解決這些問題的方法：將「創建」和「組裝複雜物件」的部分封裝在一個獨立的建構者（Builder）物件中。類別將物件的建構委託給建構者，而不是直接創建物件。
特點 可以分離生成物件的過程 相對於建構子，具有有更佳的彈性和擴展性 支援不同種類的物件生成方式 UML Graphic classDiagramclass Character {string nameRole* roleWeapon* weaponArmor* armorElement* element}class CharacterBuilder {void setName()void setRole()void setWeapon()void setArmor()void setElement()Character* getCharacter()}CharacterBuilder &lt;|-- WarriorBuilderCharacterBuilder &lt;|-- MagicianBuilderCharacterBuilder &lt;|-- ArcherBuilderCharacterBuilder &lt;|-- AssassinBuilderclass CharacterDirector {CharacterDirector(CharacterBuilder* b)}Character --&gt; CharacterDirectorCharacterDirector o-- CharacterBuilder內文 假設我們在製作一款 RPG 遊戲，其中在「創建角色」的過程，角色可以選定「戰士、弓箭手、法師、盜賊」其中一種職業遊玩。角色的屬性主要分成以下四種類型：【名稱】名稱由玩家自行填寫，不可為空。【武器】武器會根據角色所選的職業有所不同，戰士可以手持劍或斧、弓箭手固定為弓、法師的武器固定為長杖、盜賊固定為匕首。【護具】護具同樣由職業做綁定：戰士使用鐵製護具，弓箭手使用皮革護具、盜賊同樣使用皮革護具，法師則沒有護具。【元素屬性】元素屬性也是綁定職業：戰士不具有任何元素屬性（純物理攻擊）、弓箭手固定為風屬性、盜賊可以選擇不持有屬性或持有風屬性的能力、法師則可以在火土風水之中選擇一種主要屬性使用。</description>
    </item>
    
    <item>
      <title>策略模式（Strategy Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/strategy_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/strategy_pattern/</guid>
      <description>策略模式（Strategy Pattern）#說明 ChatGPT：策略模式（Strategy Pattern）是一種行為型設計模式，該模式允許在程式運行時，根據不同的需求，選擇不同的算法或行為。策略模式將演算法的定義、演算法的實現、和演算法的使用分離，這種彈性的程式撰寫方式，使得它們可以彼此獨立地變化，互相替換。策略模式的核心思想，是將「行為」封裝各種成獨立的「策略」，使得使用者（或程式）可以根據需要，選擇實踐不同的策略，同時需要改變策略的程式碼。這種靈活性和可替換性，使得策略模式在需要動態地改變物件的行為的情況下非常有用，並且能夠實現高度可定制和可擴展的系統設計。
維基百科：策略模式是一種行為型軟體設計模式，它可以在運行時選擇一個演算法。程式在撰寫的過程中，不會直接實現單一的演算法，而是根據運行時的指示。從一系列的篩選方式中，選擇一個方法出來。策略模式使得演算法能夠獨立於使用它的客戶端變化，它將「選擇使用哪個演算法」的決策推遲到運行時，可以使呼叫程式的方式更靈活和可重用。例如，對輸入數據進行驗證的類別可以使用策略模式，根據類型、來源、使用者選擇、或其他區分因素來選擇驗證演算法。因為這些後天的因素需要直到運行時才知道，因此不同的輸入可能需要執行完全不同的驗證。在此情況下，將驗證演算法（策略）與驗證的物件分開封裝，可以在系統的不同區域（甚至不同系統）中由其他驗證物件使用，而無需重複編寫代碼。
特點 定義了一個算法族 封裝算法族中的每一個算法 不同的算法可以互相替換 UML Graphic classDiagramclass Character {AttackMethod* atkattack() : atk.attack()}class AttackMethod~Interface~ {attack()}Character *-- AttackMethodclass PhysicalAttack {attack() &#34;Physical attack&#34;}class MagicAttack {attack() &#34;Magic attack&#34;}AttackMethod &lt;|-- PhysicalAttackAttackMethod &lt;|-- MagicAttack內文 光看維基百科的說明可能會有點霧煞煞，我們拿 RPG 遊戲來做一個舉例好了：設想今天，我們有一個 RPG 遊戲，裡面的角色可以選擇「劍士、盜賊、弓箭手、法師、和海盜」五種角色，同時每種角色都有其獨特的攻擊方式（劍士用刀劍、弓箭手用弓弩、海盜用手槍指虎&amp;hellip;等等）。在不使用策略模式的情況下，如果我們想要實現遊戲中的程式，可能就會需要有一個像下面的 pesudo code：
class Role { enum character {Warrior, Thief, Bowman, Magician, Pirate}; void attack() { switch(character) { case Warrior: print(&amp;#34;Using a sword to attack.</description>
    </item>
    
    <item>
      <title>簡單工廠模式（Simple Factory Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/simple_factory_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/simple_factory_pattern/</guid>
      <description>簡單工廠模式（Simple Factory Pattern）#說明 ChatGPT：簡單工廠模式（Simple Factory Pattern）是一種軟體設計模式，屬於創建型模式之一。它提供了一個集中化的「工廠」類別，負責根據客戶端的要求創建不同的產品物件，而客戶端不需要直接與具體的產品物件或其創建細節進行交互。通常，一個普通的簡單工廠會有以下的三種角色：產品（Product）：定義了一個產品的共同介面。具體產品（Concrete Product）：實現了產品的一個介面，是工廠所創建的具體物件。簡單工廠（Simple Factory）：負責根據客戶端的要求，創建具體產品物件的工廠類別。在簡單工廠模式中，客戶端通過傳入相應的參數，調用簡單工廠類別的靜態方法（或非靜態方法），由簡單工廠根據參數的不同來創建具體的產品物件。客戶端不需要關心具體的物件創建細節，只需要與簡單工廠類別進行交互即可。
維基百科：簡單工廠模式是一種創建型模式，該模式創建了一個單一的工廠類別，並在類別中宣告產生具體產品的方法。用戶端可以對該工廠輸入不同的參數，而工廠則根據參數的不同，實現不同的具體對象返回給客戶端。這種工廠類別因為與使用者的交互相對單純，因此可以將工廠方法設定為靜態方法。簡單工廠封裝了對象的建立過程。如果物件的建立過程非常複雜或繁瑣，工廠方法就非常有用了。我們可以將這種選擇邏輯包裝在一個簡單工廠中。
特點 可以集中化的物件創建 封裝創建細節，將用戶與具體產品解偶 如果打算增加新產品，則需修改工廠類別中的方法 UML Graphic classDiagramclass Role {Chatacter* chatacter;Weapon* getReward() RewardFactory.getReward(chatacter);}class RewardFactory {Weapon* getReward(Character* chatacter);}class Weapon {}Role o-- RewardFactoryRewardFactory --&gt; WeaponWeapon &lt;|-- SwordWeapon &lt;|-- BowWeapon &lt;|-- DaggerWeapon &lt;|-- Staff內文 在 GoF 的設計模式裡面，簡單工廠模式、工廠方法模式、和抽象工廠模式為三種不同的「工廠模式」，分別可以對於不同複雜度的程式降低不同程度的複雜性、和提升程式的擴展性與其他效能。「簡單工廠模式」顧名思義，就是可以透過一個「工廠」來「簡單地」生成物件的程式撰寫方式。假設我們現在有一個 RPG 遊戲，裡面需要實做一個「當玩家完成某項任務之後，遊戲可以依照其玩家的職業，給予相對應的武器作為獎賞」的程式，對於一般的程式撰寫方式，我們可能會寫出類似於下面的程式邏輯：
class Role { public: Weapon* getReward() { Weapon* reward = nullptr; switch(this -&amp;gt; character) { case Warrior: reward = new Sword(); break; case Thief: reward = new Dagger(); break; case Bowman: reward = new Bow(); break; case Magician: reward = new Staff(); break; case Pirate: reward = new HandGun(); break; } return reward; } }; 這樣的寫法並沒有什麼特別的邏輯錯誤，但這樣的寫法會產生幾個缺點：首先是「getReward() 方法的長度會隨著職業的增加而逐漸變大。」如果今天遊戲中的職業為一個恆定的數量，那麼這樣的寫作方式其實也還算允許，但如果在某一次的改版中，我們被要求「新增大約 5-10 種不同的職業，並針對這些新增的職業額外撰寫可以獲得任務獎勵。」那麼程式的量級就會愈發龐大了。另外來說，因為不同的職業會需要不同的任務獎勵，因此這樣的寫法上，【角色】類別也會依賴於各種【任務獎勵】的類別。</description>
    </item>
    
    <item>
      <title>組合模式（Composite Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_pattern/</guid>
      <description>組合模式（Composite Pattern）#說明 ChatGPT：組合模式（Composite Pattern）是一種結構型設計模式，它允許將對象組織成樹狀結構以表示「部分 - 整體」的層次結構。組合模式使得用戶可以一致地處理單個對象和組合的對象，並且無需對它們進行區分。在組合模式中，有以下幾個角色：Component（組件）：組件定義了組合中所有對象的通用接口，它可以是接口或抽象類別。它聲明了一些管理和訪問子組件的方法，並可以提供默認的實例方法。Leaf（葉子）：表示組合中的葉子節點，即沒有子節點的對象。葉子對象實現了 Component 接口。Composite（組合）：表示組合中的複合節點，即包含子節點的對象。組合對象實現了 Component 接口，並保存了一個子節點的列表。組合模式的核心思想是「讓用戶對『單個對象』和『組合的對象』進行統一處理」，從而降低了用戶程式的複雜性。用戶不需要區分當前處理的是單個對象還是組合的對象，而是統一通過 Component 接口來進行操作。
維基百科：在軟體工程中，組合模式是一種結構型模式。組合模式描述了一組對象，這些對象的處理方式與同一類型對象的單個實例相同。組合的目的是將對象「組合」成樹結構，以表示「部分 - 整體」層次結構。實現組合模式可以讓客戶端統一處理單個對象和組合。組合模式是 23 個著名的設計模式之一，它描述瞭如何解決重複出現的設計問題，以靈活的設計且可重用的物件導向程式解決問題，意即更容易實現、更改、測試和重用的對象。組合模式可以解決什麼問題？：組合模式利用了部分 - 整體的層次結構，讓客戶端可以統一對待部分和整體對象。組合模式描述了什麼解決方案？ 組合模式會將物件的部分（Leaf）和整體（Composite）定義一個統一的組件接口。各個 Leaf 直接實例 Component，而 Composite 則將請求轉發到其子組件（可能是 Leaf 或 Composite）。這使得客戶端能夠通過 Component 的接口來統一處理所有程式使得客戶端更容易實現、更改、測試和重用。
特點 利用「部分 - 整體」的遞迴結構實現單一操作的功能 UML Graphic classDiagramclass Character~Interface~ {void attack();}Character &lt;|-- Monster~Interface~Character &lt;|-- Player~Interface~Character &lt;|-- Team~Interface~class Team {Character[] teammate}Team --&gt; Character內文 組合模式所強調的「部分 - 整體」有點類似一即全，全即一的感覺，透過對於「單個物件的操作」可以遞迴影響到「整個物件群組」舊式組合模式想要解釋的概念。我們可以用一個 RPG 遊戲的例子來解釋組合模式：在一個 RPG 遊戲中，我們想要設定一個「主角可以與一同前行的人物組成『隊伍』，並透過與不同的『怪物們』相互對戰之後，最終打敗大 BOSS 取得勝利」作為一個核心的遊戲戰鬥機制。在這個機制下，所有的「成員」都是「隊伍」的一部分。而「隊伍」即是所有「成員」的組成。</description>
    </item>
    
    <item>
      <title>裝飾器模式（Decorator Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/decorator_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/decorator_pattern/</guid>
      <description>裝飾器模式（Decorator Pattern）#說明 ChatGPT：裝飾器模式（Decorator Pattern）是一種結構型設計模式，它允許動態地為對象添加額外的功能，並且不需要修改其代碼。這種模式通常用於擴展一個類的功能，並且提供了比繼承更靈活的解決方案。 在裝飾器模式中，將功能的實現分成核心部分和裝飾部分。核心部分代表原始類，它可以是一個抽象類或接口，裝飾部分則是一系列具體的裝飾器類，用於擴展核心部分的功能。裝飾器模式的典型應用場景是在不改變原始類的情況下，動態地擴展功能。例如，可以用來為一個圖形繪製程式添加不同的效果，如邊框、陰影、填充等，這些效果可以在運行時動態地添加，且不影響圖形本身的類結構。通常來說，一個裝飾器模式的基本結構包含以下角色：Component（組件）：定義了核心功能的接口，可以是抽象類或接口。Concrete Component（具體組件）：實現了 Component 接口的具體類，代表原始類。Decorator（裝飾器）：維持一個指向 Component 的引用，並實現 Component 接口，這樣可以動態地添加功能。ConcreteDecorator（具體裝飾器）：擴展 Decorator 的功能，並實現具體的裝飾行為。
維基百科：裝飾器模式又叫做「修飾模式」，是物件導向程式領域中，一種動態地往一個類別中添加新的行為的設計模式。就功能而言，裝飾器模式相比生成子類別更為靈活，這樣可以給某個對象而不是整個類別添加一些功能。通過使用裝飾器模式，可以在程式運行時，動態地擴充一個類別的功能。原理是：增加一個「修飾類」去包裹原來的類別，包裹的方式是在修飾類的構造函數中將原來的類以參數的形式傳入。裝飾類實現新的功能，但是，在不需要用到新功能的地方，它可以直接調用原來的類別中的方法。此外，修飾類必須和原來的類別有相同的接口。裝飾器模式是類別繼承的另外一種選擇。類繼承在編譯時候增加行為，而裝飾器模式則是在程式運行時增加行為。當有幾個相互獨立的功能需要擴充時，這個區別就變得很重要。在有些物件導向的程式語言中，類別不能在運行時被創建，通常在設計的時候也不能預測到有哪幾種功能組合。這就意味著要為每一種組合創建一個新類別。相反，裝飾器模式是在程式運行時候的實例化物件的，這樣就可以在程式運行的時後，根據需要進行不同地組合。
特點 可以通過裝飾器類，動態地擴展物件的功能 可以對物件任意組合功能，使得系統的擴展性更好 遵從設計原則中的「開放封閉原則」 UML Graphic classDiagramWeapon &lt;|-- SwordWeapon &lt;|-- AxeWeapon &lt;|-- Daggerclass Decorator~Interface~ {Decorator(Weapon* w)}Weapon &lt;|-- Decorator~Interface~Decorator~Interface~ &lt;|-- AttackBuffDecorator~Interface~ &lt;|-- CritBuffDecorator~Interface~ &lt;|-- PenetratingBuff#內文 裝飾器模式是一種比較特別的設計模式，它的核心用途是「利用『非繼承』的方式，擴增原本的類別」。因為裝飾器模式可以遞迴執行（或者說它的本質就是遞迴執行），因此也適用在「重複疊加某一種效果的需求」的情境上。讓我們用一個 RPG 遊戲來當例子：假設我們在實現一個【武器強化】的功能，可以針對不同的武器（像是劍、斧頭、匕首&amp;hellip;等）進行不同種的強化（增益攻擊、爆擊、或護甲穿透&amp;hellip;等），如果我們用「繼承」的方式來寫的話，可能會寫出類似於下面這樣的程式碼：
class Weapon {}; class Sword : public Weapon {}; class Attack_Buff_Sword : public Sword {}; class Crit_Buff_Sword : public Sword {}; class Penetrating_Buff_Sword : public Sword {}; class Axe : public Weapon {}; class Attack_Buff_Axe : public Axe {}; class Crit_Buff_Axe : public Axe {}; class Penetrating_Buff_Axe : public Axe {}; class Dagger : public Weapon {}; class Attack_Buff_Dagger : public Dagger {}; class Crit_Buff_Dagger : public Dagger {}; class Penetrating_Buff_Dagger : public Dagger {}; 這樣子的做法有幾個壞處：首先是程式的類別會依照【武器】與【增益效果】的變多而快速增加。在當前的狀況下，如果我們想要新增兩種武器（長槍、弓箭）那麼我們除了新增 Lance, Bow 兩種類別之外，我們還要根據不同的類別分別實作攻擊增益、爆及增益、以及穿透護甲增益三種類別。那如果再之後我們打算多新增 \(x\)種武器和 \(y\)種增益效果，類別的數量就會以驚人的速度成長了。</description>
    </item>
    
    <item>
      <title>觀察者模式（Observer Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/observer_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/observer_pattern/</guid>
      <description>觀察者模式（Observer Pattern）#說明 ChatGPT：觀察者模式（Observer Pattern）是一種行為型設計模式，也被稱為發布-訂閱（Publish-Subscribe）模式或模型-視圖（Model-View）模式。它用於建立對象之間的一對多的依賴關係，當一個對象的狀態發生變化時，所有依賴它的對象都會收到通知並自動更新。在觀察者模式中，有兩個主要角色：主題（Subject）：也稱為「可觀察對象」或「被觀察者」。它是一個被觀察的對象，當其狀態發生變化時，它會通知所有註冊過的觀察者。觀察者（Observer）：也稱為「訂閱者」或「觀察者」。它是依賴於主題的對象，當【主題】的狀態發生變化時，【觀察者】會收到通知並根據新的狀態進行更新。觀察者模式的主要目的是解耦主題和觀察者，使它們之間不需要直接相互交互，從而提高程式的靈活性和可重用性。【主題】不需要知道【觀察者】的具體類型，只需要知道它們實現了共同的觀察者接口。這樣在未來添加新的觀察者時，【主題】的程式不需要進行修改。
維基百科：觀察者模式是行為型設計模式的一種，用於建立對象之間的一對多依賴關係。在此種模式中，一個目標物件管理所有相依於它的觀察者物件，並且在它本身的狀態改變時主動發出通知。這通常透過呼叫各觀察者所提供的方法來實現。此種模式通常被用在即時事件處理系統。通常來說，觀察者模式包含以下幾種結構：【抽象主題介面】 抽象主題介面會提供一個介面，讓【觀察者】進行添附（Attach）與解附（Detach）的作業，此類別內會包含一個不公開的【觀察者】串列，且通常具有以下三種方法：添附 attach() 可以新增觀察者到串列內，以追蹤主題的變化。解附 detach() 可以將已經存在的觀察者從串列中移除。通知 notify() 利用觀察者所提供的更新函式來通知此目標已經產生變化。【主題類別】 主題類別提供了【觀察者】欲追蹤的主題，【觀察者】可以透過【目標主題】的 getState() 方法取得主題的狀態。【抽象觀察者介面】 抽象觀察者介面會定義觀察者都擁有的更新用介面，此介面是用來接收目標類別所發出的更新通知。 【觀察者類別】 觀察者類別含有一個（或多個）主題，並可以透過 update() 方法來更新主題的狀態。
特點 可以通過該模式，建立簡單地一對多關係 將【主題】與【觀察者】解耦和抽象 可以動態的對【主題】與【觀察者】進行調整與修改 UML Graphic classDiagramclass Subject~Interface~ {Observers list[]void attach()void detach()void notify()void getState()}Subject &lt;|-- Characterclass Observer~Interface~ {Subject* subjectvoid update()}Subject --&gt; ObserverObserver &lt;|-- Group內文 觀察者模式是一個蠻常見的設計模式，通常用於即時性的程式需求上，例如 GUI 介面、彈出式訊息、或者是 MVC 的應用程式&amp;hellip;等。在觀察者模式中，會有一個【主題】與一個（或多個）【觀察者】。如果用 RPG 來舉例的話，線上遊戲的「公會頻道」「隊與頻道」&amp;hellip;等訊息就可以用觀察者模式實作。我們可以想像一個情境：玩家 A 在加入公會 X 之前，如果公會的成員在「公會頻道」發出文字訊息的話，玩家 A 是不會收到任何訊息的，但在玩家 A 加入了 X 之後，如果公會中的其他成員在「公會頻道」丟出文字訊息的話，那麼 A 就會收到該訊息了。</description>
    </item>
    
    <item>
      <title>解釋器模式（Interpreter Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/interpreter_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/interpreter_pattern/</guid>
      <description>解釋器模式（Interpreter Pattern）#說明 ChatGPT：解釋器模式（Interpreter Pattern）是一種行為型設計模式，它主要用於「定義一種語言文法的表示」，並提供一個【解釋器】來解釋這種語言中的句子。該模式通常用於解決特定領域中的問題，例如解釋語言、數學表達式或查詢語句等。解釋器模式的主要組件包括：抽象表達式（Abstract Expression）、終端表達式（Terminal Expression）、非終端表達式（Non-terminal Expression）、上下文（Context）、和解釋器（Interpreter）。【抽象表達式】會定義一個抽象的介面，包含一個 interpret() 方法，這個方法會根據特定語言文法進行解釋。【終端表達式】實現了抽象表達式的 interpret() 方法，代表該語言中的終端符號，不能再分解成更小的元素。【非終端表達式】也同樣會實現【抽象表達式】的 interpret() 方法，用於組合多個終端表達式，形成複雜的語句。【上下文】包含要解釋的語句，通常由解釋器進行操作。【解釋器】則會根據語言文法對表達式進行解釋。 解釋器模式的工作流程如下：首先我們需要定義「語言文法」，並將其分解成【終端表達式】和【非終端表達式】。接下來，我們會創建對應的【表達式】類別，實現 interpret() 方法，根據語言文法進行解釋。然後，會構建一個語句的抽象語法樹（AST - Abstract Syntax Tree），將表達式組合成複雜的語句。再創建上下文，傳遞要解釋的語句。最後創建解釋器，根據語句的 AST 對其進行解釋，生成結果。
維基百科：在物件導向程式設計中，「解譯器模式」是一種行為型設計模式，用於指定「如何評估一種『語言』中的句子」。基本思想是為專門的電腦語言中的每個符號建立一個（或一些）類別，其中包含【終端類別】與【非終端類別】。該語言中，「句子」的語法樹是組合模式的實例，用於為客戶端「解釋」該句子。解譯器設計模式是 23 種著名的 GoF 設計模式之一，GoF 設計模式描述了如何解決反復出現的設計問題，以設計靈活且可重用的物件導向程式，即更容易實施、更容易變更、更容易測試和重用的對象。「解譯器設計模式可以解決哪些問題？」解釋器模式透過定義一種簡單語言的語法，讓程式可以簡單地「解釋」該語法中的不同語句。當某種問題經常一類似的結構發生時，我們可以考慮將其表示為一種新的、簡單的語言中的句子，以便【解譯器】可以通過解釋該語句來解決問題。例如：當需要指定許多不同或複雜的搜索表達式時。將它們直接硬編寫到類別中是不靈活的，因為它會使類別受限於特定的表達式，並且無法獨立於類別之外的新的表達式或更改現有的表達式。因此在這樣的情況下，透過新增一個【解釋器】，並將語句定義為各種【終端語句】與【非終端語句】會更為靈活與彈性。
特點 可以通過「語言解釋」將複雜的語句轉變為一系列的程式邏輯 可以解耦【語法】和【程式執行】，使其更為彈性 可以自由組合不同的語句，形成各種多樣語靈活的表示方法 UML Graphic classDiagramclass Character {void spellcast()}class Expression~Interface~ {interpret();}Expression &lt;|-- FixedExpressionExpression &lt;|-- GodExpressionExpression &lt;|-- StateExpression#內文 從體感上來看，個人認為解釋器模式是 23 種常見的設計模式裡最難讓人搞懂得一個模式。有學過「編譯器」這門課的人對於解釋器在做的工作應該會比較能夠有感：整體而言，解釋器模式的工作就是在「拆分」與「分析」一段句子是否符合邏輯？和他想要表達什麼樣的意思。讓我們用一個 RPG 遊戲來舉例：假設在一個 RPG 遊戲中，我們打算實踐一個「咒文詠唱系統」。其功能是讓玩家（一個法師）在進行戰鬥的時候，可以透過『輸入一串咒文』來達成「強力施法」這件事情。並且在這樣的情況下，我們定義了一個「傷害反彈」的詠唱詞：「誠惶誠恐呼喚日不見神，先祖之產土神。領受已久之山河，誠惶誠恐，僅此奉還於。(註１)」如果成功在某一特定的秒數內詠唱該詞句，便可以增加玩家的防禦力。在不使用「解釋器模式」的狀況下：可能會撰寫出類似下面的程式：
class Character { public: string name; int defense; public: Player(string name) : name(name) : defense(20) {} void spellCasting(string prayer) { if (prayer == &amp;#34;誠惶誠恐呼喚日不見神，先祖之產土神。領受已久之山河，誠惶誠恐，僅此奉還於爾&amp;#34;) { defense += 10; cout &amp;lt;&amp;lt; &amp;#34;defense += 10&amp;#34; &amp;lt;&amp;lt; endl; } else { cout &amp;lt;&amp;lt; &amp;#34;.</description>
    </item>
    
    <item>
      <title>訪問者模式（Visitor Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/visitor_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/visitor_pattern/</guid>
      <description>訪問者模式（Visitor Pattern）#說明 ChatGPT：訪問者模式（Visitor Pattern）是一種行為型設計模式，它用於將算法操作從物件的結構中分離出來。訪問者模式允許「在不修改已有的物件結構」的情況下，定義新的操作。這種模式主要用於對一組相關的物件進行某種操作，而不必修改這些物件的類別。在訪問者模式中，有兩個主要角色：分別是訪問者（Visitor）和元素（Element）。【訪問者】是一個接口或者一個抽象類別，它定義了對物件結構中，操作每個元素的方法。具體的【訪問者】類別將實現這些方法，以定義特定的操作。【元素】則是一個接口或抽象類，它定義了接受訪問者的方法。每個元素類別將實現這個方法，以便在【訪問者】來訪時，調用【訪問者】的相應方法。訪問者模式的核心思想是：「當需要對物件結構中的元素進行不同的操作時，不需要修改元素類別，而是定義新的訪問者類別來實現這些操作。」這樣可以實現操作的「新增」而不改變元素結構，同時也不會影響其他的操作。訪問者模式適用於以下情況：「當一個物件結構包含多種類型的元素，且需要對這些元素進行不同的操作時。」「當物件想要新增新的操作，同時也希望不影響現有元素類別時。」與「當對象結構中的元素結構相對穩定，但其操作算法可能會經常更改時。」總的來說，訪問者模式可以幫助我們實現對物件結構的不同元素進行多種操作，同時保持類別的相對穩定，並提高了系統的可擴展性和可維護性。
維基百科：訪問者模式（Visitor Pattern）是一種軟體設計模式，用於將演算法與物件結構分離。由於這種分離，使用者可以在不修改物件結構的情況下，向現有的物件結構添加新的操作。這是在 &amp;ldquo;物件導向程式&amp;rdquo; 和 &amp;ldquo;軟體工程&amp;rdquo; 中，遵循開放封閉原則的一種方法。基本上，訪問者允許在一個類族中添加新的虛擬函數，而無需修改這些類。接著，再創建一個訪問者類，其中實現了所有適當的虛擬函數的實例化。訪問者接收實例引用作為輸入，並通過雙重派發（double dispatch）來實現目標。訪問者模式能夠輕鬆地分支處理物件的類型，並在定義了訪問者尚未處理的新物件類型時生成編譯器錯誤。此外，訪問者設計模式也是 23 種著名的四人幫設計模式之一，它（四人幫設計模式）描述了如何解決重複性的設計問題，以設計靈活且可重用的面向對象軟體，即易於實現、更改、測試和重用的物件。「什麼問題可以通過訪問者設計模式解決？」：如果想要在不更改類的情況下，為物件結構的（某些）類別定義新操作，可以使用此類別。「訪問者設計模式描述了什麼解決方案？」訪問者模式定義一個單獨的【訪問者】物件，該物件實現對物件結構的元素執行的操作。客戶端可以遍歷物件結構，並在元素上調用訪問者進行元素操作：意即將操作將請求分派（委派）給【被接受的訪問者物件】。然後，訪問者物件對元素執行操作（&amp;ldquo;訪問元素&amp;rdquo;）。這樣一來，可以通過添加新的訪問者物件獨立於物件結構的類別來創建新的操作。
特點 可以分離【元素】與【操作】的高度耦和 新增【操作】不會影響到原【元素】的程式碼 增加程式的彈性與靈活性 UML Graphic classDiagramclass Character~Interface~ {void accept(Visitor* visitor);}note &#34;void accept(Visitor* visitor) {\n　visitor.visit(this);\n}&#34;Character &lt;|-- RoleCharacter &lt;|-- MonsterRole &lt;|-- WarriorRole &lt;|-- BowmanRole &lt;|-- MagicianRole &lt;|-- ThiefMonster &lt;|-- ZombieMonster &lt;|-- SlimeMonster &lt;|-- SkeletonclassDiagramclass Visitor~Interface~ {void visit(Role* role);void visit(Monster* monster);}Visitor &lt;|-- PhysicalAttackVisitorVisitor &lt;|-- MagicAttackVisitorVisitor &lt;|-- EscapeVisitor內文 訪問者模式主要要解決的問題是「在不更動原始物件的前提下，對原始物件進行一些新的功能擴充」也就是在不影響原始物件的前提下，進行物件的方法擴充。我們用一個 RPG 遊戲的戰鬥過程來做舉例：假設在一個 RPG 的回合制戰鬥中，【角色】總共可以對【怪物】進行兩種不同的攻擊方式，分別是「普通攻擊（物理攻及）」和「魔法攻擊」這兩種。在不使用訪問者模式的程式撰寫情境下，我們可能會寫出類似於下面的程式碼：</description>
    </item>
    
    <item>
      <title>責任鏈模式（Chain of Responsibility Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/chain_of_responsibility_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/chain_of_responsibility_pattern/</guid>
      <description>責任鏈模式（Chain of Responsibility Pattern）#說明 ChatGPT：責任鏈模式（Chain of Responsibility Pattern）是一種行為型設計模式，它允許多個物件依序處理請求，這些物件會被連成一條「鏈」（chain），每個物件都有可能處理請求，如果某個物件無法處理，則將請求傳遞給下一個物件來處理，直到有物件處理成功或者整個鏈都無法處理為止，責任鏈模式允許程式在運行時不確定哪個物件將處理這個請求。在責任鏈模式中，通常每個處理器（Handler）都會有一個指向下一個處理器的指標，從而形成了一條鏈。當一個請求進入這個鏈時，從第一個處理器開始依序檢查是否可以處理該請求？如果可以，則處理器會進行處理，但如果不行，則傳遞給下一個處理器，依此類推&amp;hellip;，直到找到能夠處理請求的處理器，或者整個鏈都無法處理為止。責任鏈模式可以將請求的發送者和接收者解耦，讓不同的處理器對請求進行獨立的處理，增加了系統的靈活性和可擴展性。同時也支持在運行時動態地組織「鏈」，方便新增或者移除處理器。責任鏈模式的主要角色有：處理器（Handler）：定義一個處理請求的接口，並且持有下一個處理器的指標，以便將請求傳遞給下一個處理器。具體處理器（Concrete Handler）：具體處理器會實現具體的【處理器】接口，並且能夠處理特定類型的請求，如果無法處理則將請求傳遞給下一個【具體處理器】。請求（Request）：定義需要處理的請求。在責任鏈模式中，【請求】將依序經過每個具體處理器，直到找到能夠處理的具體處理器為止。責任鏈模式可以達到動態組織處理器的目的，也提高了系統的靈活性和可維護性。
維基百科：在物件導向程式設計中，責任鏈模式（Chain of Responsibility Pattern）是一種行為型設計模式，該模式由【命令對象】和一系列的【處理對象】所組成。每個【處理對象】都包含（與定義）它可以處理的命令類型；如果【命令】無法被該【處理對象】執行，【命令】則會被傳遞到責任鏈中的下一個【處理對象】。此外，該模式也存在一種「將新的【處理對象】添加到該鏈末尾」的機制或方法，可以對鏈做一些刪除或擴展。此外，對於責任鏈模型的變體中，一些處理程序可以充當調度程序，向多個方向發送命令，形成一顆責任樹。在某些狀況下，這可能會產生遞歸的情況：【處理對象】使用【命令】調用更高層的【處理對象】，試圖解決問題的較小部分這種模式提倡鬆散耦合的思想。責任鏈模式（Chain of Responsibility Pattern）在結構上與裝飾器模式（Decorator Pattern）幾乎相同，不同之處在於：對於裝飾器來說，所有的類別都會處理請求；可對於責任鏈來說，只有鏈中的一個類別（也就是【處理對象】）會處理請求。
特點 aaa UML Graphic classDiagramclass Quest {void execute();}Quest &lt;|-- HuntingQuestQuest &lt;|-- GatheringQuestQuest &lt;|-- DungeonQuestclassDiagramclass Handler {Handler* next;void setNext(Handler* handeler);}Handler &lt;|-- MondayHandlerHandler &lt;|-- TuesdayHandlerHandler &lt;|-- WednesdayHandler內文 『責任鏈模式』可以用來解決客戶端「類別依賴」的問題。在一個普通的責任鏈模式中，總共會有是處理器（Handler）與客戶端（Client）兩種不同的角色，如果用 RPG 遊戲來做舉例的話，我們假設【玩家】可以依照不同的「星期」來進行不同的【活動任務】，分別是星期一的【魔物狩獵】（HuntingQuest）、星期二的【藥材採集】（GatheringQuest）、星期三的【地下城探險】（DungeonQuest）、星期四的【跑腿送信】（CourierQuest）、與星期五的【地下城探險】（DungeonQuest）&amp;hellip;，在不使用『責任鏈模式』的狀況下，程式可能會撰寫成以下的樣子：
class DailyQuest { public: virtual void execute() = 0; }; class HuntingQuest : public DailyQuest { public: void execute() override { // Monster hunting .</description>
    </item>
    
    <item>
      <title>迭代器模式（Iterator Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/iterator_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/iterator_pattern/</guid>
      <description>迭代器模式（Iterator Pattern）#說明 ChatGPT：迭代器模式（Iterator Pattern）是一種行為型設計模式，它主要用於提供一種訪問集合元素（如列表、數組、樹等）的方法，而不需要暴露該集合的內部表示。通過迭代器模式，我們可以透過統一的接口來遍歷（iterate()）集合中的元素，無需關心底層的數據結構。「迭代器模式」的主要目標是「分離集合的『遍歷行為』與『程式實現』」。這樣可以提供更好的解耦和靈活性。該模式通常包含以下主要元素：【迭代器】（Iterator）：用於定義「訪問」和「遍歷」集合元素的介面。迭代器通常包含方法如 next()（返回下一個元素）、hasNext()（檢查是否還有下一個元素）等。【具體迭代器】（Concrete Iterator）：具體迭代器實現了【迭代器】的接口，並提供了對具體集合的元素遍歷實現。不同的集合可能需要不同的具體迭代器。【集合】（Collection）： 定義了管理元素的方法，如添加、刪除元素&amp;hellip;等。可以是列表、數組、樹&amp;hellip;等。【具體集合】（Concrete Collection）：實現了【集合】的接口，提供了實際的元素管理方式。不同的具體集合可能有不同的存儲結構。通過使用迭代器模式，客戶端的程式可以僅通過【迭代器】來訪問集合的元素，而無需關心程式的底層細節。這樣可以使程式更具可讀性、可維護性，並且支持在不改變客戶端程式的情況下更改集合的實現方式。
維基百科：在物件導向程式設計中，「迭代器模式」是一種設計模式，其中使用【迭代器】來遍歷容器，並訪問容器的逐個元素。迭代器模式嘗試將「遍歷的演算法」與「容器」解耦；「迭代器模式能解決哪些問題？」該模式可以讓聚合物件（列表、數組&amp;hellip;等）的元素，在不暴露其表示資料結構的情況下，進行訪問和遍歷。同時也可以為聚合物件定義新的遍歷操作，而不改變其介面。在一般情況下，直接再聚合介面中定義「訪問」和「遍歷」操作是不靈活的，因為這樣的程式撰寫方式會使得聚合受限於特定的訪問和遍歷操作，且無法在不更改聚合介面的前提下添加新操作。「迭代器模式如何解決此問題方案？」迭代器模式會定義一個獨立的【迭代器】物件，並封裝「訪問」和「遍歷」的方法，讓聚合物件各自繼承並實例。客戶端使用可以直接使用【迭代器】來訪問方法和遍歷方法來檢視聚合物件，而不需要了解其物件內真實的資料結構。不同的迭代器可以以不同的方式訪問和遍歷聚合。可以通過定義新的迭代器來獨立地定義新的訪問和遍歷操作。
特點 分離「集合」本身的資料結構與「迭代」的程式邏輯 可以隱藏集合的資料結構，使客戶端不須依賴特定的程式操作 提供統一的遍歷程式，提高程式的可重用性 UML Graphic classDiagramclass Iterator {bool hasNext();void next();}Iterator &lt;|-- CharacterTeamIteratorIterator &lt;|-- MonsterTeamIteratorclass CharacterTeam {Iterator* iteratorCharacter teammate[]}class MonsterTeam {Iterator* iteratorMonsterNode head}CharacterTeam &lt;|-- Characterclass MonsterNode {Monster* monsterMonsterNode* next}MonsterTeam --&gt; MonsterNodeMonsterNode --&gt; Monster#內文 迭代器模式是個相對簡單的設計模式。該模式的用途是「讓所有不同的容器，都可以有一個統一的『遍歷』方法。」通常來說，一個迭代器模式裡面總共會包含著四種類別：【迭代器介面】【具體迭代器】【集合介面】和【具體集合】。讓我們用一個 RPG 遊戲來做舉例：假設再一個 RPG 的戰鬥中，總共分為「主角方」和「怪物方」兩方的陣容。在程式的撰寫上分別由工程師 A 和工程師 B 進行工作。工程師 A 在主角（Character）的地方，新增了一個 CharacterTeam 的類別，用以紀錄主角的隊伍成員，以及它們各自的資訊；工程師 B 則同樣使用了類似的做法，在怪物方（Monster）新增了一個 MonsterTeam 類別，同樣也是記錄怪物的編隊與各自的訊息，如下述的程式所示：</description>
    </item>
    
    <item>
      <title>適配器模式（Adapter Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/adapter_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/adapter_pattern/</guid>
      <description>適配器模式（Adapter Pattern）#說明 ChatGPT：適配器模式（Adapter Pattern）是一種軟體設計模式，屬於結構型模式的一種。它主要用於「將一個類別的接口」轉換成另一個「客戶端所期望的接口」，從而使原本不兼容的類別能夠一起工作。在軟體設計中，有時候因為歷史原因、不同的介面設計或第三方庫的使用，可能會出現一些類別之間接口不匹配的情況。這時候就可以使用適配器模式來解決這種問題，而無需修改原有的類別。適配器模式的核心概念是引入一個適配器（Adapter）類別，這個類別負責將不兼容的接口轉換成目標接口，使得客戶端可以通過適配器使用原本不兼容的類別。適配器可分為類別適配器和物件適配器兩種：其中類別適配器使用「繼承」的方式來進行接口轉換，物件適配器則使用「組合」的方式來進行接口轉換，通過調用原始類別的方法來實現目標接口的方法。適配器模式的優點是能夠提高程式碼的重用性和靈活性，同時也能夠保護現有程式碼，無需修改原始類別。
維基百科：在設計模式中，適配器模式（Adapter Pattern）有時候也稱包裝模式（Wrapper Pattern）。適配器模式用來將一個類別的介面轉接成使用者所期待的另一種介面。一個適配器可以讓「因程式不相容而不能在一起工作的類別」能在一起工作，其中的做法是將類別自己的介面包裹在一個已存在的類別中。適配器模式的結構通常分為兩種類型：「物件型適配器」（在適配器本身中包含一個呼叫對象的物件）和「類別型適配器」（新增一個適配器類別，繼承自原類別，並用擴增的方式使程式可以運作）。適配器模式（Adapter Pattern）是 23 個著名的設計模式之一，它通常用以解決以下的幾種問題：如何將以棄用（或很少使用）的舊型接口更新為一個新形態的程式接口、如何將原本不兼容的兩種接口相互兼容、如何為某個（或某些）類別提供替代接口、和如何將舊有的接口設計為客戶所要求的新型接口。
特點 a bb ccccc UML Graphic classDiagramclass MonsterAttackAdapter {void attack();}class Zombie {void bite();}class ZombieAttackAdapter {Zombie* zombievoid attack();}ZombieAttackAdapter --&gt; Zombieclass Goblin {void knock();}Monster &lt;|-- ZombieMonster &lt;|-- Goblinclass GoblinAttackAdapter {Goblin* goblinvoid attack();}GoblinAttackAdapter --&gt; GoblinMonsterAttackAdapter &lt;|-- ZombieAttackAdapterMonsterAttackAdapter &lt;|-- GoblinAttackAdapterclassDiagramclass CharacterAttackAdapter {void attack();}class Warrior {void chop();}class WarriorAttackAdapter {Warrior* warrior;void attack;}WarriorAttackAdapter --&gt; WarriorCharacter &lt;|-- Warriorclass Magician {void magic_attack();}class MagicianAttackAdapter {Magician* magician;void attack();}MagicianAttackAdapter --&gt; MagicianCharacter &lt;|-- MagicianCharacterAttackAdapter &lt;|-- WarriorAttackAdapterCharacterAttackAdapter &lt;|-- MagicianAttackAdapter內文 如果要用一句話來作總結的話，適配器模式的用途就是用於「將兩組原本互不兼容的程式可以相互兼容」。我們用 RPG 遊戲來舉個例子：假設我們正在製作一個簡單 RPG 遊戲，在這個 RPG 遊戲中，我們將【戰鬥】的環節設計在一個 Battle 類別的靜態方法 battle() 中，其中 battle() 方法帶有兩個參數，分別是角色物件 Character 和怪物物件 Monster，如果用「主角與魔王要進行最後的決戰」作為例子，程式大致上會像是下面的這個樣子：</description>
    </item>
    
    <item>
      <title>Without ToC</title>
      <link>https://fonu195713.github.io/_docs/example/table-of-contents/without-toc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/table-of-contents/without-toc/</guid>
      <description>At me ipso nepotibus nunc celebratior genus#Tanto oblite#Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.
Quam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque.</description>
    </item>
    
    <item>
      <title>介面隔離原則（Interface Segregation Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/interface_segregation_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/interface_segregation_principle/</guid>
      <description>介面隔離原則（Interface Segregation Principle）#ChatGPT 的說明 介面隔離原則（ISP - Interface Segregation Principle）是 SOLID 原則中的一個，SOLID 是一個首字母縮略詞，代表著五個不同的設計原則：單一職責原則（Single Responsibility Principle，SRP）、開放封閉原則（Open/Closed Principle，OCP）、里氏替換原則（Liskov Substitution Principle，LSP）、介面隔離原則（Interface Segregation Principle，ISP）、依賴反轉原則（Dependency Inversion Principle，DIP）。介面隔離原則（ISP）主要關注在設計【介面】（interface）時的合理性和適切性。ISP 的核心理念是「【客戶端】不該被迫依賴它不需要的【介面】」，這意味著【介面】應該要被分割成小的、細微的、特定的部分，以便客戶端在依賴【介面】時，不會包含到那些他們不需要的方法。更具體地說，ISP 強調以下兩個信條：「介面應該小而精簡」以及「用多個特定介面替換一個通用介面」。
【介面應該小而精簡】 在軟體開發中（特別是物件導向程式設計），設計一個適宜的【介面】是非常重要的。「介面應該小而精簡」是指一個介面應該只包含客戶端所需的要方法，不應該包含多餘的、繁冗的、不必要的方法。這條訊息鼓勵程式設計師在設計面時，將「大的、通用」的介面分割成「小的、特定的」的部分，從而使【客戶端】只需要實現（或使用）他們所需要的方法，以助於減少依賴性、提高程式的可讀性，同時也確保每個【介面】的方法都具有清晰的用途和職責。
接下來我們使用一個例子來說明「介面應該小而精簡」的想法：想像一個 RPG（角色扮演遊戲）遊戲中，我們需要設計不同【角色】的能力介面。這些角色可以是【戰士】【法師】【弓箭手】&amp;hellip;等。每個【角色】都有一些共同的行動，比如攻擊（attack）、防禦（defend）等，但也有些角色特有的行動，例如法師的魔法攻擊（magicAttack）。一個不遵循「介面應該小而精簡」信條的設計可能會如下：
class Character { public: virtual void attack() = 0; virtual void defend() = 0; virtual void magicAttack() = 0; }; 在這種情況下，即使某些角色不具備魔法攻擊能力（比如戰士），它們仍然需要實現 magicAttack 方法，這對於這些角色來說是多餘的。但如果我們有遵循「介面應該小而精簡」的原則，我們便可以將原本的程式，改成下面這樣的設計：
class Character { public: virtual void attack() = 0; virtual void defend() = 0; }; class Mage : public Character { public: void attack() override {} void defend() override {} public: void magicAttack() {} }; 這樣的設計遵循了「介面應該小而精簡」的信條，因為每個【角色】都只需要實現他們所需的行動，而不需要實現多餘的方法。比如說：【戰士】角色在這樣的設計情況下，只需要實現 attack() 方法和 defend() 方法，而不需要去實現魔法攻擊相關的方法。而【法師】除了 attack() 方法和 defend() 方法之外，因為還擁有魔法攻擊相關的方法，因此多了一個 magicAttack() 的相關方法。</description>
    </item>
    
    <item>
      <title>依賴反轉原則（Dependency Inversion Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/dependency_inversion_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/dependency_inversion_principle/</guid>
      <description>依賴反轉原則（Dependency Inversion Principle）#ChatGPT 的說明 依賴反轉原則（Dependency Inversion Principle，簡稱DIP）眾多設計原則中的一個概念，它通過重新思考軟體設計中的「依賴」關係，提供了一種更具靈活性、擴展性、與可維護性的方式來組織程式碼。這個原則的核心思想在於「改變我們對依賴的看法」，將依賴關係的方向進行反轉，以減少耦合，增加彈性，並使系統更容易擴展和維護。在傳統的軟體設計中，&amp;ldquo;較低層級的模組&amp;rdquo; 通常依賴於 &amp;ldquo;較高層級的模組&amp;rdquo;。例如：如果你正在設計一個 RPG 遊戲，【技能】（低層模組）可能會依賴於【角色】（高層模組），因為【技能】需要知道它是被哪種類型的【角色】所使用。這種設計方式可能導致 &amp;ldquo;高層模組&amp;rdquo; 的變化影響到 &amp;ldquo;低層模組&amp;rdquo;，增加了系統的脆弱性和維護難度，並限制了系統的可擴展性。
DIP的關鍵思想是：我們應.該.將.依.賴.關.係.的.方.向.反.過.來，使 &amp;ldquo;高層模組&amp;rdquo; 依賴於「&amp;ldquo;低層模組&amp;rdquo; 的抽象」，而不是依賴具體的低層細節。換句話說，我們要將控制權交給抽象類別，讓 &amp;ldquo;高層模組&amp;quot;依賴於【介面】【抽象類別】或其他抽象化的類型。這樣一來，可以帶來幾個好處是：首先是【減少耦合】：通過讓模組依賴於抽象，&amp;ldquo;高層模組&amp;rdquo; 和 &amp;ldquo;低層模組&amp;rdquo; 之間的耦合性便會降低。這意味著變更低層模組的實現不會影響高層模組的穩定性。
此外，這樣做也可以【提升程式的可擴展性】：因為高層模組只依賴於抽象被別，所以低層模組可以更容易地被替換、被修改、或延展成新的低層類別，從而實現系統的擴展。此外，這樣的撰寫方式也有助於提升程式的【可測試性】：由於高層模組可以依賴於虛擬的、可測試的抽象，這將使得測試高層模組的難度變得更加容易。使高層依賴低層的抽象也可以【減少程式的細節】：因為通過依賴【抽象類別】或【介面】來實現功能，高層模組不再需要知道低層模組的具體實現細節，這有助於提高程式的可讀性和簡潔性。
以下我們將透過一個 RPG 遊戲的情境，模擬「『低層模組』依賴『高層模組』」和「『高層模組』依賴『低層模組的抽象』」兩種程式的撰寫方式，在這個情境之下，低層模組指的是【技能】類別，而【高層】模組則是可以使用【技能】類別的其餘類別，也就是【角色】類別。首先，我們將低層模組【技能】依賴於高層模組【角色】。我們定義了【技能】的不同實現，而它們會根據【角色】的特性來調整技能的效果。
class Character; class Skill { public: void fireBall(Character&amp;amp; character) { // only the magician can use this skill if(character.type == &amp;#34;Magician&amp;#34;) cout &amp;lt;&amp;lt; character.name &amp;lt;&amp;lt; &amp;#34; uses the skill &amp;#39;fire ball&amp;#39;.&amp;#34; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; character.name &amp;lt;&amp;lt; &amp;#34; wanted to try something, but there was no response.</description>
    </item>
    
    <item>
      <title>合成/聚合複用原則（Composite/Aggregate Reuse Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/</guid>
      <description>合成/聚合複用原則（Composite/Aggregate Reuse Principle）#ChatGPT 的說明 合成/聚合複用原則（CARP）是一個軟體設計原則，旨在引導開發人員在設計類別之間的關係時，能更多地考慮「合成」和「聚合」關係，而不是過度依賴「繼承」。這個原則強調使用合成（Composition）和聚合（Aggregation）的關係來實現複用性和模組化，以增加程式碼的靈活性、可讀性和可維護性。
【合成關係】（Composition）：合成關係表示「一個物件包含其他的物件作為其一部分，這些部分物件的生命週期也與包含物件相關聯。」如果該物件被銷毀，其部分物件也會被銷毀。合成關係建立了一種高強度的耦合，表示「部分物件」與「整體物件」之間的關係非常緊密，此外，部分物件不能獨立存在。例如在 RPG 遊戲中，一個【角色】Character 可能會包含【武器】Weapon、【盔甲】Armor 與【技能】Skill 作為其【角色】的一部分，這些部分物件隨著會【角色】的存在而存在，同時也會因為【角色】的消失而消失。
【聚合關係】（Aggregation）：聚合關係表示一個「物件包含其他物件作為其部分，但這些部分物件的生命週期與包含物件無關。」即使完整物件被銷毀，其餘的部分物件仍然可以獨立存在。聚合建立了一種較為孱弱的鬆耦合，表示部分物件具有一定程度的獨立性。例如在一個 RPG 遊戲中，一個【公會】 Group 可以聚合多個【角色】Character 作為其部分，但如果【公會】消失了，【角色】仍然可以在公會之外繼續存在。
「高層模組」應該儘量避免直接依賴於「低層模組」，而是通過合成或聚合的方式來使用低層模組。這種設計可以使撰寫出來的程式碼更富有彈性，也能相較容易地替換（或添加）新的低層模組。同時，低層模組也應該避免強依賴於高層模組，以確保模組之間的耦合度降低。在 RPG 遊戲的情境中，CARP 原則還可以這樣應用：假設遊戲中的【角色】是高層模組，而【裝備】是低層模組。【角色】可以包含多個【裝備】，這些【裝備】可以通過聚合關係與【角色】相關聯。同時，裝備也可以包含多個屬性（例如攻擊力、防禦力），這些屬性通過合成關係與【裝備】相關聯。
class Attribute { private: string name; int value; public: Attribute(string name, int value) : name(name), value(value) {} public: void display() { cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;: &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; endl; } }; class Equipment { private: string name; vector&amp;lt;Attribute*&amp;gt; attributes; public: Equipment(string name) : name(name) {} public: void addAttribute(Attribute* attribute) { attributes.</description>
    </item>
    
    <item>
      <title>單一職責原則（Single Responsibility Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/single_responsibility_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/single_responsibility_principle/</guid>
      <description>單一職責原則（Single Responsibility Principle）#ChatGPT 的說明 單一職責原則（Single Responsibility Principle，簡稱 SRP）是物件導向程式設計中的一個基本原則，它強調「每個類別（或方法）應該都只有一個職責」，意即「只有『一個』理由可以導致該類別或方法產生」。換句話說，一個類別或方法應該只具有一個主要的功能或職責，而不應該承擔過多的功能。這有助於使程式更容易理解、更容易維護和更容易擴展。SRP 的核心思想是「將不同的功能隔離到不同的位置」，從而實現高內聚（High Cohesion）和低耦合（Low Coupling）。這樣做可以使程式更加模組化，且當需求發生變化時，只需要負責該變化的部分，而不會影響到其他的程式與功能。
違反 SRP 可能導致以下問題：首先是「複雜性增加」： 當一個類別承擔太多的職責時，會導致該類別的程式變得複雜、難以理解、和不易維護。再來，程式的「耦合程度也會變高」：將不同職責的程式混合在一起，會導致類別與類別的依賴加重，進而增加程式的耦合程度，這將使得當類別需要發生改變時，可能會連帶需要修改到其餘的類別，使影響範圍擴大。同時，違反單一職責也會使「程式的重用性下降」：與遵守單一職責的類別相比，具有當類別具有多重職責時，通常難以重用，因為其功能過於特定。此外，也可能發生多了類別具有相同或近似功能的重複性程式。最後，違反 SPR 的程式也會「增加程式變更的風險」： 當一個職責的變化，需要修改類別中的多個部分時，容易會發生撰寫的錯誤，進而引發程式的崩潰，此外也需要考慮是否存在「其他類別也擁有相同功能，因此需要一並修改」的可能性。簡而言之，單一職責原則有助於保持程式的清晰、可維護性和可擴展性，通過確保一個類別只有一個主要職責，可以使系統遍的更加靈活和易於改變。
以下我們使用一個簡單的情境來解釋單一職責原則，我們假設在一個 RPG 遊戲中，角色可能會有「回復」「受到攻擊」與「升級」三種可能會發生的變化，如果我們使用 SRP 的程式原則，我們就會將這三種變化區別書寫成 takeDamage(), heal(), 和 levelUp() 三種方法。但如果不使用 SRP 的撰寫原則，程式就會全部擠在 update() 裡面，使得程式變得繁冗與複雜：
// Adhering to SRP (Single Responsibility Principle) // Adhering to SRP (Single Responsibility Principle) // Adhering to SRP (Single Responsibility Principle) class Character { private: string name; int health; int level; public: Character(string name) : name(name), health(100), level(1) {} public: void takeDamage(int amount) { health -= amount; cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; takes &amp;#34; &amp;lt;&amp;lt; amount &amp;lt;&amp;lt; &amp;#34; damage.</description>
    </item>
    
    <item>
      <title>最少知識原則（Least Knowledge Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/least_knowledge_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/least_knowledge_principle/</guid>
      <description>最少知識原則（Least Knowledge Principle）#ChatGPT 的說明 最少知識原則（Principle of Least Knowledge，縮寫為 LKP），又稱作迪米特原則（Law of Demeter，縮寫為LoD），是一個軟體設計原則，該原則旨在「降低系統中各個組件之間的耦合度，從而提高系統的可讀性、可維護性和可擴展性」。最少知識原則的核心思想是「只與你直接的朋友通信」，意即「一個對象應該只認識它的直接朋友，不應該直接認識其他類別的內部結構。」這個原則強調了組件與組件之間的鬆耦合，避免了不必要的依賴關係，從而降低了系統的複雜度。最少知識原則可以透過以下幾個關鍵點來理解：
只與直接朋友通信 在可允許的情況下，一個類別的方法，應該只可以調用以下的方法：「這個類別本身的方法」「被當作參數給傳遞進來的物件的方法」和「在該方法內，被創建（或被實例）的物件的方法。」一個類別的方法應該儘量只依賴於自己的內部實現，而不是去調用其他類別的內部方法。這樣可以確保當一個類別的實現變化時，其他類別不會因此受到影響。這也有助於隔離變化，使系統更加穩定
此外「該方法的參數」可以被視為該方法的直接朋友。如果一個方法需要訪問另一個物件的方法，最好是將該物件作為參數傳遞給方法，而不是在方法內部直接訪問。這樣可以明確地傳遞相關資訊，並減少方法之間的隱含耦合；而當一個類別創建了（或實例化）另一個物件時，通常只應該調用該物件的公開介面方法（因為直接訪問該物件的內部方法，可能會導致類別之間的耦合增加）。透過只調用公開介面方法，可以保持類別之間的解耦。
避免深層次的依賴 【類別】不應該調用【其他類別】的內部方法，特別是深層次的內部方法。因為這樣的依賴關係會使系統的耦合度增加，導致代碼難以維護。例如在以下的範例中，我們有一個名為 Ability 的基礎類別，並有兩個子類別（Fireball 和 Icebolt），它們繼承自 Ability。然後我們有一個 Character 類別，它包含一個 Ability* 的成員，並有一個 performAbility() 方法用於執行能力。
進一步地 Mage 類別繼承自 Character ，並且在 Mage 的構造函數中創建了一個 Fireball 的能力。最後，我們有一個 Game 類別，該類別創建了一個 Mage 的實例，然後在 play() 方法中執行了法師的能力。這個範例中， Game 的 play() 方法就存在深層次的依賴關係。（Game &amp;gt; Mage &amp;gt; Ability &amp;gt; perform()）
class Ability { public: virtual void perform() { cout &amp;lt;&amp;lt; &amp;#34;Performing basic ability!&amp;#34; &amp;lt;&amp;lt; endl; } }; class Fireball : public Ability { public: void perform() override { cout &amp;lt;&amp;lt; &amp;#34;Casting fireball!</description>
    </item>
    
    <item>
      <title>里式替換原則（Liskov Substitution Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/liskov_substitution_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/liskov_substitution_principle/</guid>
      <description>里式替換原則（Liskov Substitution Principle）#ChatGPT 的說明 里式替換原則（Liskov Substitution Principle，簡稱 LSP）是物件導向程式設計中的一個重要原則，由 [Barbara Liskov][1] 在 1987 年的一個會議 &amp;ldquo;[Data abstraction and hierarchy][2]&amp;rdquo; 所提出。該原則強調：「子類別應該能夠替換其父類別，並且同時保持原有程式的正確性。」里式替換原則告訴我們：一個衍生類別（也就是子類別）必須能夠完全替換其基底類別（父類別）而不影響原有的程序行為。換句話說，子類別應該具有與父類別相同的行為和參數，這樣才能保證其程式的正確性和穩定性。LSP 主要包含了的 2 個關鍵點：
首先【子類別必須完全擁有父類別的屬性或行為】：子類別需要做的事情，應該是「重寫」或「擴展」父類別的方法，而不是修改其行為，例如當一個名為【角色】的類別擁有攻擊 attack()、防禦 defence()、和魔法攻擊 magicAttack() 三種方法時，所以繼承該【角色】類別的子類別，都必須完全擁有這些行為，這意味著不能完全執行這三項行為的類別不可以繼承【角色】（例如【戰士】不會使用魔法攻擊、【僧侶】沒有防禦手段&amp;hellip;等）。但我們可以透過「擴增」類別的行為，讓子類別保持與父類別一致的完整性。例如先移除【角色】中的 magicAttack(), 方法，再將【能使用魔法攻擊的角色】與【不能使用魔法攻擊的角色】分別繼承於【角色】，並將 magicAttack() 方法定義於【能使用魔法攻擊的角色】當中。這樣一來，【戰士】別即可以透過繼承【不能使用魔法攻擊的角色】成為【角色】的一員。
接下來：【子類別應該完全遵循由父類所設計的邏輯】，意即保證父類別的行為在子類別中也能夠正確執行。子類不應該修改父類別所設計的邏輯、制定的規則、前提條件、或者是後置條件，也不應該引入新的前提條件或後置條件。例如：在名為【角色】的父類別中，如果有定義一個 defence() 方法，其實作的內容為「利用手中的武器進行防禦。」那麼所有繼承於【角色】的類別，即便是改寫或擴增 defence() 方法，也不可以違背「用武器防禦」這項原則。（這意味著不可以改寫【盜賊】的 defence() 為「透過閃躲防禦」）。透過保持規則的一致性，可以避免程式的不可預測性，例如原本【戰鬥】的攻防計算為「武器攻擊力 - 武器防禦力」，但因為我們將【盜賊】的防禦修改為「閃躲」，並沒有所謂的「武器防禦力」，在這樣的情況下可能就會造成不可預知的錯誤。
以下我們使用一個簡單的情境來解釋里式替換原則和非里式替換原則的程式邏輯：我們需要製作一個 RPG 遊戲，其中有著一個【角色】類別，和【戰士】【法師】【盜賊】三種子類別。【角色】有攻擊（attack()） 和 防禦（defence()）兩種方法，有些角色也可以嘗試進行魔法攻擊（magicAttack()），此外，防禦（defence()）的程式邏輯為「受到的傷害 = 武器的攻擊力 - 自身的防禦力」。程式撰寫邏輯如下：
// Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) class Character { protected: int attack; int defense; public: Character(int attack, int defense) : attack(attack), defense(defense) {} virtual void attack() { cout &amp;lt;&amp;lt; &amp;#34;Character attacks with attack power: &amp;#34; &amp;lt;&amp;lt; attack &amp;lt;&amp;lt; endl; } virtual void defense(int received_atk) { int received_dmg = received_atk - defense; received_dmg = (received_dmg &amp;lt; 0)?</description>
    </item>
    
    <item>
      <title>開放封閉原則（Open Closed Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/open_closed_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/open_closed_principle/</guid>
      <description>開放封閉原則（Open Closed Principle）#ChatGPT 的說明 開放封閉原則（Open Closed Principle，簡稱 OCP）是物件導向程式設計中的一個重要原則，由著名的軟體工程師 Bertrand Meyer 在其著作《[物件、函數和C++]》中首次提出。該原則強調軟體實體（像是類別、模組、函數方法&amp;hellip;等）應該對擴展開放，對修改封閉。換句話說，程式應該可以在「不修改現有程式」的情況下，擴展其系統的功能，同時程式也應防止在改變功能時，對現有的程式進行修改。
開放封閉原則的核心思想是：當系統需要引入新的功能或變化時，不應該修改已存在的程式，而是通過擴展（例如增添新的類別、新的方法&amp;hellip;等）來實現。這樣可以保證原有代碼的穩定性，同時在不影響現有功能的基礎上進行擴展。要遵守開放封閉原則，通常可以採取以下策略：【使用抽象類別或抽象接口】：通過使用抽象類別或抽象接口，我們可以建立起一個（或一些）泛用的方法和屬性，並在子別類中實現這些方法的具體功能。這樣，當系統需要擴展功能時，只需添加新的子類別即可完成功能，而不需要修改現有的程式。
此外【使用多態性（polymorphism）】也可以使程式遵循開放封閉原則：通過使用 polymorphism 的程式，我們可以讓程式在運行時，根據具體的對象類別，調用不同的方法。這樣，即使新增了新的功能，只需創建新的對象與新的多態方法即可完成功能，而不需要修改原有的程式和邏輯。此外，【使用策略模式等設計模式】也可以有效地達成開放封閉原則。一些設計模式（例如策略模式）可以幫助我們實現開放封閉原則。這些模式將不同的行為封裝成獨立的策略類，並通過替換不同的策略類來實現功能的擴展。
另外，如果不遵守「開放封閉原則」，可能會導致程式產生以下的問題：首先是【程式的修改風險增加】，當系統需要引入新的功能或新的變化時，如果原程式不遵守開放封閉原則，可能會產生「添增新的功能外，同時也需要修改既存的程式，才能完成功能升級」的情況，這可能導致現有的程式功能產生錯誤或影響。可能引入新的錯誤、增加更多的複雜度、提高耦合&amp;hellip;等，增加了整個系統的風險。
此外，沒有遵守「開放封閉原則」的程式也可能會有【測試困難】的狀況發生：修改現有的程式，可能會需要重新測試整個系統，在這樣的情況下，因為程式的高度改變，可能會導致測試的困難、測試覆蓋率降低&amp;hellip;等負面影響。測試新的功能可能影響到現有的測試案例，也因此增加了測試的複雜性。此外，違反原則的程式也會使得「程式的耦合增加」：不遵守開放封閉原則的程式，可能會導致不同的功能、不同的方法、或不同的類別之間出現耦合，一旦其中一個功能發生變動，可能會連帶影響到其他功能（或類別）的正常運作。
同時，不遵守開放封閉原則也可能導致【程式的複雜性增加】【可擴展性下降】【程式的重用性下降】&amp;hellip;等問題。因此建議程式在撰寫的時候，要遵守開放封閉原則規範，才能有助於降低這些問題的風險，保持程式的靈活性和可維護性。
以下我們使用一個簡單的情境來解釋單一職責原則，我們假設在一個 RPG 遊戲中，角色（Character）可以使出「火球術 fireBallSkill」「冰錐術 iceShardSkill」和「治癒術 healSkill」三種不同的攻擊，在遵循 OCP（開放封閉原則）的情況下，角色在進行技能的選擇與擴充的時候，並不會影響到原 Character 的程式，只需要增添新的 Skill 即可，但在不遵守 OCP 的情況下，若有需要做【技能】的擴充與修改，則會連帶影響到【角色】原本的程式內容：
// Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) class Skill { public: virtual void use() = 0; }; class FireballSkill : public Skill { public: void use() override { cout &amp;lt;&amp;lt; &amp;#34;Casting Fireball!</description>
    </item>
    
    <item>
      <title>碩士的畢業證書</title>
      <link>https://fonu195713.github.io/docs/daily_life/nodes/masters_degree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/nodes/masters_degree/</guid>
      <description>碩士的畢業證書#畢業證書</description>
    </item>
    
    <item>
      <title>《深入淺出設計模式》</title>
      <link>https://fonu195713.github.io/docs/daily_life/reading_experience/head_first_design_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/reading_experience/head_first_design_pattern/</guid>
      <description>《深入淺出設計模式》閱讀心得#2023-07-07
背景 一直以來，我都對「設計模式」這個東西抱著若有似無的認知。具象一點說明的話，大概就是「知道『設計模式』是一種可以讓程式寫得更加漂亮、更有彈性的觀念和方法，但實際上這些觀念是什麼（我不知道），那些方法又該如和撰寫（我也不知道）」的狀況。然後在今年 5 月底左右吧？因為第二篇論文出現了一點卡關的狀況（文章的內容一直沒辦法寫成老師期望的那種感覺），也因為患有一點研究生症候群，就開始找手邊一些 &amp;ldquo;一直以來都有興趣，但又找不到合適的時間去了解&amp;rdquo; 的東西進行研究了。而這之中，【研究設計模式】剛好是其中之一。
這邊的研究設計模式是指「閱讀《深入淺出設計模式》這本書」。並不是閱讀比較主流的 Design Patterns: Elements of Reusable（也就是四人幫著的那本），其中一個原因是：剛開始的我，並不知道這本設計模式的聖經本，另一個原因則是它是我最快速能找到比較完整的、系統性的跟設計模式有關的書籍，所以就&amp;hellip; 這樣開始了。
內容 雖然在四人幫的著作中，共列舉了 23 種常見的設計模式，但本書並沒有包含這麼多的內容。書中的 13 個章節裡，扣掉最後一個章節在介紹 MVC 架構（Model, View, Controller），以及倒數第 2 章在介紹不同模式的合併用法之外，其餘的 11 個章節依序僅介紹了 Strategy（策略模式）、observer（觀察者）、decorator（裝飾器）、factory（工廠模式，包含簡單工廠、工廠方法、和抽象工廠）、singleton（單例模式）、Command（命令模式）、Adapter（配適器）、Facade（外觀）、Template method（模板方法）、Iterator（迭代器）、Composite（組合模式）、State（狀態模式）、Proxy pattern（代理）&amp;hellip;等。剩餘的模式則僅於書中的附錄稍作提及。但這並不代表這本書不是一本良好的教學素材。相反地，因為本書的撰寫方式有別於市面上大多數的教學書籍，採用了極大量的圖片、角色對話、與情境式的描述，為各種模式的優缺點、應用情境、特徵、使用方法做大量的說明，同時也附上了許多的觀念思考、練習題、與程式範本，因此在閱讀上，並不會出現常見的倦怠、疲憊、或單調的感覺。
心得 整體而言，這本書帶給我很多新的啟發，無論是程式的撰寫方式，例如「多用組合、少用繼承」「單一類別、單一職責」「依賴通用接口，不要依賴特定類別」&amp;hellip;等，或者是各種不同模式的應用與架構「工廠模式可以讓物件的實例化延後至子類別中實現」「模板方法只關心演算法的骨幹，因此可以在不改變演算法結構的前提下，重新定義某些方法的執行細節」「單例模式可以讓類別只生成單一物件，以確保某些資源的分配不會遇到問題或錯誤」&amp;hellip;等，抑或是程式的語法觀念，像是「C++ 的物件繼承，菱形繼承的問題與解決」「虛函數, 純虛函數」&amp;hellip;等，都是在閱讀本書之後才有了一個更加明確與更加清晰的認識。雖然是在一個比較非主動的動機下，才開始閱讀本書，但整體而言，能夠「閱讀本書，並從書本當中學到了更多的知識」對我來說實在是一件很高興又很喜歡的事情。
評分 閱讀難度：★★★☆☆ （需要有基本的物件導向程式觀念）
推薦指數：★★★★★</description>
    </item>
    
    <item>
      <title>策略模式 (Strategy Pattern)</title>
      <link>https://fonu195713.github.io/docs/_trash/strategy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/strategy/</guid>
      <description>策略模式（Strategy Pattern）#2023-07-07
前言 假設我們現在正在製作一個 RPG 遊戲，遊戲內有一個名為 Monster 的抽象類別，該類別預設有 void attack()（攻擊）、void evades()（迴避）、和 void walk()（行走）三種行為，並且分別有 Slime（史萊姆）、Skeleton（骷髏）、和 Zombie（殭屍）三種怪物繼承了 Monter 類別。根據目前的想法，我們可以畫出類似於下面的類別圖，並寫出下方的程式：
classDiagramclass Abstract_Monster {+void attack();+void evades();+void walk();}Abstract_Monster &lt;|-- SlimeAbstract_Monster &lt;|-- SkeletonAbstract_Monster &lt;|-- Zombie// C++ code class Monster { public: int hp; int atk; int def; public: virtual void attack(); virtual void evades(); virtual void walk(); }; void Monster::attack() { cout &amp;lt;&amp;lt; &amp;#34;The monster unleashes a regular attack.</description>
    </item>
    
    <item>
      <title>模板方法模式（Template Method Pattern）</title>
      <link>https://fonu195713.github.io/docs/_trash/template_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/template_method_pattern/</guid>
      <description>模板方法模式（Template Method Pattern）#說明 ChatGPT：模板方法模式（Template Method Pattern）是一種行為型設計模式，該模式會定義一個「包含一個或多個抽象方法」的抽象類別，並定義一個操作這些方法的框架。該框架包含了一組預先定義的步驟，其中某些步驟由類別內部的原方法進行實作，其餘步驟則設定為允許重寫，並由繼承該類別的子類別負責實現步驟細節。模板方法將這些步驟按照特定的順序組合在一起，進而形成一個完整的操作流程。它提供了一種通用的模板，可以在不同的情境下重複使用，同時保持算法的一致性。這種模式可以幫助開發人員實現共享的行為和結構，同時提供了彈性和可定制性。
維基百科：模板方法模式是一種行為設計模型和設計模式。模板方法（Template Method）是一個定義在父類別的方法，負責處理框架、流程、演算法的不變部分。模板方法會呼叫多個定義在父類別的其他工具方法（Helper Method），這些方法有些是演算法的可變部分（只是抽象方法並沒有實作），有些已經有一些預設的方法細節。模板方法僅決定這些工具方法的執行順序，但工具方法的執行細節不一定全由父類別實現，有些市由子類別負責實作，並且子類別不允許覆蓋模板方法（即不能重寫方法的執行順序）。
定義了一個模板方法，用以定義一個完整步驟的執行順序 模板方法中會套用許多的工具方法 工具方法可由父類別實作 工具方法也可以由子類別改寫 子類別僅可改寫工具方法，不可以改寫模板方法 UML Graphic classDiagramclass Battle {Role[] playersMonster[] enemiesFINAL void figsht(); cannot overrideFINAL void initializeFight(); cannot overrideint attack();bool endFight();}note &#34;FINAL void fight() {\n　initializeFight();\n　while(not endFight()) {\n　players.attack(enemies);\n　enemies.attack(players)\n　}\n}&#34;class NormalBattle {bool endFight() can escape}class SpecialBattle {void initializeFight() hp - 50%bool endFight() cannot escape}class BossBattle {bool endFight() cannot ecsapeint attack() boss can attack twice}Battle &lt;|-- NormalBattleBattle &lt;|-- SpecialBattleBattle &lt;|-- BossBattle舉例 假設我們需要實作一個回合制 RGP 遊戲的戰鬥流程，根據遭遇到的怪物不同，遊戲內分別會有普通戰鬥、特殊戰鬥、與 Boss 戰三種不同的戰鬥模式。模板模式方法告訴了我們「與其在所有的戰鬥裡面都寫上相同的程式，不如先定義一個【戰鬥】的類別，再在【戰鬥】內定義一個方法 fight()，並將其他戰鬥模式宣告成類別，繼承此【戰鬥】即可。」透過一個名為 fight() 的模板方法，讓其他的子類別，根據這個方法進行操作與細節呈現，就是模板方法模式想要訴說的內容。</description>
    </item>
    
    <item>
      <title>享元模式（Flyweight Pattern）</title>
      <link>https://fonu195713.github.io/docs/_trash/flyweight_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/flyweight_pattern/</guid>
      <description>享元模式（Flyweight Pattern）#說明 ChatGPT：享元模式（Flyweight Pattern），也稱為輕量級模式，是一種結構型設計模式。它旨在最小化共享物件的數量，以減少記憶體佔用和提高性能。享元模式通過共享具有相同內部狀態的物件，將大量細粒度的物件轉換為少數可共用的共享物件。在享元模式中，每一個物件都分別擁有兩種狀態：內部狀態和外部狀態。內部狀態是物件的固定部分，它可以被多個物件共享。而外部狀態則是物件本身的變化部分，每個物件都有自己的外部狀態。享元模式的核心思想是將內部狀態和外部狀態分開處理，從而節省記憶體和其他資源。享元模式的主要目的是將具有相同內部狀態的物件共享，從而減少記憶體的使用和對象創建的開銷。
維基百科：享元模式（英語：Flyweight Pattern）是一種軟體設計模式。它使用物件用來儘可能減少記憶體使用量；於相似物件中分享儘可能多的資訊。此法適用於大量物件近乎以重複方式存在，因而使用到大量記憶體的時候。通常物件中的部分狀態（state）能夠共享。常見做法是把它們放在資料結構外部，當需要使用時再將它們傳遞給享元。典型的享元模式的例子為文書處理器中以圖形結構來表示字符。一個做法是，每個字形有其字型外觀、顏色、和其它格式資訊，但這會使每個字符就耗用上千位元組。因此，取代的做法會是：將每個字符參照到一個共享的字形物件，此物件會被其它有共同特質的字符所分享；只有每個字符（文件中或頁面中）的位置才需要另外儲存。
將一個物件的屬性區分為「內部狀態」和「外部狀態」 統一參照所有此物件的內部狀態 物件本身只需要儲存其外部狀態的資訊 用以減少大量記憶體和資源消耗 </description>
    </item>
    
    <item>
      <title>新新魔塔 v2.6.6</title>
      <link>https://fonu195713.github.io/docs/daily_life/notes/xinxinmota/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/notes/xinxinmota/</guid>
      <description>新新魔塔 v2.6.6#前言 印象中第一次接觸到「魔塔」系列的遊戲，大概是在小學三四年級左右吧？那時候我還蠻喜歡到玩一些 flash 小遊戲，那時候比較有名的平台大概有史萊姆的第一個家、遊戲桃、y8、遊戲天堂&amp;hellip;等等。玩過的遊戲不算少？比較有名的大概就是越南大戰、電眼美女、麻將系列 &amp;hellip;等等，還記得那時候第一次玩遊戲天堂裡面的三國麻將，不知道它是打清章的規則，一直想說「遊戲是不是出問題了？怎麼明明能『胡』的，但是遊戲就沒有辦法『胡』」XD。此外，魔塔系列也是我小時候裡面很喜歡玩得遊戲之一。
第一次接觸到魔塔系列的遊戲，是某一天在遊戲天堂裡找到的瘋狂魔塔。總之就是一個爬塔遊戲，越上層怪物的攻擊、防禦、跟血量都會變多。但除了層數很多之外（有 50 層），遊戲的難度整體不大。除了怪物體質沒有到很極端之外，遊戲裡最大的特點是「打怪不會扣血量」這項設定，所以整個爬塔過程與其說是在「冒險解謎」，不如說它其實是一款「爬塔體驗、模組觀賞」的遊戲。整體來說，在第一次爬塔的過程蠻好玩的，但後續的體驗可能就會隨著通關次數的提升而有所下降了，畢竟爬塔的遊戲就是通關了再照同樣的公式走也能通關。
難易度：★☆☆☆☆ 遊戲性：★★☆☆☆ （會隨著通關次數的增加而遞減） 後來，在遊戲天堂裡面出了一個新的魔塔遊戲，叫做新版魔塔，整體的難易度一下提昇了不少。除了血量需要精算之外，各種攻擊力、防禦力的數值也必須要把控的相當細膩，才有可能通關，有時候甚至要在某個時期存到 1000+ 以上的金錢，再一口氣做攻防的調配才有可能順利爬下去。跟上一版只要無腦加攻的瘋狂魔塔實在是有著完完全全地天壤之別。也因為有著複雜的攻防計算，加上遊戲中期以後有 3-4 條不同的分支玩法（後面會說），遊戲性一下子提升了不少，但也因為難度大幅上修的原因，小時候的我一次都沒有完全破關就是了。對於有自虐傾向挑戰精神的人，很適合至少玩過一次。也因為極高的難易度，小時候的我在嘗試了幾次之後，就沒有再點開這個遊戲了。
難易度：★★★★★★★★★★★★★★★ 遊戲性：★★★★★ 之後過了好久好久，到了碩二口試前的大概&amp;hellip;一個月左右吧？在一次跟朋友的閒聊中，這個遊戲無意間又被其中一個人給提出來了。很意外地，研究室裡大部分的朋友都有玩過這個遊戲，而且清一色地都給出了「小時候覺得很好玩」「遊戲超級難」「從來都沒有破關過」這三條口供。因此，在碩士生症候群與好奇心的驅使下，我們就又重新地打開了這個遊戲&amp;hellip;
我們玩的版本是再新一點的新新魔塔，除了因為是後幾年推出的版本，因此動畫、音效、與視覺感受都有著更新之外，基本上玩法，玩家的初始狀態，怪物的攻防、數量、和分佈&amp;hellip;等都是跟新版魔塔一樣的，唯一一個最大的差別是新版魔塔提供了「極速模式」，主要支援「一鍵到位（省去步行的動畫）」、「快速樓層移動（省去冗長的上下樓梯）」、與「即時戰鬥（用數學的方式直接計算傷害總量，省去單回合的戰鬥過程）」三種功能。算是大大地提升了遊戲的體驗和縮短遊玩時間。
遊戲說明 《新新魔塔》，原名《魔塔》，被稱為 &amp;ldquo;三原塔&amp;quot;之一，是一款基於 Flash 製作的經典魔塔作品，由 cos105hk 於 2005 年製作完成並發布。《新新魔塔》的素材、核心玩法&amp;hellip;等都來自於原日文版魔塔《魔法の塔》（The Tower of Sorcerer）。與傳統魔塔相比，最大的特點是不具備 &amp;ldquo;完全重複性&amp;rdquo;（玩家和怪物的攻擊都有機率造成爆擊或被閃避），它也是 &amp;ldquo;三原塔&amp;rdquo; 中機制最複雜、最具有挑戰性的作品。其獨特的機制、優秀的戰鬥動畫&amp;hellip;等，都為後人創作魔塔作品留下了深遠的影響&amp;hellip; （出自《新新魔塔》中的 &amp;ldquo;遊戲說明&amp;rdquo;）
遊戲劇情簡單來說，就是一個「勇者打敗魔王，救出公主」的故事。玩家要透過所扮演的角色（也就是勇者），在魔塔的各個樓層之間闖蕩、賺取金幣、獲得經驗、提升攻擊力與防禦力，一路過關斬將，最後打敗魔王，來完成整個遊戲。（然後，再來就是防雷警告了，接下來會有一點遊戲的劇透，如果想要自己嘗試看看的話，就不要再往下看了。劇透警告！）
劇透警告 劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！
遊戲階段 遊戲主要分為 2 個階段，第 1 個階段是『假公主階段』，主要的活動範圍會是在魔塔的 1-20 層。可以從一樓老人口中的「聽說魔塔不只 20 層，但最高只能到 20 層。」發現一些端倪。這時候勇者的目標，是要打敗 1-19 層的種種怪物，並嘗試走到 20 樓與「公主」見面。但等到勇者一與 20 樓的公主說話之後，便會發現她其實是怪物所變化而成的，玩家需要打敗這個怪物，並找到真正的公主。
接下來會進入到一個小小的「過門」：玩家在打敗 20 層的假公主之後，會從假公主身上拿到一個小偷的十字稿。我們需要回到 2 樓與小偷對話，讓他去第 0 層打開「往下的門」向下探索。待走到地下 2 樓的時候，再跟精靈說話，祂會要你去打敗 15 層的大章魚，並從章魚後方的樓梯一路走到 17 樓，從 17 樓進入真正的『魔塔』。然後玩家要一路往上到魔塔 5 樓，領取其中一個『紋章』。再之後，打敗鏡像的自己，回到地下 2 樓與精靈對話，開啟更下層的空間，進入到「第二階段」，開始繼續爬塔 &amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/example/collapsed/3rd-level/4th-level/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/collapsed/3rd-level/4th-level/</guid>
      <description>4th Level of Menu#Caesorum illa tu sentit micat vestes papyriferi#Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.
Venasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/example/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/hidden/</guid>
      <description>This page is hidden in menu#Quondam non pater est dignior ille Eurotas#Latent te facies#Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona#O fallor in sustinui iussorum equidem.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/buttons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/buttons/</guid>
      <description>Buttons#Buttons are styled links that can lead to local page or external link.
Example#{{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}} Get HomeContribute</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/columns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/columns/</guid>
      <description>Columns#Columns help organize shorter pieces of content horizontally for readability.
{{&amp;lt; columns &amp;gt;}} &amp;lt;!-- begin columns block --&amp;gt; # Left Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Mid Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Right Content Lorem markdownum insigne... {{&amp;lt; /columns &amp;gt;}} Example#Left Content#Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/details/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/details/</guid>
      <description>Details#Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.
Example#{{&amp;lt; details &amp;#34;Title&amp;#34; [open] &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} {{&amp;lt; details title=&amp;#34;Title&amp;#34; open=true &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} TitleMarkdown content#Lorem markdownum insigne&amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/expand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/expand/</guid>
      <description>Expand#Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.
Example#Default#{{&amp;lt; expand &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Expand↕Markdown content#Lorem markdownum insigne&amp;hellip;With Custom Label#{{&amp;lt; expand &amp;#34;Custom Label&amp;#34; &amp;#34;...&amp;#34; &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Custom Label...Markdown content#Lorem markdownum insigne.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/hints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/hints/</guid>
      <description>Hints#Hint shortcode can be used as hint/alerts/notification block.
There are 3 colors to choose: info, warning and danger.
{{&amp;lt; hint [info|warning|danger] &amp;gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{&amp;lt; /hint &amp;gt;}} Example#Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus TelethusaMarkdown content</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/katex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/katex/</guid>
      <description>KaTeX#KaTeX shortcode let you render math typesetting in markdown document. See KaTeX
Example#{{&amp;lt;/* katex [display] [class=&amp;#34;text-center&amp;#34;] */&amp;gt;}} f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi {{&amp;lt;/* /katex */&amp;gt;}} Display Mode Example#Here is some inline example: \(\pi(x)\), rendered in the same line. And below is display example, having display: block \[f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi\]Text continues here.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/mermaid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/mermaid/</guid>
      <description>Mermaid Chart#MermaidJS is library for generating svg charts and diagrams from text.
Override Mermaid Initialization Config
To override the initialization config for Mermaid, create a mermaid.json file in your assets folder!
Example#{{&amp;lt;/* mermaid [class=&amp;#34;text-center&amp;#34;]*/&amp;gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --&amp;gt; State2 note left of State2 : This is the note to the left.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/section/first-page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/section/first-page/</guid>
      <description>First page#Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/section/second-page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/section/second-page/</guid>
      <description>Second Page#Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/tabs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/tabs/</guid>
      <description>Tabs#Tabs let you organize content by context, for example installation instructions for each supported platform.
{{&amp;lt; tabs &amp;#34;uniqueid&amp;#34; &amp;gt;}} {{&amp;lt; tab &amp;#34;MacOS&amp;#34; &amp;gt;}} # MacOS Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Linux&amp;#34; &amp;gt;}} # Linux Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Windows&amp;#34; &amp;gt;}} # Windows Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; /tabs &amp;gt;}} Example#MacOSMacOS#This is tab MacOS content.
Lorem markdownum insigne. Olympo signis Delphis!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230805/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230805/</guid>
      <description>2023-08-03 翻牌紀錄#抽到的牌卡：錢幣國王（逆）
塔羅牌牌意：穩定、不動、躊躇不前、慵懶、放置、站起身來往前走
心得：
今天同樣也是對塔羅牌的牌意有著新的領悟的一天。「逆位的錢幣國王」基本上可以拆成 3 個部分去做解讀，分別是「逆位」「錢幣」以及「國王」。「錢幣」屬土，代表物質、代表生活、代表著慾望、或者是實實在在的金錢。「國王」同樣也屬土，代表著權利、代表著穩定、代表沈著、或者是威勢。通常來講，錢幣國王如果單看正位的話，是一張很「固執」的牌，因為是土之土，最穩定、最雷打不動的那種組合，因此在這樣的情況下一般理解成「不動」「穩定」或者是「固執」「沒有變化」。可以把一成不變當成錢幣國王的關鍵字（不一定是好還是壞，對於需要打拼的人來說，這張牌偏壞：但對於已經步入正軌尋求穩定的人來說，這張牌至少有中吉）。
逆位是「過度」「不足」或「相反」。在我自己的直觀感受上，通常我會把逆位的錢幣國王用「過度」來理解，也就是更加穩定、更加不動、躊躇不前、或者是完全的慵懶和放置。也因此，今天在抽到這張牌的時候，我的預想是「好哦，看來今天會是一個完全沒有進度的一天呢。」但或許是這樣的想法促進了我工作的動力？又或者是心裡有著一種「反正不會有太多的進度，那就一切隨緣不要太用力工作吧」的心態，反倒讓自己的步伐邁得比平常更遠也說不定？總而言之，在回過神來，今天已經完成了平常進度的 2-3 倍以上了。
也因此，今天得到最大的體悟就是「原來『逆位的錢幣國王』不完全當作『過度』解讀，也可以用『相反』來做詮釋啊&amp;hellip;」整體而言算是很有收穫的一天。除了工作的進度是平常的好幾倍之外，最大的收穫就是學到了新的牌意囉囉～
準確度 ★★★★☆ </description>
    </item>
    
    <item>
      <title>一千份的手抄心經</title>
      <link>https://fonu195713.github.io/docs/daily_life/notes/heart_sutra_beforehand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/notes/heart_sutra_beforehand/</guid>
      <description>一千份的手抄心經#2020/10/24</description>
    </item>
    
    <item>
      <title>日本旅行 7 萬步</title>
      <link>https://fonu195713.github.io/docs/daily_life/notes/japan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/notes/japan/</guid>
      <description>日本旅行 7 萬步#關西機場: checkout 不用錢 到第一航廈 不用錢 坐車到天王寺 不用錢 天王寺到大阪 1520
x 回到動物園前：(大阪到動物園前 ) 寄行李 260 進動物園 不用錢 動物園買飲料 850 出動物園 不用錢 x 進通天閣 不用錢 (900) 通天閣照片 1300 買冰淇淋 170, 伴手禮 1966, 吊飾 300 73 塊的大薯 不用錢 拿行李 不用錢 近來房間睡覺 不用錢
x 睡醒去天王寺： (動物園錢到天王寺) Q-mall ( 沒有吃燒肉) 吃拉麵 1100 買泡芙 452
x 回動物園前： (天王寺到動物園前) 唐吉軻德 17008(藥) + 2600? 全家咖啡奶茶 150
26016
家裡附近： 全家的炸雞快 350 買帽子 3200
往大阪城的路上： x (動物園前到天王寺) 天王寺 &amp;gt; 大阪城公園 340 ( 大阪城門票 ) 大阪城錢幣 800 坐著吃冰淇淋 200 + 200 沒有看到馬戲團 不用錢</description>
    </item>
    
  </channel>
</rss>
