<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Fonu Site</title>
    <link>https://fonu195713.github.io/</link>
    <description>Recent content in Introduction on Fonu Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://fonu195713.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>With ToC</title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/example/table-of-contents/with-toc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/example/table-of-contents/with-toc/</guid>
      <description>Caput vino delphine in tamen vias#Cognita laeva illo fracta#Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere#Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
    <item>
      <title>Without ToC</title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/example/table-of-contents/without-toc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/example/table-of-contents/without-toc/</guid>
      <description>At me ipso nepotibus nunc celebratior genus#Tanto oblite#Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.
Quam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/example/collapsed/3rd-level/4th-level/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/example/collapsed/3rd-level/4th-level/</guid>
      <description>4th Level of Menu#Caesorum illa tu sentit micat vestes papyriferi#Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.
Venasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/example/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/example/hidden/</guid>
      <description>This page is hidden in menu#Quondam non pater est dignior ille Eurotas#Latent te facies#Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona#O fallor in sustinui iussorum equidem.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/buttons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/buttons/</guid>
      <description>Buttons#Buttons are styled links that can lead to local page or external link.
Example#{{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}} Get HomeContribute</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/columns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/columns/</guid>
      <description>Columns#Columns help organize shorter pieces of content horizontally for readability.
{{&amp;lt; columns &amp;gt;}} &amp;lt;!-- begin columns block --&amp;gt; # Left Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Mid Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Right Content Lorem markdownum insigne... {{&amp;lt; /columns &amp;gt;}} Example#Left Content#Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/details/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/details/</guid>
      <description>Details#Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.
Example#{{&amp;lt; details &amp;#34;Title&amp;#34; [open] &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} {{&amp;lt; details title=&amp;#34;Title&amp;#34; open=true &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} TitleMarkdown content#Lorem markdownum insigne&amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/expand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/expand/</guid>
      <description>Expand#Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.
Example#Default#{{&amp;lt; expand &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Expand↕Markdown content#Lorem markdownum insigne&amp;hellip;With Custom Label#{{&amp;lt; expand &amp;#34;Custom Label&amp;#34; &amp;#34;...&amp;#34; &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Custom Label...Markdown content#Lorem markdownum insigne.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/hints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/hints/</guid>
      <description>Hints#Hint shortcode can be used as hint/alerts/notification block.
There are 3 colors to choose: info, warning and danger.
{{&amp;lt; hint [info|warning|danger] &amp;gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{&amp;lt; /hint &amp;gt;}} Example#Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus TelethusaMarkdown content</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/katex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/katex/</guid>
      <description>KaTeX#KaTeX shortcode let you render math typesetting in markdown document. See KaTeX
Example#{{&amp;lt;/* katex [display] [class=&amp;#34;text-center&amp;#34;] */&amp;gt;}} f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi {{&amp;lt;/* /katex */&amp;gt;}} Display Mode Example#Here is some inline example: \(\pi(x)\), rendered in the same line. And below is display example, having display: block \[f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi\]Text continues here.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/mermaid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/mermaid/</guid>
      <description>Mermaid Chart#MermaidJS is library for generating svg charts and diagrams from text.
Override Mermaid Initialization Config
To override the initialization config for Mermaid, create a mermaid.json file in your assets folder!
Example#{{&amp;lt;/* mermaid [class=&amp;#34;text-center&amp;#34;]*/&amp;gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --&amp;gt; State2 note left of State2 : This is the note to the left.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/section/first-page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/section/first-page/</guid>
      <description>First page#Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/section/second-page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/section/second-page/</guid>
      <description>Second Page#Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/tabs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/_previous_docs/shortcodes/tabs/</guid>
      <description>Tabs#Tabs let you organize content by context, for example installation instructions for each supported platform.
{{&amp;lt; tabs &amp;#34;uniqueid&amp;#34; &amp;gt;}} {{&amp;lt; tab &amp;#34;MacOS&amp;#34; &amp;gt;}} # MacOS Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Linux&amp;#34; &amp;gt;}} # Linux Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Windows&amp;#34; &amp;gt;}} # Windows Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; /tabs &amp;gt;}} Example#MacOSMacOS#This is tab MacOS content.
Lorem markdownum insigne. Olympo signis Delphis!</description>
    </item>
    
    <item>
      <title>Clean Architecture - 無瑕的程式碼</title>
      <link>https://fonu195713.github.io/docs/life/reading_experience/clean_architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/reading_experience/clean_architecture/</guid>
      <description>Clean Architecture - 無瑕的程式碼#心得編寫日期：2023-??-??
書籍超連結
內文：
評分
閱讀難度：★★★★☆ （需要有基本的物件導向程式觀念） 推薦指數：★★★☆☆ </description>
    </item>
    
    <item>
      <title>UML</title>
      <link>https://fonu195713.github.io/docs/_trash/unified_modeling_language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/unified_modeling_language/</guid>
      <description>UML#ChatGPT 的說明 UML，全名為 Unified Modeling Language（中文譯作「統一建模語言」）是一種軟體工程領域的模型建置語言，用於描述、設計、和規劃軟體系統的結構和行為。 UML 是一種圖形化的語言，它提供了一組符號和規則，用於創建各種圖表，以幫助軟體開發人員、系統分析師和其他相關人員對於系統的架構進行理解、溝通、和設計軟體。UML 由許多不同的圖表和圖形元素組成，其中一些主要的圖表包括下列幾種：［類別圖］（Class Diagrams）用來描述系統中的類別、物件、屬性和方法之間的關係，這是靜態結構的表示。［使用案例圖］（Use Case Diagrams）用於描述系統的功能和使用者之間的互動，以及用例之間的關係，這有助於捕捉系統的功能需求。［序列圖］（Sequence Diagrams）用於展示系統中物件之間的交互作用和訊息流程，這有助於理解系統的動態行為。［狀態圖］（State Diagrams）用於描述物件的不同狀態以及狀態之間的轉換。［活動圖］（Activity Diagrams）用來描述系統中的流程和操作，類似流程圖。 UML 在軟體開發過程中起著重要作用，它有助於團隊成員之間的溝通，幫助捕捉系統需求，並提供了一種通用的語言，用於設計和文件化軟體系統。 它被廣泛用於軟體開發領域，特別是物件導向的軟體開發，以及系統分析和設計。
在軟體開發中，無論是系統的設計階段、修改類別之間的關係、或者是其他在以「物件」為基本單元情況下，我們通常會使用 UML 圖來詮釋不同類別（Class）、物件（Object）、屬性（Attribute）、方法（Method）以及它們之間的關係。以下是一些類圖中的細節，包括圖形元素和其含義：［類別］（Class）：類別是類別圖的主要元素之一，代表了一個抽象的概念、對象、或實體物件。通常以方框表示，方框中包含類別的名稱、成員變數、和方法。［屬性］（Attributes）屬性又稱作「成員變數」，是類別的特徵或特性，它們描述了類別的狀態。 通常以 &amp;ldquo;名稱：類型&amp;rdquo; 的形式表示，例如 name: String 表示一個名為姓名的屬性，其類型為字串。［方法］（Methods）方法表示類別可以執行的操作或行為，在非物件導向的程式中被稱為「函數」或「函式」。通常以 &amp;ldquo;名稱(參數清單)：傳回值類型&amp;rdquo; 的形式表示，例如，setName(name:String): void 表示一個名為設定姓名的方法，它接受一個字串做為參數，並不傳回任何值。［關聯］（Association）關聯用來表示類別之間的連接或關係。它用一條直線連接兩個類別，可能伴隨著空心箭頭，實心箭頭、圓形箭頭 &amp;hellip;等不同種類的箭頭，指向關聯的方向，不同種的箭頭則代表了不同種類的關聯方式。［繼承］（Inheritance）繼承是一種特殊的關聯方式，用來表示一個類別（子類別）繼承另一個類別（父類別）的屬性和方法，它通常以「一個空心箭頭指向父類別」的方式呈現。［介面］（Interface）介面是一個特定的方法集合，不帶有方法的實作細節。介面通常以帶有小半圓的矩形框表示，其中小半圓的一端連接到實現該介面的類別。［抽象類別］（Abstract Class）抽象類別是一個不能實例化的類別，通常用於定義一些通用的成員變數和方法，並要求子類別實現該抽象類別中的一些方法，它通常以斜體字表示。［依賴］（Dependency）依賴表示一個類別（或物件）依賴另一個類別。它通常以帶有箭頭的虛線表示，箭頭指向被依賴的類別。
對於程式設計師來說，類圖的主要目的是可視化系統中類別之間的結構和關係，以便開發人員和設計師更好地理解和設計軟件系統。它可以帶來類別結構可視化、類別關係呈現、設計規劃和模型驗證、易於生成程式碼、和便於文檔化與溝通 &amp;hellip;等，在軟體設計的過程中，可以起到不小的作用。
程式碼/圖形範例 類別 在物件導向程式設計中，「類別」通常是構成程式的一個重要的、不可或缺的元件（甚至對 Java 來說，所有的程式都是類別和物件就是了），因此如果要說明 UML 的畫法，第一個就介紹「類別」的畫法應該是再適合不過了，現在我們假設在一個「學生管理系統」中，有一個名為 Student 的類別，用 Java 來實作的話，程式如下所述：
// 類別 [學生] class Student { // 這個類別裡面目前還沒有任何東西 } 畫成 UML 圖，則會像是下面的這個樣子（很簡單，就是一個三層的方框）：
classDiagram class Student 那如果系統中有很多類別呢？像是有 Student, Teacher, School, Subject&amp;hellip; 之類的？</description>
    </item>
    
    <item>
      <title>介面隔離原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/interface_segregation_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/interface_segregation_principle/</guid>
      <description>介面隔離原則#ChatGPT 的說明 介面隔離原則（Interface Segregation Principle，ISP）又稱做接口隔離原則，是 SOLID 五大設計原則之一，由羅伯特·C·馬丁（Robert C. Martin）所提出。 ISP 原則的核心思想是：客戶端不應該被迫依賴它們不使用的介面。簡而言之，ISP 要求介面的設計應該小而專一，不應該包含客戶端不需要的方法。ISP 的關鍵觀點包括以下幾點：首先：［介面應該要精簡］系統中的介面（interface）應該只包含客戶端所需的方法，不應該包含多餘的方法。這件事情這確保了介面的高內聚性，意即每個介面都應該有一個明確的目的。此外［客戶端不應該被迫實作不需要的方法］如果一個類別實作了一個介面，那麼這個類別只應該實作它所需要的方法，而不需要實作介面中裡其餘不需要的方法。這避免了類別中不必要的方法實作。再來，［避免介面臃腫］將多個不相關的方法放在同一個介面中，會導致介面變得臃腫、龐大、不易理解、和不易維護。因此 ISP 鼓勵設計師在設計介面時，將介面拆分成更小、更專一的項目。
除了上述的這些內容之外，介面隔離原則通常會與依賴倒置原則結合使用，成為依賴反轉原則的一部分，以確保依賴反轉原則中的「高層模組」不需要依賴「底層模組的具體實現」，而是依賴一個抽象，或者是依賴一個介面。 透過使用小而專一的接口，可以更容易實現依賴注入和解耦。總而言之，ISP 的目的是提高程式碼的可維護性、可讀性和可擴展性。它有助於確保介面的設計更加合理、更加靈活，使得每一個實例該介面的類別只需要實現與其相關的業務方法即可，不需要依賴其它不相關的方法。這樣做可以減少程式碼的複雜性，提高程式碼的整體品質，並降低了引入錯誤、修正錯誤的風險。
簡單整理 類別在引入介面的時候，介面的方法全部都要實例，不要不實例
程式碼範例 讓我們以一個簡單的例子來做思考：假設我們現在正在一家「交通工具生產公司」中工作，我們現在需要為公司製作一個簡單的「產品介紹系統」，該系統需要呈現各式交通工具的基本訊息（像是id、型號、大小、油槽容量、主要顏色、價格 &amp;hellip;等），而公司的產品包含但不限於汽車、機車、腳踏車、公車、遊艇、郵輪、飛機、直升機 &amp;hellip;等。在最最直觀的情況下，我們可以很直接地將每一個公司的產品，都視做一個獨立的類別進行分類，也就是像下面的這個樣子：
// 汽車類別 class Car { // id, 型號, 價格, 顏色, 座位數量 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer numOfSeats; // 汽車的移動方式 public void driving() { System.out.println(&amp;#34;車子可以利用 4 個輪子，在道路上行駛&amp;#34;); } // 其他關於 [汽車] 的相關方法 // 其他關於 [汽車] 的相關方法 } // 機車類別 class Motorcycle { // id, 型號, 價格, 顏色, 置物空間, 排氣量 .</description>
    </item>
    
    <item>
      <title>依賴反轉原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/dependency_inversion_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/dependency_inversion_principle/</guid>
      <description>依賴反轉原則#ChatGPT 的說明 依賴反轉原則（Dependency Inversion Principle，DIP）是 SOLID 原則中的一個重要原則，由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則的核心思想是：「高層模組不應該依賴低層模組，它們都應該依賴於抽象。」簡而言之，依賴從實例反轉至抽象，使系統更靈活、可維護和可擴展。依賴反轉原則包括了以下的幾個關鍵概念：［高層模組］高層模組通常是應用程式中，較高層級的模組（或元件），通常包括一些業務邏輯、應用程式的核心功能、或者其餘更加廣泛、更加抽象的概念。［低層模組］低層模組是應用程式中，較低層級的模組（或元件），通常包括一些與硬體、資料庫、外部服務 &amp;hellip;等實體類的互動。低層模組的實作細節可能會根據不同的交互對象，而發生各式各樣的變化，而但高層模組不應受到這些變化的影響。
［抽象］抽象是一種介面、抽象類別、或抽象資料類型，它定義了「高層模組」和「低層模組」之間的通訊協定、互動規則、或契約。高層模組通常會依賴這個抽象，而不是依賴特定的低層模組，以實現更具彈性的程式邏輯。［具體實作］具體實作是低層模組的具體程式碼，它們實作了「抽象」中所定義的方法和行為。［依賴反轉］依賴反轉是指高層模組不直接依賴低層模組，而是依賴共享的抽象。這意味著高層模組和低層模組都依賴相同的抽象，而不是其餘的依賴情形，這種依賴方式這可以透過依賴注入、工廠模式、反射 &amp;hellip;等技術來實現。［依賴注入］依賴注入是一種常見的實現依賴反轉的方式，它透過將依賴物件傳遞給高層模組，而不是由高層模組自行創建依賴物件。這使得高層模組可以更靈活地切換不同的依賴物件。
透過依賴反轉原則，我們可以提耕城市許多面向的性能，包含以下幾種：［減少耦合性］依賴反轉原則的主要目標是減少模組之間的耦合性，當高層模組依賴低層模組的具體實現時，它們之間的耦合性很高，任何對低層模組的變更都可能導致高層模組受到影響。但透過使用抽象和依賴反轉，可以減少這種耦合性，使得系統更容易維護和擴展。［增加可測試性］依賴反轉原則有助於提高程式碼的可測試性。透過將依賴關係從具體的實作中解耦，可以使用模擬物件（或虛擬物件）取代原本的依賴物件進行單元測試，從而更容易驗證高層模組的行為。
簡單整理 透過讓高層模組和低層模組依賴相同的抽象類別，達到靈活且具彈性的程式
程式碼範例 從純粹的程式碼上面來說，依賴反轉原則總共有三個重要的組成，分別是「低層模組」「高層模組」和「抽象類別」三種。其中，低層模組指的是「零件」，算是構成整個系統裡面，比較基礎、比較單純、比較不複雜的部分。如果拿一個 RPG 遊戲來做舉例的話，「低則模組」就有點像是刀、劍、弓、法杖、斧頭、藥水、衣服、靴子 &amp;hellip;等比較小塊、比較基本、物件本身比較不會有太多變化的東西。
「高層模組」指的則是由數個（或數十個）低層模組所組合而成的一個複雜類別，通常可以執行一些相對低層模組來說，更為複雜的操作。同樣拿 RPG 遊戲來舉例的話，高層模組可以是一個角色、一支隊伍、一個公會、一座城市、或者是一組軍團&amp;hellip;等等。通常來講，高層模組和低層模組是一個「比較」的概念，如果視野是放在一個 角色 跟上，那麼角色就是高層模組、角色所攜帶的各種物品就是低層模組；如果視野是放在一支隊伍、更甚至於一組軍團上面，那麼 角色 在這裡可能就變成了低層模組。
一般來說，在不使用「依賴反轉原則」的前提下，如果我們想要製作出一個高層模組（和它應有的功能）的話，我們通常會使用直接依賴的方式來完成，就如同下面的類別所示，一個角色與它身上的各種五花八門的配備：
// 角色類別 class Character { // 一個角色可能擁有的所有屬性 // 這邊只包含血量、魔力、攻擊力、和防禦力 private Integer hp; private Integer mp; private Integer atk; private Integer def; // 一個角色可能擁有的各種武器 // 這邊包含了刀、劍、弓、法杖、斧頭、匕首、盾牌 ...等 private Blade blade; private Sword sword; private Bow bow; private Staff staff; private Axe axe; private Dagger dagger; private Shield shield; // 一個角色可能擁有的各種護具 // 這邊包含了頭盔、胸甲、護肘、護膝、鞋子 .</description>
    </item>
    
    <item>
      <title>創建者模式</title>
      <link>https://fonu195713.github.io/docs/_trash/builder_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/builder_pattern/</guid>
      <description>創建者模式#ChatGPT 的說明 創建者模式（Builder Pattern）是一種創建型設計模式，旨在透過將複雜物件的建置流程拆分為多個簡單物件的建置步驟，使得物件的建置流程更加靈活、可維護，同時提供更好的控制和自訂選項。創建者模式的主要想法是將一個複雜物件的建構與其表示分開。這使得客戶端程式碼可以更容易地配置和建立複雜對象，而無需了解對象的內部建置細節。創建者模式通常包括以下關鍵角色：［產品］（Product）：產品表示被建構的複雜物件。產品類別通常包含多個屬性或部分，這些部分的創建和組裝由創建者負責。［抽象創建者］（Abstract Builder）：抽象創建者定義了建構產品物件的抽象接口，包括各個部分的創建方法。抽象創建者通常包括一個獲取最終產品的方法。［具體創建者］（Concrete Builder）：具體創建者實現了「抽象創建者」的接口，負責構建產品的各個部分，同時提供了設置產品屬性的方法。每個特定創建者可以建立不同的產品變體。［指揮者］（Director）：指揮者負責依照客戶端的需求，按照一定順序呼叫特定創建者的方法來建構產品物件。指揮者不負責特定產品的創建，而是協調創建者完成建造。［客戶端］（Client）：客戶端程式碼透過指揮者來建立複雜對象，並可以根據需要選擇不同的特定創建者，來建構不同的產品變體。
創建者模式的主要優點包括：分離建造過程和表示，允許更容易建造不同的產品變體；提供了更好的控制和客製化選項，客戶端可以自訂產品的建置流程；支援逐步建構複雜對象，使得建置過程更加靈活；提高了程式碼的可維護性，將複雜建置過程封裝在特定創建者中，使得客戶端不需要知道具體的創建細節；創建者模式在需要建立具有多個配置選項或參數的複雜物件時非常有用，例如建立圖形使用者介面中的視窗、建立文件物件、建立複雜的資料結構等情況。它幫助管理和組織複雜物件的建置過程，使程式碼更具可讀性和可維護性。
簡單整理 問題描述：複雜物件往往由許多不同的必選/可選物件組成，使得建立起來非常複雜
解決方案：封裝一系列的變數和設置，令創建複雜物件不再麻煩
程式細節：參照下面的段落
UML 圖：
程式碼範例 所謂的複雜物件，在這邊指的是需要經由各個小物件進行合成（或聚合）之後，才可以被生成的物件。用現實生活來舉例的話，就像是一輛汽車（需要引擎、車輪、車殼、排氣管、油箱 &amp;hellip;等部件組成）一棟房子（需要大門、牆壁、屋頂、水電、床鋪、書櫃 &amp;hellip;等物件組成）或者是一台電腦（需要鍵盤、滑鼠、螢幕、主機板、CPU、記憶體、硬碟 &amp;hellip;等元件組成）。就拿電腦來舉例好了：假設我們在程式中需要模擬一台電腦被創建的過程，大概會像是下面的這個樣子：
class Main { public static void main(String args[]) { // 組成電腦的小物件們 MotherBoard motherBoard = new MotherBoard(); CPU cpu = new CPU(); Memory memory = new Memory(); Disk disk = new Disk(); Power power = new Power(); ComputerTower computerTower = new ComputerTower(motherBoard, cpu, memory, disk, power); Keyboard keyboard = new Keyboard(); Mouse mouse = new Mouse(); Monitor monitor = new Monitor(); // [電腦] 本身 Computer computer = new Computer(computerTower, keyboard, mouse, monitor); } } 接著我們繼續往下想：是全世界所有的電腦都不多不少，由這幾種元件所組成嗎？如果我今天只需要一台架站的伺服器電腦，那我是不是只需要主機就好？如果我今天是一個辦公室的文書機，我應該還要再加上一個印表機的連線吧？如果我今天是給阿公阿嬤用的電腦，他們會不會用到光碟機之類的元件？如果我今天是一個電競選手，是不是還需要 GPU 和幾個固態硬碟？如果我今天是一個實況主，那麼裝一個攝影機用來捕捉畫面應該很重要吧？如果&amp;hellip; 如果&amp;hellip; 如果&amp;hellip;。假設我們要把所有可能的狀況全部都定義出來的話，那麼 Computer 的程式很有可能會長得像是下面這個樣子：</description>
    </item>
    
    <item>
      <title>創建者模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/builder_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/builder_pattern/</guid>
      <description>創建者模式#ChatGPT 的說明 創建者模式（Builder Pattern）是一種創建型設計模式，旨在透過將複雜物件的建置流程拆分為多個簡單物件的建置步驟，使得物件的建置流程更加靈活、可維護，同時提供更好的控制和自訂選項。創建者模式的主要想法是將一個複雜物件的建構與其表示分開。這使得客戶端程式碼可以更容易地配置和建立複雜對象，而無需了解對象的內部建置細節。創建者模式通常包括以下關鍵角色：［產品］（Product）：產品表示被建構的複雜物件。產品類別通常包含多個屬性或部分，這些部分的創建和組裝由創建者負責。［抽象創建者］（Abstract Builder）：抽象創建者定義了建構產品物件的抽象接口，包括各個部分的創建方法。抽象創建者通常包括一個獲取最終產品的方法。［具體創建者］（Concrete Builder）：具體創建者實現了「抽象創建者」的接口，負責構建產品的各個部分，同時提供了設置產品屬性的方法。每個特定創建者可以建立不同的產品變體。［指揮者］（Director）：指揮者負責依照客戶端的需求，按照一定順序呼叫特定創建者的方法來建構產品物件。指揮者不負責特定產品的創建，而是協調創建者完成建造。［客戶端］（Client）：客戶端程式碼透過指揮者來建立複雜對象，並可以根據需要選擇不同的特定創建者，來建構不同的產品變體。
創建者模式的主要優點包括：分離建造過程和表示，允許更容易建造不同的產品變體；提供了更好的控制和客製化選項，客戶端可以自訂產品的建置流程；支援逐步建構複雜對象，使得建置過程更加靈活；提高了程式碼的可維護性，將複雜建置過程封裝在特定創建者中，使得客戶端不需要知道具體的創建細節；創建者模式在需要建立具有多個配置選項或參數的複雜物件時非常有用，例如建立圖形使用者介面中的視窗、建立文件物件、建立複雜的資料結構等情況。它幫助管理和組織複雜物件的建置過程，使程式碼更具可讀性和可維護性。
簡單整理 問題描述：複雜物件往往由許多不同的必選/可選物件組成，使得建立起來非常複雜
解決方案：封裝一系列的變數和設置，令創建複雜物件不再麻煩
程式細節：參照下面的段落
UML 圖：
程式碼範例 在物件導向程式設計中，伸縮式建構子（英文叫做 Telescoping constructor）是一種用來說明「提供多種不同參數組合的建構子，以利於物件生成」的詞彙。一般來說，伸縮式建構子只會在複雜物件的類別中出現，而所謂的複雜物件，指的則是經由不同子部件所組成的大型物件，用比較貼近生活的例子來說的話，複雜物件就像是一台汽車（由引擎、輪胎、車殼、窗戶、排氣管、方向盤 &amp;hellip;等物件組成）一棟房子（由牆壁、大門、窗戶、屋頂、床、書桌 &amp;hellip;等物件組成）或者是一台電腦（由鍵盤、滑鼠、螢幕、主機板、CPU、硬碟 &amp;hellip;等物件組成）之類的東西。用程式的方式呈現大概會像這個樣子：
class Main { public static void main(String args[]) { // 組成電腦的小物件們 MotherBoard motherBoard = new MotherBoard(); CPU cpu = new CPU(); Memory memory = new Memory(); Disk disk = new Disk(); Power power = new Power(); ComputerTower computerTower = new ComputerTower(motherBoard, cpu, memory, disk, power); Monitor monitor = new Monitor(); Keyboard keyboard = new Keyboard(); Mouse mouse = new Mouse(); // [電腦] 本身 Computer computer = new Computer(computerTower, monitor, keyboard, mouse); } } class Computer { public Computer(ComputerTower computerTower) {}; public Computer(ComputerTower computerTower, Monitor monitor) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard) {}; public Computer(ComputerTower computerTower, Monitor monitor, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, GPU gpu) {}; public Computer(ComputerTower computerTower, Monitor monitor, Keyboard keyboard, Mouse mouse, Printer printer) {}; public Computer(ComputerTower computerTower, Monitor monitor1, Monitor monitor2, Keyboard keyboard, Mouse mouse) {}; // 其他的建構子和方法 .</description>
    </item>
    
    <item>
      <title>原型是什麼？為什麼要用原型？如何使用原型？</title>
      <link>https://fonu195713.github.io/docs/creation/novel/note/45_master_characters/archetypes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creation/novel/note/45_master_characters/archetypes/</guid>
      <description>創作的原型#原型是什麼#對於創作者來說，原型是藍圖，是用來建構/刻畫人物的原則 原型用來濃縮角色的本質，原型包含角色的動機、恐懼、掛心的事物 &amp;hellip;等 原型不是「刻板印象」 刻板印象是對角色過度簡化的歸納 用原型來擴張對角色的想像#臉龐：圓潤/瘦長，過往/年齡/職業，眼神 皮膚：淺色/深色，滑順/粗糙，明顯的疤痕或胎記？ 頭髮：長髮/短髮/捲髮，髮型的原因？ 年齡：什麼年紀最適合傳達這個角色的內在掙扎？ 體型：豐腴/結實 風格：時髦/落伍 印象：別人喜歡他嗎？為什麼？ 釐清角色原型的基本人格元素#角色的性格是內向還是外向 角色的行為通常憑藉直覺還是依照邏輯 角色是否有想要改變世界的願景 角色的出身、環境、臥室的描述與外觀 角色喜歡自己嗎？為什麼？ 角色對於他人（六親）有什麼感覺和看法 角色的興趣、嗜好，專長 角色對周遭的一切有控制的慾望嗎 其他人對於這個角色有什麼想法 角色認真的看待生活嗎？他會怎麼度過自己的閒暇時光 如何使用原型#角色關心著什麼？ 如果他被困在荒島上，他會希望手邊有哪 3 樣東西 如果他的房子被一場無情的大火給燃燒殆盡，他會最想念什麼東西 他在乎什麼？在意什麼？物品？評價？抑或是生活方式？ 角色會害怕什麼？ 為他帶來噩夢的是什麼？ 在深夜裡聽到槍響，他會有什麼反應？ 他會覺得是什麼造成這個聲響？ 他（在兒時）遭遇過什麼樣的經歷，導致他有這種恐懼？ 角色的動力是什麼？ 為了單純地活下去 為了安全與保障 為了愛/一個歸屬感 為了讓他人（或自己）看得起自己 為了了解他人 為了一些無法用邏輯（理性）說明的事情 為了實現心中的目標 原型的練習#挑出 3 個原型，並試著寫出這 3 個原型如何影響故事發展 花 2 頁的篇幅來盡可能描述這個角色 嘗試與角色對話，從角色的視角與自己對話 </description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/prototype_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/prototype_pattern/</guid>
      <description>原型模式#ChatGPT 的說明 原型模式（Prototype pattern）是一種創建型設計模式，其主要目的是『透過不使用建構子的方式，創建類別中的新物件。』此模式的核心思想是基於已有對象的克隆（拷貝）來產生新的對象，這個已有對象稱為原型，而克隆的方式有淺克隆（Shallow clone）和深克隆（Deep clone）兩種。原型模式有以下關鍵特點和優點：［透過 clone 創建物件］：原型模式允許程式在運行的時後創建新的物件，而無需知道特定物件的構造細節。這是透過複製現有物件的屬性和狀態來實現的。［減少構造成本］：在某些情況下，物件的構造可能非常昂貴（像是需要花費大量資源、消耗大量時間 &amp;hellip;等），透過原型模式，可以複製已有物件，來避免重複執行構造操作，從而提高效能和效率。［支援多樣化的物件］：原型模式允許建立多個不同屬性的物件，而無需重新實作整個物件的建構邏輯，這對於物件的變種非常有用。［簡化物件的創建］：原型模式簡化了物件的創建過程，尤其是在物件具有複雜結構或大量屬性時。可以使客戶端只需要呼叫模式中的 clone 方法，便可以實踐物件的創立。
而在原型模式中，克隆（或拷貝）物件的方式總共分成兩種：［淺克隆］（Shallow clone）：淺克隆會在方法內建立一個新原型的物件，但該新物件的內部成員變數仍然與原始的原型物件共用同樣的子物件。這意味著，雖然新物件本身是與原物件獨立的，但在新物件內部仍然引用了原始物件中的某些子物件。如果對我們對任一物件的共享去性進行修改，這些修改將在兩個物件中都可見，因為它們引用同一份資料。淺克隆通常是較快且較節省記憶體的方式，但需要注意在共享子物件上可能出現潛在問題。［深克隆］（Deep Copy）：深拷貝重樣會創建一個新的物件，但與淺克隆不同的是。這種「創建」包括原始的原型物件，以及該物件的所有子物件（以遞回的方式完全複製整個物件結構）。這確保了新物件與原始物件之間完全獨立，對其中一個物件所做的修改不會影響另一個物件。深克隆通常比較安全，因為它避免了共享資料的問題，但可能需要更多時間和記憶體來執行，特別是對於複雜的物件結構。
簡單整理 問題描述：有時候使用 new 的方式建立物件會影響程式的可讀性、彈性、和可重用性。
解決方案：可以透過 clone 方法解決對創建物件的細節依賴。
程式細節：參照下面的段落
UML 圖：
程式碼範例 </description>
    </item>
    
    <item>
      <title>合成/聚合複用原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/</guid>
      <description>合成/聚合複用原則#ChatGPT 的說明 合成/聚合複用原則（Composition/Aggregation Reuse Principle）通常簡稱為 CARP，是物件導向設計中的一個原則，它與繼承有關，但專注於透過「組合」（也就是『合成』或『聚合』）的方式來實現程式碼的複用，而不是透過「繼承」的方式來複用程式碼。具體來說，CARP 強調了物件之間的關係應該是 &amp;ldquo;鬆耦合&amp;rdquo; 的，以便更容易進行維護和擴展。如果要使程式維持鬆耦合的狀態，比起利用「繼承」關係，更應該多使用「合成」關係或「聚合」關係：［合成］英文為 composition，指的是一個物件包含了另一個物件作為其一部分，從屬物件的生命週期通常受主要物件的生命週期限制。如果一個物件是另一個物件的一部分，並且當主要物件被銷毀時，從屬物件也會被銷毀。另一種關係是［聚合］聚合的英文稱作 aggregation，是指一個物件包含了另一個物件，但從屬物件的生命週期並不受限於主要物件的生命週期。
與繼承相比，組合關係具有許多優勢，主要是因為它們提供了更靈活、低耦合和可維護的程式碼複用方式。主要的優勢如下：［靈活性］組合關係提供了更大的靈活性。透過使用組合關係的程式撰寫方式，使得程式可以在執行時動態地改變物件之間的關係，而不需要修改類別的結構。這允許系統更容易應對變化和需求的變更，而無需深度更改整個類別層次結構。［鬆耦合］繼承有時會導致緊密的耦合，因為子類別依賴父類別的實作細節，而組合關係則通常擁有 &amp;ldquo;鬆耦合&amp;rdquo; 的關係，因為父類別和子類別之間的依賴性較少。這降低了物件之間的耦合度，使得程式碼更容易理解、維護、和擴展。
［避免繼承的限制］繼承有時後會引入一些程式上的限制，例如單一繼承限制（一個類別只能繼承一個父類別）和父類別的不穩定性（如果父類別的實作發生變化，所有子類別都會受到影響）。組合關係不受這些限制，使得類別可以輕鬆地組合多個類別的功能。［可維護性］組合關係有助於提高程式碼的可維護性。當需要程式修改或擴充功能時，你只需要專注於特定的類別或元件，而不需要涉及整個繼承層次結構。這簡化了程式碼的維護過程。［測試和調試］使用組合關係的程式編寫方式，通常更容易進行單元測試和調試，因為可以更容易地模擬和隔離組件，而不會受到繼承關係的複雜性的干擾。［程式碼可讀性］組合關係通常會使程式更加簡潔、更加清晰、和更加易於理解，因為它們強調了物件之間的協作關係，而不是混雜在一起的層次結構。
簡單整理 多用組合、少用繼承
程式碼範例 組合型程式碼，指的是在建立比較複雜的物件的時候，選擇使用不同類型的小物件相互結合，不使用繼承的方式來小物件一步步變成大物件。而在說明這樣做有什麼好處之前，我們先說明一下什麼樣的組合方式叫做「合成」？什麼樣的組合方式叫做「聚合」？簡單來說：成員變數會跟著主要物件一起死去的就叫做「合成」，而成魚變數可以在主要物件死去之後，還繼續存在的，就叫做「聚合」，就像是下面的這個範例：
// 關於 &amp;#34;合成&amp;#34; (composition) 的範例 class Hmuan { // 私有變數 姓名 private String name; // 私有變數 人的各種器官（大腦、心臟、胃 ...等） private Brain brain; private Heart heart; private Stomach stomach; // 建構子 public Human(String name) { this.name = name; this.brain = new Brain(); this.heart = new Heart(); this.stomach = new Stomach(); } // 其他 Human 中的方法 .</description>
    </item>
    
    <item>
      <title>單一職責原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/single_responsibility_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/single_responsibility_principle/</guid>
      <description>單一職責原則#ChatGPT 的說明 單一職責原則（Single Responsibility Principle，簡稱 SRP）是物件導向程式設計和軟體設計的基本原則之一，該原則由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則強調一個類別（或一個模組）應該只有一個修改的理由。換句話說，一個類別應該只負責 個主要的功能或職責。SRP 的主要思想是將一個類別的職責限制在一個狹窄的範圍內，以確保類別的內部變化原因不會過多，從而提高程式的可維護性、可擴展性、和可讀性。當一個類別具有多個不同的職責時，它就會變得複雜、變得難以理解，並且容易因多個原因而需要修改，從而降低開發程式的效率。
以下是 SRP 的主要目標：［每個類別應該都只負責一個主要職責］一個類別的 &amp;ldquo;主要職責&amp;rdquo; 即是它的核心任務，該類別應該專注於執行這份任務，而不需要干預（或處理）其他不關核心任務的事情。［分離不同的職責］如果一個類別的 &amp;ldquo;主要職責&amp;rdquo; 可能包含多項不同面向的 &amp;ldquo;子職責&amp;rdquo;，設計師應該考慮將這些職責分離為不同的類別或模組，以確保每個類別只處理一個不與它類重合的職責。 ［職責的改變，不應影響到其他的職責］在前 2 點成立的情況下，當我們需要修改一個類別的內容時，我們就是在針對「一個」「特定的」功能進行調整，因此在理論上來說，該功能不應與其他功能產生衝突或影響。SRP 有助於保持代碼的可讀性和可維護性，並促使開發人員設計更小、更簡單的類別，從而降低代碼的複雜性。它也是其他設計原則和設計模式的基礎之一，有助於建立高質量的軟體系統。
簡單整理 簡單來說，SRP 在說的就是「一個類別，只負責一組類似的事情」
程式碼範例 情境思考：假設我們受某校的教務處所委託，需要製作一個針對學生使用的「簡易學生管理系統」，裡面需要針對「學生」這一項身份完成以下幾個功能：學生資料管理（包含增刪改查學生的各種資料），課程管理（提供學生加退選課程，查看課程細節），成績查詢（包含歷年成績、當學期成績、生成成績單&amp;hellip;等），以及文件下載（包含各式各樣的學校文件，諸如學費繳費單、各式申請書、或者各處室的相關文件&amp;hellip;等）。在最最不推薦的狀況下，我們可以寫出類似於下面的程式碼：
public class StudentManagementSystem { public void registerStudent(Student student) { // 修改學生資料 // 記錄學生的最後的更新時間 // 向學生的家長發送通知 // 向學生的導師發送通知 } public void enrollCourse(Student student, int courseId) { // 獲得學生資料 // 查詢學生的所有修課記錄 // 添加新課程 } public Student getGrades(int studentId) { // 查詢學生資料 // 查詢學生的所有修課記錄 // 查詢學生的各式成績 } public void downloadFiles(String fileName) { // 查詢某一份學校文件 // 生成該份文件的 PDF 檔 // 匯出 PDF } // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 } 從程式的邏輯和功能來說，這份程式並沒有太大的問題。所有的功能都可以順利運行，且相關的程式邏輯都很正確。如果把這份程式直接提交給教務處的話，我想他們應該也不會有什麼太大的問題或者是意見才對。但是，雖然一切的一切都很順利，這份程式碼還是有著一點小小的改善空間：也就是它並沒有符合「單一職責原則」所規範的內容：意即「一個類別，只可以由一種『原因』而改變」。</description>
    </item>
    
    <item>
      <title>單例模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/singleton_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/singleton_pattern/</guid>
      <description>單例模式#ChatGPT 的說明 單例模式（Singleton Pattern）是一種創建型設計模式，旨在確保一個類別只有一個實例，並提供一種存取該實例的全域方法。單例模式能確保無論在應用程式中哪個地方，都只會有一個實例化的物件，並且提供了對該物件的全域存取點。單例模式通常包含以下要素：私有建構子（Private Constructor）：單例類別的建構子通常是用 private 關鍵字進行封裝，這樣才可以確保其他類別無法直接實例化該類別的物件。私有靜態成員變數（Private Static Instance）：單例類別的內部會包含一個私有的靜態成員變數，用來儲存唯一的實例化的物件。公共靜態方法（Public Static Method）：單例模式的類別內部，也會包含一個公共的靜態方法，允許其他類別透過該方法取得單例物件。如果類別中的靜態成員變數為 null，那麼這個方法就會負責創建並回傳成員變數，但如果靜態成員變數不為 null，該方法則會直接回傳靜態成員變數的記憶體位址。
單例模式的主要目標有以下三點：分別是「確保該類別的物件在應用程式中，只有一個物件存在，從而節省系統資源。」「提供一個對成員變數的全域存取點，以便其他類別可以輕鬆存取該物件。」以及「避免多次建立相同類型的對象，以確保對象的一致性和資料共享。」通常來說，單例模式可能會在以下的幾種情境出現：［資源共享］：當多個部分需要共享某個資源（例如資料庫連線、thread pool &amp;hellip;等）時，可以使用單例模式確保只有一個資源實例［全域配置］：當應用程式需要一個全域配置對象，以儲存配置資訊，並在整個應用程式中共用時，可以使用單例模式。［日誌記錄器］：在應用程式中使用單例模式來建立唯一的日誌記錄器，以確保所有日誌資訊都被記錄到同一個日誌檔案中。［快取管理］：單例模式可用於建立快取管理器，以確保快取的一致性和共用。
簡單整理 問題描述：當某一個類別只需要一個物件的時候，該如何撰寫程式
解決方案：將建構子私有化，並透過靜態方法和靜態變數進行物件生成
程式細節：參照下面的段落
UML 圖：
程式碼範例 單例模式算是所有設的計模式當中，最好理解的一個。該模式的目的很明確：就是要確保「一個類別，只會生成一個物件。」那為什麼要確保一個類別只會生成一個物件呢？大多情況下是需要確保一些資料的一致性，像是在一個「資料庫系統」中，如果我們只有一個資料庫的話，可能就會希望這個「操縱資料庫」的物件是唯一的，不然如果發生一些並行的狀況，系統就會需要進行一些併發狀況的程式邏輯（像是事物隔離的邏輯判斷 &amp;hellip;等），使得整個程式變得更加複雜。
而實現單例模式的方法有很多，大致上可以歸類成 7 種不同的寫法，分別是：「final static variable」「static block initialization」「simple lazy initialization」「mutual exclusion」「double checked locking」「inner static class」和「enumerated type」。其中前 2 種為 Eager Singleton（中文譯做：餓漢式單例模式），中間 4 種為 Lazy intialization Singleton（中文譯做：懶漢式單例模式）。最後 1 種 &amp;hellip;就是 enum。
先從第 1 種做法講起：final static variable 顧名思義，就是在類別裡面宣告一個常數的、靜態的成員變數，透過存取類別中唯一且無法被更改的變數，來達到單例模式的程式需求。這種寫法可以保證多執行緒下仍然維持單一物件，但缺點是如果該變數本身是屬於比較複雜的物件的話，初始化可能需要花費比較多的時間，並且如果該變數在初始化之後一直都沒有被使用的話，它就會變得有點佔記憶體空間，寫法如下：
// 1. final static variable class Singleton { private final static Singleton INSTANCE = new Singleton(); private Singleton() {} public static Singleton getInstance() { return INSTANCE; } } 第 2 種方式是利用 Java 類別內的 static 區域，幫靜態成員變數做初始賦值，大致上跟方法 1 有著一模一樣的功能，差別只在於一個初始化的地方是寫在程式的變數後面，另外一個是寫在類別中的 static 區域。餓漢式單例模式的特點在於「會在系統初始化的最一開始，就為變數進行賦值」，因此無論是方法 1 還是方法 2，都有著 &amp;ldquo;系統初始化可能比較花時間&amp;rdquo; &amp;ldquo;可能很佔空間&amp;rdquo; 以及 &amp;ldquo;確保在多執行緒的環境下也能保持單例&amp;rdquo; 的優缺點。</description>
    </item>
    
    <item>
      <title>工廠方法模式</title>
      <link>https://fonu195713.github.io/docs/_trash/factory_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/factory_method_pattern/</guid>
      <description>工廠方法模式#ChatGPT 的說明 工廠方法模式（Factory Method Pattern）是一種創建型設計模式，它提供了一種創建物件的介面，但允許子類別決定要實例化的類別。這種模式的核心思想是「將物件的創建過程延遲到子類別中去實現。」從而達到物件的 &amp;ldquo;創建&amp;rdquo; 與 &amp;ldquo;使用&amp;rdquo; 分離，使得系統更加靈活和可擴展。工廠方法模式的主要組成部分包括以下角色：［抽象工廠］（Abstract Factory）：抽象工廠定義了一個抽象的工廠介面，包含一個用於建立產品物件的抽象方法。通常情況下，抽象工廠中可能會包含多個建立產品的方法，每個方法用於建立不同類型的產品。［具體工廠］（Concrete Factory）：具體工廠是實現抽象工廠介面的類別，負責創建具體產品。每個具體工廠對應於一種具體產品（或一組相關的特定產品）。［抽象產品］（Abstract Product）：抽象產品定義一個抽象的產品介面，通常包含了產品的通用方法或通用屬性。［具體產品］（Concrete Product）：具體產品是實現抽象產品介面的具體類別，用以表示不同類型的產品。
工廠方法模式的關鍵點是「透過將物件的創建委託給子類的具體工廠來實現。」這樣客戶端程式碼不需要直接依賴特定的工廠類型，而只需要依賴抽象工廠和抽象產品介面。這種方式使得系統更容易擴展，可以輕鬆添加新的工廠類型或變體，而無需修改現有的客戶端程式碼。以下是工廠方法模式的一些優點：［可擴充性］：使用工廠方法模式，可以透過建立新的特定工廠類別，來新增新的產品類型，而不影響現有的程式碼。［封裝性］：客戶端程式碼與特定的工廠類別解耦，只依賴抽象工廠和抽象產品接口，隱藏了具體產品的實作細節。［靈活性］：不同的具體工廠可以選擇不同的產品實現方式，以適應不同的需求和不同的環境。
簡單整理 問題描述：使用唯一的 Factory 可能會使該類別變得龐大
解決方案：透過建立 AbstractFactory 類別，讓 Factory 變得更加靈活
程式細節：參照下面的段落
UML 圖：
程式碼範例 貼心提醒：建議先看過簡單工廠模式會比較好。
工廠方法模式，算是比簡單工廠模式再更複雜一點的程式。那也因為這個模式跟簡單工廠很類似，所以我們就用同樣的例子繼續做解釋：在簡單工廠模式中，我們假設正在製作一個「資料庫操作程式系統」，並且有著幾個比較重要的類別：分別是代表使用者的 User、代表資料庫的 Database、以及代表工廠的 QueryFactory。User 可以透過 Database 裡面的方法（通常為靜態？），進行像是 INSERT, SELECT ..等不同的資料庫操作，而 Database 在接收到 User 的 query 之後，會再轉手交給 QueryFactory 負責解析，而 factory 則會根據 query 的不同，回傳不同的結果。
class User { public QueryResult query(String query) { QueryResult queryResult = Database.getQueryResult(query); return queryResult; } } class Database { public static QueryResult query(String query) { QueryResult queryResult = QueryFactory.</description>
    </item>
    
    <item>
      <title>工廠方法模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/factory_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/factory_method_pattern/</guid>
      <description>工廠方法模式#ChatGPT 的說明 工廠方法模式（Factory Method Pattern）是一種創建型設計模式，它提供了一種創建物件的介面，但允許子類別決定要實例化的類別。這種模式的核心思想是「將物件的創建過程延遲到子類別中去實現。」從而達到物件的 &amp;ldquo;創建&amp;rdquo; 與 &amp;ldquo;使用&amp;rdquo; 分離，使得系統更加靈活和可擴展。工廠方法模式的主要組成部分包括以下角色：［抽象工廠］（Abstract Factory）：抽象工廠定義了一個抽象的工廠介面，包含一個用於建立產品物件的抽象方法。通常情況下，抽象工廠中可能會包含多個建立產品的方法，每個方法用於建立不同類型的產品。［具體工廠］（Concrete Factory）：具體工廠是實現抽象工廠介面的類別，負責創建具體產品。每個具體工廠對應於一種具體產品（或一組相關的特定產品）。［抽象產品］（Abstract Product）：抽象產品定義一個抽象的產品介面，通常包含了產品的通用方法或通用屬性。［具體產品］（Concrete Product）：具體產品是實現抽象產品介面的具體類別，用以表示不同類型的產品。
工廠方法模式的關鍵點是「透過將物件的創建委託給子類的具體工廠來實現。」這樣客戶端程式碼不需要直接依賴特定的工廠類型，而只需要依賴抽象工廠和抽象產品介面。這種方式使得系統更容易擴展，可以輕鬆添加新的工廠類型或變體，而無需修改現有的客戶端程式碼。以下是工廠方法模式的一些優點：［可擴充性］：使用工廠方法模式，可以透過建立新的特定工廠類別，來新增新的產品類型，而不影響現有的程式碼。［封裝性］：客戶端程式碼與特定的工廠類別解耦，只依賴抽象工廠和抽象產品接口，隱藏了具體產品的實作細節。［靈活性］：不同的具體工廠可以選擇不同的產品實現方式，以適應不同的需求和不同的環境。
簡單整理 問題描述：使用唯一的 Factory 可能會使該類別變得龐大
解決方案：透過建立 AbstractFactory 類別，讓 Factory 變得更加靈活
程式細節：參照下面的段落
UML 圖：
程式碼範例 工廠方法模式，是比[簡單工廠]模式還要再複雜一點點的設計模式。主要的使用情境是「當單的 simple Factory 變得過於龐大」的時候。同樣拿簡單工廠模式中的「傢俱系統」作為例子：假設我們的家俱利統中，除了可以展示各種不同類別的傢俱之外，它可以針對不同的傢俱分類（像是金屬製、實木製、塑膠製 &amp;hellip;等）展示出更加細節的傢俱種類（像是實木桌、橡木桌、組合木桌、大理石桌、塑膠桌 &amp;hellip;等），此外每個傢俱都有自己的材質組合（衣櫃不會有玻璃的、床架只有木頭跟金屬的 &amp;hellip;等），如果我們還是用原本的簡單工廠模式來實作這項功能的話，可能會變成下面這個樣子：
class FurnutireFactory { // 靜態的 createFurniture() 方法 // 現在多了一個 [材質] 的參數 public static Furniture createFurniture(String material, String name) { Furniture furniture = null; if(name.equal(&amp;#34;chair&amp;#34;)) { if(material.equals(&amp;#34;Wooden&amp;#34;)) furniture = new WoodenChair(); else if(material.equals(&amp;#34;plastic&amp;#34;)) furniture = new PlasticChair(); else if(material.</description>
    </item>
    
    <item>
      <title>抽象工廠模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/abstract_factory_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/abstract_factory_pattern/</guid>
      <description>抽象工廠模式#ChatGPT 的說明
簡單整理
問題描述：當系統變得愈發龐大，即使將工廠進行抽象，也會導致程式高度耦合
解決方案：對 Factory 和 Product 同時進行抽象
程式細節：參照下面的段落
UML 圖：
程式碼範例 抽象工廠模式，是三個與「工廠」有關的設計模式中（簡單工廠模式、工廠方法模式、和抽象工廠模式），最為複雜的一個模式。也因此，在這三種設計模式當中，抽象工廠模式是使用在最為複雜的情境之中。我們同樣承接前兩個「工廠」中的情境，以一個傢俱系統作為例子：假設現在我們的系統除了需要呈現不同材質的傢俱之外，各種傢俱也有一些更微細項的分類，像是「床」有單人床、雙人床、單人床加大 &amp;hellip;等，書櫃有三層櫃、四層櫃 &amp;hellip;等，桌子也有分無抽屜、一個抽屜、兩個抽屜 &amp;hellip;等，如果同樣用工廠方法來處理的話，可能會變成下面這樣：
// 抽象類別 [傢俱工廠] abstract class FurnitureFactory { // 在 createProduct() 方法中加入一個 &amp;#34;description&amp;#34; 的參數 public abstract Furniture createFurniture(String name, String description); } // 繼承 [傢俱工廠] 的 [木製傢俱工廠] class WoodenFurnitureFactory extends FurnitureFactory { @Override public Furniture createFurniture(String name, String description) { Furniture furniture = null; if(name.equal(&amp;#34;bed&amp;#34;)) { if(description.equals(&amp;#34;single bed&amp;#34;)) furniture = new SingleBed(); else if(description.</description>
    </item>
    
    <item>
      <title>最少知識原則</title>
      <link>https://fonu195713.github.io/docs/_trash/least_knowledge_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/least_knowledge_principle/</guid>
      <description>最少知識原則#ChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 &amp;ldquo;朋友&amp;rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 &amp;ldquo;封裝&amp;rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。
此外在物件導向程式設計中，一個物件的 &amp;ldquo;朋友&amp;rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 &amp;ldquo;朋友&amp;rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 &amp;ldquo;朋友&amp;rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 &amp;ldquo;朋友&amp;rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 &amp;ldquo;朋友&amp;rdquo;。 需要注意的是，儘管可以與這些 &amp;ldquo;朋友&amp;rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。
簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。
程式碼範例 迪米特法則的核心是「盡量保持鬆耦合」的設計思想：當一個物件（或一個方法）需要透過很 &amp;ldquo;遠&amp;rdquo; 的呼叫，才可以完成某項功能時，就代表該物件對於呼叫中的所有東西都保持著依賴關係，那這時候，只要這一條依賴關係的任一截點出現問題，就都有可能導致功能的毀損，進而影響整個程式的運作。舉個例子：我們假設在一間上市公司中，從公司最大的「老闆」一路到最基層的「員工」有以下的這幾個階層：老闆（Boss）&amp;gt; 各部門的部處長（DepartmentDirector）&amp;gt; 專案經理（ProjectManager）&amp;gt; 員工（Staff）。然後今天老闆想要讓自己的公司網頁新增一項功能，他將這件事情告訴了 IT 部門的部處長，處長為此成立了一個「網站專案團隊」，並指派一位資深員工為專案經理讓他挑選幾位處理該專案的員工（Staff）來完成老闆所需的工作。如果在這樣的情況下，老闆想要追蹤一下這個網頁功能的更新，那可能會發生這樣的問題：
Log websiteInfo = boss.getDepartmentDirector(&amp;#34;IT&amp;#34;).getProjectManager(&amp;#34;web&amp;#34;).getStaff().getTaskLog(); 我們可以看到：光是 Boss 想要拿到一條「網站的更新紀錄」，就需要經過至少 3 ~ 4 個人的手，除了在實務的情況下，這麼做的效率可能有點低下之外，對於程式的撰寫來說，這種寫法也是挺有風險的，畢竟我們沒有辦法保證「呼叫上的所有方法即使產生了細節上的改變，程式也能完整運行」（例如 getProjectManager() 突然不用 &amp;ldquo;專案名稱&amp;rdquo; 做為參數，改用 &amp;ldquo;專案代號&amp;rdquo; 之類的），因此，迪米特法則告訴了我們「不要跟這麼多人講話」，也就是不要依賴過多的 &amp;ldquo;陌生人&amp;rdquo;。盡可能只透過，跟身邊的「朋友」聊天，就能拿到必要的資訊。降低方法間的相互調用，也就降低了「依賴於 &amp;lsquo;方法&amp;rsquo; 的一致性」，進而提升程式整體的品質，就是迪米特法則想要告訴我們的事情。
Log websiteInfo = boss.getInfo(&amp;#34;WebsiteUpdate&amp;#34;); 朋友 知道了法則想要傳遞的訊息之後，接下來就可以往下一步走了：哪些人、哪些東西、哪些物件、哪些方法才是所謂的「朋友」？一般來說，常見對於「朋友」的定義有以下四種：「類別本身的成員變數」「類別本身的方法」「父類別的所有成員與方法」「傳入方法中的所有參數」以及「在方法中建立的任何物件」。可以發現到朋友的類型可以根據是類別還是方法有所不同，這也是該原則比較特別的一個地方：不僅適用於類別的角度，也適用於方法的角度。
類別本身的成員變數 這個應該蠻好理解的？畢竟是「自己本身就有的東西」。「類別本身的成員變數」可以視為是一個自己的親近朋友，無論是 &amp;ldquo;基本資料型態&amp;rdquo;（像是 int, float, long, double &amp;hellip;等），或者是 &amp;ldquo;參考資料型態&amp;rdquo;（各種類別：諸如 Object, System, Boss, Staff, Library &amp;hellip;等），只要是類別自己有的東西，都可以視為自己的朋友，這點也包含所有的父類別、父父類別、父父父類別 &amp;hellip;等。</description>
    </item>
    
    <item>
      <title>最少知識原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/least_knowledge_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/least_knowledge_principle/</guid>
      <description>最少知識原則#ChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 &amp;ldquo;朋友&amp;rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 &amp;ldquo;封裝&amp;rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。
此外在物件導向程式設計中，一個物件的 &amp;ldquo;朋友&amp;rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 &amp;ldquo;朋友&amp;rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 &amp;ldquo;朋友&amp;rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 &amp;ldquo;朋友&amp;rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 &amp;ldquo;朋友&amp;rdquo;。 需要注意的是，儘管可以與這些 &amp;ldquo;朋友&amp;rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。
簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。
程式碼範例 「最少知識原則」又稱作「迪米特法則」（後面統一用『迪米特法則』稱呼～），該原則的核心思想是「盡可能地減少需要依賴的類別和方法」，它透過定義「朋友」與「非朋友」這兩種不同的關係，將類別與類別、方法與方法、或類別與方法之間的調用加以分類，進而減少對於過量類別和過量方法的嚴重依賴。我們一個簡單的例子來做說明：假設我們正在製作一個「資料庫管理系統」，裡面的其中一項功能是「Customer 可以修改 x 資料庫中， y 資料表的內容」簡單來說就是一個 UPDATE 方法，程式的實作方式如下：
// [使用者] 類別 class User { // 私有變數 system, 用來獲取 &amp;#39;資料庫系統&amp;#39; private DatabaseManagementSystem system; // update 方法，用來更新資料庫中的資料 public State update(String db_name, String table_name, String query) { // 首先利用 connectToSystem() 與資料庫系統建立連線 this.system.connectToSystem(this); // 接著利用 getDatabase() 來取得想要操作的資料庫 // 然後利用 getPermission() 取得資料庫得操作權限 // 再來利用 getTable() 獲取想要操作的資料表 // 最後利用 setQuery() 進行資料上的修改 return this.</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/template_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/template_pattern/</guid>
      <description>模板方法模式#ChatGPT 的說明 模板方法模式（Template Method Pattern）又稱作模板模式（Template Pattern）是一種行為型設計模式，該模式定義了一種演算法的骨架，並允許將特定步驟的程式細節延遲到子類別中實現。這個模式使得程式可以在不改變演算法結構的情況下，對演算法的某些步驟進行重新定義。模板方法模式在許多程式語言和框架中廣泛應用，它可以用於創建框架或函式庫，以便子類別可以自訂某些演算法的行為，同時保持整個演算法的一致性。
以下是模板方法模式的關鍵要素和工作原理：［抽象模板］（Abstract Template）：抽象模板是一個抽象類別或接口，它用於定義演算法的骨架，通常包含一個（或多個）不同的模板方法，這些模板方法是演算法的關鍵步驟。通常，抽象模板中的模板方法會呼叫一些抽象的（或可擴展的）方法，以便在子類別中具體實現。［具體模板］（Concrete Template）：具體模板是抽象模板的子類別，它用於實作抽象模板中的抽象方法，以定義演算法的具體行為。具體模板通常的功能在於實作抽象方法，而不需要改變演算法的整體結構。［模板方法］（Template Method）：模板方法是抽象模板中所定義的方法，它描述了演算法的步驟和順序。這些步驟可以包括一些已經實現的操作和一些需要在特定子類別中實現的操作。模板方法透過呼叫抽象方法來完成演算法的不同部分。［鉤子方法］（Hook Method）：鉤子方法是在抽象模板中定義的可選方法，子類別可以選擇性地覆寫它們來影響演算法的行為。這允許子類別在不改變整體演算法結構的情況下，對演算法進行擴展或自訂。
模板方法模式的優點包括以下 3 點：「透過提供特定的演算法的骨架，使得程式碼可以重複使用，減少了不同類別間的重複程式碼。」「允許在不改變整個演算法結構的情況下，讓使用者自訂特定步驟中的具體行為。」以及「提供了一種易於維護和擴展的程式設計方式。」
簡單整理 問題描述：相似的類別會有著相似的方法、內容、或呼叫順序
解決方案：透過建立一個通用的模板，讓不同類別可以使用相同模板，進而減少程式冗餘
程式細節：參照下面的段落
UML 圖：
程式碼範例 </description>
    </item>
    
    <item>
      <title>深入淺出設計模式</title>
      <link>https://fonu195713.github.io/docs/life/reading_experience/head_first_design_patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/reading_experience/head_first_design_patterns/</guid>
      <description>深入淺出設計模式#心得編寫日期：2023-07-07
書籍超連結
內文：
一直以來，我都對「設計模式」這個東西抱著若有似無的認知。具象一點說明的話，大概就是「知道『設計模式』是一種可以讓程式寫得更加漂亮、更有彈性的觀念和方法，但實際上這些觀念是什麼（我不知道），那些方法又該如和撰寫（我也不知道）」的狀況。然後在今年 5 月底左右吧？因為第二篇論文出現了一點卡關的狀況（文章的內容一直沒辦法寫成老師期望的那種感覺），也因為患有一點研究生症候群，就開始找手邊一些「一直以來都有興趣，但又找不到合適的時間去了解」的東西進行研究了。而這之中，【研究設計模式】剛好是其中之一。
這邊的 &amp;ldquo;研究設計模式&amp;rdquo; 是指「閱讀和設計模式相關的書籍」。這邊我挑的是《深入淺出設計模式》並不是閱讀比較主流的《Design Patterns: Elements of Reusable》也就是四人幫撰寫的那本）。會選擇那本書的其中一個原因是：剛開始的我，並不知道這本設計模式的聖經本，另一個原因則是它是我最快速能找到的相關書籍，所以就&amp;hellip; 這樣開始了。
雖然在四人幫的著作中，共列舉了 23 種常見的設計模式，但本書並沒有包含這麼多的內容。書中的 13 個章節裡，扣掉最後一個章節在介紹 MVC 架構（Model, View, Controller），以及倒數第 2 章在介紹不同模式的合併用法之外，其餘的 11 個章節依序僅介紹了 Strategy（策略模式）、observer（觀察者）、decorator（裝飾器）、factory（工廠模式，包含簡單工廠、工廠方法、和抽象工廠）、singleton（單例模式）、Command（命令模式）、Adapter（配適器）、Facade（外觀）、Template method（模板方法）、Iterator（迭代器）、Composite（組合模式）、State（狀態模式）、Proxy pattern（代理）&amp;hellip; 等。剩餘的模式則僅於書中的附錄稍作提及。但這並不代表這本書不是一本良好的教學素材。相反地，因為本書的撰寫方式有別於市面上大多數的教學書籍，採用了極大量的圖片、角色對話、與情境式的描述，為各種模式的優缺點、應用情境、特徵、使用方法做大量的說明，同時也附上了許多的觀念思考、練習題、與程式範本，因此在閱讀上，並不會出現常見的倦怠、疲憊、或單調的感覺。
整體而言，這本書帶給我很多新的啟發，無論是程式的撰寫方式，例如「多用組合、少用繼承」「單一類別、單一職責」「依賴通用接口，不要依賴特定類別」&amp;hellip; 等，或者是各種不同模式的應用與架構「工廠模式可以讓物件的實例化延後至子類別中實現」「模板方法只關心演算法的骨幹，因此可以在不改變演算法結構的前提下，重新定義某些方法的執行細節」「單例模式可以讓類別只生成單一物件，以確保某些資源的分配不會遇到問題或錯誤」&amp;hellip; 等，抑或是程式的語法觀念，像是「C++ 的物件繼承，菱形繼承的問題與解決」「虛函數, 純虛函數」&amp;hellip; 等，都是在閱讀本書之後才有了一個更加明確與更加清晰的認識。雖然是在一個比較非主動的動機下，才開始閱讀本書，但整體而言，能夠「閱讀本書，並從書本當中學到了更多的知識」對我來說實在是一件很高興又很喜歡的事情。
評分
閱讀難度：★★★☆☆ （需要有基本的物件導向程式觀念） 推薦指數：★★★★★ </description>
    </item>
    
    <item>
      <title>照抄妖精的尾巴</title>
      <link>https://fonu195713.github.io/docs/creation/novel/note/0_hand_paper/copy_fairy_tail/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creation/novel/note/0_hand_paper/copy_fairy_tail/</guid>
      <description>照抄妖精的尾巴#序場（開頭定調）
暗示主角即將遭遇巨大的危險 預告故事的未知比觀眾想像的還要未知 由一群地位很高（或實力很強）的人來鋪墊主角群 王道情節：「成長」的故事
「厲害的人」可以是好人或壞人
主角可以是好人、麻煩的人、或（暫時的）壞人
舉例：用序場墊高主角的做法
一群壞魔法師， 他們最想解決的不是魔法協會 而是小小的魔法組織 因為他們有預感 這個小團體才是未來最大的威脅 &amp;hellip; 魔法監獄要處死魔法界的大惡人 麼法協會會長第一次親自來到行刑現場 因為要處死的人當中有主角 而會長打算赦免主角 &amp;hellip; 墊高之後需要顧及的兩件事情
幫角色添加反差 序場是故事的定調 幫角色做反差
可以讓會長/主角當作純粹的好/壞人 可以在好壞上面做反差（大家以為他很好，但其實他很壞） 可以拿來做反差的東西：性格、背景、招式、外貌 用登場方式幫角色做反差： 墊高角色之後，先往下拉，展現出角色的弱 看上主角什麼能力，就先讓主角在那個能力上翻車 用配角呼應主角
讓配角的登場方式與主角相互關聯 烏斯懷亞怕水 vs. 西米來到港口找護船人 主/配角因某事而相遇 在某個事件（困境）裡，其中一方受到另一方的幫助 因此產生交集 補充：困境最好跟故事/主題本身有關 磨合段落
角色沒有主要行動 行為、地點、要素的限制較少 可以不用先想，自由度高 最後面的情節
配角「被騙」，遭遇某個困境 困境如果可以呼應主角的「弱」會更好 主角出面解決問題 在這邊反轉「主角很弱」這個印象 結尾接回序場 做主角的二次墊高（因為他們，使得xx得以安分） 拋出伏筆（因為他們擁有某種 &amp;ldquo;力量&amp;rdquo;） </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/19</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231019/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231019/</guid>
      <description>番茄鐘工作紀錄 2023/10/19#Youtube：《故事的解剖》深度導讀 - 01 Youtube：《故事的解剖》深度導讀 - 01、借閱《故事的解剖》和《45個人格原型》 閱讀《故事的解剖》中的 01（故事面臨的難題：品質、技藝、課題、天賦） 閱讀《故事的解剖》中的 02（故事設計的相關術語：結構、事件） 閱讀《45個人格原型》中的第 1 部，並編寫筆記 閱讀《45個人格原型》中的魅惑繆思、亞馬遜女戰士、父之女、和養育者 閱讀《45個人格原型》中的女族長、神秘客、女救世主、和天真少女 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/20</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231020/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231020/</guid>
      <description>番茄鐘工作紀錄 2023/10/20#抄寫般若波羅密多心經，Gooaye EP.95 抄寫般若波羅密多心經，Gooaye EP.96 抄寫般若波羅密多心經，Gooaye EP.97 抄寫般若波羅密多心經，Gooaye EP.98（前半） 複習 0 號手稿「照抄妖精的尾巴」的內容，同時重新寫筆記 構思小說女主角的人物、形象 &amp;hellip;等設定 - 1（未完成） 構思小說女主角的人物、形象 &amp;hellip;等設定 - 2（未完成） 構思小說女主角的人物、形象 &amp;hellip;等設定 - 3（未完成） 構思小說女主角、男主角、女配角的性格、形象 &amp;hellip;等設定（未完成） 構思小說女主角、男主角、女配角的性格、形象 &amp;hellip;等設定（未完成） 構思小說第一章的內容（未完成） </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/20</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231022/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231022/</guid>
      <description>番茄鐘工作紀錄 2023/10/20#重構 nccu_project（程式外觀） 重構 nccu_project（程式外觀） 構思小說第一章情節（未完成） 構思小說第一章情節（未完成） 構思小說第一章情節（未完成） </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/21</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231021/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231021/</guid>
      <description>番茄鐘工作紀錄 2023/10/21#重構 nccu_project/index.php（未完成） 重構 nccu_project/index.php（完成） 構思小說第一章的故事主題（未完成） 構思小說第一章的故事主題（未完成） 構思小說第一章的故事主題（初稿完成） 構思小說第一章的故事主題（修改中/未完成） 構思小說第一章的故事主題（完成） </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/23</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231023/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231023/</guid>
      <description>番茄鐘工作紀錄 2023/10/23#抄心經，Gooaye Ep.99 抄心經，Gooaye Ep.100 抄心經，Gooaye Ep.101 重新建構故事第一章（未完成） 重新建構故事第一章（未完成） </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/24</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231024/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231024/</guid>
      <description>番茄鐘工作紀錄 2023/10/24#抄心經，Gooaye Ep.102 抄心經，Gooaye Ep.103 抄心經，Gooaye Ep.104 幫大頭跟彪哥解決網站的問題 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/25</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231025/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231025/</guid>
      <description>番茄鐘工作紀錄 2023/10/25#抄心經，0 號手稿技術面分析 抄心經，0 號手稿技術面分析 抄心經，0 號手稿技術面分析 幫大頭跟彪哥解決網站的問題 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/26</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231026/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231026/</guid>
      <description>番茄鐘工作紀錄 2023/10/26#學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/27</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231027/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231027/</guid>
      <description>番茄鐘工作紀錄 2023/10/27#幫大頭解決 apache 連不到 MySQL 的問題 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 思考小說的架構與情節 思考小說的架構與情節 思考小說的架構與情節 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/28</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231028/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231028/</guid>
      <description>番茄鐘工作紀錄 2023/10/28#學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 教大頭 git command, ocp (Open Close Principle) 教大頭 git command, ocp (Open Close Principle) </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/29</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231029/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231029/</guid>
      <description>番茄鐘工作紀錄 2023/10/29#學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 幫大頭解決 git 的相關問題 幫大頭解決 git 的相關問題 幫大頭解決 git 的相關問題 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/30</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231030/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231030/</guid>
      <description>番茄鐘工作紀錄 2023/10/30#2502 meeting 2502 meeting 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/10/31</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202310/20231031/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202310/20231031/</guid>
      <description>番茄鐘工作紀錄 2023/10/31#陪阿公復健、圖書館借書 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/11/01</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202311/20231101/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202311/20231101/</guid>
      <description>番茄鐘工作紀錄 2023/11/01#學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 幫大頭解決 Ubuntu 中， MySQL 無法和 PHP 溝通的問題 學習 Angular2+ (Angular)，參考 Youtube：凱哥寫程式 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/11/03</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202311/20231103/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202311/20231103/</guid>
      <description>番茄鐘工作紀錄 2023/11/03#抄心經，Gooaye Ep.105 抄心經，Gooaye Ep.106 嘗試用 Sprinig boot 做一個 backend api 研究 maven 的用法、嘗試用 Sprinig boot 做一個 backend api 嘗試了解 maven, gradle 的差異 練習 gradle.kts 練習 gradle.kts 練習 gradle.kts </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/11/04</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202311/20231104/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202311/20231104/</guid>
      <description>番茄鐘工作紀錄 2023/11/04#練習利用 gradle.kts 生成一個 java application。參考 呈上。撰寫模板方法模式的內容 撰寫模板方法模式的內容（說明、整理） 模板方法模式、gradle、小說內容 了解軟體設計模式，參考資料：YT - 水球軟體學院 了解軟體設計模式，參考資料：YT - 水球軟體學院 了解軟體設計模式，參考資料：YT - 水球軟體學院 抄心經，聽 YT：遊戲微服務計畫 抄心經，聽 YT：遊戲微服務計畫 抄心經，聽 YT：遊戲微服務計畫 </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/11/05</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202311/20231105/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202311/20231105/</guid>
      <description>番茄鐘工作紀錄 2023/11/05#研究 gradle 的運作流程，參考：Medium 文章：Gradle 的系列文章，學 jUnit test 5 研究 gradle 的運作流程，參考：Medium 文章：Gradle 的系列文章，學 jUnit test 5 利用 gradle 和 spring boot 建制出一個簡單的本地後端 api。參考：spring boot 教學 利用 gradle 和 spring boot 建制出一個簡單的本地後端 api。參考：spring boot 教學 了解 TDD, BDD, MVC, MVP &amp;hellip;等不同的軟工術語 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 抄心經，聽 YT：在地上滾的工程師 Nic </description>
    </item>
    
    <item>
      <title>番茄鐘工作紀錄 2023/11/06</title>
      <link>https://fonu195713.github.io/docs/life/pomodoro/202311/20231106/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/pomodoro/202311/20231106/</guid>
      <description>番茄鐘工作紀錄 2023/11/06#監考，雅芬老師的數位邏輯 監考，慧鳳老師的管理數學 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 閱讀Clean Architecture - 無瑕的程式碼 編寫閱讀心得：Clean Architecture - 無瑕的程式碼 編寫閱讀心得：Clean Architecture - 無瑕的程式碼 </description>
    </item>
    
    <item>
      <title>第一章重點</title>
      <link>https://fonu195713.github.io/docs/creation/novel/note/story/ch01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creation/novel/note/story/ch01/</guid>
      <description>第一章重點#善良的背面一定是邪惡嗎？
英雄就是要摧毀邪惡？還是號召善良？
聖人是什麼？
用某一個片刻來呈現角色過往的一切</description>
    </item>
    
    <item>
      <title>簡單工廠模式</title>
      <link>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_1/</guid>
      <description>簡單工廠模式#ChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。
簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。
簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 &amp;hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。
簡單整理 問題描述：Client 對於 Product 有著高度的依賴
解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴
程式細節：參照下面的段落
UML 圖：
程式碼範例 在常見的設計模式裡面，跟「工廠」有關的設計模式共有三種，分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過一個工廠，來簡單地改寫程式碼的一種設計模式。讓我們來想像一種情境：假設我們正在製作一個「繪製不同圖型」的程式，裡面有一個一個用來繪製圖形的畫布 Canvas，以及一些預設的可繪製圖形 Circle, Square, Rectangle, Triangle, 和 Polygon &amp;hellip;等。我們首先假設所有的圖形都繼承於 Shape 類別，我們也假設只要呼叫 Canvas 裡面的 addShape() 方法，並透過傳入的 String 參數，該方法就會幫我們繪製圖形，如下所示：
// 抽象父類別 [形狀] abstract class Shape {} // 各種繼承 [形狀] 的子類別們 class Circle extends Shape {} class Square extends Shape {} class Rectangle extends Shape {} class Triangle extends Shape {} class Polygon extends Shape {} // 繪圖類別 `Canvas` class Canvas { public void addShape(String shape) { // 建立圖形變數 &amp;#39;shape&amp;#39; Shape shape = null; // 把 &amp;#39;shape&amp;#39; 變成我們預設的其中一種形狀 if(shape.</description>
    </item>
    
    <item>
      <title>簡單工廠模式</title>
      <link>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_2/</guid>
      <description>簡單工廠模式#ChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。
簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。
簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 &amp;hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。
簡單整理 問題描述：Client 對於 Product 有著高度的依賴
解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴
程式細節：參照下面的段落
UML 圖：
程式碼範例 在常見的設計模式裡，跟「工廠」有關的設計模式共有三種。它們從簡單到複雜分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過生成一個「簡單的」工廠，來分離不同職責的程式碼，讓程式可以達到更好的靈活性、可讀性，和良好的封裝性。讓我們用一個簡單的例子來做說明：假設我們現在正在撰寫一個「資料庫操作程式系統」，該系統需要包含一些使用者對於資料庫的簡單操作，像是 SELECT, UPDATE&amp;hellip;等，在不使用簡單工廠模式的情況下，程式可能會寫成像是下面的這個樣子：
// 資料庫系統中的 [使用者] 類別 class User { private Database database; private String account; private String password; public User(String account, String password) { this.account = account; this.password = password; } public QueryResult query(Database.operation operation, String query) { this.database = this.</description>
    </item>
    
    <item>
      <title>簡單工廠模式</title>
      <link>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/simple_factory_pattern_3/</guid>
      <description>簡單工廠模式#ChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。
簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。
簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 &amp;hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。
簡單整理 問題描述：Client 對於 Product 有著高度的依賴
解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴
程式細節：參照下面的段落
UML 圖：
程式碼範例 在常見的設計模式當中，跟「工廠」有關的設計模式共有三種，它們從簡單到複雜分別是簡單工廠模式、工廠方法模式、和抽象工廠模式。簡單工廠模式顧名思義，就是透過一個結構「簡單」的工廠，來將程式碼拆分，以提高程式系統的可讀性、靈活性、和可擴展性。讓我們以一個簡單的例子來做說明：假設我們現在需要製作一個「網站架設系統」，該系統需要包含一些關於前後端的程式內容，而其中一項功能的描述如下：「使用者可以透過輸入不同的 SQL 語句，來取得不同的資料庫內容。」用程式來呈現的話，可能會像這個樣子：
// 架站系統中的 [客戶端] 類別 class Client { private String account; private String password; public Object getDatabaseData(String query) { Database database = this.getDatabaseConnection(account, password); Object data = null; Database.Operation operation = database.getOperation(query); switch(operation) { case Database.Operation.INSERT: data = database.insertQuery(query); break; case Database.</description>
    </item>
    
    <item>
      <title>簡單工廠模式</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/simple_factory_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/simple_factory_pattern/</guid>
      <description>簡單工廠模式#ChatGPT 的說明 簡單工廠模式（Simple Factory Pattern）是一種創建型設計模式，屬於工廠模式的變體。它旨在提供一個通用的、用於創建物件的接口，而隱藏創建物件的具體細節。簡單工廠模式由三個主要部分組成：［客戶類別］（Client class）：客戶是使用工廠模式的程式碼部分。客戶透過呼叫簡單工廠裡的公開方法（例：getProduct()），請求工廠創建具體產品的物件。［工廠類別］（Factory Class）：工廠類別負責生成具體的物件。這個類別通常包含一個（或多個）靜態方法，根據輸入的參數或條件建立不同類型的物件。[具體產品類別]（Concrete Product Class）：具體產品類別是簡單工廠最後會產出的物件，工廠類別透過判斷條件或參數來建立不同的特定產品物件。（可選）［抽象產品類別］（Abstract Product Class）：在某些簡單工廠中還會定義一個抽象產品類別。該類別定義了產品物件的通用接口，它是所有特定產品類別的共同父類別或介面。
簡單工廠模式的步驟如下：首先，定義一個抽象的產品類，讓該類別定義一些產品的共同介面或抽象方法，或者直接建立具體的產品類，實作抽象產品類別的介面或方法，定義具體產品的屬性與行為。接著，建立一個工廠類別，該工廠類別可以包含一個靜態方法或非靜態方法，根據輸入參數或條件建立並傳回特定產品的實例。最後，客戶端可以透過呼叫工廠類別的靜態（或非靜態）方法來取得所需的具體產品實例。
簡單工廠模式包含著幾個優點：它可以封裝物件的建立過程。透過簡單工廠模式，客戶端可以在「不需要知道物件的具體建立細節」的前提下獲得物件。降低了客戶端與特定產品類別之間的耦合度。除此之外，這種做法也提升了程式的靈活性，因為客戶端只需要依賴於工廠所提供的方法或介面即可，不需要依賴任何的具體產品。再來，工廠可以根據不同的需要，動態切換回傳給客戶的具體產品類，而不影響需要客戶端的程式碼 &amp;hellip;。然而，簡單工廠模式還是有著一些缺點的：例如每次增加新的產品類型時，都需要修改工廠類，違反了開放封閉原則。除此之外，在一些複雜的場景下，可能會導致簡單工廠需要負責過多的產品細節，使得類別變得過與旁大過於臃腫，進而違反單一職責原則。
簡單整理 問題描述：Client 對於 Product 有著高度的依賴
解決方案：透過建立一個 Factory 類別，解決客戶與產品間的依賴
程式細節：參照下面的段落
UML 圖：
程式碼範例 在常見的設計模式當中，與「工廠」有關的設計模式共有三種，它們由間單到複雜依序是簡單工廠模式、工廠方法模式、以及抽象工廠模式。簡單工廠模式顧名思義，就是透過一個「工廠」類別，將比較「簡單的」程次區域給獨立出來，通常會配合單一職責原則進行程式碼的檢查，如果某一段程式不符合單一職責原則的話，就可以考慮用簡單工廠將程式給區分出來。讓我們用一個簡單的範例來做說明：假設我們正在開發一個「線上傢俱閱覽系統」，使用者可以根據不同的需要來瀏覽、比較、或購買傢俱，程式片段大致如下所述：
// 系統中的 [顧客] 類別 class Customer { private String account; private String password; // 透過不同的關鍵字，取得不同傢俱 public Furniture getFurniture(String name) { Furniture furniture = null; if(name.equal(&amp;#34;chair&amp;#34;)) furniture = new Chair(); else if(name.equals(&amp;#34;desk&amp;#34;)) furniture = new Desk(); else if(name.equals(&amp;#34;sofa&amp;#34;)) furniture = new Sofa(); else if(name.</description>
    </item>
    
    <item>
      <title>記帳 2023/08</title>
      <link>https://fonu195713.github.io/docs/life/track_expenses/202308/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/track_expenses/202308/</guid>
      <description>記帳 2023/08#各方面金流
台幣活存：4098 台股股票淨值：19278 借貸狀況： 借出共 143,500 + 50,000 元 貸款共 0 元 保險： 儲蓄型保單收到了 2 元的回饋 備註
因為信用卡還沒開辦的原因，所以個人的信用評分應該還算是很低很低。加上現在還是處在比較高利的情況，所以我不打算去做一些跟信貸有關的相關操作。因此貸款的數字是 0。另外借出約 20 萬左右的金額，主要是由兩個人所組成，預計會在近 1-2 年內回收完畢吧？如果到時候還沒回收的話，可能就會採取比較激進一點的行動方針。
活存的部分 &amp;hellip;只能說相當可怕啦。下個月的花錢必須要非常拮据與謹慎，不然一不小心就會直接死給大家看了。台股的淨值大約是 20k，它是我 4 個月定期應額 006208 的小小成果，基本上台股的部分不會有太多的更動，它就會是一個每個月固定 5000, 5000 投入的狀況。不打算做一點短線的投機，次要原因是目前沒有甚麼了解的標的在低檔位的股價，主要原因是沒有多餘的閒錢 （哭）
大概是這樣，目前看來沒什麼大問題，除了活存的數字真的是有夠少之外 &amp;hellip;。整體而言，自評的話大概會給 57-58 左右吧？滿分是 100 分。不及格的部分是活存水位過低、沒有緊急預備金。但剩下的 &amp;hellip; 我覺得基本上沒有大問題，但這　1-2　個月要好好調整自己的用錢習慣就是，畢竟已經沒有研究室的研究補貼了，算命的收入要想辦法拉高一點。</description>
    </item>
    
    <item>
      <title>記帳 2023/09</title>
      <link>https://fonu195713.github.io/docs/life/track_expenses/202309/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/track_expenses/202309/</guid>
      <description>記帳 2023/09#各方面金流
資產的部分 台幣活存 31,222 元 台股股票淨值：28,964 元 借出共 143,500 元 負債的部分 貸款共 157,000 元 備註
這禮拜活存大概暴增了 3-4 萬有，是因為上個月有一筆的 5 萬的借款拿回來了。股票淨值多了大約 10k，是因為這個月多買了一次 5000 的零股，但台股的錢基本上不會去動啦，畢竟是 006208 的定期定額 &amp;hellip;。另外有一筆借出約 15 萬左右的款項被我劃掉了，因為那筆借貸目前在法院的訴訟中，但我覺得有高機率拿不回來 XDD，所以就先當沒這筆錢，因此目前的總資產大約落在 55-60 k 左右。
負債的部分 &amp;hellip; 最近妹妹不小心被人騙錢了 XD 大概被騙了 15 萬左右，身為哥哥，當然就是全扛下來啦～雖然寫是寫「負債」，但比較像是「這筆錢妳就當我先跟妳借的，我再慢慢還妳」的那種感覺，所以比較像是無期限(? 的 0 利率貸款，超划算對吧～哈哈哈哈，不過之後還是要慢慢還就是了。</description>
    </item>
    
    <item>
      <title>記帳 2023/10</title>
      <link>https://fonu195713.github.io/docs/life/track_expenses/202310/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/life/track_expenses/202310/</guid>
      <description>記帳 2023/10#各方面金流
資產的部分 台幣活存 23,368 元 台股股票淨值：33,297 元 借出共 143,500 元 錢包現金 2,977 元 負債的部分 貸款 157,000 元 備註
這禮拜基本身上的錢沒什麼變化。定期定額仍然轉了大約 5,000 在 006208 上面，算命收到了大概 500-1000 左右的零用錢，家裡因為在大部分的情況下會幫我備餐，所以吃的錢幾乎沒什麼花到，然後借出的錢嘛 &amp;hellip;，雖然法院有寄強制執行的單子過來，但我猜帳戶大概率是沒錢啦？不過這兩天會去問看看、試試運氣。（雖然我還是打從心底覺得是我的錢終究會回到我身上就是了 XD）
這個月有個 &amp;hellip;比較有趣的點？雖然最近沒在注意股市，不過 006208 的價格在這 1-2 個月越來越低了，這幾天應該會順便研究一下價格掉下來的原因？然後找個機會逢低加碼一些錢錢進去，算是早早存股、早早滾錢，預計多放個 3000-5000 進去？如果繼續跌的話，預計放進去的錢會再多一點。</description>
    </item>
    
    <item>
      <title>里氏替換原則</title>
      <link>https://fonu195713.github.io/docs/_trash/liskov_substitution_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/liskov_substitution_principle/</guid>
      <description>里氏替換原則#ChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。
LSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。
這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。
簡單整理 簡單來說：父類別沒有的，子別類不一定要有，但是父類別有的，子類別都一定要有
程式碼範例 里氏替換原則討論的是關於類別（或介面）發生繼承時，應該遵守或者是留意一個規範或想法。大致上的重點在於「子類別應該完全實現父類別的想法」「子類別可以對付類別的想法作出補充」以及「子類別應該遵循與父類別一致的規則」這句話上面。簡單來說就是「父類別的擁有和要求，子類別都要做到」但「父類別沒有要求的，子類別可以不用做到」這兩句話上。
自己稍微唸了一下，感覺還是有點饒口，直接用一個範例程式碼來做舉例好了：假設我們現在受到了某某大型運輸公司的委託，需要製作一個該公司的「交通工具查閱系統」，裡面需要包含一些常見的交通工具的相關資訊，像是汽車、船、機車、公車、腳踏車、直升機、飛機 &amp;hellip;等，在最最直觀的情況下，我們可以把所有的交通工具都寫成互不相關的獨立類別，就像是下面的這個樣子：
class Car { String id; String type; public void driving() { System.out.println(&amp;#34;在馬路上行駛&amp;#34;); } // 其他跟[汽車]有關的方法 // 其他跟[汽車]有關的方法 } class Boat { String id; String type; public void sailing() { System.out.println(&amp;#34;在河道或海中航行&amp;#34;); } // 其他跟[船]有關的方法 // 其他跟[船]有關的方法 } &amp;hellip;（還有其他好多類型的交通工具）
class Helicopter { String id; String type; public void flight() { System.</description>
    </item>
    
    <item>
      <title>里氏替換原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/liskov_substitution_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/liskov_substitution_principle/</guid>
      <description>里氏替換原則#ChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。
LSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。
這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。
簡單整理 父類別的方法，如果換成子類別來做，應該要得出一樣的結果
程式碼範例 在所有的設計原則中，里氏替換原則應該是最難懂的（至少在我自己理解的過程中 XD），作為設計原則中的其中一項原則，里氏替換原則所討論，是關於類別與類別間的繼承（inherit）和改寫（override）的問題。里氏替換原則的核心，就是在確保簡單整理中的那句話：「父類別的方法，如果換成子類別來做，應該要得出一樣的結果。」也就是說，如果在一個程式裡面我們看到了 Parent.method(arg) 這樣的語句。里氏替換原則要求的，就是希望如果我們寫成 Child.method(arg) 時，程式同樣也可以呈現出原本的結果，不應該換了一個子類別執行，程式的結果就發生改變。
更仔細一點的說，雖然我們在學習的過程中，被告知了「『繼承』即是包含了 is-a 的概念的兩個類別」，但該原則告訴了我們：嚴格一點來說，我們並不能夠單純地因為 A is-a B，就讓 A 跟 B 使用繼承（像是正方形 is-a 矩形，企鵝 is-a 鳥類 &amp;hellip;等），在使用繼承的時候，應該要更加嚴謹，更加小心。里氏替換原則包含以下幾個想法：子類別的參數數量和順序應該與父類別完全相同、子類別的前置條件不應該比父類別嚴格、子類別的後續條件不應該比父類別寬鬆、以及在父類別中沒有被改變的參數，子類別也應該對其保持不變。
我們用一個簡單的例子，快速了解這之中的差別：在數學的定義上，我們可以知道「矩形」是四個角都是直角的四邊形，「正方形」是四個角都是直角、且四個邊都有相同長度的四邊形。因此，在數學的分類上，我們可以說「正方形是一種矩形」也就是「Sruare is a Rectangle」，那在程式上，我們同樣也能說出「Sruare is a Rectangle」嗎？讓我們用程式來觀察觀察，我們先假設正方形是長方形的一種：
// 長方形 class Rectangle { protected int width; protected int height; // 建構子 public Rectangle() {} // 長方形的 setter (getter 就先省略了) public void setWidth(int width) { this.</description>
    </item>
    
    <item>
      <title>開放封閉原則</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/open_closed_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/open_closed_principle/</guid>
      <description>開放封閉原則#ChatGPT 的說明 開放封閉原則（Open-Closed Principle，OCP）是物件導向程式設計中的一個重要原則，由著名的軟體工程師貝瑞·波 (Bertrand Meyer) 在他的著作《Object-Oriented Software Construction》中首次提出。該原則強調軟體實體（例如類別、模組、函數 &amp;hellip;等）應該對擴展保持開放，對修改保持封閉。這樣做可以實現程式碼的可擴展性和可維護性。具體來說，開放封閉原則有以下兩個重要概念：首先是［開放性］：開放性表示軟體應該在不需要修改現有程式碼的前提下，允許新增新的功能或新的特性。當系統需要新增功能時，應該通過擴展現有的實體，而不是修改原有的程式來完成。這有助於防止對現有程式碼的不必要修改，降低了引入錯誤的風險。其次是［封閉性］：封閉性說明程式實現某一功能後，程式本身應該被封閉，即不應該再對其內容進行修改。當一個實體達到預期的功能時，應該停止對它的修改，而是應該通過擴展或建立新的實體來添加新功能。
開放封閉原則的優勢包括下列幾項：首先是可擴展性，當需要新增功能時，開發人員可以通過創建新的子類別、新的模組或擴展介面來實現，而不需要修改原有的程式碼，這有助於降低風險，並維護程式碼的穩定性。其次是可維護性，因為不需要經常修改原有的程式碼，所以程式碼變得更容易維護。每個功能都位於獨立的模組、類別、或者介面之中，使得錯誤的追蹤與修復能變得更加容易。此外程式的重用性也會被提高，因為功能被分割成獨立的實體，我們可以更容易地重用這些已經撰寫完成的程式碼，這有助於提高程式的效率和一致性。
簡單整理 OCP 在說的就是：寫好的程式需要有『容易擴展』和『不再需要更改』兩種特性
程式碼範例 開放封閉原則算是一個蠻好理解的設計原則，基本上就是「寫好的程式碼，盡量保持在不需要頻繁編輯的狀態」跟「寫好的程式碼，要容易被後來的程式碼飲用或擴充」這兩句話。用一個比較常見的舉例方式來解釋的話，讓我們考慮以下的情境：假設我們需要撰寫一支程式，該程式需要能夠透過不同參數，生成不同的圖形（圓形、正方形、長方形 &amp;hellip;等），並且程式也要能夠計算該圖形的面積。如果不使用開放封閉原則的話，可能會寫出以下的程式：
// 定義各種不同的圖形 class Circle { Double radius; public Circle(Double radius) { this.radius = radius; } } class Square { Double sideLength; public Square(Double sideLength) { this.sideLength = sideLength; } } class Rectangle { Double width; Double height; public Rectangle(Double width, Double height) { this.width = width; this.height = height; } } // 定義一個用來計算圖形面積的類別 class AreaCalculator { public Double getArea(Object shape) { if(shape instanceof Circle) return ((Circle)shape).</description>
    </item>
    
  </channel>
</rss>
