<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Fonu Site</title>
    <link>https://fonu195713.github.io/</link>
    <description>Recent content in Introduction on Fonu Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://fonu195713.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>（據透）小說世界觀</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/note/worldview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/note/worldview/</guid>
      <description>（據透）小說世界觀#在一個被遺忘的世界中，主人公必須挖掘過去的信仰和傳說 以填補內心的空虛，並拯救世界的命運。
世界上總共有 7 位神明，分別為火、土、風、水、天、地、無 眾神們創造世界，無神負責重製世界（為了平衡與新鮮感） 主角需要打破「無神重製世界」的這一個約束，以保護所心愛的人事物 第一步：序場（開頭定調故事）#故事情節：
主角生活在一個及不起眼的小村莊內，樸實地生活著 有一天，村莊外圍突然出現了一群高強的「&amp;hellip;」 為了擊退來犯的「&amp;hellip;」，【妖精】展現出了過人的力量來解決這個危機 【妖精】告誡大家離開，但為時已晚，「龍」來到了村莊 「龍」殺掉了主角、主角的奶奶和其他村莊內的所有人 頻死之際，主角被「ooo」救活了 主要疑問：
「&amp;hellip;」是什麼？為什麼會攻擊村莊 「龍」是誰？為什麼要殺掉主角的奶奶 「ooo」又是誰？為什麼要救主角 解答：#</description>
    </item>
    
    <item>
      <title>［置頂］0 號手稿的筆記</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/notebook/note_of_manuscript_0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/notebook/note_of_manuscript_0/</guid>
      <description>［置頂］0 號手稿的筆記#衝突或反差：背景、遭遇、招式、能力、外表、性格（同時有強有弱）。人際、感情觀、個人能力
情節 + 情節 + 情節 = 分場（艾斯被抓、白鬍子、背叛、救到、黑鬍子） 分場 + 分場 + 分場 = 篇章（角色的故事） 篇章 + 篇章 + 篇章 = 故事 「硬」的人不去做最「硬」的事
第一話的 5 個步驟#介紹世界觀 告訴觀眾主角想要做什麼 交代主角的背景 讓主角經歷一些衝突 用一個巨大的變化來做收尾 (1 + 2 + 3 + 4) = 5
什麼背景的人，經歷了什麼事情，造成他怎麼樣的麻煩（或加強他哪方面的心境） 可以用世界觀讓主角的背景變得既普通又特殊 巨人：用新的坑來填補舊有的坑，讓【所.有.】的坑都不離第一個坑太遠
獵人：開放式劇情，讓所有的故事在【當下】就全.部.講.完.
封閉式劇情：自問自答式的劇情
故事的開場 = 自我介紹 = 觀眾的面試
利用特徵差異最大化來安排角色性格
嘗試寫一個巨人的故事#從一個最初的想法、元素、或概念來萌芽 人類被圈在牆內，牆外都是充滿危險的巨人，中間有著障礙 【找衝突點】 全力把該「衝突點」放到最大最大 把衝突點以外的「所有事情」都用來塑造那個衝突 按照合理的邏輯把所有事情推理下去 遵循故事內在（像是自由、內涵、意義、象徵、精神、「故事真正的樣子」）#一般情況下，故事會需要有良好節奏、循序漸進的發展，但如果角色們是怪咖時，他們的真實人生一定是相對「不工整」的，這時候，要不就像【自殺突擊隊】的作法，把它們的「怪」塞進「工整」的故事裡面，要不就【釋放角色破壞故事的權力】：比較好的做法是用角色的「特點」來破壞故事，像「瑪奇瑪把下屬當狗」，那這樣的話，即使「帕瓦」是重要角色，依然直接讓瑪奇瑪破壞掉帕瓦的重要性，讓「狗真的只是狗」。這樣就可以「讓故事遵循了瑪奇瑪的內在」，也就是「破壞了故事的平衡」和破壞觀眾對故事的看法與習慣認知。
反邏輯正因為最懂邏輯，所以才曾將邏輯反過來運用
角色的命很重要，所以要好好珍惜 反派只會越來越強，最後的魔王在一開始就會有線索 人越害怕，惡魔就會越強 「設定」如何使用？如何跟故事配合？#核心法：故事之初就把設定都說玩，後續故事都是靠最初的設定碰撞出來的（2077）</description>
    </item>
    
    <item>
      <title>［置頂］工作日誌</title>
      <link>https://fonu195713.github.io/docs/daily_life/working_log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/working_log/</guid>
      <description>［置頂］工作日誌#2023, 7 月...日期 標題 分類 備註 07-07 《深入淺出設計模式》 心得 . 07-08 設計模式 分類 . 07-09 策略模式 內容 . 07-10 模板方法模式 內容 . 07-11 享元模式 內容 . 07-12 狀態模式 內容 . 07-13 單例模式 內容 . 07-14 簡單工廠模式 內容 . 07-14 工作日誌 內容 . 07-14 文章留言板 功能 . 07-15 工廠方法模式 內容 . 07-16 抽象工廠模式 內容 . 07-17 生成器模式 內容 . 07-18 原型模式 內容 . 07-21 適配器模式 內容 .</description>
    </item>
    
    <item>
      <title>［置頂］待辦事項</title>
      <link>https://fonu195713.github.io/docs/daily_life/to_do_list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/to_do_list/</guid>
      <description>［置頂］待辦事項#日本的心得文 小說 </description>
    </item>
    
    <item>
      <title>With ToC</title>
      <link>https://fonu195713.github.io/_docs/example/table-of-contents/with-toc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/table-of-contents/with-toc/</guid>
      <description>Caput vino delphine in tamen vias#Cognita laeva illo fracta#Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere#Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
    <item>
      <title>中介者模式（Mediator Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/mediator_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/mediator_pattern/</guid>
      <description>中介者模式（Mediator Pattern）#說明 ChatGPT：中介者模式（Mediator Pattern）是一種行為型設計模式，用於降低多個物件之間的直接溝通。物件會透過一個名為【中介者】的物件來進行通信。中介者模式有助於減少物件之間的耦合性，使得物件之間的交互更加靈活和可維護。在中介者模式中，多個物件（也稱為同事物件）不再直接相互溝通，而是通過【中介者】進行間接通訊。當其中一個物件需要與其他物件進行交互時，它不會直接調用其他物件的方法，而是通過中介者的方法來進行調用請求，然後中介者再將請求訊息傳遞給該物件。這樣一來，各個物件之間的相互依賴關係就減少了，它們只需要依賴於【中介者】這個抽象介面，而不需要知道彼此的存在。這樣不僅降低了物件之間的耦合性，同時也使得程式的結構更加清晰，易於維護和擴展。中介者模式適用於以下情況：「當多個物件之間的交互複雜且互相依賴時，使用中介者模式可以簡化物件之間的耦和與依賴，使得物件之間的關係更加清晰。」；「當物件之間的耦合性過高，導致修改一個物件可能影響到其他物件時，可以使用中介者模式將這些物件的交互集中在中介者中，從而降低耦合性」；「當一個物件需要和多個其他物件進行通信時，使用中介者模式可以避免物件之間建立大量的相互引用關係，從而提高程式的可讀性和可維護性。」
維基百科：在軟體工程中，中介者模式定義了一個「封裝了一組物件互動方式」的物件。由於這種模式可以改變程式的運行行為，因此被認為是一種行為型設計模式。在物件導向程式設計中，程序通常會由許多的類別組成，各種邏輯和計算會在這些類別之間分散和互相調用。然而，隨著在程式中添加更多的類別或方法，在維護或重構程式期間，因為類別之間相互的高度耦和，使得維護與重構程式需要耗費巨大的時間成本。此外，由於任何更改都可能影響到其他幾個類別中的程式邏輯，因此更改程式會變得更為困難。因此中介者模式會將物件之間的通信，封裝在一個【中介者】物件中。讓其餘物件不再直接通信，而是通過【中介者】進行通信。這減少了物件之間的相依性，從而減少了耦合。中介者模式是 23 種著名的設計模式之一，該模式可以解決的問題有：「對高度耦和的物件進行解耦的動作」「讓物件彼此的行為各自獨立，而不依賴於其餘類別。」中介者模式描述的解決方案是：定義一個單獨的【中介者】物件，讓該物件封裝「物件之間的互動」。其餘物件將其互動的請求委派給【中介者】，而不是直接物件進行互動。物件通過一個 &amp;ldquo;控制&amp;rdquo; 和 &amp;ldquo;協調互動&amp;rdquo; 的種介者物件間接地與彼此互動。使得物件之間可以維持鬆散地耦合。
特點 封裝物件的互動，讓物件只透過【中介者】進行溝通與調節 將物件的行為集中控制，從而避免混亂的調用 減少物件與物件之間的耦和，降低程式的維護成本 UML Graphic classDiagramclass Mid內文 中介者模式的用途就是「在多個物件之中提供一個協調的『管道』或『平台』」，透過一個【中介者】類別，【物件】可以直接將所需要的請求託付給【中介者】處理，或者是經由【中介者】取得其他【物件】所回傳過來的回應或參數。我們可以用一個 RPG 遊戲來解釋「中介者模式」的運作方式：假設在一個 RPG 遊戲中，我們要實作一個回合制的戰鬥場景。戰鬥總共分為兩方陣營（主角方與怪物方），如果沒有使用中介者模式的話，程式有可能會像是下面的這個樣子：
class Character { public: string name; int hp; int atk; public: Character(string name, int hp, int atk) : name(name), hp(hp), atk(atk) {} public: string getName() { return name; } public: virtual void attack(Character* target) = 0; virtual void takeDamage(int atk) = 0; }; class Player : public Character { public: Player(string name) : name(name) {} public: void attack(Character* target) override { cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; attacked &amp;#34; &amp;lt;&amp;lt; (targrt -&amp;gt; name) &amp;lt;&amp;lt; &amp;#34;.</description>
    </item>
    
    <item>
      <title>享元模式（Flyweight Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/flyweight_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/flyweight_pattern/</guid>
      <description>享元模式（Flyweight Pattern）#說明 ChatGPT：享元模式（Flyweight Pattern）是一種結構型設計模式，旨在通過共享對象来最大程度地减少資源消耗和提高性能。該模式適用於存在大量相同或近似對象的情况，通過共享對象的方式，減少對象的創建和記憶體開銷。在享元模式中，對象共分為兩種類型：共享對象（Flyweight）：是可以被共享的對象，包含內部狀態和外部狀態。內部狀態是不變的，因此可以被多個相同的對象共享；外部狀態是可變的，需要在使用時傳遞给共享對象。非共享對象（Unshared Flyweight）：是不可共享的對象，每個對象都是獨立的。通過將對象的狀態分為內部狀態和外部狀態，享元模式可以實現共享內部狀態，減少對象的數量，並通過傳遞外部狀態來保持對象的獨立性。
維基百科：享元模式（英語：Flyweight Pattern）是一種軟體設計模式。它使用物件用來儘可能減少記憶體使用量；於相似物件中分享儘可能多的資訊，共享數據結構的概念稱為「哈希共享」。當大量物件近乎重複方式存在，因而使用大量記憶體時，此法適用。通常物件中的部分狀態（state）能夠共享。常見做法是把它們放在資料結構外部，當需要使用時再將它們傳遞給享元。典型的享元模式的例子為文書處理器中以圖形結構來表示字符：每個字形有其字型外觀、字模、和其它格式資訊，如果要全部儲存，會使每個字符就耗用掉上千位元組。因此，我們會使用享元模式，將每個字符參照到一個【共享字形】物件，此物件會被其它有共同特質的字符所分享和使用；只有每個字符的獨特資訊（例如位置訊息）才需要另外儲存。享元模式（Flyweight Pattern）指的是通過與其他相似對象共享一部分數據，來最小化記憶體使用的一種程式設計模式。
特點 將物件定義為「內部狀態」與外部狀態 同一物件的內部狀態會完全相同，外部狀態會因物件而異 物件的內部狀態可以被定義為一個共同的參照 減少大量的記憶體消耗 通常會與「工廠模式」一併使用 UML Graphic classDiagramclass Map {TreeFactory* tree_factory;Tree[] tree_arycreateMap() : create tree and buildingcreateTree() : tree_factory.createTree()}class TreeFactory {Tree* tree_records[]createTree();}Map --&gt; TreeFactorynote &#34;Tree* createTree() {\n　Tree tree = Rnd.tree(name)\n　if(tree in tree_records) {\n　return tree;\n　}else{\n　Tree* t = new Tree(name);\n　tree_records.add(t);\n　return t;\n　}\n}&#34;</description>
    </item>
    
    <item>
      <title>代理模式（Proxy Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/proxy_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/proxy_pattern/</guid>
      <description>代理模式（Proxy Pattern）#說明 ChatGPT：代理模式（Proxy Pattern）是一種結構型設計模式，它允許通過使用一個「代理對象」來代表真實對象，從而控制對真實對象的訪問。代理模式提供了一個額外的層次，用於處理對真實對象的訪問，並可以在不改變真實對象的情況下，為其添加一些額外的功能。代理模式的核心思想是：「在【客戶端】和【真實對象】之間引入一個【代理對象】」，這個代理對象充當了客戶端和真實對象之間的中間人。當客戶端想要訪問真實對象時，它不直接與真實對象進行交互，而是通過代理對象來進行訪問。代理對象在接收到客戶端的訪問請求後，可以選擇是否轉發請求給真實對象，並可以在轉發請求前後執行一些額外的操作。代理模式主要包含以下幾個角色：Subject（主題）：主題定義了真實對象和代理對象之間的共同接口，這樣在任何使用真實對象的地方都可以使用代理對象。RealSubject（真實主題）：真實對象實現了 Subject 定義的接口，也就是真實對象，客戶端並不直接與它進行交互。Proxy（代理）：代理同樣也實現了 Subject 定義的接口，內部包含一個真實對象的引用，客戶端通過訪問該對象來代替訪問真實對象。
維基百科：代理模式（英語：Proxy Pattern）是軟體工程中的一種設計模式。所謂的【代理者】是指一個類別可以作為其它東西的介面。【代理者】可以作任何東西的介面：例如網路連接、記憶體中的大物件、某些特定檔案、或其它昂貴或無法複製的資源。著名的代理模式例子為參照計數（英語：reference counting）指標物件。此外，當一個複雜物件的多份副本須存在時，代理模式可以結合享元模式以減少記憶體用量，典型的作法是建立一個複雜物件及多個代理者，每個代理者都會參照到原本的複雜物件，而作用在代理者的運算會轉送到原本物件，而一旦所有的代理者都不存在時，該複雜物件將會被移除。
特點 通過代理者減少對於實體對象的依賴 能夠保持真實對象的穩定與獨立 可以客製化地提供真實對象的擴充功能 UML Graphic classDiagramclass Serverclass ProxyServer &lt;|-- Proxyclass User {Proxy* proxyvoid call_server()}User --&gt; Proxynote &#34;void call_server() {\n　proxy.request();\n}&#34;內文 類似於「霧運算」或者是「邊緣計算」的概念，代理模式的功能是透過一個【代理者】類別，將【真實對象】的工作給區分出去，讓【客戶】有需要進行一些對於【真實對象】的存取時，可以透過【代理者】來進行，從而減少對【真實對象】的依賴或負擔。例如在一個 RPG 遊戲中，我們每次在創建線上遊戲的角色的時候，都會需要做一個「確認 ID 是否重複」的事情，在程式的撰寫上可能會有向下面這樣的例子：
class GameServer { public: std::vector&amp;lt;string&amp;gt; id_vector; public: bool name_duplicated(string str) { auto it = std::find(id_vector.begin(), id_vector.end(), str); if(it != id_vector.end()) return true; else return false; } }; class Character { private: std::string name; public: void set_user_name() { GameServer server = new GameServer(); std::string tmp_name; std::cin &amp;gt;&amp;gt; tmp_name; while(server.</description>
    </item>
    
    <item>
      <title>原型模式（Prototype Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/prototype_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/prototype_pattern/</guid>
      <description>原型模式（Prototype Pattern）#說明 ChatGPT：原型模式（Prototype Pattern）是一種軟體設計模式，屬於創建型模式的一種。它的主要目的是「通過複製現有的物件」來創建新的物件，而不需要知道具體的建構過程。這種方式可以避免重複性的建構過程，特別是當物件建構較為複雜或耗時的時候。在原型模式中，每個物件都是一個原型（prototype），可以通過複製（clone）來創建新的物件。這裡的「複製」不僅僅是複製物件的內容，而是將整個物件的狀態複製一份給新建的物件，新物件與原物件是相互獨立的，對其中一個物件的修改不會影響另一個。原型模式的核心概念是基於現有物件（原型）來創建新物件，而不是從頭開始創建。這樣可以節省建構時間和資源，同時提高程式碼的效率和可讀性。原型模式通常需要實現一個拷貝方法（Clone Method），用於複製物件。這個拷貝方法可以是淺拷貝（Shallow Copy）或深拷貝（Deep Copy），具體取決於物件的需求和關聯性。
維基百科：原型模式是一種創建型設計模式。當要創建的物件類型由原型實例確定時，可以通過拷貝（clone）該原型來產生新的物件。該模式的使用可以避免在客戶端應用程式中對物件創建者進行子類別化，就像工廠方法模式所做的那樣，並且可以避免以標準方式（例如使用 &amp;ldquo;new&amp;rdquo; 關鍵字）創建新物件時所帶來的固有成本，尤其是對於某些應用程式來說這樣做代價過高的情況。要實現這種模式，客戶端先聲明一個原型基類，其中定義了一個 clone() 方法。任何需要具備「多型建構子」功能的類別都要繼承該類別，並實作 clone() 方法。客戶端不再直接在程式中使用 new 來建立物件，而是呼叫原型的 clone() 方法，一個常見的原型模式的例子是細胞的有絲分裂，一個細胞可以產生兩個相同的細胞，彼此相同，但彼此並不相關聯，就是原型模式的一個例子。
特點 通過複製物件快速得到新物件，而不需重新執行建構的過程 將物件的建構細節隱藏在物件內部。 動態地增減物件，通過複製不同類型的原型來創建物件 UML Graphic classDiagramclass World {string nameMap* maps[]void add_map();}class Map {Item* items[]}class Monster {Monster* clone();}World &lt;|-- MapMap &lt;|-- BuildingMap &lt;|-- NPCMap &lt;|-- MonsterMonster &lt;|-- ZombieMonster &lt;|-- Skeleton內文 簡單來說，原型模式就是透過 clone() 函數來代替用 new 的方法創立物件。這麼做有幾種好處，同樣用製作一個 RPG 遊戲來做舉例：首先是「快速初始化」，如果我們想要快速地創建多個相同類別的怪物物件的時候，雖然用 new 是一個不錯的方法，但如果考慮到怪物也許在某些地方會有某些加成，像是殭屍在靠近墓地的時候，會比一般殭屍高出一點點攻擊、防禦、和血量。這時候相對於「用 new 新增一個原本的殭屍，再微調每一個殭屍的所有數值。」，用 clone() 的方法複製第一個已經調整好參數的殭屍會來的更加簡潔。</description>
    </item>
    
    <item>
      <title>命令模式（Command Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/command_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/command_pattern/</guid>
      <description>命令模式（Command Pattern）#說明 ChatGPT：命令模式（Command Pattern）是一種行為型設計模式，它將請求（request）或操作封裝成一個獨立的對象，使得能夠將客戶端的請求參數化、延遲執行或者將請求排入佇列中。這樣可以使請求的發送者和接收者解耦。在命令模式中，主要包含以下角色：【命令】（Command）：它是一個抽象類或接口，聲明了執行請求的方法 execute()。【具體命令】（Concrete Command）：具體命令實現了命令接口，包含了具體的操作和接收者。通常會持有接收者的實例，用來執行實際的請求。【接收者】（Receiver）：接收者知道如何執行真正的操作，接收者會被具體命令所調用。【調用者】（Invoker）：調用者持有命令對象，並在需要的時候調用命令的 execute() 方法。【客戶端】（Client）：創建具體命令對象，設置命令的接收者，並將命令對象設置給調用者。命令模式的核心思想是將「操作」和「操作的執行」解耦，將它們封裝成對象，從而實現請求的發送者和接收者之間的解耦。這使得我們可以輕鬆地增加新的請求類型，或進行撤銷、重做等功能，，對於實現複雜的交互操作和請求發送的場景非常有用。
維基百科：在物件導向程式設計中，命令模式是一種行為型設計模式，它使用一個物件來封裝所有執行動作或稍後觸發事件所需的資訊。這些資訊包括方法名稱、擁有該方法的物件和該方法的參數值。命令模式通常與四個術語相關，它們是命令（Command）、接收者（Receiver）、調用者（Invoker）和客戶端（Client）。一個【命令】了解接收者並調用接收者的方法，該方法的參數值會存儲在命令中。【接收者】用於執行這些方法。當調用【命令】中的 execute() 方法時，【接收者】便開始執行工作。【調用者】物件知道如何執行一個命令，並可以選擇性地進行有關命令執行的記錄。【調用者】不知道具體的命令，只知道【命令】的介面。【客戶端】持有【調用者】、【命令】和【接收者】。【客戶端】決定將哪些【接收者】指派給【命令】，以及將哪些【命令】指派給【調用者】。【客戶端】決定在何時執行哪些命令。為了執行一個命令，它將【命令】傳遞給【調用者】。使用【命令】可以更容易地構建通用元件，這些元件需要在它們選擇的時間點委派、序列化、或執行方法的呼叫，而無需了解方法的類別或方法的參數。這個設計模式的核心思想與「函數式程式設計」中的「一等函數」和「高階函數」的語義非常相似，具體來說，【調用者】是高階函數，而【命令】是一等參數。
特點 將請求封裝成【命令】，使得命令可以參數化 可以將【調用者】和【接收者】解耦 容易進行擴展操作，且支持命令的延遲執行 UML Graphic classDiagramclass Command~Interface~ {Character* charactervoid execute();void undo();}Command &lt;|-- AttackCommandCommand &lt;|-- DefenceCommandclass AttackCommand {void execute() : character.attack();void undo() : character.cancelAttack();}class DefenceCommand {void execute() : character.defence();void undo() : character.cancelDefence();}classDiagramclass Character~Interace~Character &lt;|-- WarriorCharacter &lt;|-- BowmanCharacter &lt;|-- MagicianCharacter &lt;|-- Thiefclass Character {void attack();void cancelAttack();void defence();void cancelDefence();}class CommandInvoker {Command* commandvoid setCommand(Command* cmd);void execute() : cmd.</description>
    </item>
    
    <item>
      <title>單例模式（Singleton Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/singleton_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/singleton_pattern/</guid>
      <description>單例模式（Singleton Pattern）#說明 ChatGPT：單例模式（Singleton Pattern）是一種創建型設計模式，它確保一個類別只有一個唯一的實例，並提供一個全局的訪問點來訪問該實例。單例模式確保一個類別只有一個實例，並且提供全局的訪問點來訪問該實例。實現單例模式的一種常見方式是使用一個私有的靜態成員變量來存儲類別的唯一實例，並提供一個公共的靜態方法來獲取這個實例。在這個方法中，方法首先會檢查實例是否已經存在？如果存在，則返回該實例，否則創建一個新的實例並返回。此外，為了防止通過其他途徑創建額外的實例。單例模式會將類別的構造函數設為私有。
維基百科：單例模式（Singleton Pattern）也叫單子模式，是一種常用的軟體設計模式，屬於創建型模式的一種。在應用這個模式時，單例對象的類必須保證只有一個實例存在。實現單例模式的思路是：一個類僅能返回對象一個引用（永遠是同一個）和一個獲得該實例的方法（必須是靜態方法，通常使用 getInstance() 這個名稱）；當我們調用這個方法時，如果類持有的引用不為空就返回這個引用，如果類保持的引用為空就創建該類的實例，並將實例的引用賦予該類保持的引用；同時我們還將該類的構造函數定義為私有方法，這樣其他處的代碼就無法通過調用該類的構造函數來實例化該類的對象，只有通過該類提供的靜態方法來得到該類的唯一實例。
特點 可以確保一個類別只會生成一個物件 提供簡易的接口，讓程式對實例的訪問與操作更為簡單 可以延遲實例，僅在需要時才創建，節省資源使用 UML Graphic classDiagramclass Singleton {static Singleton obj;static Singleton* getInstance();}內文 單例模式是一個很簡單的概念，就是「單一類別，只會生成單一物件（也就是單一實例）的一種設計模式。」雖說概念很簡單，但實作起來，還是有點眉角在裡面的。在直覺上的想法中，「透過私有的建構子，讓生成物件的權限只限制給類別本身」「『靜態變數』是讓類別中所有物件共用的一個變數」這兩個想法，就可以生成一個簡單的單例模式的程式了，就如下方所示：
class Singleton { static Singleton* obj; private: Singleton() {} public: static Singleton* getInstance() { if(obj == nullptr) { obj = new Singleton(); } return obj; } }; Singleton::obj = nullptr; 在上方的程式中，透過將 Singleton() 建構子宣告成私有的方式，來讓「生成物件」這項工作只有 Singleton 類本身能夠做到，接著讓 obj 初始化成 nullptr，並在 getInstance() 中做一個 obj 的判斷，如果 obj == nullptr，那就生成一個 obj，否則就直接回傳 obj 的記憶體位址。透過這樣的寫法，可以保證 obj 只要一被生成，那麼 obj = new Singleton(); 這件事情就不會被執行，也就代表了一定程度上的「單一類別只會有單一實例」的任務。</description>
    </item>
    
    <item>
      <title>外觀模式（Facade Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/facade_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/facade_pattern/</guid>
      <description>外觀模式（Facade Pattern）#說明 ChatGPT：外觀模式（Facade Pattern）是一種結構型設計模式，它提供了一個簡單的介面（外觀），用於封裝一組複雜的子系統，使得客戶端可以通過這個簡單的介面來訪問子系統的功能，而不需要直接與子系統的細節互動。外觀模式的目的是「簡化客戶端和子系統之間的交互」，降低客戶端對於子系統的依賴程度，同時提供了一個高層次的介面來統一訪問子系統的功能。這樣的設計有助於降低整個系統的複雜性，提高程式的可讀性和可維護性。在外觀模式中，通常有以下兩個角色：Facade（外觀）：這是外觀模式的核心類別，它負責提供了一個簡單的介面，用於封裝子系統的複雜操作。客戶端通常只與外觀類進行交互，而不需要直接訪問子系統。Subsystem（子系統）：這是一組相互關聯的類別或功能，它們共同實現了一個（或一些）複雜的功能。外觀模式將這些子系統封裝起來，使得客戶端不需要了解子系統的細節，只需通過外觀類來使用子系統的功能。
維基百科：外觀模式（Facade pattern），是軟體工程中常用的一種軟體設計模式，它為子系統中的一組介面提供一個統一的高層介面，使得子系統更容易使用。外觀模式是一個物件導向程式設計中常用的設計模式。類似於一個建築學中的立面，該立面作為一個前端接口，來屏蔽更複雜的底層或結構代碼。外觀模式可以提供以下功能：「通用簡化的 API 屏蔽與更複雜的內部組件和結構，以提高 Software library 的可讀性和可用性」「為更通用的功能提供上下文特定的接口」「為 Monolithic System 或 Tight coupling 的軟體系統提供一個簡化的啟動點，更有利於更多的鬆耦合程式」。當一個系統非常複雜或難以理解時，開發人員通常會使用外觀模式，因為原系統通常有許多相互依賴的類別，或者因為其它的原因，使得直接調用原始程式碼會耗費極大的成本。Facade pattern 隱藏了更大系統的複雜性，為客戶端提供了一個更簡單的接口。
特點 定義了一個算法族 封裝算法族中的每一個算法 不同的算法可以互相替換 UML Graphic classDiagramclass SkillFacade {void show();}class Swordman {void chop();void hack();void parry();}class Magician {void fire_magic_attack();void earth_magic_attack();void wind_magic_attack();void water_magic_attack();void heal();}class Bowman {void aim();void throw();void toss();void shoot();}class Thief {void poke();void kick();void evade();void counter_attack();void ninjutsu();}SkillFacade --&gt; SwordmanSkillFacade --&gt; MagicianSkillFacade --&gt; BowmanSkillFacade --&gt; Thiefnote &#34;</description>
    </item>
    
    <item>
      <title>工廠方法模式（Factory Method Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/factory_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/factory_method_pattern/</guid>
      <description>工廠方法模式（Factory Method Pattern）#說明 ChatGPT：工廠方法模式（Factory Method Pattern）是一種軟體設計模式，屬於創建型模式之一。它提供了一種「分離物件的創建與使用」的方式，通過使用工廠類別內的方法來創建物件，而不是直接在客戶端代碼中使用 new 關鍵字。 在工廠方法模式中，工廠會定義了一個接口（或抽象類別），其中包含了創建產品物件的抽象方法，具體的物件創建則由實現該接口的具體工廠類別來實現。這樣一來，客戶端代碼只需要和工廠接口進行交互，而不需要知道具體的物件創建細節。工廠方法模式的核心思想是：「將物件的創建延遲到子類別中」，使得客戶端的程式與具體的物件創建解耦。這樣做的好處是，當需要新增一種具體的產品時，只需要擴展相應的具體工廠類別即可，不需要額外修改客戶端代碼，因此符合設計原則中的「開放封閉原則」。
維基百科：在物件導向程式設計中，工廠方法模式（Factory Method Pattern）是一種創建型模式，它使用工廠方法來處理創建物件的問題，而不需要明確指定將要創建的物件的確切類別。這是通過調用工廠中的方法來創建物件來實現的，而不是通過調用構造函數來實現。其中，工廠中的方法可以在介面中抽象化，並由子類實現，或者在類別本身中實現，並由子類別選擇性地覆蓋。創建物件通常會擁有一個複雜的流程，該流程並不適合再複合類別中實現。物件的創建可能導致代碼的重複、可能需要組合物件無法訪問的資訊、可能無法提供足夠的抽象層次、或者可能與組合物件的關注點無關。因此，工廠方法模式通過「定義一個獨立的方法來創建物件」來解決這些問題，子類可以覆蓋該方法以指定將要創建的衍生類型。
特點 將物件的「創建」與「使用」分離 可以輕易擴展 符合開放封閉原則 UML Graphic classDiagramclass EnchantingFactory~Interface~ {Sword* createSword();}class KnockbackFactory {Sword* createSword() return KnockbackSword();}class FireAspectFactory {Sword* createSword() return FireAspectSword();}EnchantingFactory~Interface~ &lt;|-- KnockbackFactoryEnchantingFactory~Interface~ &lt;|-- FireAspectFactory內文 小建議：可以先看過簡單工廠模式，再回來看這個「工廠方法模式」會比較好。
如同簡單工廠模式所述：在四人幫的著作裡面，工廠模式共分為簡單工廠模式、工廠方法模式、和抽象工廠模式這三種。相對於「在【工廠】中直接建立【產品】」的簡單工廠模式，工廠方法模式更在乎「其他的『工廠』有沒有依循著同樣的『方法』」來建立物件。通常來說，工廠方法會先定義出一個『工廠介面』，再讓其他的【工廠】去繼承這個工廠介面，從而確保所有的【工廠】都有類似或相同的產品製造方法。用另外一個 RPG 遊戲來做舉例，假設在一個遊戲中，我們想要實作出不同附魔類別的劍，簡單工廠的方法可能會像是下面的樣子：
class SimpleFactory { public: static Sword* enchantSword(Enchantments enchantments) { Sword* sword = nullptr; switch(enchantments) { case Knockback: sword = new KnockbackSword(); break; case FireAspect: sword = new FireAspectSword(); break; // other codes .</description>
    </item>
    
    <item>
      <title>抽象工廠模式（Abstract Factory Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/abstract_factory_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/abstract_factory_pattern/</guid>
      <description>抽象工廠模式（Abstract Factory Pattern）#說明 ChatGPT：抽象工廠模式（Abstract Factory Pattern）是一種創建型設計模式，它提供了一種「創建一系列相關或相互依賴對象」的接口，而無需指定具體的類別。該模式允許客戶端使用抽象接口來創建一組相關的對象，而不必關心實際的對象實現細節。抽象工廠模式的目標是實現產品族的創建，其中產品族是指「一組相互關聯的產品」，這些產品之間有共同的約束或邏輯關係。抽象工廠模式使得系統更具靈活性，易於切換產品族，而不需要修改客戶端程式。總的來說，抽象工廠魔是總共由四個核心部分組成：抽象工廠（Abstract Factory）：定義創建產品族的接口，通常由一個抽像類或接口來表示。該接口包含多個抽象方法，每個方法用於創建一個具體產品。具體工廠（Concrete Factory）：實現【抽象工廠】中的接口，負責創建具體的產品對象。抽象產品（Abstract Product）：定義產品族中的某類產品的接口，可以是抽象類別或接口。具體產品（Concrete Product）：實現【抽象產品】中的接口，負責定義實際產品的樣貌與屬性，【具體工廠】會創建這些產品的實例。
維基百科：抽象工廠模式（Abstract factory pattern）是一種軟體開發設計模式。抽象工廠模式提供了一種方式，可以將一組具有同一主題的單獨的工廠封裝起來。在正常使用中，客戶端程式需要建立抽象工廠的具體實現，然後使用抽象工廠作為介面來建立這一主題的具體對象。客戶端程式不需要知道（也不需要關心）它從這些內部的工廠方法中獲得對象的具體類型，因為客戶端程式僅使用這些對象的通用介面。抽象工廠模式將「一組對象的實現細節」與「它們的使用」分離開來。【工廠】類別是建立產品的地方，其目的是將產品的建立與產品的使用分離。抽象工廠模式的目的，是將若干抽象產品的介面，與不同主題產品的具體實現分離開。這樣就能在增加新的具體工廠的時候，不用修改參照抽象工廠的客戶端代碼。使用抽象工廠模式，能夠在具體工廠變化的時候，不用修改使用工廠的客戶端代碼，甚至是在執行時。然而，使用這種模式或者相似的設計模式，可能給編寫代碼帶來不必要的複雜性和額外的工作。
特點 將物件的「創建」與「使用」分離 可以輕易擴展 符合開放封閉原則 UML Graphic classDiagramclass MonsterMonster &lt;|-- ZombieMonster &lt;|-- GoblinMonster &lt;|-- Skeletonclass WeaopnWeaopn &lt;|-- SwordWeaopn &lt;|-- AxeWeaopn &lt;|-- BowclassDiagramclass MonsterFactory {Monster* create();}class ZombieFactory {Monster* create() new Zombie()}class GoblinFactory {Monster* create() new Goblin()}class SkeletonFactory {Monster* create() new Skeleton()}MonsterFactory &lt;|-- ZombieFactoryMonsterFactory &lt;|-- GoblinFactoryMonsterFactory &lt;|-- SkeletonFactoryclassDiagramclass WeaponFactory {Weapon* create();}class SwordFactory {Weapon* create() new Sword()}class AxeFactory {Weapon* create() new Axe()}class BowFactory {Weapon* create() new Bow()}WeaponFactory &lt;|-- SwordFactoryWeaponFactory &lt;|-- AxeFactoryWeaponFactory &lt;|-- BowFactoryclassDiagramclass AdvancedMonster {Monster* createAdvancedMonster();}note &#34;</description>
    </item>
    
    <item>
      <title>模板方法模式（Template Method Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/template_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/template_method_pattern/</guid>
      <description>模板方法模式（Template Method Pattern）#說明 ChatGPT：模板方法模式（Template Method Pattern）是一種行為設計模式，它定義了一个演算法的「框架」，並將該演算法的細節程式延遲到子類中進行實現。在模板方法模式中，一個抽象類別會公開定義一個（或多個）方法的骨架，而將一些方法中的具體細節推遲稻子類別中。這樣可以确保方法的整體結構不會改變，但允許子類別根據需要，重新定義某些步骤。在模板方法模式中，主要有三種類型的方法：模板方法（Template Methods）：模板方法會在方法內部定義一系列該方法的執行步驟。抽象方法（Abstract Methods）：抽象方法由抽象類別聲明，它們没有具體的程式細節，在模板方法模式中，子類必須實作這些方法。鉤子方法（Hook Methods）：鉤子方法有一個預設的程式實作，但子類別可以選擇性地呼叫或重寫它們，鉤子方法可以在模板方法中的不同步骤中，插入自定義的行為。
維基百科：模板方法模式是一種行為設計模型和設計模式。模板方法（template method）是一個定義在父類別的方法，負責處理流程和演算法的不變部分。模板方法會呼叫多個定義在父類別的其他工具方法（helper method），這些方法是演算法的可變部分，有的工具方法可能只是抽象方法，並沒有實作，也有的工具方法已經有一些實作的程式，但仍允許子類改寫。模板方法僅決定這些抽象方法的執行順序，這些抽象方法由子類別負責實作。此外，子類別不允許覆蓋模板方法（意即不能重寫處理流程）。這種設計模式是一種控制反轉的實現方式。因為高層級的程式不再需要控制演算法的細節實作，而僅需在意演算法的框與流程。
特點 定義了一個算法流程 將各流程的實際實作延遲至子類進行實踐 子類的實作方式各不同，但流程相同 UML Graphic classDiagramclass CharacterCreator {Race* race;Appearance* appearance;Attribute* attribute;void createCharacter(); : cannot overridevoid selectRace();void selectAttributes();void customizeAppearance();bool hasUniqueAbility();void customizeUniqueAbility();void saveCharacter();}note &#34;void createCharacter() {\n　selectRace()\n　selectAttributes()\n　customizeAppearance()\n　if(hasUniqueAbility()) {\n　customizeUniqueAbility()\n　}\n　saveCharacter()\n}&#34;class Orcish {selectRace(): &#34;orcish&#34;}class NightElf {selectRace(): &#34;</description>
    </item>
    
    <item>
      <title>橋接模式（Bridge Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/bridge_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/bridge_pattern/</guid>
      <description>橋接模式（Bridge Pattern）#說明 ChatGPT：橋接模式（Bridge Pattern）是軟體設計模式的一種，它屬於結構型模式之一。橋接模式的主要目的是「將『抽象部分』與『實現部分』分離」，使它們可以獨立地變化，從而降低了它們之間的耦合性。在軟體開發中，常常會遇到「類之間的耦合」和「功能之間的耦合」。類之間的耦合指的是一個類與另一個類之間的相依關係，而功能之間的耦合則是指一個類內部不同功能模塊之間的相依關係。當類之間的耦合度過高時，一個類的變化可能會影響到其他相關的類，這樣的系統就會變得脆弱且難以擴展。橋接模式通過使用抽象和實現之間的分離，解決了這些耦合性問題。在橋接模式中，『抽象部分』和『實現部分』分別由兩個獨立的類層次結構來表示。抽象部分包含高層次的抽象介面，而實現部分則包含具體的實現細節。這樣，抽象部分和實現部分可以獨立擴展，互不影響。
維基百科：橋接模式（Bridge Pattern）是軟體工程中使用的一種設計模式，它旨在「將抽象與其實現分離，以便兩者可以獨立變化」，是由四人幫引入的一種設計模式。橋接模式使用封裝、聚合，並且可以使用繼承將職責分離到不同的類中。當類別經常變化時，物件導向程式設計的功能就變得非常有用，因為即使對程式有很少的先驗知識，也可以輕鬆地更改程式代碼。當類別及其功能經常變化時，橋接模式會顯得非常有用。類別本身可以被視為抽象，而類別可以做的行為則被視為實例。橋接模式也可以被認為是兩層抽象。
特點 分離抽象介面與實例創建的程式邏輯 可將抽象類別與實例類別獨立開來 採用「組合」的方式減少「繼承」的大量使用 UML Graphic classDiagramclass Character~Interface~ {Weapon* weaponArmor* armor;void equip();void attack()virtual void weild();virtual void swing();virtual void unweild();}note &#34;void equip() {\n　print(equip weapon.name);\n　print(equip armor.name);\n}&#34;note &#34;void attack() {\n　weapon.waild();\n　weapon.swing();\n　weapon.unweild();\n}&#34;Character~Interface~ &lt;|-- KnightCharacter~Interface~ &lt;|-- WarriorCharacter~Interface~ &lt;|-- ThiefclassDiagramWeapon~Interface~ &lt;|-- SwordWeapon~Interface~ &lt;|-- AxeWeapon~Interface~ &lt;|-- DaggerArmor~Interface~ &lt;|-- AlloyArmorArmor~Interface~ &lt;|-- IronArmorArmor~Interface~ &lt;|-- LeatherArmor內文 橋接模式的核心觀念是「多用組合、少用繼承」。也就是合成/聚合複用原則（CARP - Composite/Aggregate Reuse Principle）所提倡的概念。橋接模式的用途在於「將二維（或多維）的程式邏輯轉變為兩個（或多個）一維的狀態」讓我們用一個 RPG 遊戲來做舉例：假設我們這在撰寫一個 RPG 遊戲，遊戲裡面提供了「騎士、戰士、和盜賊」3 種不同的職業類別。遊戲裡面也定義了「劍、斧頭、和匕首」3 種不同的武器選項，以及「皮製護具、鐵製鎧甲、與合金盔甲」3 種不同的防禦性裝備。因為我們允許不同的職業做不同的武器防具組合（『騎士 + 劍 + 鐵製鎧甲』，或者『盜賊 + 斧頭 + 皮製護具』&amp;hellip;等），因此在當前的情況下，總共會有 \(3 \times 3 \times 3 = 27\)種不同的組合。那如果我們單純用 Character 類別 + 繼承來實現這組遊戲腳色的程式的話，可能就會像下面這個樣子：</description>
    </item>
    
    <item>
      <title>狀態模式（State Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/state_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/state_pattern/</guid>
      <description>狀態模式（State Pattern）#說明 ChatGPT：狀態模式（State Pattern）是一種行為型設計模式，它允許物件在相異的狀態下展現不同的行為，並讓使用者看起來好像改變了它的類別。這種模式可以將物件的狀態封裝在不同的類別中，並且使物件能夠在運行時根據狀態的改變而改變其行為。狀態模式的主要目的是將複雜的條件判斷轉換成一組一組相關的狀態類別，從而使代碼更具可讀性、可維護性和可擴展性。它遵循開放-封閉原則，因為可以通過添加新的狀態類別來擴展系統的行為，而無需修改現有的代碼。使用狀態模式，可以將每個狀態實現為一個具體狀態類別，並將狀態相關的行為封裝在這些類別中。上下文類別（VendingMachine）持有當前狀態的引用，並將相應的請求委派給當前狀態對象。當狀態發生改變時，上下文物件將切換到新的狀態，並且行為也隨之改變。透過狀態模式，可以實現狀態機進行狀態轉換和行為管理的解耦，使得系統更靈活、可擴展且易於維護。
維基百科：狀態模式是一種行為型設計模式，它允許對象在内部狀態改變時，改變其行為。該模式與有限狀態機的概念密切相關。狀態模式可以解释為一種策略模式，通過調用模式接口中定義的方法來切換策略。狀態模式在軟體工程中用於封裝同一對象的不同行為，基於其內部狀態。這可以是對象在運行時改變行為的一種清晰呈現，而無需使用大量的 if else 語句，從而提高可維護姓。狀態模式旨在解决兩個主要問題：「對象在何時改變其狀態與行為」「不同的狀態與行為該如何定義」。也就是說，在狀態模式下，增添新的狀態並不會影響原有的狀態與各自的行為。此外，因為直接在一個類別中實特定狀態的行為是不靈活的因此該模式會為每個狀態定義一個單獨的狀態接口，並定義單獨的狀態對象，封装每個狀態的特定行為。並於類別中切換與調用。
特點 將每一種「狀態」各自定義成一個類別 透過委託的方式，讓各狀態分別實現不同的行為 通常會配合枚舉（enum）一同使用 State Graphic stateDiagramStand --&gt; SquatDownStand --&gt; WalkStand --&gt; JumpStand --&gt; AttackSquatDown --&gt; StandSquatDown --&gt; AttackWalk --&gt; StandWalk --&gt; RunWalk --&gt; JumpWalk --&gt; AttackRun --&gt; StandRun --&gt; RollRun --&gt; JumpRun --&gt; AttackRoll --&gt; StandRoll --&gt; AttackJump --&gt; StandJump --&gt; WalkJump --&gt; AttackAttack --&gt; Stand內文 假設我們正在製作一款 2D 橫向卷軸的 RPG 遊戲，玩家可以透過不同的按鍵操縱遊戲中的角色。在不使用狀態模式的程式撰寫方法下，我們可能會需要利用一些的條件判斷語句來完成「角色移動」的這個概念，就如下面的程式所示：</description>
    </item>
    
    <item>
      <title>生成器模式（Builder Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/builder_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/builder_pattern/</guid>
      <description>生成器模式（Builder Pattern）#說明 ChatGPT：生成器模式（Builder Pattern）是一種軟體設計模式，用於創建複雜物件時，將建構過程和表示分離，使得同樣的建構過程可以創建不同的表示。這種模式通常用於創建具有多個可選屬性的物件，以及具有多個步驟或配置過程的物件。通常來說，一個創建者模式裡面，主要包含以下幾個元素：產品（Product）：這是要建構的複雜物件，通常包含多個屬性。它可以是一個複雜的類別或結構。建構者（Builder）：建構者通常是一個介面（或抽象類別），它定義了建構產品的各個步驟，並且可能包含設置屬性的方法。具體建構者（Concrete Builder）：實現建構者介面的類別，負責實際建構物件並設置其屬性。指揮官（Director）：可選元素，對於複雜的建構過程，可以使用指揮者來將建構過程進行組織和管理，以確保生成符合需求的物件。
維基百科：生成器模式（Builder Pattern）是一種設計模式，又名：建造者模式、創建者模式，是一種對象構建模式。它可以將對象的建造過程，利用一系列抽象的步驟提取出來，使這個抽象過程的不同實現方法可以構造出不同表現（屬性）的對象。生成器模式解決了以下的幾問題：一個類別如何擁有類似的建構過程，但又可以創建出具有不同屬性的物件？一個類別如果包含大量的屬性，它該如何簡化包含建構複雜物件的類別？生成器設計模式描述了如何解決這些問題的方法：將「創建」和「組裝複雜物件」的部分封裝在一個獨立的建構者（Builder）物件中。類別將物件的建構委託給建構者，而不是直接創建物件。
特點 可以分離生成物件的過程 相對於建構子，具有有更佳的彈性和擴展性 支援不同種類的物件生成方式 UML Graphic classDiagramclass Character {string nameRole* roleWeapon* weaponArmor* armorElement* element}class CharacterBuilder {void setName()void setRole()void setWeapon()void setArmor()void setElement()Character* getCharacter()}CharacterBuilder &lt;|-- WarriorBuilderCharacterBuilder &lt;|-- MagicianBuilderCharacterBuilder &lt;|-- ArcherBuilderCharacterBuilder &lt;|-- AssassinBuilderclass CharacterDirector {CharacterDirector(CharacterBuilder* b)}Character --&gt; CharacterDirectorCharacterDirector o-- CharacterBuilder內文 假設我們在製作一款 RPG 遊戲，其中在「創建角色」的過程，角色可以選定「戰士、弓箭手、法師、盜賊」其中一種職業遊玩。角色的屬性主要分成以下四種類型：【名稱】名稱由玩家自行填寫，不可為空。【武器】武器會根據角色所選的職業有所不同，戰士可以手持劍或斧、弓箭手固定為弓、法師的武器固定為長杖、盜賊固定為匕首。【護具】護具同樣由職業做綁定：戰士使用鐵製護具，弓箭手使用皮革護具、盜賊同樣使用皮革護具，法師則沒有護具。【元素屬性】元素屬性也是綁定職業：戰士不具有任何元素屬性（純物理攻擊）、弓箭手固定為風屬性、盜賊可以選擇不持有屬性或持有風屬性的能力、法師則可以在火土風水之中選擇一種主要屬性使用。</description>
    </item>
    
    <item>
      <title>策略模式（Strategy Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/strategy_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/strategy_pattern/</guid>
      <description>策略模式（Strategy Pattern）#說明 ChatGPT：策略模式（Strategy Pattern）是一種行為型設計模式，該模式允許在程式運行時，根據不同的需求，選擇不同的算法或行為。策略模式將演算法的定義、演算法的實現、和演算法的使用分離，這種彈性的程式撰寫方式，使得它們可以彼此獨立地變化，互相替換。策略模式的核心思想，是將「行為」封裝各種成獨立的「策略」，使得使用者（或程式）可以根據需要，選擇實踐不同的策略，同時需要改變策略的程式碼。這種靈活性和可替換性，使得策略模式在需要動態地改變物件的行為的情況下非常有用，並且能夠實現高度可定制和可擴展的系統設計。
維基百科：策略模式是一種行為型軟體設計模式，它可以在運行時選擇一個演算法。程式在撰寫的過程中，不會直接實現單一的演算法，而是根據運行時的指示。從一系列的篩選方式中，選擇一個方法出來。策略模式使得演算法能夠獨立於使用它的客戶端變化，它將「選擇使用哪個演算法」的決策推遲到運行時，可以使呼叫程式的方式更靈活和可重用。例如，對輸入數據進行驗證的類別可以使用策略模式，根據類型、來源、使用者選擇、或其他區分因素來選擇驗證演算法。因為這些後天的因素需要直到運行時才知道，因此不同的輸入可能需要執行完全不同的驗證。在此情況下，將驗證演算法（策略）與驗證的物件分開封裝，可以在系統的不同區域（甚至不同系統）中由其他驗證物件使用，而無需重複編寫代碼。
特點 定義了一個算法族 封裝算法族中的每一個算法 不同的算法可以互相替換 UML Graphic classDiagramclass Character {AttackMethod* atkattack() : atk.attack()}class AttackMethod~Interface~ {attack()}Character *-- AttackMethodclass PhysicalAttack {attack() &#34;Physical attack&#34;}class MagicAttack {attack() &#34;Magic attack&#34;}AttackMethod &lt;|-- PhysicalAttackAttackMethod &lt;|-- MagicAttack內文 光看維基百科的說明可能會有點霧煞煞，我們拿 RPG 遊戲來做一個舉例好了：設想今天，我們有一個 RPG 遊戲，裡面的角色可以選擇「劍士、盜賊、弓箭手、法師、和海盜」五種角色，同時每種角色都有其獨特的攻擊方式（劍士用刀劍、弓箭手用弓弩、海盜用手槍指虎&amp;hellip;等等）。在不使用策略模式的情況下，如果我們想要實現遊戲中的程式，可能就會需要有一個像下面的 pesudo code：
class Role { enum character {Warrior, Thief, Bowman, Magician, Pirate}; void attack() { switch(character) { case Warrior: print(&amp;#34;Using a sword to attack.</description>
    </item>
    
    <item>
      <title>簡單工廠模式（Simple Factory Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/simple_factory_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/simple_factory_pattern/</guid>
      <description>簡單工廠模式（Simple Factory Pattern）#說明 ChatGPT：簡單工廠模式（Simple Factory Pattern）是一種軟體設計模式，屬於創建型模式之一。它提供了一個集中化的「工廠」類別，負責根據客戶端的要求創建不同的產品物件，而客戶端不需要直接與具體的產品物件或其創建細節進行交互。通常，一個普通的簡單工廠會有以下的三種角色：產品（Product）：定義了一個產品的共同介面。具體產品（Concrete Product）：實現了產品的一個介面，是工廠所創建的具體物件。簡單工廠（Simple Factory）：負責根據客戶端的要求，創建具體產品物件的工廠類別。在簡單工廠模式中，客戶端通過傳入相應的參數，調用簡單工廠類別的靜態方法（或非靜態方法），由簡單工廠根據參數的不同來創建具體的產品物件。客戶端不需要關心具體的物件創建細節，只需要與簡單工廠類別進行交互即可。
維基百科：簡單工廠模式是一種創建型模式，該模式創建了一個單一的工廠類別，並在類別中宣告產生具體產品的方法。用戶端可以對該工廠輸入不同的參數，而工廠則根據參數的不同，實現不同的具體對象返回給客戶端。這種工廠類別因為與使用者的交互相對單純，因此可以將工廠方法設定為靜態方法。簡單工廠封裝了對象的建立過程。如果物件的建立過程非常複雜或繁瑣，工廠方法就非常有用了。我們可以將這種選擇邏輯包裝在一個簡單工廠中。
特點 可以集中化的物件創建 封裝創建細節，將用戶與具體產品解偶 如果打算增加新產品，則需修改工廠類別中的方法 UML Graphic classDiagramclass Role {Chatacter* chatacter;Weapon* getReward() RewardFactory.getReward(chatacter);}class RewardFactory {Weapon* getReward(Character* chatacter);}class Weapon {}Role o-- RewardFactoryRewardFactory --&gt; WeaponWeapon &lt;|-- SwordWeapon &lt;|-- BowWeapon &lt;|-- DaggerWeapon &lt;|-- Staff內文 在 GoF 的設計模式裡面，簡單工廠模式、工廠方法模式、和抽象工廠模式為三種不同的「工廠模式」，分別可以對於不同複雜度的程式降低不同程度的複雜性、和提升程式的擴展性與其他效能。「簡單工廠模式」顧名思義，就是可以透過一個「工廠」來「簡單地」生成物件的程式撰寫方式。假設我們現在有一個 RPG 遊戲，裡面需要實做一個「當玩家完成某項任務之後，遊戲可以依照其玩家的職業，給予相對應的武器作為獎賞」的程式，對於一般的程式撰寫方式，我們可能會寫出類似於下面的程式邏輯：
class Role { public: Weapon* getReward() { Weapon* reward = nullptr; switch(this -&amp;gt; character) { case Warrior: reward = new Sword(); break; case Thief: reward = new Dagger(); break; case Bowman: reward = new Bow(); break; case Magician: reward = new Staff(); break; case Pirate: reward = new HandGun(); break; } return reward; } }; 這樣的寫法並沒有什麼特別的邏輯錯誤，但這樣的寫法會產生幾個缺點：首先是「getReward() 方法的長度會隨著職業的增加而逐漸變大。」如果今天遊戲中的職業為一個恆定的數量，那麼這樣的寫作方式其實也還算允許，但如果在某一次的改版中，我們被要求「新增大約 5-10 種不同的職業，並針對這些新增的職業額外撰寫可以獲得任務獎勵。」那麼程式的量級就會愈發龐大了。另外來說，因為不同的職業會需要不同的任務獎勵，因此這樣的寫法上，【角色】類別也會依賴於各種【任務獎勵】的類別。</description>
    </item>
    
    <item>
      <title>組合模式（Composite Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_pattern/</guid>
      <description>組合模式（Composite Pattern）#說明 ChatGPT：組合模式（Composite Pattern）是一種結構型設計模式，它允許將對象組織成樹狀結構以表示「部分 - 整體」的層次結構。組合模式使得用戶可以一致地處理單個對象和組合的對象，並且無需對它們進行區分。在組合模式中，有以下幾個角色：Component（組件）：組件定義了組合中所有對象的通用接口，它可以是接口或抽象類別。它聲明了一些管理和訪問子組件的方法，並可以提供默認的實例方法。Leaf（葉子）：表示組合中的葉子節點，即沒有子節點的對象。葉子對象實現了 Component 接口。Composite（組合）：表示組合中的複合節點，即包含子節點的對象。組合對象實現了 Component 接口，並保存了一個子節點的列表。組合模式的核心思想是「讓用戶對『單個對象』和『組合的對象』進行統一處理」，從而降低了用戶程式的複雜性。用戶不需要區分當前處理的是單個對象還是組合的對象，而是統一通過 Component 接口來進行操作。
維基百科：在軟體工程中，組合模式是一種結構型模式。組合模式描述了一組對象，這些對象的處理方式與同一類型對象的單個實例相同。組合的目的是將對象「組合」成樹結構，以表示「部分 - 整體」層次結構。實現組合模式可以讓客戶端統一處理單個對象和組合。組合模式是 23 個著名的設計模式之一，它描述瞭如何解決重複出現的設計問題，以靈活的設計且可重用的物件導向程式解決問題，意即更容易實現、更改、測試和重用的對象。組合模式可以解決什麼問題？：組合模式利用了部分 - 整體的層次結構，讓客戶端可以統一對待部分和整體對象。組合模式描述了什麼解決方案？ 組合模式會將物件的部分（Leaf）和整體（Composite）定義一個統一的組件接口。各個 Leaf 直接實例 Component，而 Composite 則將請求轉發到其子組件（可能是 Leaf 或 Composite）。這使得客戶端能夠通過 Component 的接口來統一處理所有程式使得客戶端更容易實現、更改、測試和重用。
特點 利用「部分 - 整體」的遞迴結構實現單一操作的功能 UML Graphic classDiagramclass Character~Interface~ {void attack();}Character &lt;|-- Monster~Interface~Character &lt;|-- Player~Interface~Character &lt;|-- Team~Interface~class Team {Character[] teammate}Team --&gt; Character內文 組合模式所強調的「部分 - 整體」有點類似一即全，全即一的感覺，透過對於「單個物件的操作」可以遞迴影響到「整個物件群組」舊式組合模式想要解釋的概念。我們可以用一個 RPG 遊戲的例子來解釋組合模式：在一個 RPG 遊戲中，我們想要設定一個「主角可以與一同前行的人物組成『隊伍』，並透過與不同的『怪物們』相互對戰之後，最終打敗大 BOSS 取得勝利」作為一個核心的遊戲戰鬥機制。在這個機制下，所有的「成員」都是「隊伍」的一部分。而「隊伍」即是所有「成員」的組成。</description>
    </item>
    
    <item>
      <title>裝飾器模式（Decorator Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/decorator_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/decorator_pattern/</guid>
      <description>裝飾器模式（Decorator Pattern）#說明 ChatGPT：裝飾器模式（Decorator Pattern）是一種結構型設計模式，它允許動態地為對象添加額外的功能，並且不需要修改其代碼。這種模式通常用於擴展一個類的功能，並且提供了比繼承更靈活的解決方案。 在裝飾器模式中，將功能的實現分成核心部分和裝飾部分。核心部分代表原始類，它可以是一個抽象類或接口，裝飾部分則是一系列具體的裝飾器類，用於擴展核心部分的功能。裝飾器模式的典型應用場景是在不改變原始類的情況下，動態地擴展功能。例如，可以用來為一個圖形繪製程式添加不同的效果，如邊框、陰影、填充等，這些效果可以在運行時動態地添加，且不影響圖形本身的類結構。通常來說，一個裝飾器模式的基本結構包含以下角色：Component（組件）：定義了核心功能的接口，可以是抽象類或接口。Concrete Component（具體組件）：實現了 Component 接口的具體類，代表原始類。Decorator（裝飾器）：維持一個指向 Component 的引用，並實現 Component 接口，這樣可以動態地添加功能。ConcreteDecorator（具體裝飾器）：擴展 Decorator 的功能，並實現具體的裝飾行為。
維基百科：裝飾器模式又叫做「修飾模式」，是物件導向程式領域中，一種動態地往一個類別中添加新的行為的設計模式。就功能而言，裝飾器模式相比生成子類別更為靈活，這樣可以給某個對象而不是整個類別添加一些功能。通過使用裝飾器模式，可以在程式運行時，動態地擴充一個類別的功能。原理是：增加一個「修飾類」去包裹原來的類別，包裹的方式是在修飾類的構造函數中將原來的類以參數的形式傳入。裝飾類實現新的功能，但是，在不需要用到新功能的地方，它可以直接調用原來的類別中的方法。此外，修飾類必須和原來的類別有相同的接口。裝飾器模式是類別繼承的另外一種選擇。類繼承在編譯時候增加行為，而裝飾器模式則是在程式運行時增加行為。當有幾個相互獨立的功能需要擴充時，這個區別就變得很重要。在有些物件導向的程式語言中，類別不能在運行時被創建，通常在設計的時候也不能預測到有哪幾種功能組合。這就意味著要為每一種組合創建一個新類別。相反，裝飾器模式是在程式運行時候的實例化物件的，這樣就可以在程式運行的時後，根據需要進行不同地組合。
特點 可以通過裝飾器類，動態地擴展物件的功能 可以對物件任意組合功能，使得系統的擴展性更好 遵從設計原則中的「開放封閉原則」 UML Graphic classDiagramWeapon &lt;|-- SwordWeapon &lt;|-- AxeWeapon &lt;|-- Daggerclass Decorator~Interface~ {Decorator(Weapon* w)}Weapon &lt;|-- Decorator~Interface~Decorator~Interface~ &lt;|-- AttackBuffDecorator~Interface~ &lt;|-- CritBuffDecorator~Interface~ &lt;|-- PenetratingBuff#內文 裝飾器模式是一種比較特別的設計模式，它的核心用途是「利用『非繼承』的方式，擴增原本的類別」。因為裝飾器模式可以遞迴執行（或者說它的本質就是遞迴執行），因此也適用在「重複疊加某一種效果的需求」的情境上。讓我們用一個 RPG 遊戲來當例子：假設我們在實現一個【武器強化】的功能，可以針對不同的武器（像是劍、斧頭、匕首&amp;hellip;等）進行不同種的強化（增益攻擊、爆擊、或護甲穿透&amp;hellip;等），如果我們用「繼承」的方式來寫的話，可能會寫出類似於下面這樣的程式碼：
class Weapon {}; class Sword : public Weapon {}; class Attack_Buff_Sword : public Sword {}; class Crit_Buff_Sword : public Sword {}; class Penetrating_Buff_Sword : public Sword {}; class Axe : public Weapon {}; class Attack_Buff_Axe : public Axe {}; class Crit_Buff_Axe : public Axe {}; class Penetrating_Buff_Axe : public Axe {}; class Dagger : public Weapon {}; class Attack_Buff_Dagger : public Dagger {}; class Crit_Buff_Dagger : public Dagger {}; class Penetrating_Buff_Dagger : public Dagger {}; 這樣子的做法有幾個壞處：首先是程式的類別會依照【武器】與【增益效果】的變多而快速增加。在當前的狀況下，如果我們想要新增兩種武器（長槍、弓箭）那麼我們除了新增 Lance, Bow 兩種類別之外，我們還要根據不同的類別分別實作攻擊增益、爆及增益、以及穿透護甲增益三種類別。那如果再之後我們打算多新增 \(x\)種武器和 \(y\)種增益效果，類別的數量就會以驚人的速度成長了。</description>
    </item>
    
    <item>
      <title>觀察者模式（Observer Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/observer_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/observer_pattern/</guid>
      <description>觀察者模式（Observer Pattern）#說明 ChatGPT：觀察者模式（Observer Pattern）是一種行為型設計模式，也被稱為發布-訂閱（Publish-Subscribe）模式或模型-視圖（Model-View）模式。它用於建立對象之間的一對多的依賴關係，當一個對象的狀態發生變化時，所有依賴它的對象都會收到通知並自動更新。在觀察者模式中，有兩個主要角色：主題（Subject）：也稱為「可觀察對象」或「被觀察者」。它是一個被觀察的對象，當其狀態發生變化時，它會通知所有註冊過的觀察者。觀察者（Observer）：也稱為「訂閱者」或「觀察者」。它是依賴於主題的對象，當【主題】的狀態發生變化時，【觀察者】會收到通知並根據新的狀態進行更新。觀察者模式的主要目的是解耦主題和觀察者，使它們之間不需要直接相互交互，從而提高程式的靈活性和可重用性。【主題】不需要知道【觀察者】的具體類型，只需要知道它們實現了共同的觀察者接口。這樣在未來添加新的觀察者時，【主題】的程式不需要進行修改。
維基百科：觀察者模式是行為型設計模式的一種，用於建立對象之間的一對多依賴關係。在此種模式中，一個目標物件管理所有相依於它的觀察者物件，並且在它本身的狀態改變時主動發出通知。這通常透過呼叫各觀察者所提供的方法來實現。此種模式通常被用在即時事件處理系統。通常來說，觀察者模式包含以下幾種結構：【抽象主題介面】 抽象主題介面會提供一個介面，讓【觀察者】進行添附（Attach）與解附（Detach）的作業，此類別內會包含一個不公開的【觀察者】串列，且通常具有以下三種方法：添附 attach() 可以新增觀察者到串列內，以追蹤主題的變化。解附 detach() 可以將已經存在的觀察者從串列中移除。通知 notify() 利用觀察者所提供的更新函式來通知此目標已經產生變化。【主題類別】 主題類別提供了【觀察者】欲追蹤的主題，【觀察者】可以透過【目標主題】的 getState() 方法取得主題的狀態。【抽象觀察者介面】 抽象觀察者介面會定義觀察者都擁有的更新用介面，此介面是用來接收目標類別所發出的更新通知。 【觀察者類別】 觀察者類別含有一個（或多個）主題，並可以透過 update() 方法來更新主題的狀態。
特點 可以通過該模式，建立簡單地一對多關係 將【主題】與【觀察者】解耦和抽象 可以動態的對【主題】與【觀察者】進行調整與修改 UML Graphic classDiagramclass Subject~Interface~ {Observers list[]void attach()void detach()void notify()void getState()}Subject &lt;|-- Characterclass Observer~Interface~ {Subject* subjectvoid update()}Subject --&gt; ObserverObserver &lt;|-- Group內文 觀察者模式是一個蠻常見的設計模式，通常用於即時性的程式需求上，例如 GUI 介面、彈出式訊息、或者是 MVC 的應用程式&amp;hellip;等。在觀察者模式中，會有一個【主題】與一個（或多個）【觀察者】。如果用 RPG 來舉例的話，線上遊戲的「公會頻道」「隊與頻道」&amp;hellip;等訊息就可以用觀察者模式實作。我們可以想像一個情境：玩家 A 在加入公會 X 之前，如果公會的成員在「公會頻道」發出文字訊息的話，玩家 A 是不會收到任何訊息的，但在玩家 A 加入了 X 之後，如果公會中的其他成員在「公會頻道」丟出文字訊息的話，那麼 A 就會收到該訊息了。</description>
    </item>
    
    <item>
      <title>解釋器模式（Interpreter Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/interpreter_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/interpreter_pattern/</guid>
      <description>解釋器模式（Interpreter Pattern）#說明 ChatGPT：解釋器模式（Interpreter Pattern）是一種行為型設計模式，它主要用於「定義一種語言文法的表示」，並提供一個【解釋器】來解釋這種語言中的句子。該模式通常用於解決特定領域中的問題，例如解釋語言、數學表達式或查詢語句等。解釋器模式的主要組件包括：抽象表達式（Abstract Expression）、終端表達式（Terminal Expression）、非終端表達式（Non-terminal Expression）、上下文（Context）、和解釋器（Interpreter）。【抽象表達式】會定義一個抽象的介面，包含一個 interpret() 方法，這個方法會根據特定語言文法進行解釋。【終端表達式】實現了抽象表達式的 interpret() 方法，代表該語言中的終端符號，不能再分解成更小的元素。【非終端表達式】也同樣會實現【抽象表達式】的 interpret() 方法，用於組合多個終端表達式，形成複雜的語句。【上下文】包含要解釋的語句，通常由解釋器進行操作。【解釋器】則會根據語言文法對表達式進行解釋。 解釋器模式的工作流程如下：首先我們需要定義「語言文法」，並將其分解成【終端表達式】和【非終端表達式】。接下來，我們會創建對應的【表達式】類別，實現 interpret() 方法，根據語言文法進行解釋。然後，會構建一個語句的抽象語法樹（AST - Abstract Syntax Tree），將表達式組合成複雜的語句。再創建上下文，傳遞要解釋的語句。最後創建解釋器，根據語句的 AST 對其進行解釋，生成結果。
維基百科：在物件導向程式設計中，「解譯器模式」是一種行為型設計模式，用於指定「如何評估一種『語言』中的句子」。基本思想是為專門的電腦語言中的每個符號建立一個（或一些）類別，其中包含【終端類別】與【非終端類別】。該語言中，「句子」的語法樹是組合模式的實例，用於為客戶端「解釋」該句子。解譯器設計模式是 23 種著名的 GoF 設計模式之一，GoF 設計模式描述了如何解決反復出現的設計問題，以設計靈活且可重用的物件導向程式，即更容易實施、更容易變更、更容易測試和重用的對象。「解譯器設計模式可以解決哪些問題？」解釋器模式透過定義一種簡單語言的語法，讓程式可以簡單地「解釋」該語法中的不同語句。當某種問題經常一類似的結構發生時，我們可以考慮將其表示為一種新的、簡單的語言中的句子，以便【解譯器】可以通過解釋該語句來解決問題。例如：當需要指定許多不同或複雜的搜索表達式時。將它們直接硬編寫到類別中是不靈活的，因為它會使類別受限於特定的表達式，並且無法獨立於類別之外的新的表達式或更改現有的表達式。因此在這樣的情況下，透過新增一個【解釋器】，並將語句定義為各種【終端語句】與【非終端語句】會更為靈活與彈性。
特點 可以通過「語言解釋」將複雜的語句轉變為一系列的程式邏輯 可以解耦【語法】和【程式執行】，使其更為彈性 可以自由組合不同的語句，形成各種多樣語靈活的表示方法 UML Graphic classDiagramclass Character {void spellcast()}class Expression~Interface~ {interpret();}Expression &lt;|-- FixedExpressionExpression &lt;|-- GodExpressionExpression &lt;|-- StateExpression#內文 從體感上來看，個人認為解釋器模式是 23 種常見的設計模式裡最難讓人搞懂得一個模式。有學過「編譯器」這門課的人對於解釋器在做的工作應該會比較能夠有感：整體而言，解釋器模式的工作就是在「拆分」與「分析」一段句子是否符合邏輯？和他想要表達什麼樣的意思。讓我們用一個 RPG 遊戲來舉例：假設在一個 RPG 遊戲中，我們打算實踐一個「咒文詠唱系統」。其功能是讓玩家（一個法師）在進行戰鬥的時候，可以透過『輸入一串咒文』來達成「強力施法」這件事情。並且在這樣的情況下，我們定義了一個「傷害反彈」的詠唱詞：「誠惶誠恐呼喚日不見神，先祖之產土神。領受已久之山河，誠惶誠恐，僅此奉還於。(註１)」如果成功在某一特定的秒數內詠唱該詞句，便可以增加玩家的防禦力。在不使用「解釋器模式」的狀況下：可能會撰寫出類似下面的程式：
class Character { public: string name; int defense; public: Player(string name) : name(name) : defense(20) {} void spellCasting(string prayer) { if (prayer == &amp;#34;誠惶誠恐呼喚日不見神，先祖之產土神。領受已久之山河，誠惶誠恐，僅此奉還於爾&amp;#34;) { defense += 10; cout &amp;lt;&amp;lt; &amp;#34;defense += 10&amp;#34; &amp;lt;&amp;lt; endl; } else { cout &amp;lt;&amp;lt; &amp;#34;.</description>
    </item>
    
    <item>
      <title>訪問者模式（Visitor Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/visitor_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/visitor_pattern/</guid>
      <description>訪問者模式（Visitor Pattern）#說明 ChatGPT：訪問者模式（Visitor Pattern）是一種行為型設計模式，它用於將算法操作從物件的結構中分離出來。訪問者模式允許「在不修改已有的物件結構」的情況下，定義新的操作。這種模式主要用於對一組相關的物件進行某種操作，而不必修改這些物件的類別。在訪問者模式中，有兩個主要角色：分別是訪問者（Visitor）和元素（Element）。【訪問者】是一個接口或者一個抽象類別，它定義了對物件結構中，操作每個元素的方法。具體的【訪問者】類別將實現這些方法，以定義特定的操作。【元素】則是一個接口或抽象類，它定義了接受訪問者的方法。每個元素類別將實現這個方法，以便在【訪問者】來訪時，調用【訪問者】的相應方法。訪問者模式的核心思想是：「當需要對物件結構中的元素進行不同的操作時，不需要修改元素類別，而是定義新的訪問者類別來實現這些操作。」這樣可以實現操作的「新增」而不改變元素結構，同時也不會影響其他的操作。訪問者模式適用於以下情況：「當一個物件結構包含多種類型的元素，且需要對這些元素進行不同的操作時。」「當物件想要新增新的操作，同時也希望不影響現有元素類別時。」與「當對象結構中的元素結構相對穩定，但其操作算法可能會經常更改時。」總的來說，訪問者模式可以幫助我們實現對物件結構的不同元素進行多種操作，同時保持類別的相對穩定，並提高了系統的可擴展性和可維護性。
維基百科：訪問者模式（Visitor Pattern）是一種軟體設計模式，用於將演算法與物件結構分離。由於這種分離，使用者可以在不修改物件結構的情況下，向現有的物件結構添加新的操作。這是在 &amp;ldquo;物件導向程式&amp;rdquo; 和 &amp;ldquo;軟體工程&amp;rdquo; 中，遵循開放封閉原則的一種方法。基本上，訪問者允許在一個類族中添加新的虛擬函數，而無需修改這些類。接著，再創建一個訪問者類，其中實現了所有適當的虛擬函數的實例化。訪問者接收實例引用作為輸入，並通過雙重派發（double dispatch）來實現目標。訪問者模式能夠輕鬆地分支處理物件的類型，並在定義了訪問者尚未處理的新物件類型時生成編譯器錯誤。此外，訪問者設計模式也是 23 種著名的四人幫設計模式之一，它（四人幫設計模式）描述了如何解決重複性的設計問題，以設計靈活且可重用的面向對象軟體，即易於實現、更改、測試和重用的物件。「什麼問題可以通過訪問者設計模式解決？」：如果想要在不更改類的情況下，為物件結構的（某些）類別定義新操作，可以使用此類別。「訪問者設計模式描述了什麼解決方案？」訪問者模式定義一個單獨的【訪問者】物件，該物件實現對物件結構的元素執行的操作。客戶端可以遍歷物件結構，並在元素上調用訪問者進行元素操作：意即將操作將請求分派（委派）給【被接受的訪問者物件】。然後，訪問者物件對元素執行操作（&amp;ldquo;訪問元素&amp;rdquo;）。這樣一來，可以通過添加新的訪問者物件獨立於物件結構的類別來創建新的操作。
特點 可以分離【元素】與【操作】的高度耦和 新增【操作】不會影響到原【元素】的程式碼 增加程式的彈性與靈活性 UML Graphic classDiagramclass Character~Interface~ {void accept(Visitor* visitor);}note &#34;void accept(Visitor* visitor) {\n　visitor.visit(this);\n}&#34;Character &lt;|-- RoleCharacter &lt;|-- MonsterRole &lt;|-- WarriorRole &lt;|-- BowmanRole &lt;|-- MagicianRole &lt;|-- ThiefMonster &lt;|-- ZombieMonster &lt;|-- SlimeMonster &lt;|-- SkeletonclassDiagramclass Visitor~Interface~ {void visit(Role* role);void visit(Monster* monster);}Visitor &lt;|-- PhysicalAttackVisitorVisitor &lt;|-- MagicAttackVisitorVisitor &lt;|-- EscapeVisitor內文 訪問者模式主要要解決的問題是「在不更動原始物件的前提下，對原始物件進行一些新的功能擴充」也就是在不影響原始物件的前提下，進行物件的方法擴充。我們用一個 RPG 遊戲的戰鬥過程來做舉例：假設在一個 RPG 的回合制戰鬥中，【角色】總共可以對【怪物】進行兩種不同的攻擊方式，分別是「普通攻擊（物理攻及）」和「魔法攻擊」這兩種。在不使用訪問者模式的程式撰寫情境下，我們可能會寫出類似於下面的程式碼：</description>
    </item>
    
    <item>
      <title>責任鏈模式（Chain of Responsibility Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/chain_of_responsibility_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/chain_of_responsibility_pattern/</guid>
      <description>責任鏈模式（Chain of Responsibility Pattern）#說明 ChatGPT：責任鏈模式（Chain of Responsibility Pattern）是一種行為型設計模式，它允許多個物件依序處理請求，這些物件會被連成一條「鏈」（chain），每個物件都有可能處理請求，如果某個物件無法處理，則將請求傳遞給下一個物件來處理，直到有物件處理成功或者整個鏈都無法處理為止，責任鏈模式允許程式在運行時不確定哪個物件將處理這個請求。在責任鏈模式中，通常每個處理器（Handler）都會有一個指向下一個處理器的指標，從而形成了一條鏈。當一個請求進入這個鏈時，從第一個處理器開始依序檢查是否可以處理該請求？如果可以，則處理器會進行處理，但如果不行，則傳遞給下一個處理器，依此類推&amp;hellip;，直到找到能夠處理請求的處理器，或者整個鏈都無法處理為止。責任鏈模式可以將請求的發送者和接收者解耦，讓不同的處理器對請求進行獨立的處理，增加了系統的靈活性和可擴展性。同時也支持在運行時動態地組織「鏈」，方便新增或者移除處理器。責任鏈模式的主要角色有：處理器（Handler）：定義一個處理請求的接口，並且持有下一個處理器的指標，以便將請求傳遞給下一個處理器。具體處理器（Concrete Handler）：具體處理器會實現具體的【處理器】接口，並且能夠處理特定類型的請求，如果無法處理則將請求傳遞給下一個【具體處理器】。請求（Request）：定義需要處理的請求。在責任鏈模式中，【請求】將依序經過每個具體處理器，直到找到能夠處理的具體處理器為止。責任鏈模式可以達到動態組織處理器的目的，也提高了系統的靈活性和可維護性。
維基百科：在物件導向程式設計中，責任鏈模式（Chain of Responsibility Pattern）是一種行為型設計模式，該模式由【命令對象】和一系列的【處理對象】所組成。每個【處理對象】都包含（與定義）它可以處理的命令類型；如果【命令】無法被該【處理對象】執行，【命令】則會被傳遞到責任鏈中的下一個【處理對象】。此外，該模式也存在一種「將新的【處理對象】添加到該鏈末尾」的機制或方法，可以對鏈做一些刪除或擴展。此外，對於責任鏈模型的變體中，一些處理程序可以充當調度程序，向多個方向發送命令，形成一顆責任樹。在某些狀況下，這可能會產生遞歸的情況：【處理對象】使用【命令】調用更高層的【處理對象】，試圖解決問題的較小部分這種模式提倡鬆散耦合的思想。責任鏈模式（Chain of Responsibility Pattern）在結構上與裝飾器模式（Decorator Pattern）幾乎相同，不同之處在於：對於裝飾器來說，所有的類別都會處理請求；可對於責任鏈來說，只有鏈中的一個類別（也就是【處理對象】）會處理請求。
特點 aaa UML Graphic classDiagramclass Quest {void execute();}Quest &lt;|-- HuntingQuestQuest &lt;|-- GatheringQuestQuest &lt;|-- DungeonQuestclassDiagramclass Handler {Handler* next;void setNext(Handler* handeler);}Handler &lt;|-- MondayHandlerHandler &lt;|-- TuesdayHandlerHandler &lt;|-- WednesdayHandler內文 『責任鏈模式』可以用來解決客戶端「類別依賴」的問題。在一個普通的責任鏈模式中，總共會有是處理器（Handler）與客戶端（Client）兩種不同的角色，如果用 RPG 遊戲來做舉例的話，我們假設【玩家】可以依照不同的「星期」來進行不同的【活動任務】，分別是星期一的【魔物狩獵】（HuntingQuest）、星期二的【藥材採集】（GatheringQuest）、星期三的【地下城探險】（DungeonQuest）、星期四的【跑腿送信】（CourierQuest）、與星期五的【地下城探險】（DungeonQuest）&amp;hellip;，在不使用『責任鏈模式』的狀況下，程式可能會撰寫成以下的樣子：
class DailyQuest { public: virtual void execute() = 0; }; class HuntingQuest : public DailyQuest { public: void execute() override { // Monster hunting .</description>
    </item>
    
    <item>
      <title>迭代器模式（Iterator Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/iterator_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/iterator_pattern/</guid>
      <description>迭代器模式（Iterator Pattern）#說明 ChatGPT：迭代器模式（Iterator Pattern）是一種行為型設計模式，它主要用於提供一種訪問集合元素（如列表、數組、樹等）的方法，而不需要暴露該集合的內部表示。通過迭代器模式，我們可以透過統一的接口來遍歷（iterate()）集合中的元素，無需關心底層的數據結構。「迭代器模式」的主要目標是「分離集合的『遍歷行為』與『程式實現』」。這樣可以提供更好的解耦和靈活性。該模式通常包含以下主要元素：【迭代器】（Iterator）：用於定義「訪問」和「遍歷」集合元素的介面。迭代器通常包含方法如 next()（返回下一個元素）、hasNext()（檢查是否還有下一個元素）等。【具體迭代器】（Concrete Iterator）：具體迭代器實現了【迭代器】的接口，並提供了對具體集合的元素遍歷實現。不同的集合可能需要不同的具體迭代器。【集合】（Collection）： 定義了管理元素的方法，如添加、刪除元素&amp;hellip;等。可以是列表、數組、樹&amp;hellip;等。【具體集合】（Concrete Collection）：實現了【集合】的接口，提供了實際的元素管理方式。不同的具體集合可能有不同的存儲結構。通過使用迭代器模式，客戶端的程式可以僅通過【迭代器】來訪問集合的元素，而無需關心程式的底層細節。這樣可以使程式更具可讀性、可維護性，並且支持在不改變客戶端程式的情況下更改集合的實現方式。
維基百科：在物件導向程式設計中，「迭代器模式」是一種設計模式，其中使用【迭代器】來遍歷容器，並訪問容器的逐個元素。迭代器模式嘗試將「遍歷的演算法」與「容器」解耦；「迭代器模式能解決哪些問題？」該模式可以讓聚合物件（列表、數組&amp;hellip;等）的元素，在不暴露其表示資料結構的情況下，進行訪問和遍歷。同時也可以為聚合物件定義新的遍歷操作，而不改變其介面。在一般情況下，直接再聚合介面中定義「訪問」和「遍歷」操作是不靈活的，因為這樣的程式撰寫方式會使得聚合受限於特定的訪問和遍歷操作，且無法在不更改聚合介面的前提下添加新操作。「迭代器模式如何解決此問題方案？」迭代器模式會定義一個獨立的【迭代器】物件，並封裝「訪問」和「遍歷」的方法，讓聚合物件各自繼承並實例。客戶端使用可以直接使用【迭代器】來訪問方法和遍歷方法來檢視聚合物件，而不需要了解其物件內真實的資料結構。不同的迭代器可以以不同的方式訪問和遍歷聚合。可以通過定義新的迭代器來獨立地定義新的訪問和遍歷操作。
特點 分離「集合」本身的資料結構與「迭代」的程式邏輯 可以隱藏集合的資料結構，使客戶端不須依賴特定的程式操作 提供統一的遍歷程式，提高程式的可重用性 UML Graphic classDiagramclass Iterator {bool hasNext();void next();}Iterator &lt;|-- CharacterTeamIteratorIterator &lt;|-- MonsterTeamIteratorclass CharacterTeam {Iterator* iteratorCharacter teammate[]}class MonsterTeam {Iterator* iteratorMonsterNode head}CharacterTeam &lt;|-- Characterclass MonsterNode {Monster* monsterMonsterNode* next}MonsterTeam --&gt; MonsterNodeMonsterNode --&gt; Monster#內文 迭代器模式是個相對簡單的設計模式。該模式的用途是「讓所有不同的容器，都可以有一個統一的『遍歷』方法。」通常來說，一個迭代器模式裡面總共會包含著四種類別：【迭代器介面】【具體迭代器】【集合介面】和【具體集合】。讓我們用一個 RPG 遊戲來做舉例：假設再一個 RPG 的戰鬥中，總共分為「主角方」和「怪物方」兩方的陣容。在程式的撰寫上分別由工程師 A 和工程師 B 進行工作。工程師 A 在主角（Character）的地方，新增了一個 CharacterTeam 的類別，用以紀錄主角的隊伍成員，以及它們各自的資訊；工程師 B 則同樣使用了類似的做法，在怪物方（Monster）新增了一個 MonsterTeam 類別，同樣也是記錄怪物的編隊與各自的訊息，如下述的程式所示：</description>
    </item>
    
    <item>
      <title>適配器模式（Adapter Pattern）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/adapter_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/adapter_pattern/</guid>
      <description>適配器模式（Adapter Pattern）#說明 ChatGPT：適配器模式（Adapter Pattern）是一種軟體設計模式，屬於結構型模式的一種。它主要用於「將一個類別的接口」轉換成另一個「客戶端所期望的接口」，從而使原本不兼容的類別能夠一起工作。在軟體設計中，有時候因為歷史原因、不同的介面設計或第三方庫的使用，可能會出現一些類別之間接口不匹配的情況。這時候就可以使用適配器模式來解決這種問題，而無需修改原有的類別。適配器模式的核心概念是引入一個適配器（Adapter）類別，這個類別負責將不兼容的接口轉換成目標接口，使得客戶端可以通過適配器使用原本不兼容的類別。適配器可分為類別適配器和物件適配器兩種：其中類別適配器使用「繼承」的方式來進行接口轉換，物件適配器則使用「組合」的方式來進行接口轉換，通過調用原始類別的方法來實現目標接口的方法。適配器模式的優點是能夠提高程式碼的重用性和靈活性，同時也能夠保護現有程式碼，無需修改原始類別。
維基百科：在設計模式中，適配器模式（Adapter Pattern）有時候也稱包裝模式（Wrapper Pattern）。適配器模式用來將一個類別的介面轉接成使用者所期待的另一種介面。一個適配器可以讓「因程式不相容而不能在一起工作的類別」能在一起工作，其中的做法是將類別自己的介面包裹在一個已存在的類別中。適配器模式的結構通常分為兩種類型：「物件型適配器」（在適配器本身中包含一個呼叫對象的物件）和「類別型適配器」（新增一個適配器類別，繼承自原類別，並用擴增的方式使程式可以運作）。適配器模式（Adapter Pattern）是 23 個著名的設計模式之一，它通常用以解決以下的幾種問題：如何將以棄用（或很少使用）的舊型接口更新為一個新形態的程式接口、如何將原本不兼容的兩種接口相互兼容、如何為某個（或某些）類別提供替代接口、和如何將舊有的接口設計為客戶所要求的新型接口。
特點 a bb ccccc UML Graphic classDiagramclass MonsterAttackAdapter {void attack();}class Zombie {void bite();}class ZombieAttackAdapter {Zombie* zombievoid attack();}ZombieAttackAdapter --&gt; Zombieclass Goblin {void knock();}Monster &lt;|-- ZombieMonster &lt;|-- Goblinclass GoblinAttackAdapter {Goblin* goblinvoid attack();}GoblinAttackAdapter --&gt; GoblinMonsterAttackAdapter &lt;|-- ZombieAttackAdapterMonsterAttackAdapter &lt;|-- GoblinAttackAdapterclassDiagramclass CharacterAttackAdapter {void attack();}class Warrior {void chop();}class WarriorAttackAdapter {Warrior* warrior;void attack;}WarriorAttackAdapter --&gt; WarriorCharacter &lt;|-- Warriorclass Magician {void magic_attack();}class MagicianAttackAdapter {Magician* magician;void attack();}MagicianAttackAdapter --&gt; MagicianCharacter &lt;|-- MagicianCharacterAttackAdapter &lt;|-- WarriorAttackAdapterCharacterAttackAdapter &lt;|-- MagicianAttackAdapter內文 如果要用一句話來作總結的話，適配器模式的用途就是用於「將兩組原本互不兼容的程式可以相互兼容」。我們用 RPG 遊戲來舉個例子：假設我們正在製作一個簡單 RPG 遊戲，在這個 RPG 遊戲中，我們將【戰鬥】的環節設計在一個 Battle 類別的靜態方法 battle() 中，其中 battle() 方法帶有兩個參數，分別是角色物件 Character 和怪物物件 Monster，如果用「主角與魔王要進行最後的決戰」作為例子，程式大致上會像是下面的這個樣子：</description>
    </item>
    
    <item>
      <title>（據透）筆記區</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/note/note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/note/note/</guid>
      <description>（據透）筆記區#想法：想寫一個跟「信仰」「信念」有關的作品
關於主題：信仰有什麼意義？存在的價值是什麼？
跟主題有關的問題：
何為【信仰】又何為【信念】 鬼、怪物、惡魔、神明 不同人的角度： 對某些人來說，【信仰】即是【信念】，二者之間並無太大的差別 對某些人來說，所謂的【信念】，即是推使自己活下去的重要動力 對某些人來說，【信念】僅僅是個可有可無的存在，沒有特別看法 對某些人來說，可以依靠名為【信仰】的概念，獲得欲追求的利益 參照作品：鋼鍊、獵人、咒術迴戰
世界設定成【輪迴型的世界】 </description>
    </item>
    
    <item>
      <title>Without ToC</title>
      <link>https://fonu195713.github.io/_docs/example/table-of-contents/without-toc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/table-of-contents/without-toc/</guid>
      <description>At me ipso nepotibus nunc celebratior genus#Tanto oblite#Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.
Quam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque.</description>
    </item>
    
    <item>
      <title>不速之客的打擾 - 1</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/01/</guid>
      <description>不速之客的打擾 - 1#滴答…滴答…滴答…
水滴沉沉地敲擊由石塊所構築成的狹小走道，聲音在整個空間裡迴盪起來。
滴答…滴答…滴答…
邁著小心翼翼的步伐，少年全神貫注地警惕四周的動靜，不敢放過身旁的任何一絲細節。
滴答…滴答…滴答…
高舉著手中的火炬，上頭的微弱火光，是這裡唯一的弱小光源。
「鑿城鼠有囤積閃亮東西的習慣，從它們的巢穴裡，有時候可以找到一些不錯的東西。」少年默默地在心中念起方才無意所聽到的對話，火炬的亮光照出了前方一分為二的岔路。
「不錯的東西？」
「大部分是一些光滑的石頭，或者是旅人在行徑森林之後所遺留下來的物品，像是衣袖、紋章、或者是一些碎飾。偶爾也能找到像是金幣、短刀、甚至是水晶這類的值錢玩意兒。」經歷了一番抉擇之後，他選擇向右邊的道路前進。
少年名叫格雷瑪，是名居住在福洛斯村的 14 歲青年。該村落以領主赫拉爾·杰弗里斯的三子福洛斯·杰弗里斯為名，佔地約 130 公頃。是赫拉爾預計在福洛斯成年時分封給他的一塊領地。
因為福洛斯村的東邊緊鄰著坎澤爾森林的緣故，村落的居民大部分以林業和木類加工業為主，此外，由於森林的魔力有時候也會讓住在森林裡的動物變得暴躁、強悍、甚至是襲擊村落的設施，這裡時不時也會聚集一些透過委託或者是請求而從外地來的冒險者們，討伐那些變異的魔物。
「這麼說，只要能到牠們的洞穴裡瞧瞧，說不定就能找到什麼好東西囉？」
「你也可以這麼理解。但在大多時候，直接闖入可不是什麼好決定。」格雷瑪又向巢穴的深處探了幾步。愈發潮濕的環境，以及泥濘中混雜的腐敗氣味令他的鼻腔感到逐漸不適。
「為什麼？」
「除了地域性、攻擊性極強之外，作為被森林影響的一種魔物，鑿城鼠的聽覺、嗅覺、和移動能力也有著顯著的提升，它那龐大的體型、強而有力的門牙、和銳利的爪子更是許多初來乍到的冒險者的一大剋星。這也是為什麼它會被命名為『鑿城鼠』的一大原因。」
「因此，相對於直接闖入，我們會利用熏煙的方式，在巢穴的門口鋪設少量的干草、將之點燃。因為老鼠的靈敏嗅覺，鑿城鼠在聞到燃燒的氣味之後，便會傾巢而出。通常我們才會趁著那個時候，走進牠們的洞穴一探究竟。」或許是適應了巢穴內的黑暗，也或許是愈發加深的恐懼感，少年的步伐開始由緩轉急。眼前出現的第二個岔口，更是想都沒想的往左前進。
「但從鼠群竄出，到它們返回巢穴的時間間隔大概只有 15 分鐘，如果鼠群回到巢穴之後你還在裡面的話，結果就不用我多加說明了吧。」
「嗚姆……」
「因此，除非隊伍有配置天屬性的小隊成員，否則我們一般會以『三個岔路』作為計時單位，如果走了三個岔路，仍然沒有找到什麼值錢的東西的話，在遇到第四個岔路的時候，我們就會原地往返。」繞過腳邊的遺骸小骨，想到這裡的同時，格雷瑪的眼前出現了第三個岔路路口。
——還是選擇左邊⋯⋯嗎？
像是在尋求神明回答似的，格雷瑪在在岔路的路口停了下來，但緊接著，「在想什麼東西啊」和「得抓緊時間才行呢」等接二連三的念頭，促使著他向左邊的道路前進。
「所以，可以理解成『在不以討伐為前提的條件下，煙熏過後 15 分鐘內的鼠巢是個好入侵的空白時段』是嗎？」微弱的火光在照耀前方道路的同時，也稍微反射了一些向前行進的光線。這意味著前方的地面上有著什麼閃亮的東西。
——是錢幣！
格雷瑪再次地加快腳步上前查看。
——沒錯！是錢幣，看這個的數量⋯⋯大概有個 2-3 銀幣左右的價格。
「在大部分的情況下是可以這麼理解的。」
「大部分？」
『『⋯⋯吱⋯吱吱』』
——！ ！ ！ ！ ！ ！ ！ ！ ！ ！ ！ ！ ！ ！
少年瞪大了雙孔並屏住呼吸。此刻，越發急促的心跳聲是他希望在腦海裡能夠聽得到的唯一聲音。
『『⋯⋯吱⋯吱吱』』
試探性的將火把微微向前，光緣的尾端逐漸照映出了一雙沾滿泥濘的巨大爪子。
「在煙熏的情況下，鼠穴只有一種可能還會留有老鼠，那就是如果巢穴裡有無法行動的幼鼠的時候，母鼠會抱持著保護孩子的心情也待在巢穴裡頭。在那個時候，那種老鼠的危險性應該可以從 C級一下子提升到 B或 B- 吧？但這情況幾乎是微乎其微就是了。」
「那⋯⋯如果在那個很小很小的機率上，真的碰著了該怎麼辦呢？」
——吶⋯⋯當然是選擇趕快逃跑或者是死在它的爪下囉。</description>
    </item>
    
    <item>
      <title>不速之客的打擾 - 2</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/02/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/02/</guid>
      <description>不速之客的打擾 - 2#「出於保護幼鼠心態，巢穴內的母鼠在遇到敵人之後，並不會立刻發起攻擊，反而會先以一種低頻的聲音發出警戒，並死死地盯著擅自闖入巢穴的外來者。」少年正努力地回想方才所聽到的字句。
『唧………』鑿城鼠的低沉怒吼，伴隨著火炬的噼咔噪響，迴盪在巢穴中的每個角落。狹小空間的悶熱空氣，更是將原本劍拔弩張的氛圍帶到了一個更加上方的高度。僵滯，或許已經是此時此刻能採取的一種最好方法。
「那接下來該怎麼辦阿？」
「如果沒有信心打敗牠的話，那就不要跟牠有眼神上的接觸。畢竟對方可是等級 B 的魔物。對牠們來說，從『眼神』和『敵我氛圍』來判斷彼此之間的戰力並不是什麼太難的事。也因此，換句話說…」
——死死的盯著地面就好。
或許是出自於本能的反應？也或許是早已把忠告牢記在心。格雷瑪在得知母鼠的存在之後，就一直單純且純粹地望著火把所映照出的某個地方，而非順著火把的餘光，朝向魔物所在的位置視去。
從「保護自己」的這點來看，他做的非常地好。
「接下來要做的事情是安靜的離開現場。這點就沒什麼竅門了，總之就是腳步盡量放輕，然後身體慢慢移動。」少年仍維持右手伸出、身體稍微前傾的姿勢，先前嘗試踏出的右腳，正以非常緩慢的速度向後移動。
待到右腳的位置移動至身體的後方之後，少年便將懸空的腳尖微微地向下擺放。等到腳尖有了接觸地面的感覺之後，再慢慢地、慢慢地將足弓、腳跟…等右腳的其餘部分貼合地面。
然後將右邊的膝蓋微蹲，控制身體的重心由原來的左膝轉移至身體右側，並輕輕地抬起左腳，重複剛剛的動作，讓左腳輕微、但用盡全力地向後跨出。
一步……
火炬在顫慄的右手之下，搖曳的更加劇烈。
兩步……
諾大的汗水，正緩慢地從額頭滑落。
三步……
工靴的金屬材質、和褲管尾端的鈕扣在每次的移動中都會產生些微的碰撞。雖然從邏輯上來看，它們發出的聲音極為細小，但此刻，全身緊繃的神經並沒有辦法準確地判斷實際的音量為何？因此格雷瑪只能祈禱著這樣的聲音不至於加深老鼠的怒火，從而對自己發起攻擊。
「通常母鼠會在岔路後的5-10公尺左右定巢和安置幼鼠。」少年持續地回想著冒險者教科書般的對話內容。
「一般來說，只要能離開母鼠所在的那條岔路，後續也不發出什麼大聲響，危險的程度就算是降到和牠面對面的五分之一或以下了。」
「因為相對於打倒入侵者來說，保護幼鼠才是牠的首要目標。」銘記著腦海裡擁有的少數情報，少年仍在嘗試踏出危險的邊緣。
——這就是面臨死亡的感覺嗎？
他又再往後退了幾步。
——這就是那些人平常的生活嗎？
他嘗試透過自我對話的方式，覆蓋掉由內心恐懼所帶來的呆滯與無力。
——這就是所謂的「冒險者」嗎？
火炬的外側，在向後的過程中，照耀出了另一條由老鼠所開鑿的道路。這表示格雷瑪已經退到了岔路所在的地方。
『唧………』雖然魔物的聲音逐漸變小，但可以確定的是牠仍在觀察。不管是由牠所發出的聲音，或者是內心那種「正被直勾勾的盯著」的直覺都能加以佐證。再一步、再一步…再快一點、再快一點…的想法在少年的腦海中瘋狂打轉。並促使著他的腳步愈發加速。
機械性地繼續往後踏出一步，正如同前幾次所做的那樣，少年的腳尖感受到了一種類似於石塊的觸感。他並沒有多想，也沒有多做確認，只是單純地著對腳尖所碰觸到的地方施力，同時將自己的重心移往腳尖所在的那個位置。
「最後就是一些額外的提醒了：因為是野獸的緣故，所以牠們並不會固定在某一個地方進食，而是只要在巢穴裡頭，確認自己『沒有危險』『足夠安全』之後，就會直接啃食到手的食物。」
【喀！喀噠！】
一個清脆的聲音從少年的腳下響起。
「也因為牠們是野獸的緣故，所以一些像是骨頭阿、金屬阿這類比較硬的、不能夠咬東西，就會直接被牠們隨地吐在旁邊。」
腳尖原本類似於『石塊』的觸感正逐漸由『空氣』所取代，這也表示少年原本所預期的著腳點正在消失。為了不失去重心，他下意識地退了幾步，並在後退的過程中，不停地製造出踩碎東西的聲音。
【喀啦！喀啦！噠！喀啦！】
待到腳步回穩之後，他才發現原本前方預計下腳的地方，正有著一些已經被自己踩碎的、由動物的骨頭所堆積而成的小峰。而那些正是老鼠們在用餐過後，所遺棄的動物頭骨。
「如果不小心踩碎巢穴裡的骨頭的話，那可是個不小的聲響呢。」
『吱！！！！！！！！！！！』
尖銳的高頻叫聲，幾乎是毫無懸念地在耳邊響起。
同時，或者説幾乎是同一時間，少年由原本的微蹲姿態，直接調整為向後起跑的姿勢，並且開始朝著轉頭之後所看到的道路即起狂奔。
——我還不想死！我還不想死！
危險的氣息，重新回到了最開始的高點……不對，甚至比那還要更高！
『吱吱吱！！！！！』
——不能被追上！不能被追上！
身後愈發急促的腳步聲，暗示著自己與魔物的距離正在逐漸接近。
——要再快一點！要再快一點！
腎上腺素逼迫著全身上下的每個細胞超速運作，大腿的肌肉以從來都沒有過的速度進行延展和收縮，這也使得少年能夠以更加迅捷的速度向前移動。 此外，除了身體的下半身，左手的手臂也同樣在配合雙腳的動作，在它們交替踏出時不停地前後擺動，以維持自己的身體動力和平衡，讓肌肉能夠更有效率的完成此時大腦所指定的工作。
而右手呢？則是緊緊握著四周唯一的光線來源，並盡其所能地向上高舉，以確保火炬能夠最大限度地開闢出眼前的道路，並利用雙眼將光線所提供的情報傳給自己的大腦。以便於身體能在最短的時間內判斷出「該往哪裡前進」的訊息。
『吱！！！！吱吱！！！！！』
危險仍然沒有消失。而且正如剛才所說，牠還在愈發靠近。
格雷瑪快速地通過了另一個初來時的岔口，但緊接著，後方的魔物也在僅僅幾秒之後，就通過了原本少年所在的地方。
——我不要！！！！
【可能在離開洞口之前，就會被母鼠追上】的想法不停地敲擊著本就已經足夠最弱的幼小心靈。少年一邊奔跑，一邊本能地在內心裡抗拒地嘶吼著。
或許是這個反抗的意識，也或許是身體開始熟稔超頻運作下的工作方式，他奔跑的速度逐漸加快，雙腿的步伐能夠向前邁得更加大步，兩手的手臂也能更有規律和節奏地配合著身體的規則擺動。
「母鼠在保護幼鼠的時候，不會離開巢穴。」冒險者的聲音仍然在少年的耳邊響起，同時他也通過了距離出口的最後一個岔口，但想當然地…後方的魔物也還沒放棄追逐眼前這個擅自闖進巢穴的入侵者。
「所以只要能夠成功地逃離老鼠的巢穴內，那怕只是一步，都可以讓自己在極度危險的情況下瞬間變得安全。」原本需要借由火炬才能提供光明的一片漆黑，在少年經過了某個拐角之後，出現了一個白色的光點。緊接著，光點的範圍從中心開始愈來愈大、愈來愈大。雖然他現在還看不清楚白光後方的景色，但毫無疑問，對於現在的少年來說，眼前的白光正是「終點」的所在！
最後，他在距離洞口 3 公尺的地方向前一躍，懸浮於空中。下個瞬間，少年的身體開始承受不住來自地面的引力而開始落下，他將身體捲曲，令自己在接觸到地面的同時可以以「滾動」的狀態持續前進。
洞穴的外頭是個緩而長的斜坡，也因此，少年在離開了鑿城鼠的巢穴之後，仍然向前滾動了一段距離才完全停下。
格雷瑪在這之後勉強地拖起傷痕累累的身軀向後望去，只見高度約 2-3 尺的巨大魔物向巢穴外探出了一半的身軀，在「房屋」的大門以向前微蹲的姿態持續地盯著眼前這位來這不善的「客人」。一段時間過後，鑿城鼠才緩慢地從洞口退回去，但牠仍惡狠狠地盯著眼前的這位不速之客。
而格雷瑪也在這之後，逐漸放下了心中的恐懼、昏沉過去。</description>
    </item>
    
    <item>
      <title>介面隔離原則（Interface Segregation Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/interface_segregation_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/interface_segregation_principle/</guid>
      <description>介面隔離原則（Interface Segregation Principle）#ChatGPT 的說明 介面隔離原則（ISP - Interface Segregation Principle）是 SOLID 原則中的一個，SOLID 是一個首字母縮略詞，代表著五個不同的設計原則：單一職責原則（Single Responsibility Principle，SRP）、開放封閉原則（Open/Closed Principle，OCP）、里氏替換原則（Liskov Substitution Principle，LSP）、介面隔離原則（Interface Segregation Principle，ISP）、依賴反轉原則（Dependency Inversion Principle，DIP）。介面隔離原則（ISP）主要關注在設計【介面】（interface）時的合理性和適切性。ISP 的核心理念是「【客戶端】不該被迫依賴它不需要的【介面】」，這意味著【介面】應該要被分割成小的、細微的、特定的部分，以便客戶端在依賴【介面】時，不會包含到那些他們不需要的方法。更具體地說，ISP 強調以下兩個信條：「介面應該小而精簡」以及「用多個特定介面替換一個通用介面」。
【介面應該小而精簡】 在軟體開發中（特別是物件導向程式設計），設計一個適宜的【介面】是非常重要的。「介面應該小而精簡」是指一個介面應該只包含客戶端所需的要方法，不應該包含多餘的、繁冗的、不必要的方法。這條訊息鼓勵程式設計師在設計面時，將「大的、通用」的介面分割成「小的、特定的」的部分，從而使【客戶端】只需要實現（或使用）他們所需要的方法，以助於減少依賴性、提高程式的可讀性，同時也確保每個【介面】的方法都具有清晰的用途和職責。
接下來我們使用一個例子來說明「介面應該小而精簡」的想法：想像一個 RPG（角色扮演遊戲）遊戲中，我們需要設計不同【角色】的能力介面。這些角色可以是【戰士】【法師】【弓箭手】&amp;hellip;等。每個【角色】都有一些共同的行動，比如攻擊（attack）、防禦（defend）等，但也有些角色特有的行動，例如法師的魔法攻擊（magicAttack）。一個不遵循「介面應該小而精簡」信條的設計可能會如下：
class Character { public: virtual void attack() = 0; virtual void defend() = 0; virtual void magicAttack() = 0; }; 在這種情況下，即使某些角色不具備魔法攻擊能力（比如戰士），它們仍然需要實現 magicAttack 方法，這對於這些角色來說是多餘的。但如果我們有遵循「介面應該小而精簡」的原則，我們便可以將原本的程式，改成下面這樣的設計：
class Character { public: virtual void attack() = 0; virtual void defend() = 0; }; class Mage : public Character { public: void attack() override {} void defend() override {} public: void magicAttack() {} }; 這樣的設計遵循了「介面應該小而精簡」的信條，因為每個【角色】都只需要實現他們所需的行動，而不需要實現多餘的方法。比如說：【戰士】角色在這樣的設計情況下，只需要實現 attack() 方法和 defend() 方法，而不需要去實現魔法攻擊相關的方法。而【法師】除了 attack() 方法和 defend() 方法之外，因為還擁有魔法攻擊相關的方法，因此多了一個 magicAttack() 的相關方法。</description>
    </item>
    
    <item>
      <title>依賴反轉原則（Dependency Inversion Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/dependency_inversion_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/dependency_inversion_principle/</guid>
      <description>依賴反轉原則（Dependency Inversion Principle）#ChatGPT 的說明 依賴反轉原則（Dependency Inversion Principle，簡稱DIP）眾多設計原則中的一個概念，它通過重新思考軟體設計中的「依賴」關係，提供了一種更具靈活性、擴展性、與可維護性的方式來組織程式碼。這個原則的核心思想在於「改變我們對依賴的看法」，將依賴關係的方向進行反轉，以減少耦合，增加彈性，並使系統更容易擴展和維護。在傳統的軟體設計中，&amp;ldquo;較低層級的模組&amp;rdquo; 通常依賴於 &amp;ldquo;較高層級的模組&amp;rdquo;。例如：如果你正在設計一個 RPG 遊戲，【技能】（低層模組）可能會依賴於【角色】（高層模組），因為【技能】需要知道它是被哪種類型的【角色】所使用。這種設計方式可能導致 &amp;ldquo;高層模組&amp;rdquo; 的變化影響到 &amp;ldquo;低層模組&amp;rdquo;，增加了系統的脆弱性和維護難度，並限制了系統的可擴展性。
DIP的關鍵思想是：我們應.該.將.依.賴.關.係.的.方.向.反.過.來，使 &amp;ldquo;高層模組&amp;rdquo; 依賴於「&amp;ldquo;低層模組&amp;rdquo; 的抽象」，而不是依賴具體的低層細節。換句話說，我們要將控制權交給抽象類別，讓 &amp;ldquo;高層模組&amp;quot;依賴於【介面】【抽象類別】或其他抽象化的類型。這樣一來，可以帶來幾個好處是：首先是【減少耦合】：通過讓模組依賴於抽象，&amp;ldquo;高層模組&amp;rdquo; 和 &amp;ldquo;低層模組&amp;rdquo; 之間的耦合性便會降低。這意味著變更低層模組的實現不會影響高層模組的穩定性。
此外，這樣做也可以【提升程式的可擴展性】：因為高層模組只依賴於抽象被別，所以低層模組可以更容易地被替換、被修改、或延展成新的低層類別，從而實現系統的擴展。此外，這樣的撰寫方式也有助於提升程式的【可測試性】：由於高層模組可以依賴於虛擬的、可測試的抽象，這將使得測試高層模組的難度變得更加容易。使高層依賴低層的抽象也可以【減少程式的細節】：因為通過依賴【抽象類別】或【介面】來實現功能，高層模組不再需要知道低層模組的具體實現細節，這有助於提高程式的可讀性和簡潔性。
以下我們將透過一個 RPG 遊戲的情境，模擬「『低層模組』依賴『高層模組』」和「『高層模組』依賴『低層模組的抽象』」兩種程式的撰寫方式，在這個情境之下，低層模組指的是【技能】類別，而【高層】模組則是可以使用【技能】類別的其餘類別，也就是【角色】類別。首先，我們將低層模組【技能】依賴於高層模組【角色】。我們定義了【技能】的不同實現，而它們會根據【角色】的特性來調整技能的效果。
class Character; class Skill { public: void fireBall(Character&amp;amp; character) { // only the magician can use this skill if(character.type == &amp;#34;Magician&amp;#34;) cout &amp;lt;&amp;lt; character.name &amp;lt;&amp;lt; &amp;#34; uses the skill &amp;#39;fire ball&amp;#39;.&amp;#34; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; character.name &amp;lt;&amp;lt; &amp;#34; wanted to try something, but there was no response.</description>
    </item>
    
    <item>
      <title>合成/聚合複用原則（Composite/Aggregate Reuse Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/</guid>
      <description>合成/聚合複用原則（Composite/Aggregate Reuse Principle）#ChatGPT 的說明 合成/聚合複用原則（CARP）是一個軟體設計原則，旨在引導開發人員在設計類別之間的關係時，能更多地考慮「合成」和「聚合」關係，而不是過度依賴「繼承」。這個原則強調使用合成（Composition）和聚合（Aggregation）的關係來實現複用性和模組化，以增加程式碼的靈活性、可讀性和可維護性。
【合成關係】（Composition）：合成關係表示「一個物件包含其他的物件作為其一部分，這些部分物件的生命週期也與包含物件相關聯。」如果該物件被銷毀，其部分物件也會被銷毀。合成關係建立了一種高強度的耦合，表示「部分物件」與「整體物件」之間的關係非常緊密，此外，部分物件不能獨立存在。例如在 RPG 遊戲中，一個【角色】Character 可能會包含【武器】Weapon、【盔甲】Armor 與【技能】Skill 作為其【角色】的一部分，這些部分物件隨著會【角色】的存在而存在，同時也會因為【角色】的消失而消失。
【聚合關係】（Aggregation）：聚合關係表示一個「物件包含其他物件作為其部分，但這些部分物件的生命週期與包含物件無關。」即使完整物件被銷毀，其餘的部分物件仍然可以獨立存在。聚合建立了一種較為孱弱的鬆耦合，表示部分物件具有一定程度的獨立性。例如在一個 RPG 遊戲中，一個【公會】 Group 可以聚合多個【角色】Character 作為其部分，但如果【公會】消失了，【角色】仍然可以在公會之外繼續存在。
「高層模組」應該儘量避免直接依賴於「低層模組」，而是通過合成或聚合的方式來使用低層模組。這種設計可以使撰寫出來的程式碼更富有彈性，也能相較容易地替換（或添加）新的低層模組。同時，低層模組也應該避免強依賴於高層模組，以確保模組之間的耦合度降低。在 RPG 遊戲的情境中，CARP 原則還可以這樣應用：假設遊戲中的【角色】是高層模組，而【裝備】是低層模組。【角色】可以包含多個【裝備】，這些【裝備】可以通過聚合關係與【角色】相關聯。同時，裝備也可以包含多個屬性（例如攻擊力、防禦力），這些屬性通過合成關係與【裝備】相關聯。
class Attribute { private: string name; int value; public: Attribute(string name, int value) : name(name), value(value) {} public: void display() { cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;: &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; endl; } }; class Equipment { private: string name; vector&amp;lt;Attribute*&amp;gt; attributes; public: Equipment(string name) : name(name) {} public: void addAttribute(Attribute* attribute) { attributes.</description>
    </item>
    
    <item>
      <title>單一職責原則（Single Responsibility Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/single_responsibility_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/single_responsibility_principle/</guid>
      <description>單一職責原則（Single Responsibility Principle）#ChatGPT 的說明 單一職責原則（Single Responsibility Principle，簡稱 SRP）是物件導向程式設計中的一個基本原則，它強調「每個類別（或方法）應該都只有一個職責」，意即「只有『一個』理由可以導致該類別或方法產生」。換句話說，一個類別或方法應該只具有一個主要的功能或職責，而不應該承擔過多的功能。這有助於使程式更容易理解、更容易維護和更容易擴展。SRP 的核心思想是「將不同的功能隔離到不同的位置」，從而實現高內聚（High Cohesion）和低耦合（Low Coupling）。這樣做可以使程式更加模組化，且當需求發生變化時，只需要負責該變化的部分，而不會影響到其他的程式與功能。
違反 SRP 可能導致以下問題：首先是「複雜性增加」： 當一個類別承擔太多的職責時，會導致該類別的程式變得複雜、難以理解、和不易維護。再來，程式的「耦合程度也會變高」：將不同職責的程式混合在一起，會導致類別與類別的依賴加重，進而增加程式的耦合程度，這將使得當類別需要發生改變時，可能會連帶需要修改到其餘的類別，使影響範圍擴大。同時，違反單一職責也會使「程式的重用性下降」：與遵守單一職責的類別相比，具有當類別具有多重職責時，通常難以重用，因為其功能過於特定。此外，也可能發生多了類別具有相同或近似功能的重複性程式。最後，違反 SPR 的程式也會「增加程式變更的風險」： 當一個職責的變化，需要修改類別中的多個部分時，容易會發生撰寫的錯誤，進而引發程式的崩潰，此外也需要考慮是否存在「其他類別也擁有相同功能，因此需要一並修改」的可能性。簡而言之，單一職責原則有助於保持程式的清晰、可維護性和可擴展性，通過確保一個類別只有一個主要職責，可以使系統遍的更加靈活和易於改變。
以下我們使用一個簡單的情境來解釋單一職責原則，我們假設在一個 RPG 遊戲中，角色可能會有「回復」「受到攻擊」與「升級」三種可能會發生的變化，如果我們使用 SRP 的程式原則，我們就會將這三種變化區別書寫成 takeDamage(), heal(), 和 levelUp() 三種方法。但如果不使用 SRP 的撰寫原則，程式就會全部擠在 update() 裡面，使得程式變得繁冗與複雜：
// Adhering to SRP (Single Responsibility Principle) // Adhering to SRP (Single Responsibility Principle) // Adhering to SRP (Single Responsibility Principle) class Character { private: string name; int health; int level; public: Character(string name) : name(name), health(100), level(1) {} public: void takeDamage(int amount) { health -= amount; cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; takes &amp;#34; &amp;lt;&amp;lt; amount &amp;lt;&amp;lt; &amp;#34; damage.</description>
    </item>
    
    <item>
      <title>最少知識原則（Least Knowledge Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/least_knowledge_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/least_knowledge_principle/</guid>
      <description>最少知識原則（Least Knowledge Principle）#ChatGPT 的說明 最少知識原則（Principle of Least Knowledge，縮寫為 LKP），又稱作迪米特原則（Law of Demeter，縮寫為LoD），是一個軟體設計原則，該原則旨在「降低系統中各個組件之間的耦合度，從而提高系統的可讀性、可維護性和可擴展性」。最少知識原則的核心思想是「只與你直接的朋友通信」，意即「一個對象應該只認識它的直接朋友，不應該直接認識其他類別的內部結構。」這個原則強調了組件與組件之間的鬆耦合，避免了不必要的依賴關係，從而降低了系統的複雜度。最少知識原則可以透過以下幾個關鍵點來理解：
只與直接朋友通信 在可允許的情況下，一個類別的方法，應該只可以調用以下的方法：「這個類別本身的方法」「被當作參數給傳遞進來的物件的方法」和「在該方法內，被創建（或被實例）的物件的方法。」一個類別的方法應該儘量只依賴於自己的內部實現，而不是去調用其他類別的內部方法。這樣可以確保當一個類別的實現變化時，其他類別不會因此受到影響。這也有助於隔離變化，使系統更加穩定
此外「該方法的參數」可以被視為該方法的直接朋友。如果一個方法需要訪問另一個物件的方法，最好是將該物件作為參數傳遞給方法，而不是在方法內部直接訪問。這樣可以明確地傳遞相關資訊，並減少方法之間的隱含耦合；而當一個類別創建了（或實例化）另一個物件時，通常只應該調用該物件的公開介面方法（因為直接訪問該物件的內部方法，可能會導致類別之間的耦合增加）。透過只調用公開介面方法，可以保持類別之間的解耦。
避免深層次的依賴 【類別】不應該調用【其他類別】的內部方法，特別是深層次的內部方法。因為這樣的依賴關係會使系統的耦合度增加，導致代碼難以維護。例如在以下的範例中，我們有一個名為 Ability 的基礎類別，並有兩個子類別（Fireball 和 Icebolt），它們繼承自 Ability。然後我們有一個 Character 類別，它包含一個 Ability* 的成員，並有一個 performAbility() 方法用於執行能力。
進一步地 Mage 類別繼承自 Character ，並且在 Mage 的構造函數中創建了一個 Fireball 的能力。最後，我們有一個 Game 類別，該類別創建了一個 Mage 的實例，然後在 play() 方法中執行了法師的能力。這個範例中， Game 的 play() 方法就存在深層次的依賴關係。（Game &amp;gt; Mage &amp;gt; Ability &amp;gt; perform()）
class Ability { public: virtual void perform() { cout &amp;lt;&amp;lt; &amp;#34;Performing basic ability!&amp;#34; &amp;lt;&amp;lt; endl; } }; class Fireball : public Ability { public: void perform() override { cout &amp;lt;&amp;lt; &amp;#34;Casting fireball!</description>
    </item>
    
    <item>
      <title>里式替換原則（Liskov Substitution Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/liskov_substitution_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/liskov_substitution_principle/</guid>
      <description>里式替換原則（Liskov Substitution Principle）#ChatGPT 的說明 里式替換原則（Liskov Substitution Principle，簡稱 LSP）是物件導向程式設計中的一個重要原則，由 [Barbara Liskov][1] 在 1987 年的一個會議 &amp;ldquo;[Data abstraction and hierarchy][2]&amp;rdquo; 所提出。該原則強調：「子類別應該能夠替換其父類別，並且同時保持原有程式的正確性。」里式替換原則告訴我們：一個衍生類別（也就是子類別）必須能夠完全替換其基底類別（父類別）而不影響原有的程序行為。換句話說，子類別應該具有與父類別相同的行為和參數，這樣才能保證其程式的正確性和穩定性。LSP 主要包含了的 2 個關鍵點：
首先【子類別必須完全擁有父類別的屬性或行為】：子類別需要做的事情，應該是「重寫」或「擴展」父類別的方法，而不是修改其行為，例如當一個名為【角色】的類別擁有攻擊 attack()、防禦 defence()、和魔法攻擊 magicAttack() 三種方法時，所以繼承該【角色】類別的子類別，都必須完全擁有這些行為，這意味著不能完全執行這三項行為的類別不可以繼承【角色】（例如【戰士】不會使用魔法攻擊、【僧侶】沒有防禦手段&amp;hellip;等）。但我們可以透過「擴增」類別的行為，讓子類別保持與父類別一致的完整性。例如先移除【角色】中的 magicAttack(), 方法，再將【能使用魔法攻擊的角色】與【不能使用魔法攻擊的角色】分別繼承於【角色】，並將 magicAttack() 方法定義於【能使用魔法攻擊的角色】當中。這樣一來，【戰士】別即可以透過繼承【不能使用魔法攻擊的角色】成為【角色】的一員。
接下來：【子類別應該完全遵循由父類所設計的邏輯】，意即保證父類別的行為在子類別中也能夠正確執行。子類不應該修改父類別所設計的邏輯、制定的規則、前提條件、或者是後置條件，也不應該引入新的前提條件或後置條件。例如：在名為【角色】的父類別中，如果有定義一個 defence() 方法，其實作的內容為「利用手中的武器進行防禦。」那麼所有繼承於【角色】的類別，即便是改寫或擴增 defence() 方法，也不可以違背「用武器防禦」這項原則。（這意味著不可以改寫【盜賊】的 defence() 為「透過閃躲防禦」）。透過保持規則的一致性，可以避免程式的不可預測性，例如原本【戰鬥】的攻防計算為「武器攻擊力 - 武器防禦力」，但因為我們將【盜賊】的防禦修改為「閃躲」，並沒有所謂的「武器防禦力」，在這樣的情況下可能就會造成不可預知的錯誤。
以下我們使用一個簡單的情境來解釋里式替換原則和非里式替換原則的程式邏輯：我們需要製作一個 RPG 遊戲，其中有著一個【角色】類別，和【戰士】【法師】【盜賊】三種子類別。【角色】有攻擊（attack()） 和 防禦（defence()）兩種方法，有些角色也可以嘗試進行魔法攻擊（magicAttack()），此外，防禦（defence()）的程式邏輯為「受到的傷害 = 武器的攻擊力 - 自身的防禦力」。程式撰寫邏輯如下：
// Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) class Character { protected: int attack; int defense; public: Character(int attack, int defense) : attack(attack), defense(defense) {} virtual void attack() { cout &amp;lt;&amp;lt; &amp;#34;Character attacks with attack power: &amp;#34; &amp;lt;&amp;lt; attack &amp;lt;&amp;lt; endl; } virtual void defense(int received_atk) { int received_dmg = received_atk - defense; received_dmg = (received_dmg &amp;lt; 0)?</description>
    </item>
    
    <item>
      <title>開放封閉原則（Open Closed Principle）</title>
      <link>https://fonu195713.github.io/docs/computer_science/design_pattern/open_closed_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/design_pattern/open_closed_principle/</guid>
      <description>開放封閉原則（Open Closed Principle）#ChatGPT 的說明 開放封閉原則（Open Closed Principle，簡稱 OCP）是物件導向程式設計中的一個重要原則，由著名的軟體工程師 Bertrand Meyer 在其著作《[物件、函數和C++]》中首次提出。該原則強調軟體實體（像是類別、模組、函數方法&amp;hellip;等）應該對擴展開放，對修改封閉。換句話說，程式應該可以在「不修改現有程式」的情況下，擴展其系統的功能，同時程式也應防止在改變功能時，對現有的程式進行修改。
開放封閉原則的核心思想是：當系統需要引入新的功能或變化時，不應該修改已存在的程式，而是通過擴展（例如增添新的類別、新的方法&amp;hellip;等）來實現。這樣可以保證原有代碼的穩定性，同時在不影響現有功能的基礎上進行擴展。要遵守開放封閉原則，通常可以採取以下策略：【使用抽象類別或抽象接口】：通過使用抽象類別或抽象接口，我們可以建立起一個（或一些）泛用的方法和屬性，並在子別類中實現這些方法的具體功能。這樣，當系統需要擴展功能時，只需添加新的子類別即可完成功能，而不需要修改現有的程式。
此外【使用多態性（polymorphism）】也可以使程式遵循開放封閉原則：通過使用 polymorphism 的程式，我們可以讓程式在運行時，根據具體的對象類別，調用不同的方法。這樣，即使新增了新的功能，只需創建新的對象與新的多態方法即可完成功能，而不需要修改原有的程式和邏輯。此外，【使用策略模式等設計模式】也可以有效地達成開放封閉原則。一些設計模式（例如策略模式）可以幫助我們實現開放封閉原則。這些模式將不同的行為封裝成獨立的策略類，並通過替換不同的策略類來實現功能的擴展。
另外，如果不遵守「開放封閉原則」，可能會導致程式產生以下的問題：首先是【程式的修改風險增加】，當系統需要引入新的功能或新的變化時，如果原程式不遵守開放封閉原則，可能會產生「添增新的功能外，同時也需要修改既存的程式，才能完成功能升級」的情況，這可能導致現有的程式功能產生錯誤或影響。可能引入新的錯誤、增加更多的複雜度、提高耦合&amp;hellip;等，增加了整個系統的風險。
此外，沒有遵守「開放封閉原則」的程式也可能會有【測試困難】的狀況發生：修改現有的程式，可能會需要重新測試整個系統，在這樣的情況下，因為程式的高度改變，可能會導致測試的困難、測試覆蓋率降低&amp;hellip;等負面影響。測試新的功能可能影響到現有的測試案例，也因此增加了測試的複雜性。此外，違反原則的程式也會使得「程式的耦合增加」：不遵守開放封閉原則的程式，可能會導致不同的功能、不同的方法、或不同的類別之間出現耦合，一旦其中一個功能發生變動，可能會連帶影響到其他功能（或類別）的正常運作。
同時，不遵守開放封閉原則也可能導致【程式的複雜性增加】【可擴展性下降】【程式的重用性下降】&amp;hellip;等問題。因此建議程式在撰寫的時候，要遵守開放封閉原則規範，才能有助於降低這些問題的風險，保持程式的靈活性和可維護性。
以下我們使用一個簡單的情境來解釋單一職責原則，我們假設在一個 RPG 遊戲中，角色（Character）可以使出「火球術 fireBallSkill」「冰錐術 iceShardSkill」和「治癒術 healSkill」三種不同的攻擊，在遵循 OCP（開放封閉原則）的情況下，角色在進行技能的選擇與擴充的時候，並不會影響到原 Character 的程式，只需要增添新的 Skill 即可，但在不遵守 OCP 的情況下，若有需要做【技能】的擴充與修改，則會連帶影響到【角色】原本的程式內容：
// Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) // Adhering to OCP (Open Closed Principle) class Skill { public: virtual void use() = 0; }; class FireballSkill : public Skill { public: void use() override { cout &amp;lt;&amp;lt; &amp;#34;Casting Fireball!</description>
    </item>
    
    <item>
      <title>白髮精靈 - 1</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/03/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/03/</guid>
      <description>白髮精靈 - 1#1373 年 11 月 27 日，下午 5 點 31分，弗洛斯村靠近中央廣場旁的孚爾契酒館。一名身高約 140 公分左右，帶有一頭淺橘色捲髮的矮人男子，正大口大口的喝著店裡最為上好的美酒。
「呼啊～～果然只有這裡的萊姆才是真正的萊姆啊。」酒滴從男子的嘴角和杯緣滑落，接著再順著那粗獷的橘色鬍鬚落至由杉木所組成的圓桌上。
「瓦爾斯，我還是不覺得這是一個好主意。」與眼前的橘髮男子不同，聲音的主人是一名有著淺黃色長髮、左耳的耳角帶有華麗耳飾、穿著綠色上衣，但又用一席深色長袍覆蓋著全身的精靈女子。儀態端莊地坐在男子的對面，細細品嚐店裡的其他美食。
「什～麼主意啊～提朵？」瓦爾斯兩手撐在圓桌，略微強烈的醉意微微地壓著他的肩膀，使得這個身高只有 1 米 4 的矮人更需要將頭稍稍的斜仰，才能夠看向眼前的精靈女子。
「老鼠的事。」提朵不悅地說。
「呼哈～你說那個赫力在意的小子嗎～我也只不過是把我所知道的魔物情報說給其他冒險者聽而已嘛～至於其他人有沒有聽到？聽到了之後又會有怎樣的反應？可就不關我的事了吧～」即使這已經不知道是他今天的第幾杯了，瓦爾斯依舊毫無顧忌的又喝了一口手中的萊姆酒。
「這也就表示你知道那孩子有聽到，而且也會真的跑進去，對吧？」提朵暫停了用餐的動作，用著微微散發殺氣的眼神，死死盯著眼前的矮人男子。
「挖喔～～別用這麼凶狠的眼神看著我嘛～至少風險跟應對的方法我也都有講出來阿，不是只跟他說裡面會有好東西而已嘛～」瓦爾斯稍微別過自己的臉，但提在嘴角前的酒杯和略為瞇著的眼睛仍然出賣不了自己喜悅的心情。
「而且我覺得妳要再重新思考對於不同種族來說，『孩子』代表什麼意思哦？妳是不是覺得無論任何種族，只要歲數低於一定的數字都是小孩啊？對我們矮人來說，雖然他那個年紀雖然還不到成年，但早就已經是個可以獨當一面的戰士了呢～哈哈哈哈哈！」豪爽的笑聲帶起了周圍本就活絡的氣氛，瓦爾斯用眼神致意，讓店裡的服務生再拿兩瓶萊姆酒過來。
「但他還不是個冒險者。」重新拾起桌上的餐具，提朵在繼續用餐之前又唸了一段。
「但也『還』不是個冒險者而已不是嗎？」瓦爾斯放下了手中的酒杯。愈發強烈的酒意雖然讓這名矮人的臉頰變得更為通紅，但從他的眼神來看，可以確定方才他所說出來的話語並不是酒後的胡言亂語。
「所以你覺得讓他闖進一個有著母鼠的巢穴，再帶著洞穴內的戰利品出來，公會就有機會讓他成為一個合格的冒險者嗎？」提朵的心情變得更加不悅了。
「不對～不對～不對～～這句話有兩個地方說錯了～」瓦爾斯搖著頭。
「首先～那裡不是一個『有著母鼠的巢穴』，而是一個『經調查之後，對母鼠的存在抱持著高度肯定的巢穴。』這也就是說，在一定的機率下，那裡還是有機會不出現有母鼠的～」看了看右手已經被自己清空的容器之後，矮人又從桌子的其他位置拿起了一杯全滿的酒杯。
「其次，如果有一個莫約 12 歲的人族男子，在獨自一人闖進了有著母鼠的巢穴之後，還能夠平安地回來的話，公會並不是『有機會』讓他成為冒險者，而應該更傾向『直接將他視為冒險者』才對。」
「你這個守序邪惡的爛人。」
雖然並沒有望向眼前的矮人男子，但心中的怒火並沒有因為方才的辯解而達到減弱的趨勢。
但瓦爾斯的這一席話，的確也讓提朵開始思考著事情的其他含意：沒錯，雖然對於一般的冒險者來說，要單獨討伐難度 B- 或 B 的魔物並非毫無勝算可言。畢竟在定義上來說，難度 B 的意思是「等級 1 至 3 的冒險者『建議』以小隊的形式進行討伐的魔物，等級 4 及以上則不在此限。」但定義上是以『建議』的條文進行輸血，而非『必須』這個字眼，這也就表示，即使母鼠的威脅相對於普通的鑿城鼠還要更高，對於公會來說，這也還不到禁止初階冒險者單獨討伐的程度。
那在這樣的前提之下，如果公會聽聞了「一名莫約 12 歲的人族男性，在闖入了有著母鼠的巢穴之後，還能平安無事、或至少活著的走出來」的消息之後，省略掉常規的檢定手續，而直接將他視為一位合格的冒險者也不是什麼出乎意料的事。
——只不過……
「對於一個普通的人族少年來說，還是太過勉強了吧。」修正了自己對於年紀上的認知，精靈女子望向了店裡遠方的魔物標本說道。
「而且對於一個初階的冒險者來說，要單獨打倒至少 -B 級的魔物，至少也得做好身體（武器與防具）和心理（了解恐懼和風險）的準備，才有辦法達成吧？這樣對他來說，難度難道仍舊不會太高嗎？」
「所～以～說～嘛～～如果在這樣的情況下，那個小子還能夠達成的話～不就代表真的有料嗎？而且妳不也說過什麼…『那小子有資質成為冒險者～』『小小的妖精也時常跟著他』之類的話嗎～」
「我說的是他有著通常人族不具有的『魔力容器』。」提朵修正道。
個體的妖精一般不會接近人族，因為祂們不喜歡沒有魔力的東西。因此相對於絕大多數「白紙」一般的人類來說，祂們更寧願在路邊一顆被丟棄的小石子上停滯和逗留。因此在半個月前，在提朵準備踏進酒館時，酒館門口那望著酒館內部、且肩上留有妖精停留痕跡的褐髮少年的確吸引到了自己的注意。
也不由得讓自己對他使用了一次【魔力感知】。進而發現**那.孩.子.天.生.就.帶.有.容.器.**的事實。
「但就算他有容器，在人族中也不算極其罕見的情況吧？至少你我除了那個孩子之外，也認識了好幾個帶有容器的人類不是嗎？」酒館內的服務生將兩杯滿量的特大號酒杯、和一份豐盛的地方餐點擺放至兩人的餐桌上，長髮精靈在這之後則將視線從遠方的目標移回眼前的料理中。
「唉啊～～～人家不是都說精靈是善於觀察跟思考的種族嗎？怎麼從這點來看，我比妳還要更像你們這群捨不得衣服髒的小公主小王子啊～」
無視著前方傳來愈發強烈的憤怒，矮人喝了一口從服務生承遞過來的大酒之後又繼續說道：「我看的是眼神阿～眼神！管他什麼年紀什麼魔力的，他那個就像在說『讓我去吧』『我也要加入』的眼神，不覺得將來就是個很不錯的小子嗎？哈哈哈哈哈！」
時而嚴肅時而醉意的語氣除了讓提朵對於餐間的對話感到相當不悅之外，就沒有任何其餘的情緒了。也因此，她並沒有對瓦爾斯的說法提出任何的回覆。僅僅將之作為耳邊風，中斷談話，並專注地品嘗眼前的美味佳餚。</description>
    </item>
    
    <item>
      <title>白髮精靈 - 2</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/04/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/04/</guid>
      <description>白髮精靈 - 2#與此同時，位於村落另一角落的木屋中，一位白髮女精靈正端坐在屋裡的書桌前，靜靜地閱讀放在桌上的老舊書籍。她時而輕抿嘴唇、時而輕輕地手指翻閱書籍，一舉一動無不流漏著高雅的氣息。精靈名叫「阿洛蕾·佴瑠斯·貝魯貝斯」，是這間木屋的主人，也在這個福洛斯村裡面居住的唯一一位精靈。
「嗚姆…」這個微弱聲音的主人，是位躺在床上的褐髮少年。
『阿洛蕾…姊姊…』少年的將雙眼微微睜開，他蒼白的臉色，和鼻樑與額頭上的包紮痕跡，像是在暗示他在早些時候遇到了什麼巨大的危險一般？他像是在說著夢話似的，微弱地發出了聲音。
「醒來了嗎？格雷瑪。」白髮精靈輕柔地丟出了一個問句。
「這裡…是…」
「是家裡呦～是林場的大家把你帶回來的。」同樣是一句輕輕的回覆。
「他們說你好像未經許可就跑到了森林的深處，還嘗試跑進鑿城鼠的洞穴裡面，等他們武裝上山的時候，就看到你一個人渾身是傷、倒在巢穴的路口前，所以才趕忙把你帶回來的。」
「這是真的嗎？」語畢。白髮精靈的語氣同樣維持著一開始的輕柔，但身旁的褐髮少年似乎是看穿了什麼一般？猛然睜大眼睛坐了起來，並轉向右邊的白髮精靈、下意識地將原本靠在頭上的枕頭舉了起來，擋在兩人的中間。
「不…不是的，不是他們說的那樣！」格雷瑪慢慢地向床的另一個角落退去。但床原本就是依靠著角落擺設的，無論格雷瑪再怎麼向後退，還是沒有辦法與阿洛蕾拉出一個更大的距離。
「如果不是的話…你為甚麼會看起來這麼害怕呢？而且你『不是』的意思是…托姆他們在騙我囉？」阿洛蕾輕輕地將書本闔上，然後轉過身來，用著同樣端莊的坐姿瞇著眼給了前方的格雷瑪一抹微笑。然後格雷瑪臉上的恐懼就以肉眼可見的速度不停地浮現出來。
緊接著，在精靈身旁的空間開始出現了一點異常。一開始是一些類似於亮片般的閃爍光點，然後在光點發生的地方，慢慢地浮現出了數個微小、不規則狀的透明液體。液體在出線之後，又像是被降溫一般慢慢被塑型、結凍，待到液體完全硬化之時，它們早已變成一個個冰錐似的形狀。
然後，再下一秒。
精靈身旁的一個冰錐以迅雷不及掩耳的速度，精準地、毫無猶豫地被插進了距離少年臉龐不到 3 公分的、木頭與木頭之間的空隙裡。
「怎麼不說話了呢～格雷瑪？我有教過你『我在問話的時候，什麼都不要說』嗎？」問句來自同樣的笑容。
「還是你想說『其實你只是一個人不小心跑到了森林比較裡面的地方，不小心的看到了某個洞穴、不小心的走了進去、然後不小心地發現裡面有魔物、最後在出來的時候又不小心地摔倒，所以才會渾身是傷的倒在那裡』呢？」阿洛蕾的身旁又出現了一個冰錐，並且其餘的冰錐也在以緩慢的速度靠近著格雷瑪。
面對此刻的情境，格雷瑪用手中的枕頭緊緊的保護住頭部，並扭過頭去，賭氣似的喊道「我只是想要知道冒險者們平常到底都在做什麼而已嘛！」
「所以就可以因為這樣，給別人也給自己添麻煩嗎？」
招架不住阿洛蕾姊姊連番的逼問，格雷瑪用力地放下枕頭並大吼道「好啦！我知道錯了！對不起啦！」接著，便用近乎要哭出來的眼神看著眼前的白髮精靈。
在對峙了 3-5 秒之後，白髮精靈像是放棄似的長嘆了一口氣：「好啦。知道錯了就好，下次記得不要再這樣了，大家都會很擔心的。」接著，阿洛蕾便操縱體內的魔力，將身邊的冰錐重新液化並聚集成一顆顆的水珠，並讓其中一個水珠輕輕地拭過格雷瑪的臉龐，最後再讓所有的水珠消散於空中。
「我大概治好你身上比較明顯的傷口了，剩下的小傷口就當作是給你的小懲罰和提醒。應該有體力走路吧？先去跟林場的大家報聲平安，我等等要見一個重要的人，在太陽下山之前都先不要回來。」
「欸！？姊姊有朋友？」
「你想再受傷一次嗎？」這一次，阿洛蕾給了格雷瑪一個今天最為開朗，但最富有惡意的笑容。
看著姊姊今天…不對，是此生最.為.和.藹.的.笑.容之後，格雷瑪便從床上跳了起來，以最快速的速度換上了外出服，並頭也不回的離開了房屋內。
而留下來的白髮精靈，在看著褐髮少年離去之後，靜靜地站起身來，闔上少年因急促而未緊閉的房門。接著她伸出手指，在指尖處凝結出不同於方才的淡紅色液體，在門口稍稍地比劃，而淡紅色的液體也隨著精靈的比劃逐漸構築成了一個微小而精緻的法陣，接著法陣像是嵌入木門一般的消失，而在這之後，白髮精靈便重新地回到了原來書桌上的位置坐著。
「好久不見了，赫力。這幾年過得好嗎？找我有什麼事？」白髮的精靈重新翻閱起了最一開始的古老書籍說著。
與此同時，在書桌後方的空間內開始颳起了一陣怪異的旋風，旋風由下至上、逐漸形成了一條細長的風紋然後消散。而在消散之後，出現了一位身著深藍色連帽長袍、腰間繫著腰包、有著金色短髮、以及深藍色眼眸的精靈族少年。少年略彎著腰，眼睛直面著前方的地面說道：「好久不見，貝魯貝斯大人。近來可好？」
「我早就說過了，不要用那麼生疏的叫法叫我。」白髮精靈仍舊望著眼前的老舊書籍。</description>
    </item>
    
    <item>
      <title>白髮精靈 - 3</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/05/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/ch01/05/</guid>
      <description>白髮精靈 - 3#精靈，是在【世界】之中較為長壽的一個種族。依照不完全統計，作為風神「佴瑠斯」所創造的一個種族，精靈的平均壽命略約在 750 至 850 歲之間，祂們的一生大概可以分為前 100 年左右的幼年期、100 至 600 年的成年期、以及 600 年以上的老年期。此外，不同於其他種族存在著散落的國度或部族，精靈自始至終都只有一個比較明顯、龐大、且有影響力的國家「梅爾布雷納」，位於西南大陸的阿茲克勒大森林中。梅爾布雷納的政治形態為派系政治，國家的最高權力機構「議事堂」共由 7 名議事成員組成。祂們會通過討論、整理、投票的方式，決定國家中的各種重大決策。而在議事堂中的其中一個席次，正是由貝魯貝斯家族所持有與掌握。
而在此同時，位於弗洛斯村溪西北側的一間老舊木屋中，一位貝魯貝斯家系、身著深藍色連帽長袍、腰間繫著腰包、有著金色短髮以及深藍色眼眸的精靈族少年，正以略彎著腰，眼睛直面著前方的地面的姿勢，恭敬地說道：「好久不見，貝魯貝斯大人。近來可好？」
「我早就說過了，不要用那麼生疏的叫法叫我。」聲音的主人，是名坐在少年前方大約 1 公尺的木椅上的女姓白髮精靈。
「叫我『阿洛蕾』或『姊姊』就好。然後，家主的位置早在好久以前就交給二哥了，所以現在的「貝魯貝斯大人」並不是我，是二哥。這你應該也早就知道了吧？赫力。」阿洛蕾背對著赫力說道。她仍專注且仔細地望著老舊書籍中的內容，從她深邃且精緻的眼神中，不難看出這本書對她的重大影響。
「那好吧，姊姊大人。」赫力停止了鞠躬的動作，並在書桌旁的床沿坐了下來。
「時間過得真的好快&amp;hellip; 我從森林裡離開的時候，你大概才 20 歲左右吧？沒想到現在已經變成一個有模有樣的小大人了。」阿洛蕾抬起手來，並從書籍中抽出了一張照片遞給右邊的赫力，後者在接到相片之後，僅僅是看了一眼相片的內容，便將之還給了眼前的白髮精靈——那是一張泛黃的照片，雖然因為時間的緣故而有點模糊，但仍能看得出是阿洛蕾與赫力兩人的合照。
「姊姊不也是嗎？『白巫，阿洛蕾·佴瑠斯·貝魯貝斯』的名號也早名聞遐邇了，現在家鄉的大家無不認識姊姊的名號，也正因為如此，二哥在『家裡』說的話才有著不錯的份量。」
「那也是很久以前的事情了吧，至少我現在也不是冒險者了&amp;hellip;」
「&amp;hellip;」精靈們稍微沉寂了一下。
「算了，回歸正題，你找我有什麼事呢？」阿洛蕾將眼前的書籍闔上，隨後轉過身來，以左手放在書上、右手擺在大腿上的姿勢直接但柔和地望向坐在床邊的許久不見的弟弟。
「森林的動靜最近很奇怪，魔力的流動紊亂、動物的數量急遽下降、愈發狂躁的魔物、還有森林深處出現了一些明顯是人為形成的怪異地形&amp;hellip; 種種的跡象都顯示著森林裡正會發生一些奇怪的事情，因此『公會』預計對這一片區域，發布等級 B 至 B+ 的危險警示，到時候這個村落的村民也會被迫撤離一段時間吧？姊姊要先考慮離開嗎？」少年問道。
「哈哈哈～這可不能呢！畢竟我當初就是因為答應了杰弗里斯公爵『保護領地』的請求，他才願意讓我藏身在這裡的。如果我現在逃跑，不就違反了當初與他的承諾了嗎？」
「而且&amp;hellip; 現在的我也有新的『家族』了。」語畢，白髮精靈將眼睛微微閉上，並露出了一抹微笑。精靈潔白的牙齒因為這抹微笑而顯露出來，赫力能感覺阿洛蕾所說的都是實話，因此心裡一股複雜的情緒從自己的心中慢慢地湧現出來。
「那個人族的男孩？」
「他是我以前的同伴的孫子，應該看不出來吧？在他短短的人生當中，已經經歷過兩次的生離死別了哦！第一次是『龍』摧毀了他的家鄉，整個村莊只有不到 10 人活了下來，那場災難除了我的同伴之外，那孩子的其他親人都被殺掉了。在那之後僅僅過去了 2 年，帕珈也因為人族的壽命和她兩年前與『龍』戰鬥所受的傷離世了。至此為止，那孩子在血緣意義上的『親人』都完全離他遠去，我也是在這時候才開始扶養他的。」
「那時候的他大概也才 8-9 歲左右吧？他在後來的 3 年一直都表現得很沉默與冷靜，直到最近，搬到這裡之後，他才漸漸開始對周遭的人事物產生比較明顯的好奇和興趣。對人族的男孩來說，現在應該是很重要的時間吧？形塑自己、形塑環境、形塑他對這個世界的認識 &amp;hellip;」說著說著，白髮精靈的眼角輕微泛紅。
——雷瓦特的事件嗎&amp;hellip;。
赫力在心裡想著。
「有時候我會思考，如果我那時候早點放棄夢想，勒達大哥是不是就不會死了？如果我早點發現真相，帕珈他們是不是就能活下來了？如果我真的照著父親的建議，老老實實的坐在梅爾布雷納的議事堂裡面，這一切的一切是不是就都不會發生了。」
「姊姊。」一雙溫暖的手握住了阿洛雷微微顫抖的右手，不知何時開始不停流出的眼淚也在此刻得到了抑制。
「我們都很清楚，這不是姊姊的錯，而且如果姐姐沒有離開森林的話，其他人會怎麼看待時到今日仍然對外封閉的梅爾布雷納？又怎麼能得到象徵著聖潔、治癒的白髮巫師的【白巫】稱號？而且雷瓦特的事件已經在後續的調查中被確定是『蓄意為之』了，並沒有明確的證據可以證明那起事件與姊姊的決定有著什麼關聯。」
「姊姊已經做的夠好了。無論是大哥的事、雷瓦特的事、或者是關於『自己』的事&amp;hellip;」赫力堅毅地看著眼前情緒即將潰堤的阿洛蕾。
阿洛蕾聽到赫力所說的話之後，先事愣了一下，接著便用左手擦拭掛在臉上眼淚說道：「原來你已經知道『封印』的事情了，是誰跟你說的？杰弗里斯公爵嗎？」
「他的線索是其一，另外一些上古的謠言和記錄也讓我對這件事有了大概的認知。」
「所以你才會問我要不要先離開這裡嗎？」
「沒錯&amp;hellip; 因為『公會』並不排除這是雷瓦特之後的下一起事件。那樣的話，姐姐會有『暴露』的危險吧。」
看著今天一直以來都很冷靜的赫力，在此刻散發出了一絲擔憂的氣息，阿洛蕾將身體前傾，並輕柔的抱住赫力說：「放心吧。無論是你、還是格雷瑪、抑或是村裡的大家、還是杰弗里斯，只要我待在這裡，就不會讓你們遇到危險的。此外，關於封印的事情，我也有自己的解決方法，那方法道是意外的很順利哦！」
「欸？」
「所以，我還是會待在這裡，無論之後這裡會不會發生危險。除了跟杰弗里斯的約定之外，更重要的是不可以再讓任何人死掉了。」
身為阿洛蕾最為親密的家人之一的赫力，在聽完了前者的說法之後，便明白了「即使再勸下去，也是無法改變姐姐的心意的」的念頭。因此，他從原本的坐姿站起身來，並拍了拍身上的灰塵，向著方才嵌入法陣的木門走去。
——姊姊還是一如既往的固執呢&amp;hellip;</description>
    </item>
    
    <item>
      <title>《深入淺出設計模式》</title>
      <link>https://fonu195713.github.io/docs/daily_life/reading_experience/head_first_design_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/reading_experience/head_first_design_pattern/</guid>
      <description>《深入淺出設計模式》閱讀心得#2023-07-07
背景 一直以來，我都對「設計模式」這個東西抱著若有似無的認知。具象一點說明的話，大概就是「知道『設計模式』是一種可以讓程式寫得更加漂亮、更有彈性的觀念和方法，但實際上這些觀念是什麼（我不知道），那些方法又該如和撰寫（我也不知道）」的狀況。然後在今年 5 月底左右吧？因為第二篇論文出現了一點卡關的狀況（文章的內容一直沒辦法寫成老師期望的那種感覺），也因為患有一點研究生症候群，就開始找手邊一些 &amp;ldquo;一直以來都有興趣，但又找不到合適的時間去了解&amp;rdquo; 的東西進行研究了。而這之中，【研究設計模式】剛好是其中之一。
這邊的研究設計模式是指「閱讀《深入淺出設計模式》這本書」。並不是閱讀比較主流的 Design Patterns: Elements of Reusable（也就是四人幫著的那本），其中一個原因是：剛開始的我，並不知道這本設計模式的聖經本，另一個原因則是它是我最快速能找到比較完整的、系統性的跟設計模式有關的書籍，所以就&amp;hellip; 這樣開始了。
內容 雖然在四人幫的著作中，共列舉了 23 種常見的設計模式，但本書並沒有包含這麼多的內容。書中的 13 個章節裡，扣掉最後一個章節在介紹 MVC 架構（Model, View, Controller），以及倒數第 2 章在介紹不同模式的合併用法之外，其餘的 11 個章節依序僅介紹了 Strategy（策略模式）、observer（觀察者）、decorator（裝飾器）、factory（工廠模式，包含簡單工廠、工廠方法、和抽象工廠）、singleton（單例模式）、Command（命令模式）、Adapter（配適器）、Facade（外觀）、Template method（模板方法）、Iterator（迭代器）、Composite（組合模式）、State（狀態模式）、Proxy pattern（代理）&amp;hellip;等。剩餘的模式則僅於書中的附錄稍作提及。但這並不代表這本書不是一本良好的教學素材。相反地，因為本書的撰寫方式有別於市面上大多數的教學書籍，採用了極大量的圖片、角色對話、與情境式的描述，為各種模式的優缺點、應用情境、特徵、使用方法做大量的說明，同時也附上了許多的觀念思考、練習題、與程式範本，因此在閱讀上，並不會出現常見的倦怠、疲憊、或單調的感覺。
心得 整體而言，這本書帶給我很多新的啟發，無論是程式的撰寫方式，例如「多用組合、少用繼承」「單一類別、單一職責」「依賴通用接口，不要依賴特定類別」&amp;hellip;等，或者是各種不同模式的應用與架構「工廠模式可以讓物件的實例化延後至子類別中實現」「模板方法只關心演算法的骨幹，因此可以在不改變演算法結構的前提下，重新定義某些方法的執行細節」「單例模式可以讓類別只生成單一物件，以確保某些資源的分配不會遇到問題或錯誤」&amp;hellip;等，抑或是程式的語法觀念，像是「C++ 的物件繼承，菱形繼承的問題與解決」「虛函數, 純虛函數」&amp;hellip;等，都是在閱讀本書之後才有了一個更加明確與更加清晰的認識。雖然是在一個比較非主動的動機下，才開始閱讀本書，但整體而言，能夠「閱讀本書，並從書本當中學到了更多的知識」對我來說實在是一件很高興又很喜歡的事情。
評分 閱讀難度：★★★☆☆ （需要有基本的物件導向程式觀念）
推薦指數：★★★★★</description>
    </item>
    
    <item>
      <title>策略模式 (Strategy Pattern)</title>
      <link>https://fonu195713.github.io/docs/_trash/strategy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/strategy/</guid>
      <description>策略模式（Strategy Pattern）#2023-07-07
前言 假設我們現在正在製作一個 RPG 遊戲，遊戲內有一個名為 Monster 的抽象類別，該類別預設有 void attack()（攻擊）、void evades()（迴避）、和 void walk()（行走）三種行為，並且分別有 Slime（史萊姆）、Skeleton（骷髏）、和 Zombie（殭屍）三種怪物繼承了 Monter 類別。根據目前的想法，我們可以畫出類似於下面的類別圖，並寫出下方的程式：
classDiagramclass Abstract_Monster {+void attack();+void evades();+void walk();}Abstract_Monster &lt;|-- SlimeAbstract_Monster &lt;|-- SkeletonAbstract_Monster &lt;|-- Zombie// C++ code class Monster { public: int hp; int atk; int def; public: virtual void attack(); virtual void evades(); virtual void walk(); }; void Monster::attack() { cout &amp;lt;&amp;lt; &amp;#34;The monster unleashes a regular attack.</description>
    </item>
    
    <item>
      <title>模板方法模式（Template Method Pattern）</title>
      <link>https://fonu195713.github.io/docs/_trash/template_method_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/template_method_pattern/</guid>
      <description>模板方法模式（Template Method Pattern）#說明 ChatGPT：模板方法模式（Template Method Pattern）是一種行為型設計模式，該模式會定義一個「包含一個或多個抽象方法」的抽象類別，並定義一個操作這些方法的框架。該框架包含了一組預先定義的步驟，其中某些步驟由類別內部的原方法進行實作，其餘步驟則設定為允許重寫，並由繼承該類別的子類別負責實現步驟細節。模板方法將這些步驟按照特定的順序組合在一起，進而形成一個完整的操作流程。它提供了一種通用的模板，可以在不同的情境下重複使用，同時保持算法的一致性。這種模式可以幫助開發人員實現共享的行為和結構，同時提供了彈性和可定制性。
維基百科：模板方法模式是一種行為設計模型和設計模式。模板方法（Template Method）是一個定義在父類別的方法，負責處理框架、流程、演算法的不變部分。模板方法會呼叫多個定義在父類別的其他工具方法（Helper Method），這些方法有些是演算法的可變部分（只是抽象方法並沒有實作），有些已經有一些預設的方法細節。模板方法僅決定這些工具方法的執行順序，但工具方法的執行細節不一定全由父類別實現，有些市由子類別負責實作，並且子類別不允許覆蓋模板方法（即不能重寫方法的執行順序）。
定義了一個模板方法，用以定義一個完整步驟的執行順序 模板方法中會套用許多的工具方法 工具方法可由父類別實作 工具方法也可以由子類別改寫 子類別僅可改寫工具方法，不可以改寫模板方法 UML Graphic classDiagramclass Battle {Role[] playersMonster[] enemiesFINAL void figsht(); cannot overrideFINAL void initializeFight(); cannot overrideint attack();bool endFight();}note &#34;FINAL void fight() {\n　initializeFight();\n　while(not endFight()) {\n　players.attack(enemies);\n　enemies.attack(players)\n　}\n}&#34;class NormalBattle {bool endFight() can escape}class SpecialBattle {void initializeFight() hp - 50%bool endFight() cannot escape}class BossBattle {bool endFight() cannot ecsapeint attack() boss can attack twice}Battle &lt;|-- NormalBattleBattle &lt;|-- SpecialBattleBattle &lt;|-- BossBattle舉例 假設我們需要實作一個回合制 RGP 遊戲的戰鬥流程，根據遭遇到的怪物不同，遊戲內分別會有普通戰鬥、特殊戰鬥、與 Boss 戰三種不同的戰鬥模式。模板模式方法告訴了我們「與其在所有的戰鬥裡面都寫上相同的程式，不如先定義一個【戰鬥】的類別，再在【戰鬥】內定義一個方法 fight()，並將其他戰鬥模式宣告成類別，繼承此【戰鬥】即可。」透過一個名為 fight() 的模板方法，讓其他的子類別，根據這個方法進行操作與細節呈現，就是模板方法模式想要訴說的內容。</description>
    </item>
    
    <item>
      <title>享元模式（Flyweight Pattern）</title>
      <link>https://fonu195713.github.io/docs/_trash/flyweight_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/_trash/flyweight_pattern/</guid>
      <description>享元模式（Flyweight Pattern）#說明 ChatGPT：享元模式（Flyweight Pattern），也稱為輕量級模式，是一種結構型設計模式。它旨在最小化共享物件的數量，以減少記憶體佔用和提高性能。享元模式通過共享具有相同內部狀態的物件，將大量細粒度的物件轉換為少數可共用的共享物件。在享元模式中，每一個物件都分別擁有兩種狀態：內部狀態和外部狀態。內部狀態是物件的固定部分，它可以被多個物件共享。而外部狀態則是物件本身的變化部分，每個物件都有自己的外部狀態。享元模式的核心思想是將內部狀態和外部狀態分開處理，從而節省記憶體和其他資源。享元模式的主要目的是將具有相同內部狀態的物件共享，從而減少記憶體的使用和對象創建的開銷。
維基百科：享元模式（英語：Flyweight Pattern）是一種軟體設計模式。它使用物件用來儘可能減少記憶體使用量；於相似物件中分享儘可能多的資訊。此法適用於大量物件近乎以重複方式存在，因而使用到大量記憶體的時候。通常物件中的部分狀態（state）能夠共享。常見做法是把它們放在資料結構外部，當需要使用時再將它們傳遞給享元。典型的享元模式的例子為文書處理器中以圖形結構來表示字符。一個做法是，每個字形有其字型外觀、顏色、和其它格式資訊，但這會使每個字符就耗用上千位元組。因此，取代的做法會是：將每個字符參照到一個共享的字形物件，此物件會被其它有共同特質的字符所分享；只有每個字符（文件中或頁面中）的位置才需要另外儲存。
將一個物件的屬性區分為「內部狀態」和「外部狀態」 統一參照所有此物件的內部狀態 物件本身只需要儲存其外部狀態的資訊 用以減少大量記憶體和資源消耗 </description>
    </item>
    
    <item>
      <title>新新魔塔 v2.6.6</title>
      <link>https://fonu195713.github.io/docs/daily_life/notes/xinxinmota/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/notes/xinxinmota/</guid>
      <description>新新魔塔 v2.6.6#前言 印象中第一次接觸到「魔塔」系列的遊戲，大概是在小學三四年級左右吧？那時候我還蠻喜歡到玩一些 flash 小遊戲，那時候比較有名的平台大概有史萊姆的第一個家、遊戲桃、y8、遊戲天堂&amp;hellip;等等。玩過的遊戲不算少？比較有名的大概就是越南大戰、電眼美女、麻將系列 &amp;hellip;等等，還記得那時候第一次玩遊戲天堂裡面的三國麻將，不知道它是打清章的規則，一直想說「遊戲是不是出問題了？怎麼明明能『胡』的，但是遊戲就沒有辦法『胡』」XD。此外，魔塔系列也是我小時候裡面很喜歡玩得遊戲之一。
第一次接觸到魔塔系列的遊戲，是某一天在遊戲天堂裡找到的瘋狂魔塔。總之就是一個爬塔遊戲，越上層怪物的攻擊、防禦、跟血量都會變多。但除了層數很多之外（有 50 層），遊戲的難度整體不大。除了怪物體質沒有到很極端之外，遊戲裡最大的特點是「打怪不會扣血量」這項設定，所以整個爬塔過程與其說是在「冒險解謎」，不如說它其實是一款「爬塔體驗、模組觀賞」的遊戲。整體來說，在第一次爬塔的過程蠻好玩的，但後續的體驗可能就會隨著通關次數的提升而有所下降了，畢竟爬塔的遊戲就是通關了再照同樣的公式走也能通關。
難易度：★☆☆☆☆ 遊戲性：★★☆☆☆ （會隨著通關次數的增加而遞減） 後來，在遊戲天堂裡面出了一個新的魔塔遊戲，叫做新版魔塔，整體的難易度一下提昇了不少。除了血量需要精算之外，各種攻擊力、防禦力的數值也必須要把控的相當細膩，才有可能通關，有時候甚至要在某個時期存到 1000+ 以上的金錢，再一口氣做攻防的調配才有可能順利爬下去。跟上一版只要無腦加攻的瘋狂魔塔實在是有著完完全全地天壤之別。也因為有著複雜的攻防計算，加上遊戲中期以後有 3-4 條不同的分支玩法（後面會說），遊戲性一下子提升了不少，但也因為難度大幅上修的原因，小時候的我一次都沒有完全破關就是了。對於有自虐傾向挑戰精神的人，很適合至少玩過一次。也因為極高的難易度，小時候的我在嘗試了幾次之後，就沒有再點開這個遊戲了。
難易度：★★★★★★★★★★★★★★★ 遊戲性：★★★★★ 之後過了好久好久，到了碩二口試前的大概&amp;hellip;一個月左右吧？在一次跟朋友的閒聊中，這個遊戲無意間又被其中一個人給提出來了。很意外地，研究室裡大部分的朋友都有玩過這個遊戲，而且清一色地都給出了「小時候覺得很好玩」「遊戲超級難」「從來都沒有破關過」這三條口供。因此，在碩士生症候群與好奇心的驅使下，我們就又重新地打開了這個遊戲&amp;hellip;
我們玩的版本是再新一點的新新魔塔，除了因為是後幾年推出的版本，因此動畫、音效、與視覺感受都有著更新之外，基本上玩法，玩家的初始狀態，怪物的攻防、數量、和分佈&amp;hellip;等都是跟新版魔塔一樣的，唯一一個最大的差別是新版魔塔提供了「極速模式」，主要支援「一鍵到位（省去步行的動畫）」、「快速樓層移動（省去冗長的上下樓梯）」、與「即時戰鬥（用數學的方式直接計算傷害總量，省去單回合的戰鬥過程）」三種功能。算是大大地提升了遊戲的體驗和縮短遊玩時間。
遊戲說明 《新新魔塔》，原名《魔塔》，被稱為 &amp;ldquo;三原塔&amp;quot;之一，是一款基於 Flash 製作的經典魔塔作品，由 cos105hk 於 2005 年製作完成並發布。《新新魔塔》的素材、核心玩法&amp;hellip;等都來自於原日文版魔塔《魔法の塔》（The Tower of Sorcerer）。與傳統魔塔相比，最大的特點是不具備 &amp;ldquo;完全重複性&amp;rdquo;（玩家和怪物的攻擊都有機率造成爆擊或被閃避），它也是 &amp;ldquo;三原塔&amp;rdquo; 中機制最複雜、最具有挑戰性的作品。其獨特的機制、優秀的戰鬥動畫&amp;hellip;等，都為後人創作魔塔作品留下了深遠的影響&amp;hellip; （出自《新新魔塔》中的 &amp;ldquo;遊戲說明&amp;rdquo;）
遊戲劇情簡單來說，就是一個「勇者打敗魔王，救出公主」的故事。玩家要透過所扮演的角色（也就是勇者），在魔塔的各個樓層之間闖蕩、賺取金幣、獲得經驗、提升攻擊力與防禦力，一路過關斬將，最後打敗魔王，來完成整個遊戲。（然後，再來就是防雷警告了，接下來會有一點遊戲的劇透，如果想要自己嘗試看看的話，就不要再往下看了。劇透警告！）
劇透警告 劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！劇透警告！
遊戲階段 遊戲主要分為 2 個階段，第 1 個階段是『假公主階段』，主要的活動範圍會是在魔塔的 1-20 層。可以從一樓老人口中的「聽說魔塔不只 20 層，但最高只能到 20 層。」發現一些端倪。這時候勇者的目標，是要打敗 1-19 層的種種怪物，並嘗試走到 20 樓與「公主」見面。但等到勇者一與 20 樓的公主說話之後，便會發現她其實是怪物所變化而成的，玩家需要打敗這個怪物，並找到真正的公主。
接下來會進入到一個小小的「過門」：玩家在打敗 20 層的假公主之後，會從假公主身上拿到一個小偷的十字稿。我們需要回到 2 樓與小偷對話，讓他去第 0 層打開「往下的門」向下探索。待走到地下 2 樓的時候，再跟精靈說話，祂會要你去打敗 15 層的大章魚，並從章魚後方的樓梯一路走到 17 樓，從 17 樓進入真正的『魔塔』。然後玩家要一路往上到魔塔 5 樓，領取其中一個『紋章』。再之後，打敗鏡像的自己，回到地下 2 樓與精靈對話，開啟更下層的空間，進入到「第二階段」，開始繼續爬塔 &amp;hellip;</description>
    </item>
    
    <item>
      <title>一千份的手抄心經</title>
      <link>https://fonu195713.github.io/docs/daily_life/notes/heart_sutra_beforehand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/notes/heart_sutra_beforehand/</guid>
      <description>一千份的手抄心經#前言 2020 年 10 月 24 日是我開始抄心經的第一天。那時候因為生活上遇到了一點困難，所以想要試著尋求一些神佛和心靈上的安慰。雖然在此之前，我就算是一個篇迷信的「宗教狂熱者」（畢竟身邊點的最歪但也點的最完整的技能樹是『算命』），平常有事沒空就會去拜拜（最密集的時候大概一個禮拜會去個 1-2 次吧？），平常沒事就看點宗教學的書、研究研究塔羅、八字、紫微斗數、古典占星&amp;hellip;等等。但一直以來其實並沒有抄經（或者是唸經）的習慣，一方面是那時候『抄經』對我來說很繁瑣也很花時間，另一方面是自己真的沒有什麼特別想要做這件事的緣由。也就沒有把這項技能給「點起來」了。
不過後來生活上發生了點意外，說的細節一點是跟感情有關。這時候「會算命」倒也變成了一種比較麻煩的事情：因為你自己會透過一些占卜之類的方法，不斷地、不斷地、不斷地、不斷地、不斷地、不斷地、不斷地去尋求一些答案。雖然平常的時候總會把「迷信迷信，迷而不信」掛在嘴邊，但在那時候我反倒是便成了最迷的那一個。除此之外，我也嘗試過花一些錢，買一些傳聞中的開運產品、桃花手鍊&amp;hellip;等迷信小物。（一條手鍊可以賣到 5200 欸超扯），但想當然的，後來的功效如果不是「完全沒有」，就只能用「微乎其微」來形容了。
也大概是在那個時候，我開始接觸到「經文」這一類的東西
一開始是配合著開運手鍊賣家的建議，可以嘗試每天抄抄，抄完之後順便許願 + 迴向。據她所說，只要有穩定的在進行的話，大概 100 天左右之後就會有不錯的結果吧？抄的經文是最大眾的「般若波羅密多心經」，全文只有 260 字，加上標題跟標點符號大概 300 上下。一開始那個姊姊是說「抄完之後要在口唸（或默念）三次補闕真言才算完成。」但因為心經的部分我自己是用 400 字的稿紙抄寫，所以後來索性就直接把箴言給補在稿紙的後面了（畢竟空間夠）。然後傳聞中的 100 天有效嘛 &amp;hellip; 這個就見仁見智了，我猜我應該是不夠虔誠 XD
抄經（馬步期） 最一開始的前兩個月，因為自己並沒有背誦過心經的全文，所以都是抄個 5-10 個字，就要看一次手機，然後再抄個 5-10 個字，再看一次手機，算是抄經的「馬步期」。老實說算是個挺特別的經歷。或許是心理因素？又或者是真有其事？我自己在反覆查閱跟書寫的過程中，是真的可以感受到那種「體悟心靈祥和」的感覺，準確來說，有點類似「煩惱在抄寫的當下都會被全部丟掉」的感覺，但就只有「抄寫的當下」就是了，抄前抄後不順的心情還是會有，哈哈哈哈！
除此之外，我大概也是從這個時期開始，養成每天跑 3000 公尺的生活習慣（雖然這習慣在堅持近一年之後就斷掉了）。那時候的 3000 公尺成績，最好最好可以到大約 13:40 左右吧？以一個 &amp;ldquo;資工肥宅&amp;rdquo; 來說，我猜也是個很好的成績 XD。總而言之，這兩個習慣（抄經 + 跑步）的培養與維持，雖然沒有讓我「獲得桃花手鍊所期待的功效」，但也讓我對於之後「回歸平常」的心境起到了不小的功用。
之後大概就是穩定的維持抄經的習慣，需要看手機的次數越來越少、背誦的熟練度也越來越高，每天 1 份、每週 7 份、每個月約 30 份，這種日復一日的工作（沒錯，在這時候對我來說已經算是工作了），大概也維持了 4-500 天有。這期間的心理開始不會感受到最純粹的「體悟心靈祥和」。我自己用科學上的解釋的話 &amp;hellip;因為一開始並不會背誦，所以心裡必須要一直「照見五蘊皆空，度一切苦厄 &amp;hellip;」之類的一直唸一直唸，心裡沒有辦法塞其他的東西進來。所以才會有那種極度專注真極度禪學的感覺。
抄經（築基期） 但自從我開始熟稔了之後，就會開始想東想西了。但這邊也有挺神奇的事情：就是雖然在「築基期」（開始累積經文手本的時期）裡會有一些「雜念」，但這些唸投多半也是跟自己本身有關，像是「等等要吃什麼？」「等等程式要怎麼寫？」「畢業專題的那個進度可不可以用 xx 試試看？」&amp;hellip;等等的。「我在感情上有沒有辦法 &amp;hellip;」這樣的念頭可以說是完全沒有（或者有，但微乎其微到我忘記了）。這或許也是冥冥之中神明對我的引導吧？我不確定，但我自己是蠻樂意這樣解釋的，或單純思考成「運氣超好，從來都沒想過『感情』的事情」也行～
在這段時期，我也會配合一些「白噪音」來進行抄經的活動，通常是 youtube 那種長時數的雨聲、燒柴、缽音，有時候也會是吉他、頻率音段，在那時候 podcast 也剛紅起來，我也有廳類似股癌、百靈果之類的節目來配合抄寫過。總之就不是那種最原汁原味的「全神貫注地抄經」了（這也是我開頭會說我不構虔誠的原因）。</description>
    </item>
    
    <item>
      <title>第 2 次問事</title>
      <link>https://fonu195713.github.io/docs/daily_life/notes/ask_buddha_for_advice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/notes/ask_buddha_for_advice/</guid>
      <description>第 2 次問事#前言 佛母的全名叫做準提佛母，從維基百科上的資料來看，祂應該算是菩薩的一種，宗教分類是在佛教那邊，再細一點應該是藏傳佛較。第一次聽到佛母的&amp;hellip;名號(?) 是在剛學紫微斗數的時候，我紫微斗數的老師算是一個比較相信「善有善報，惡有惡報」那一套循環的人，也是相信「算命會幫人家背負業障」的那一邊。所以在老師的影響下，我也算是慢慢變得比較像是這種價值觀的人。
老師之前有說過，他會定期的去請別人幫忙他&amp;hellip;清業障？他比較常見的作法是【拜拜】跟【刀療】，拜拜沒什麼好講的，就是「希望神明可以幫我把業障清掉～」類似這樣的拜拜感覺。刀療的話&amp;hellip; 聽老師說：那個刀療的師傅算是在一定程度上面有一點靈異體質（或敏感體質？），所以可以透過師傅的刀療去把一些不好的負面能量給刀掉。那除了這兩個之外，【找佛母問事】則是老師算是定期會做的事情。
佛母的&amp;hellip;廟？全名叫做「宇宙天 天敎聚善堂」，地點在屏東的高朗，google map 沒有辦法指出非常精確的位置，但地點大致上是在那邊沒錯（正負誤差 50m 左右）。在我的印象中，老師大概有去過至少 &amp;hellip; 4 次以上？但我覺得實際次數應該會更多。那裡本質上就是一個用來問事的廟宇（或者說空間），費用現場的話是隨喜，如果用 line 問事的話則是每 10 分鐘 600 元，然後無論哪種都不限題數。
背景 第一次體驗到佛母的問事是在去年的年中（大概 2022/06），是網路預約，我約了一個 10 分鐘（所以是 600 塊）。那時候主要是因為一些感情跟工作上的問題在煩惱。感情準確一點來說是「想知道跟喜歡的人有沒有機會」和「沒機會的話哪時候有桃花可以嘗試」，工作則是「不知道畢業之後的未來應該要做什麼。」整體而言，無論是哪一邊，都算是比較迷茫的那種情況。那第一次的心得嘛&amp;hellip;本質上來說【準.的.有.點.可.怕.】。
畢竟自己是做算命的，所以大致上來是有辦法分辨得出「江湖術士」「神棍」跟「算命」的區別。江湖術士&amp;hellip; 本質上是騙術的累積，基本上算是一些大家只要花點心思就可以練成的技巧或問話方式；「神棍」算是我現在的階段，有一定的命理基礎，但是大概還是有一些東西是需要用猜的才能準；「算命」則是再更高一層的階段了，基本上老師大概就是在這個位置，然後我覺得「神棍」跟「算命」的差別在於【大量的累積】，無論是學理或者是實務經驗都是。至於「問事」嘛&amp;hellip; 那很明顯是通靈，而且對我來說是真的「什麼前因都沒有說過，他就可以直接說出來」的那種準確的通靈。
總的來說，第一次的解答主要有幾個方向：「我那時候不適合全職算命（或把算命當主業）」「桃花近期會有」「要再對自己有信心一點」跟「跟藏傳佛教挺有緣的，可以多多接觸」這幾點。扣掉桃花的部分（直到目前都是單身），其他都還算是在意料之內，但不能夠粉科學地驗證這些東西，所以就算是比較純粹的寫出來做個紀錄、當作分享。
第二次的話，就是這個禮拜三（2023/08/23）了。這次是實際過去，會想去的動機有 3 個：第 1 個是我第一次去找佛母問事的時候，算是處在「經文斷更」的狀態，詳情可以看這篇。因為第一次「很有感」的經驗，所以我心裡一直希望可以再去找一次佛母，聽他說說最近我的狀態；此外我的老師其實也一直都有跟我們說「建議至少可以去找佛母一次問問題，可以得到不少收穫」，這也加深了我想要「當面」過去的想法。
但最主要推使我去找佛母的動力算是去的前一天的小小意外。因為口試完也畢業完了，因此我跟我朋友在現在算是比較 free 的狀況。他一直想找一個機會「當面」去找佛母，所以就在禮拜二的時候問我「要不要去？」然後我回答「好！」就去了 XD，沒錯，就是這麼突然跟沒有情節。沒什麼長遠的故事，純粹就是一個你問我答、你走我就走的那種調調。
心得 那這次去找佛母有什麼收穫呢？主要有以下幾個：首先是【仍然很準】。老實說最近的我自從&amp;hellip; 補完經文的斷更之後？就一直算是處在對一切都很 free、很愜意、很 for fun 的那種狀態，沒有什麼特別想問的，無論是工作還是感情。但這次畢竟還是跟朋友去了，所以就抱持著一種「反正都來了，就順便問唄」的那種心態進去，結果佛母連我還沒坐下椅子，只遠遠的看了一下我，聽了旁邊的師姐念一下我的名字，然後就直接說「你不是沒有問題想要問我嗎？」「看起來你都有做出決定了阿，而且決定都沒什麼問題」「怎麼還會想要過來呢？」直接讓我在當下一個嘴角失守，幹&amp;hellip; 還是好準。
但本質上來講，我還問了三個問題，分別是 1 感情 2 工作 。
首先是感情的部分，但因為感情真的沒甚麼想問的，所以題目仍舊是「哪時候會有桃花」之類的，佛姆只說要「好好許願」，言下之意我覺得是「善用吸引力法則」，然後我立馬有想到好久之前寫過一張希望的條件列表，我再猜佛母同樣也再講那個。然後祂有給我幾個線索：對方會獨生女、家世背景大概率會不錯或很好、然後大概會在今年下半年會出現。剩下的條件&amp;hellip; 應該就是用力地用那張之前寫過的紙張許願就沒問題了。
再來是工作：第一個問題大概還是圍繞在「畢業之後要做什麼會比較好」的這一點上，目前有幾個想法：【持續算命】【菲律賓遠端程式博弈】跟【其他】。但總而言之，我的想法比較偏向「總之先去博弈。因為它最確定，同時錢最多。然後算命也要兼顧，其他的之後再說。」對此，佛母沒有說我這個想法好還是不好，大致的意思比較像是「遵循心中的決定就可以了，沒甚麼問題。」所以我自己的解讀比較像是「做博弈可以，但是要記得捐錢，然後要用之前自己心中的明碼捐獻」大概會是&amp;hellip; 1/3 左右的淨收入。
工作的第二個跟算命比較有關，我一直想知道「要怎麼樣，才可以最有效率的幫助人（或者效益最大）。」對這個問題，佛母給出的回答是「相信自己、相信老天、相信總有一天你能成功&amp;hellip;」之類的話。因為前面感情那邊有先想到吸引力法則，所以這邊我覺得潛台詞應該同樣是「多多善用吸引力法則」那樣的感覺，我自認我大概當下就有聽出這個意思，但實際上是不是真的這個意思則不確定（但我大概有 9 成（或以上）的信心覺得是對的）。
然後最後在那邊走之前，我在那裡買了一個銀色的大衛星水晶項鍊，價格要 \(\$2800\)，就是比那種 1688 開運手鍊再貴一點的那種開運項鍊 XD，買之前還給佛母加持了一下～據說它可以讓我比較能夠接收到宇宙天地間的能量，我自己是相信啦（不然就不會買了哈哈），但我的朋友一致都覺得我是一個怪人就是了，哈哈哈哈。</description>
    </item>
    
    <item>
      <title>碩士畢業證書</title>
      <link>https://fonu195713.github.io/docs/daily_life/nodes/masters_degree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/nodes/masters_degree/</guid>
      <description>碩士畢業證書#前言 在開寫部落格之後的第一個人生重要節點，大概就是【從碩士裡畢業】這件事情了吧？也因此，這件事想當然地成為了節點中的第一篇文章，這篇文章會稍微寫一下當時候讀碩士的緣起、過程、最後拿到畢業證書之後的心得、和一些整體而言的感想。總的來說，算得上是又一篇的流水帳總之就是單純紀錄用的文章 XD
碩士之前 首先，我必須承認，在最最一開始的時候，我並不是一個對於「讀碩士」這件事情很有熱誠或者是很有追求的人。雖然大家都說「電資相關的科系，就是要讀碩士！之後的薪水才會高！」但我一直都覺得那樣做有點沒必要，有點為了學歷而拿學歷的那種感覺（少了【學習】的過程）。所以在一開始，大概是大二左右的時候吧？當學校附近的知名研究所補習班來找我們工商的時候，我是完全都沒在聽的。
但後來發生了幾個比較重要的事情，影響到了我對於「碩士意願」的看法：第一個是我認識了一個善於做隱寫術的系上教授，因為大學專題的緣故，所以跟該教授共同研究了一段時間，在那段時間我了解到「【做學術研究】這件事對我來說，其實還挺有興趣的？」此外，教授也有大概跟我分享了一些公立教授的薪水、福利、或者是一些日常&amp;hellip;等。
對於那時候對未來什麼都還不確定的我來說，老實說，「一路讀到博士，然後找一個公立的大學教授職缺」的確是一個挺好的主意，也因此加深了我「畢業之後要讀碩士」的一些動機和意願。但後來因為一點家裡和個人考量的緣故，雖然升上碩士之後還是在原本的學校就讀，但指導教授就不是原本的隱寫術老師了，在我升上碩士之後，換了一個比較善於密碼學的老師作為我的指導教授。
會轉實驗室的原因主要有以下幾個：首先是「當上教授」這個夢想（或者說目標？）在我大概大四上或鄰近畢業的那一陣子，就驟然地退卻了。主要的原因到現在為止還是沒有甚麼比較明顯或特別可以拿出來說事情，比較像是很單純地 &amp;ldquo;就是沒興趣了&amp;rdquo; 的感覺。另外一點是，大概在大三下左右的時候，我重新拾起了「算命」的這一嗜好，並打算將之培養成後續的一種生財方式。
所以在那時候，我的生活重心從「認真的做研究」轉變成了「想要認真的學習和累積算命經驗。」為此我幫自己做了兩個總結：讀碩士可以再讓我晚 2 年出社會，因此有多出來的兩年時間可以累積算命經驗；找一個最為輕鬆和最為能夠給學生自由時間的實驗室待著，用來成立第一點的目標。因此，我就在大四下左右的時間裡找了一個最為輕鬆、碩士期間給學生最大限度的自由研究室來研習了。
碩士生活 算命#因為有先打聽和考察的緣故，碩士的生活整體而言跟我的預期沒有差到一個太多。扣除掉研究室內部的論文報告之外，基本上在讀碩的兩年時間，老師不會安排其他特別的事情給她底下的指導學生，可以這麼說：不管是案子、計畫、或者是其他跟研究相關的雜事，只要不是跟「自己的碩論」有關，老師就不會把事情放下來給我們做。算是較為少見的佛系教授。
因，在碩士的生涯中，除了日常的一些論文閱讀之外，我在工作方面最常做的事情就是算命、算命、以及算命。可以很肯定地說：因為指導教授的緣故，我的算命功力在這兩年內的確有著很大量很大量的提升。直到現在我都很感謝指導教授的指導風格。也很感謝她的為人處事、以及跟我們說的一些觀念、人生道理、或者是生活經驗之類的分享。
學術#而至於學術方面，因為老師的專長是密碼學，所以在碩士的生活期間也學到了（或者說加深了？）各種密碼學的操作、流程、演算法、或者是不同算法之間的比較、效率、或者是生成原因、歷史沿革&amp;hellip;等。從【加解密方式】來說，最基礎的對稱式 AES, DES，非對稱式的 RSA, ElGamal 等演算法，到後來的 ECDSA、Schnorr、Paillier、Rabin 都有涉略與研究。
理論的話&amp;hellip;關於【密碼學有關的數論】大概有 模運算、中國剩餘定理、費馬小定理、歐拉定理（尤拉定理）&amp;hellip;等。從在這之後又衍生出來理論有&amp;hellip;【公認難題】像是大數分解、解離散對數、和後量子的格密碼學&amp;hellip;之類的，【其他】像是各種不同的加解密衍生的系統，例如 &amp;ldquo;簽章&amp;rdquo;（比較特別的又有 &amp;ldquo;盲簽章&amp;rdquo;、&amp;ldquo;群簽章&amp;rdquo; 和 &amp;ldquo;環簽章&amp;rdquo; 這幾種），&amp;ldquo;各種加解密體系&amp;rdquo;（基於離散對數、ECC、雜湊、非交互式、零知識證明&amp;hellip;等）都是這兩年內重新加深印象 or 新學到的東西。
也因此，整體而言如果要給我的碩士生活打上一個分數的話，我會給大約 97-98/100 的分數。缺少的分數大概是&amp;hellip; 覺得自己有時候還是太過鬆散了（如果時間抓緊的話可以在學更多東西）以及「總覺得自己還可以在某些方面加強，來讓自己更好」這一方面。但這並不影響我覺得我的碩士生活很美好啦 XD，跟大部分的碩士生不太一樣，我這兩年過得挺開心的。
論文#後來就是寫論文、然後畢業。論文的題目是「A Research on Security Mechanisms in Smart Grids」，算是一篇攻擊型論文，該論文主要可以分成 4 個部分：介紹何為 Smart Grids 以及該項技術的相關應用與研究、分析相關研究 A 的演算法並接露該算法的安全性缺失、分析相關研究 B 的演算法並接露該算法的安全性缺失、總結兩種相關研究的缺失與提供改進和結論。
研究 A 主要是建立一個新的 Smart Grids 架構，核心技術有【區塊鏈技術】和 【Paillior Cryptography】兩種。該方案無論是在區塊鏈的理解和應用上都有著一些問題，此外對於 Paillior 的加解密流程也有點錯誤認知，因此給到了一個很好的攻擊機會。研究 B 則是從 Smart Grids 的資料傳輸切入，提供了一個透過【XOR】與【雜湊函數】形成的輕量級加解密運作，但該流程可以透過一些攻擊手段，來讓使用者的核心資訊被盜取，因此兩種方案都有存在著一些問題，進而讓我的碩士論文有了不錯的方向。</description>
    </item>
    
    <item>
      <title>日本旅行 7 萬步</title>
      <link>https://fonu195713.github.io/docs/daily_life/notes/osaka_3_days/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/notes/osaka_3_days/</guid>
      <description>日本旅行 7 萬步#前言 記得人生中，第 1 次出國旅遊大概是在上幼稚園的時候。那時候去了 10 天的中國，是跟阿公阿嬤還有其他的家族長輩一起去的。整體來說已經沒甚麼印象了，但隱約記得看過萬里長城、紫禁城（印象中超大的）、好像還有張家界？跟樂山大佛。第二次出國是在我小 2 的時候，那時候是暑假去了兩個月的菲律賓語言學校。算是表哥他們一起去的（表哥一家是台菲混血）。再後來的話&amp;hellip; 就沒有出國玩的印象了。一方面是因為後來主要都在拚學業，寒暑假都是補習班跑，另一方便自己也開始養成了「待在家好像也不錯？」的宅屬性，所以就一直待在台灣了。直到上個禮拜，近 20 年後的「出國旅遊」才又被我重新提起。
這次的行程是去日本，總共 3 天，但是是第一天凌晨到日本，第三天 10 點的班機，所以嚴格來說，算是只有兩天半的遊玩時間。去的人只有我跟我妹兩個，算是很輕量的人數。此外，行程有 99% 以上都是我妹排的，基本上我算是負責當一個全肯定 + 工具人 + 陪玩陪聊天的旅伴這樣（挺沒有用的，老實說 XDDD）。主要的行程都在大阪，但第 3 天有京都的和服體驗。整體來說，這趟旅程滿分 100 及格 60 的話，我會給 98 或 99。
首日 旅行的前一天，是搭桃園機場凌晨 2 點的飛機。我們大概 11:30 左右就開始排 check in 了，直到完全通關（等上機）的時候，大概是 1 點左右？所以有近一個小時的時間可以逛免稅。但我跟我妹那時候都在找休息區補眠 XD，畢竟行程是從一下飛機就馬上開始的，因此在出境的時候，我們是沒有逛多少東西的。
後來 2 點左右上了班機，我們搭的是樂桃航空的飛機（代號 MM），去程的乘坐體驗如果滿分 100 及格 60 的話，我會給 20-30 分。其原因在於 &amp;ldquo;幾.乎.整.趟.航.班.都.是.在.劇.烈.的.搖.晃.中.度.過.的&amp;quot;。第一次感受到完全的無力，當你面對一個「覺得隨時可能都會突然發生意外」但只能坐在椅子上等待的時候，那個背後是真的會有毛骨悚然的感覺的！但好加在，飛機最後還是在 6:20 左右順利抵達日本的關西第二航廈。
抵達航廈之後會先走一個近 400 公尺的入境審查。在這邊也發生了一點有趣的事情：因為語言不通，加上我身上拿了兩個大行李（一個揹著、一個拖著），所以在入境審查的時候，那個審查官有大概問了我一些事情，不過因為他講的超快、加上又是說日文、以及 &amp;ldquo;他.不.管.問.什.麼，我.一.路.都.是. YES. YES. 的.回.答&amp;rdquo; 所以我大概就被當成「可能有待一些違禁品入境的外國人」被多扣了一陣子了，幸好最後還是化解了這場誤會，哈哈哈！</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/example/collapsed/3rd-level/4th-level/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/collapsed/3rd-level/4th-level/</guid>
      <description>4th Level of Menu#Caesorum illa tu sentit micat vestes papyriferi#Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.
Venasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/example/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/example/hidden/</guid>
      <description>This page is hidden in menu#Quondam non pater est dignior ille Eurotas#Latent te facies#Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona#O fallor in sustinui iussorum equidem.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/buttons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/buttons/</guid>
      <description>Buttons#Buttons are styled links that can lead to local page or external link.
Example#{{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}} Get HomeContribute</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/columns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/columns/</guid>
      <description>Columns#Columns help organize shorter pieces of content horizontally for readability.
{{&amp;lt; columns &amp;gt;}} &amp;lt;!-- begin columns block --&amp;gt; # Left Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Mid Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Right Content Lorem markdownum insigne... {{&amp;lt; /columns &amp;gt;}} Example#Left Content#Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/details/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/details/</guid>
      <description>Details#Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.
Example#{{&amp;lt; details &amp;#34;Title&amp;#34; [open] &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} {{&amp;lt; details title=&amp;#34;Title&amp;#34; open=true &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} TitleMarkdown content#Lorem markdownum insigne&amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/expand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/expand/</guid>
      <description>Expand#Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.
Example#Default#{{&amp;lt; expand &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Expand↕Markdown content#Lorem markdownum insigne&amp;hellip;With Custom Label#{{&amp;lt; expand &amp;#34;Custom Label&amp;#34; &amp;#34;...&amp;#34; &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Custom Label...Markdown content#Lorem markdownum insigne.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/hints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/hints/</guid>
      <description>Hints#Hint shortcode can be used as hint/alerts/notification block.
There are 3 colors to choose: info, warning and danger.
{{&amp;lt; hint [info|warning|danger] &amp;gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{&amp;lt; /hint &amp;gt;}} Example#Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus TelethusaMarkdown content</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/katex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/katex/</guid>
      <description>KaTeX#KaTeX shortcode let you render math typesetting in markdown document. See KaTeX
Example#{{&amp;lt;/* katex [display] [class=&amp;#34;text-center&amp;#34;] */&amp;gt;}} f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi {{&amp;lt;/* /katex */&amp;gt;}} Display Mode Example#Here is some inline example: \(\pi(x)\), rendered in the same line. And below is display example, having display: block \[f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi\]Text continues here.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/mermaid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/mermaid/</guid>
      <description>Mermaid Chart#MermaidJS is library for generating svg charts and diagrams from text.
Override Mermaid Initialization Config
To override the initialization config for Mermaid, create a mermaid.json file in your assets folder!
Example#{{&amp;lt;/* mermaid [class=&amp;#34;text-center&amp;#34;]*/&amp;gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --&amp;gt; State2 note left of State2 : This is the note to the left.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/section/first-page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/section/first-page/</guid>
      <description>First page#Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/section/second-page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/section/second-page/</guid>
      <description>Second Page#Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/_docs/shortcodes/tabs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/_docs/shortcodes/tabs/</guid>
      <description>Tabs#Tabs let you organize content by context, for example installation instructions for each supported platform.
{{&amp;lt; tabs &amp;#34;uniqueid&amp;#34; &amp;gt;}} {{&amp;lt; tab &amp;#34;MacOS&amp;#34; &amp;gt;}} # MacOS Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Linux&amp;#34; &amp;gt;}} # Linux Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Windows&amp;#34; &amp;gt;}} # Windows Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; /tabs &amp;gt;}} Example#MacOSMacOS#This is tab MacOS content.
Lorem markdownum insigne. Olympo signis Delphis!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230813/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230813/</guid>
      <description>2023/08/13 每日一翻#抽牌：寶劍八（逆）#解析：#寶劍八是寶劍系列的第 8 張牌，風屬性，代表的關鍵字是「徬徨」「猶豫」「迷茫」或者是「不安」&amp;hellip;等。在膩味的情況下可以將牌意做「相反、過度、or 不足」的理解，也就是「堅定」「決心」「屏除一切」或者是「邁進」「向前」&amp;hellip;等意思。套用在今天的狀況的話，這一張寶劍八應該是指「重新前進」的意思。
為什麼說是重新前進呢？因為大概在 7 的時候「不小心」讓自己放了一天的假，什麼都不做的完全休息，然後之後的每一天就都『沒關係啦明天再努力吧』『沒關係啦再給自己放一天吧』&amp;hellip;這樣的過了下去。就像是寶劍八的那個女生一樣，被劍陣圍繞著（也就是被一些困難、阻礙、或者是在我這邊比較像是『偷懶的藉口』）。即使劍陣沒有完全地封住去路 &amp;hellip;
然後直到今天，終於「逆位」了，也就是「向前邁進了」，在我這邊的話，就是意指「終於不再利用『偷懶』之類的藉口，來讓自己通散的度過一天」這樣。（今天整理了 2502 的實驗室，修好一台電腦、整理了畢業之前的文件、圖書館還書、查勤了一下精裝論文的進度、同時也寫了兩篇的 blog 文章、順便複習了一下 Matlab 的語法和程式 &amp;hellip;等）。整體來說，相較於前一個禮拜左右的虛無飄渺、荒蕪度日，今天的確算是比較充實也比較努力的一天。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230814/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230814/</guid>
      <description>2023/08/14 每日一翻#抽牌：聖杯侍者（逆）#解析：#做為聖杯系列的宮廷牌，聖杯侍者因為屬於風屬性的「侍者」，因此它也是 4 張宮廷牌（侍者、騎士、王后、國王）裡面最為「動態」的一張牌。聖杯侍者通常的涵義可以理解為好奇、期待、點子、思考、或者是多元的想法 &amp;hellip;等。與「水之水」的聖杯王后不同，「水之風」的聖杯侍者更有那種跳躍性的、靈活的、外向與活潑的、或者是忽然的、突發奇想的、靈光一現的想法跟點子在內。也因此，聖杯侍者在人物上可以理解成發明家、哲學家、創意與企劃人才 &amp;hellip;等。
至於逆位的聖杯侍者，就有「相反」「不足」或者「過度」的意思了。通常可以理解成想的不夠多、稍微遲鈍、或者是想太多、太過跳躍&amp;hellip;等。那套用在今天的情況的話，我會覺得這張逆位的聖杯侍者比較像是「停止思考」的一張牌，有點類似想得不夠多。因為今天比較重要的事件應該就是「來回跑了 3-4 次的加恩影印」還有「試跑了一次離校程序」這兩件事情吧？
無論是哪一件事情，都是急需身體力行的任務，也可能是因為我「想的不夠多」所以在一些流程上面做了許多重複的事情（像是加恩可以不用跑這麼多次，如果東西都有備妥的話；或者是離校程序其實不用拖那麼久，如果我有把東西一次問清楚的話&amp;hellip;）。總而言之，今天「逆位的聖杯侍者」我覺得比較像是我「因為對事情沒有想得太過周慮，因此在流程上面出現比較繁瑣的情況」來做解釋比較類似。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230815/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230815/</guid>
      <description>2023/08/15 每日一翻#抽牌：權杖侍者（逆）#解析：#權杖侍者，屬性火之風，是一張同時具有火風兩種比較主動、比較富有熱情、和比較動態能量的一張牌。在我一般的理解上，因為相對於騎士、王后、和國王&amp;hellip;等，侍者是屬於比較低位階的職位，因此在職務的邏輯判斷上，我會把侍者思考成類似基層、工讀生、跑腿的人 &amp;hellip; 等比較初階的職位。那在牌意的理解上，扣除掉「想法」「展望」「熱忱」和「期待」&amp;hellip;等比較偏純牌面的牌意，這裡因為是每日運勢，所以也可以理解成「今天會比較忙」「今天會比較需要跑腿」「今天會需要一直走動，但整體而言還算帶有熱情、還算開心」的那種感覺或狀態。
但，今天的權杖侍者可不是正的。
權杖侍者的逆位，可以簡單地理解成「權杖侍者」+「逆位」這兩種狀態來解釋。用牌意理解的話，就是「想法、期待、行動、展望」配上「過度、不足、相反」所以就是「期待落空、事倍功半」或「錯誤的期待」&amp;hellip;等訊息。那套用在今天的情境下的話，有幾個狀態可以描述這一張牌具體的一些實現和心境：首先是 重新列印的論文文本不能用，因為一些程序上的原因，所以總計 200+ 張的 A4 指在今天直接變成一大疊的廢紙。
再來是 學校的畢業流程繁瑣，這個比較像是行政體系本身的問題，今天為了跑離校，前前後後忙了大概快一天，大概跑了 4-6 個處室的行政手續，其中有一些還會被推走，或者是說資料不足不予處理，然後也被這之中的 3-5 個人說「文件不是他們所 規.定. 的那個樣子」但又找不到任何的規定或條文，有點像是「你們必須得跟著我們這個習慣成自然的規定走才可以」的那種感覺。整體來說，今天算是極度事倍功半、消磨心力、疲於奔命的一天。希望之後的流程可以再順利一點。我大概也會花一點時間幫之後的學弟妹寫一個「畢業前的教戰手則」之類的檔案留給他們吧？希望能夠平安落幕。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230816/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230816/</guid>
      <description>2023/08/16 每日一翻#抽牌：正義（逆）#解析：#正義牌，大阿爾克納的編號 11，舊式的塔羅也有編號為 8 的版本。主要的意思為均衡、穩定、維持、準則、固定、規章、或者是流程。也因為是大牌的一員，因此在心靈層面可以去做延伸解讀，不過要怎麼解讀&amp;hellip;基本上還是得看配牌或當下的直覺來定，一般在每日抽牌上，除非翻開的當下有什麼比較連結到的感應，不然不會對心靈層面的解釋做過度的解讀。
那逆位的正義，就可以從「不足」「過度」或「相反」解釋，可以理解成「違背原則」「違反善良風俗」「矯枉過正」或者是「差別待遇、雙重標準」之類的意涵在裡面，今天的話 &amp;hellip;比較像是「違反規則」吧？講的簡單一點是鴿子，講的複雜一點就是「因為某些原因，所以放了朋友鴿子。」至於是什麼原因嘛&amp;hellip;在趕隔天要做的論文報告 ppt。
跟朋友的約是前幾天約的，原本說好【晚上 8 點要算牌】，但後來雲端出了點&amp;hellip;問題(?)，原本做好的 ppt 不知道為甚麼沒有被雲端儲存起來，它存起來的只有一開始的標題頁 &amp;amp; 後面的空白簡報，所以大概在下午 6,7 點左右，趕了 5 個小時（11:42 完成），最後才把原定的進度全部完成。也因此就直接放掉我朋友算命那邊的事情了（他明天還要上班，沒辦法等我這麼久）有點感到抱歉。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230818/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230818/</guid>
      <description>2023/08/18 每日一翻#抽牌：聖杯王后（逆）#解析：#聖杯王后，元素水之水，是在 78 張塔羅牌裡面最為感性的一張牌。一般狀態理解為「沉澱」「思考」「冥想」或者是「期盼」等意涵，基本上，把這張牌當作一個「很感性的人」或者是「很善於思考的人」是一個蠻不錯的解牌方向。在行為上通常會理解成「跟女生有關」「跟細膩的人有關」，在事物上則是水、液體、流動性的、杯子、盛載的器皿，或者是化妝品。
在每日占卜上，聖杯王后通常可以理解成「今天會是一個相對感性的一天」「今天是個比較容易有情緒起伏的一天」或者是「今天是個比較容易想很多的一天」以及「今天是一個比較容易被一個女生影響到的一天」等訊息。通常以吉來論，但在感情上不代表有突破的進展，比較像是那種慢慢升溫，或者是慢慢變好的感覺。工作上的話則是比較容易受到照顧、保護、或者是被呵護、被承擔。
那在我自己的體感上的話&amp;hellip;因為抽到的是「逆位」的聖杯王后，所以比較情緒上、又比較負面或過度的狀態&amp;hellip;應該是「沒有辦法在今天交出畢業的審核」這件事情吧因為要交畢業審核表的話，需要附贈一個精裝本的論文文本，然後請託印製的印刷店跟我們說預計 4 點可以取件，可以取件的當下會打電話跟我們說（系辦今天 5 點停止收件），但我們等到 4:40 都還沒有等到電話。
然後回撥之後才發現東.西.早.就.好.了.，只是不知道為什麼沒有打電話給我們，等我們過去取件、再回來學校的時候，已經是 5 點快半了，系辦想當然的也已經關了。這算是今天比較難過的事情吧？但整體而言，覺得還好就是了。沒有到特別傷心，但還是有一點點小難過啦 XD</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230819/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230819/</guid>
      <description>2023/08/19 每日一翻#抽牌：隱者（逆）#解析：#隱者牌，在大阿爾克納中編號為 9，常見的牌意為孤獨、思考、徘徊、找尋、等待，或者是看不清、模糊&amp;hellip;等意涵。同時也因為是大牌，因此牌面可以偏心靈層面來解讀，在日常的每日占卜中耶可以想像成是「頗有內心感悟」的一天，也就是代表今天可能會有一些具啟發性的想法或情境發生。然後直接從結論來看的話嘛&amp;hellip; 我覺得稍微有點對到，但沒有很完美的 match 到就是了。
今天的牌是逆位的隱者，因此可以做為「迷茫」「找不到方向」來解釋。主要發生在今天的事情大概會是「沒有什麼實質上面的進度」這件事情吧？不管是 blog 的內容（0 進度）、畢業流程（禮拜 6 學校行政沒開）、或者是人際關係的進度（冠姵有來 2502 聊天，但本質上沒什麼嶄新的收穫）、然後也沒有抄經、沒有先洗澡再睡覺 &amp;hellip;整體而言就像是虛度了一整天一樣。希望明天不會這樣！</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230820/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230820/</guid>
      <description>2023/08/20 每日一翻#抽牌：權杖三（逆）#解析：#連續不知道第幾天的逆位牌 &amp;hellip;。
今天的牌是逆位的權杖三，權杖三代表著成就、藍圖、小有所成、目標、或者是想法實現的瞬間&amp;hellip;等等，它算是一張「怒力之後，達成了自己的某個目標」的一張牌，整體而言偏好，無論是在工作或者是在感情上都算是喜聞樂見的一張牌。但如果權杖三「逆位」了，那麼意涵就會往不足、相反、或過度去做解釋。從今天的體感來觀察的話，我覺得這張牌會是一個「不足的權杖三」。
會說是不足的權杖三是因為：今天的我，整體而言過的不是很有目標或者是很有方向，簡單來說：今天同樣也是虛擲光陰的一天啦！也是那種直接睡到中午，然後啥事都沒做就直接去學校，去了學校又什麼事都沒幹，最後又直接回家，然後才勉勉強強在家裡面超抄了兩份經，假裝自己有在「努力」的一天，算是過得挺虛擲的。期待上的話&amp;hellip;希望明天會過得好一點。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230821/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230821/</guid>
      <description>2023/08/21 每日一翻#抽牌：皇后（正）#解析：#在連續抽到了 7 天 10 天的逆位牌之後，今天終於抽到了一張正位的每日塔羅了！而且還是偏好的「皇后」牌，不是什麼寶劍三啊、寶劍九啊、聖杯五、聖杯八&amp;hellip;之類的，依牌的好壞來說，算是久旱逢甘霖的一天了吧。至於牌意的話，塔羅牌裡面的『皇后』牌是大阿爾克大裡面編號為 3 的一張牌，表面上的意思有「豐盛」「富足」「盈滿」「喜悅」「開心」「豐沛」&amp;hellip;等意涵在裡面，基本上可以算是一個「付出終於有收穫了！」或者是「哇！終於得到這個東西了！」的意思。
至於從今天的經驗上來驗證的話&amp;hellip;毫無疑問，皇后在說的事情是「我把系辦要的資料都交出去了」這件事情。從來沒有想到跑系辦的離校流程是這麼需要花費心力的事情，老實說它真的讓我有一種「寫論文是不是比較輕鬆啊&amp;hellip;」的感覺在裡面，除了意義不明且不清不楚的規則之外，系辦姊姊每一次也都給人那種「歐天啊為什麼要一直來問」的感覺，而且因為每次問的姊姊都是不同的人，不同的人就會給出不一樣的看法跟說明 :) 從最一開始的「這份大學如果是讀本校的話不用交啊」到後來的「這份大學讀本校還是要交啊，只是不用跑某些程序而已」跟「只要是碩士從這裡畢業的，管你大學讀哪裡都要跑這個流程好嗎 = =&amp;rsquo;&amp;rsquo;&amp;rsquo;」超級混亂也超不明確。
但好在這樣的「溝通地獄」在今天大致劃上一個完整的句號了（雖然劃的過程有點曲折）。早上在被退件了兩次之後，第三次終於得到「我們這邊如果有什麼問題的話，會再打電話跟你說」以及「你朋友的那一份昨天審過了，如果你的檔案跟他一樣的話那應該是沒什麼大問題」的回覆。聽到這樣的回覆&amp;hellip;真的是非常感謝啊 !!!! 一想到這兩個禮拜以來的各種磨練終於在今天能夠結束之後，就真的覺得真的是太好了！</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230822/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230822/</guid>
      <description>2023/08/22 每日一翻#抽牌：太陽（正）#解析：#今天抽到的牌是正位的太陽，大小牌的定位在『大』的那邊，序號則是 19。基本的涵義為洋溢、喜悅、開心、正能量、笑臉迎人、積極、晴天、或者是成就之類的意思。在今天來看的話，大致上有幾個可以對應的事件，本質上都還蠻近似的就是了：第一個是「跟孟哲聊天」，這禮拜是孟哲第二個禮拜來 2502 閒聊，蠻開心可以跟他保持聯絡的，椰聽他分享了一些他工作上或者是人生上面的一些新的目標或看法，整體而言真的有一種「果然很厲害的人只會持續變厲害啊&amp;hellip;」的感覺 XD
第二個是「找到了一個新的 YouTube 頻道」這件事。是一個名為 0 號手稿的頻道，裡面主要會分享一些熱銷的動畫、漫畫們在創作過程中的一些邏輯、規則、軌跡&amp;hellip;等，算是對於我在進行小說裡面起到了真的很大.很大.很大的幫助。也因為頻道內的影片數跟時常都不多，目前大概 40 部左右 10-15 分鐘的影片而已，所以我預計大概再花個 1-2 天把所有的東西都看完，然後補完小說的設定跟進度，讓『套牢仔的新連載』重新開始。
其他還有像是「找回了當初大學的專題檔案」「把 github 的一些 side projects 連到這一個網站裡面」「學到了一些新的紫微斗數的算命技巧跟看法」「決定明天要去找準提佛母」&amp;hellip;等，總的來說，真的是過得很開心、很快樂、很有成就感的一天。希望明天的日子、之後的日子、未來的日子都也可以持續正面積極的過下去！</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230823/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230823/</guid>
      <description>2023/08/23 每日一翻#抽牌：聖杯王后（正）#解析：#正位的聖杯王后，代表著盈滿、富足、思緒、考慮，整體而言，作為宮廷牌中的「水之水」，它是小牌中最為「感性」的一張牌。也因此，聖杯王后在每日的塔羅抽牌裡面，它毫無疑問是個「可以讓今天引發一段省思」的一張牌。並且，從結果來看，今天的確讓我得到了很多的省思，因為今天我又再去找了一次準提佛母問事（第二次去了）。準提佛母的詳情可以看這篇問事心得。
簡單來說，佛母給了我很多有用的資訊：下一次的桃花可能會在之後的半年出現、對方大機率獨生女且家境不錯、工作上基本沒什麼問題，照著自己想要走的方向去走就好 &amp;hellip;相較於第一次的問事，這次幾乎都是比較正面的回覆，可能跟心境有著很大很大的關係吧？距離上次（去年 6 月底）過了一年又多一點，整個人的確看開也愜意了許多。
想當然的，這些&amp;hellip;情報(?) 也讓我有了很多迴響或反思，第一是「心境真的能夠改變身邊的事情。」相由心生、境隨心轉至少對於目前的我來說有了初步的驗證，因此在之後套用一些吸引力法則的情況的時候，應該可以更加順利。第二個是「工作不會有什麼問題。」雖然佛母沒有說我工作之後會好還是壞？但從推敲出來的資訊我會給出「沒什麼問題」的結論，算是給了畢業生的我一顆很大的定心丸。最後是「感情在最近的時間有機會」這點蠻讓我意外的？除了反思可能會怎麼遇到之外，也讓我開始對感情有了一些新的期待。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230825/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230825/</guid>
      <description>2023/08/25 每日一翻#抽牌：權杖三（逆）#解析：#這是記錄每日抽牌裡，第 2 次抽到權杖三，第一次是在 8/20 出現的。那因為是同樣的牌，因此在關鍵字或牌意是一樣的，也就是夢想、小期望、小成就、藍圖、實現目標、或者是初步達成&amp;hellip;等。逆位的權杖三則是可以理解成『目標沒有達成』『藍圖構築的方式不對』或者是『重新實現、重新起步』&amp;hellip;等等之類的。
套用在今天的狀況的話，比較像是「重寫第 n 次的小說構想」這件事情吧？今天算是全部看完了 0 號手稿的所有 Youtube 影片，雖然還沒有正式開始按照影片中的內容實踐，但倒是先直接寫了滿滿的筆記，說實在也從中學到了很多。算是有符合逆位的權杖三那種「打掉原本的目標或期待」的那種感覺。
此外，今天很有感的部分還有一點：就是「黃底的牌背在大多數的情況下，即便是逆位了，也可以有不錯的結果」這件事情。就像是今天的權杖三雖然是逆位的，但整體而言並沒有給我「好難過喔&amp;hellip;」的感覺，反倒有一種「哦哇，雖然整體而言算是阻礙，但另一方面震得很有進步的感覺」也就是從失敗中成長的那種意味吧？蠻有趣的～</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230826/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230826/</guid>
      <description>2023/08/26 每日一翻#抽牌：權杖騎士（逆）#解析：#宮廷牌中的【權杖騎士】元素屬【火之火】，算是所有小牌裡面最為動態、最有行動力、最熱情、最強烈、或者是最積極的一張牌，基本的含義可以從中延伸成「前進」「行動」「衝突」「勇往直前」或者是「樂觀」「向上」&amp;hellip;等訊息在裡面。那今天的牌因為是逆位的，因此可以從相反、過度、或不足來做解釋，至於是哪種解釋嘛&amp;hellip;今天的狀況應該是相反（或不足）。
主要可以體現逆位權杖騎士的地方有幾點：第 1 點是「今天沒有做出什麼實質上的進展。」像是推進小說進度、推進算命的盈利模式和授課 ppt、或者閱讀接收新知識、或看其他可以讓我感到『進步』的東西&amp;hellip;等。但不代表今天的我過得很頹廢，因為今天有陪外婆吃飯、陪我妹去中友又淋雨在她回家、還有重回 discord 跟朋友聊天 &amp;hellip;等，算頗有收穫的。
第 2 點是「職涯進度沒有進展」這件事情。這件事算是原本心裡就有底了，今天中友的職涯博覽會大多是製造業的專場，科技業的職缺大多也以製造為主（像是製程、CNC 切割、或其他跟電子零件相關的）。純軟體的工作&amp;hellip;無論是 AI、前後端、移動裝置、或者是什麼系統類的幾乎少之又少，更不用說我朋友的「駭客資安攻防」的工作了。
也因此，今天的逆騎士比較像是「沒有足以讓自己激起波瀾、或者是帶有那種『往想要達成』的動力的事情發生」的感覺，整體而言我覺得也算是至少 70% 左右有 match，但可以的話，希望明天（和之後）還是穩定讓自己「有進度」一點會比較好。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230907/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/fortune_telling/tarot/daily_log/20230907/</guid>
      <description>2023/09/07 每日一翻#抽牌：隱者（正）#解析：#正位的隱者，代表找尋、徬徨、迷茫、濃霧、沒有方向性、靜止、或者是獨自一人。此外，因為【隱者】為大牌的一員，因此它也可以代表在心靈上有著比較深刻的體悟。那套用在今天的感想的話&amp;hellip; 無論是哪一種解釋，大概都有 8-9 成左右的準確度，因此整體而言算是非常、非常準確的一張每日塔羅。也因為如此，才給了自從記事以來的第一次滿分 5/5 顆星，也是我休息了這麼久的每日記事之後，覺得一定要寫出來的一天。
今天比較大的事情有幾項：第一個是我格式化了學校的電腦，算是更近一步地拉遠了我跟碩士生活的距離（也就是更脫離了研究室一點點）。這點在隱者上並沒有什麼特別突出的 match 或者是連結，因此它只能算是一個比較小的事件。第二個是我格式化了自己的電腦，因為原本筆電裡面的內容有點雜亂，一時間也不知道要怎麼整理，所以就選擇了最簡單（但也最暴力）的「整理」方法，但這也還好，沒有到特別 match。
最後一件大事，也是促成我現在即便快三點了（02:55），但還坐在電腦前面的原因：我初步理解了「spring」「spring framework」和「spring boot」三者之間的關聯，也對於「java」「javac」「jar」「javap」&amp;hellip;等不同的命令列指令有了更深的理解，還對於 Java 中的「import」「package」有了一進一步的認識。這也是今天我覺得會開出【隱者】牌的原因。簡單來說，我重新體會了一次 打程式超級無敵燒腦 和 debug 是一個超痛苦的過程 這兩件事情。
靠著自己的努力，重新抓 spring 的 jar、重新寫 spring framework 的程式、不用任何套件（STS - Spring Tool Suite），找不到任何直接的幫助，幾乎是靠著自己的努力重現出了最基本的 spring 語法，從 0 開始理解 jar, javac, javap, class 檔和 jar 檔的用途與區別，然後再花一點時間理解 package 和 import 的細節用法，再被 javac 中的 -cp 拖了近 1 小時的時間&amp;hellip; 最後成功執行，比起成就感，更多的是「終於成功了」的如釋重負的感覺。
真的很有隱者那種「在迷霧中前進」「找不到方向」「獨自一個人行走著」的那種徬徨、不確定、孤單、但堅定、持續努力、不放棄 &amp;hellip; 的那種感覺。也很高興今天的隱者是正位的（也代表著前進的路雖然看不清，但大致上的路徑都是對的），如果是逆位&amp;hellip; 可能現在的我還卡在某一個 bug 裡面吧&amp;hellip; 想想就覺得好累。但也很高興最後有成功跑出東西來了，明天就繼續之前看的教學影片，繼續往前走吧。</description>
    </item>
    
    <item>
      <title>JAVA 相關的面試題</title>
      <link>https://fonu195713.github.io/docs/computer_science/java/job_interview_questions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/computer_science/java/job_interview_questions/</guid>
      <description>JAVA 相關的面試題#mySQL 使用 innoDB 引擎，请简述 mySQL 索引的最左前缀如何优化 order by 语句 參考連結 參考連結 </description>
    </item>
    
    <item>
      <title>格雷瑪·貝魯貝斯</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/note/character/grema_berubes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/note/character/grema_berubes/</guid>
      <description>格雷瑪·貝魯貝斯#一個只習慣【失去】而不習慣【擁有】的主角#ChatGPT 的靈感發想：
14 歲的格雷瑪，雖然年紀尚幼，卻已經背負著遠比同齡人沉重的心靈。在他的短暫人生中，三次失去了親人，每一次失去都像是一道不可磨滅的烙印，深深刻在他的心靈深處。第一次失去時，他學會了面對傷痛，儘管那時的他還不太理解。第二次失去時，他學會了如何堅強地活下去，即便心碎成千上萬片。第三次失去時，他學會了如何將記憶轉化為堅定的信念，讓親人們的存在在他心中永恆。這些失去讓格雷瑪變得成熟而內斂，他從不怨恨命運的不公，反而以堅毅的意志面對每一個挑戰。他的眼神透露出一種超越年齡的沉穩，他的笑容蘊含著對生命的深刻理解。格雷瑪的內心，早已經經歷過太多的風霜，但這也使他更加堅韌，更加珍惜每一個瞬間。他或許失去了太多，但在這個痛與喜並存的世界裡，他卻得到了超越年齡的心靈成熟度。
在 14 歲的格雷瑪身上，三次的別離帶來了一種超越年齡的心靈成熟。他的眼神中蘊含著早熟的智慧，仿佛已經歷過無數風雨，卻依然能在困境中找到出路。格雷瑪的微笑不再是純真的，而是一種蘊藏著生命歷程的深邃笑容。這些不幸的經歷塑造了格雷瑪的性格，他變得內斂而堅強，學會以平和的心態面對生活的挑戰。他的內心宛如一座堅固的堡壘，曾經的痛苦已被轉化為他奮鬥的動力。格雷瑪的存在，像是一束明亮的光芒，在黑暗中指引著他自己和周遭的人。無論是哪一次的失去，格雷瑪都學會了珍惜眼前的一切。他的眼眸中透露出對生命的深刻理解，他知道幸福和悲傷同時存在於這個世界，而他選擇用他的堅強和智慧去迎接一切。格雷瑪，這個14歲的靈魂，早已超越了他的年齡，成為一個真正的生命勇者。
特點#在他的短暫人生中，經歷了三次失去了親人的時刻
第一次失去時，他學會了面對傷痛，儘管那時的他還不太理解。 第二次失去時，他學會了如何堅強地活下去，即便心碎成千上萬片。 第三次失去時，他學會了如何將記憶轉化為堅定的信念，讓親人們的存在在他心中永恆。 性格描述#他是個內向的青年，雖然年紀尚幼，卻已經背負著遠比同齡人沉重的心靈。在他的短暫人生中，三次失去了親人，每一次失去都像是一道不可磨滅的烙印，深深刻在他的心靈深處。第一次失去時，他學會了面對傷痛，儘管那時的他還不太理解。第二次失去時，他學會了如何堅強地活下去，即便心碎成千上萬片。第三次失去時，他學會了如何將記憶轉化為堅定的信念，讓親人們的存在在他心中永恆。
在大部分的時候，總是默默地沉浸在自己的世界當中。他以冷靜的邏輯，思考這個世界所運行的規則，雖然總是笑臉迎人，但實則不喜歡將自己真實的情緒外露。他善於細查事物的本質，卻對於事物「為何會這樣」與「之後會怎樣」沒有過多的思考。他並不渴望改變整個世界，但他的內心深處卻渴望尋求是什麼原因造就了他需要經歷如此的苦難。
他的臥房總是整潔、樸素，每一本書、每一張紙都有其特定的位置，這個安靜的角落是他思考和反思的場所，也是他與世界交流的窗口。而他的外表同樣延續了他的內向特質，簡樸的服飾和整潔的容顏，彰顯出他的內心平和與不追求過度耀眼的態度。他對自己的外表要求不高，只需符合通俗的審美標準，並不追求過度的華麗，甚至有時帶著一絲樸素。他深深地理解著人性的複雜性，也因此，他的內向並非封閉，而是一種對於內心的自我探索。他知道每一次的失去都是一次成長，而他的邏輯思維讓他更能從中學習。
他從不尋求驚世駭俗的變革，但對於生命的意義和他所經歷的一切，他內心深處一直在尋找著那個原因。</description>
    </item>
    
    <item>
      <title>記帳 2023/08</title>
      <link>https://fonu195713.github.io/docs/daily_life/nodes/finance/fin_202308/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/daily_life/nodes/finance/fin_202308/</guid>
      <description>記帳 2023/08#各方面金流
台幣活存：4098 台股股票淨值：19278 借貸狀況： 借出共 143,500 + 50,000 貸款數字目前為 0 保險： 儲蓄型保單收到了 2 元的回饋 備註
因為信用卡還沒開辦的原因，所以個人的信用評分應該還算是很低很低。加上現在還是處在比較高利的情況，所以我不打算去做一些跟信貸有關的相關操作。因此貸款的數字是 0。另外借出約 20 萬左右的金額，主要是由兩個人所組成，預計會在近 1-2 年內回收完畢吧？如果到時候還沒回收的話，可能就會採取比較激進一點的行動方針。
活存的部分 &amp;hellip; 只能說相當可怕啦。下個月的花錢必須要非常拮据與謹慎，不然一不小心就會直接死給大家看了。台股的淨值大約是 20k，它是我 4 個月定期應額 006208 的小小成果，基本上台股的部分不會有太多的更動，它就會是一個每個月固定 5000, 5000 投入的狀況。不打算做一點短線的投機，次要原因是目前沒有甚麼了解的標的在低檔位的股價，主要原因是沒有多餘的閒錢 :)))
大概是這樣，目前看來沒什麼大問題，整體而言的評分是 58/100，不及格的部分是活存水位過低、沒有緊急預備金，剩下的&amp;hellip;基本上沒有大問題，但這　1-2　個月要好好調整自己的用錢習慣就是（畢竟已經沒有研究室的研究補貼ㄌ）。</description>
    </item>
    
    <item>
      <title>阿洛蕾·佴瑠斯·貝魯貝斯</title>
      <link>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/note/character/alorei_nairus_berubes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fonu195713.github.io/docs/creative_writing/novel/workspace/faith/note/character/alorei_nairus_berubes/</guid>
      <description>阿洛蕾·佴瑠斯·貝魯貝斯#ChatGPT 的靈感發想：
1 阿洛蕾·佴瑠斯·貝魯貝斯，是一位精靈女性，已經度過了約 320 個春秋，相當於人類年齡的 30 至 35 歲左右。她的性格獨具特色，充滿了對自由的渴望，總是隨心所欲，來去自如。作為家族中的長女，她一直被灌輸著需要繼承家業的使命，但她對這個命運感到不甘心。阿洛蕾不願意接受束縛，她更傾向於自己選擇自己的道路，因此她經常逃避家庭的期望和責任，探索世界的每個角落，尋找屬於她自己的冒險和機會。這位精靈女性以她勇敢的心靈和對自由的無限追求而聞名，她的故事充滿了挑戰傳統和尋找自我身份的元素，她堅信自己可以找到一條完全屬於她自己的道路。
2 阿洛蕾·佴瑠斯·貝魯貝斯，這位精靈女王的故事更顯立體，她早年一直逃避著繼承家業的命運，總是在探尋自己所渴望的自由和冒險。她經歷過無數次的逃避，不想被束縛於家族的期望，更不願面對那個她不願承擔的真相。
然而，在一次探險中，她不得不面對這個真相，這是關於世界的秘密，一個可以改變整個大陸的重要發現。儘管她逃避了許多年，但當她發現這個真相時，她最終接受了宿命，因為她知道她是唯一能夠傳遞這個信息的人。她理解她的使命遠比她個人的渴望重要，因此她決定將這個真相託付給一名年輕的人族少年。
阿洛蕾的生命走到盡頭時，她已經接受了自己的宿命，她成為了一位既逃避又接受的精靈女王，最終將世界的真相留給了那名少年，希望他能夠承擔起這個沉重的責任，將真相傳達給整個大陸，改變世界的未來。阿洛蕾的故事展現了她的成長和轉變，以及她對家族和世界的責任感，讓她成為一位傳奇的女王。
3 阿洛蕾·佴瑠斯·貝魯貝斯，是那個家族中的特殊存在，生於四個兄弟姐妹之中的第三位，唯一的女性。她的命運從出生就注定與魔法緊密相關，擁有驚人的魔力資質，對於魔法的運用、理解、概念、知識都超越同齡人。她的精緻五官、纖細手指和難得一見的白色長髮為她賦予了一種神秘而美麗的外表。
原本，阿洛蕾被視為家族的未來接班人，但她心中的叛逆和對自由的渴望驅使她離開了家族的束縛。她選擇了冒險者的生活，成為一位遠近馳名的英雄。然而，她的大哥也加入了這個冒險者的行列，試圖證明自己的實力，卻在一次冒險中不幸喪命。在那次的冒險中，阿洛蕾同樣發生了劇變，也意外得知了一些世界的真相。
面對這些真相，她選擇逃避現實，隱居在一個偏僻的鄉村李，遠離家族、遠離冒險者、和遠離世界。在那裡，她扶養了一名人族少年，將自己的知識和智慧傳承給他。最終，她生命的最後時刻，因為一些想法上的改變，她決定將那些關於真相的秘密托付給了這位少年，希望他能夠繼續她未完成的使命。
角色歷程#四個孩子裡面的第三位孩子，同時是唯一的一個女生 擁有天賦異稟的魔力天分，對於魔力的操作、理解、概念、知識都非常濃厚 擁有精緻的五官、纖細的手指、以及少見的白色長髮 為原定的家族接班人 因其叛逆的個性、嚮往自由，因而逃離家族 後來成為一位遠近馳名的冒險者 大哥後來成為家族的接班人，同時為了證明自己的實力，也成為了一名冒險者 大哥後來於一次意外的冒險中戰死 在該次的意外，也讓阿洛蕾意外得知部分世界的真相 為了逃避真相，阿洛雷選擇隱居在偏僻的鄉村 扶養了一名人族少年 生命的最後，她將「真相」託付給該少年 特點#一生都在不斷地逃避，但在最後選擇接受她的宿命 第一次逃避，是逃避家族的業 第二次逃避，是逃避世界的業 第三次，她不再逃避，選擇了面對這個業 </description>
    </item>
    
  </channel>
</rss>
