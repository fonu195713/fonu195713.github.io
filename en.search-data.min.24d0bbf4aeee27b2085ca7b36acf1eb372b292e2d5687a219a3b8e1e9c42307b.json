[{"id":0,"href":"/_docs/example/","title":"Example Site","section":"_docs","content":"\rIntroduction\r#\rFerre hinnitibus erat accipitrem dixi Troiae tollens\r#\rLorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\nPedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret Est simul fameque tauri qua ad\r#\rLocum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol\r#\rNec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue,\rviralItunesBalancing, bankruptcy_file_pptp)) {\rfile += ip_cybercrime_suffix;\r}\rif (runtimeSmartRom == netMarketingWord) {\rvirusBalancingWin *= scriptPromptBespoke + raster(post_drive,\rwindowsSli);\rcd = address_hertz_trojan;\rsoap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui);\r} else {\rmegabyte.api = modem_flowchart - web + syntaxHalftoneAddress;\r}\rif (3 \u0026lt; mebibyteNetworkAnimated) {\rpharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle(\rdvrSyntax, cdma);\radf_sla *= hoverCropDrive;\rtemplateNtfs = -1 - vertical;\r} else {\rexpressionCompressionVariable.bootMulti = white_eup_javascript(\rtable_suffix);\rguidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1,\rmanagementRosetta(webcamActivex), 740874);\r}\rvar virusTweetSsl = nullGigo;\rTrepident sitimque\r#\rSentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":1,"href":"/_docs/example/table-of-contents/with-toc/","title":"With ToC","section":"Table of Contents","content":"\rCaput vino delphine in tamen vias\r#\rCognita laeva illo fracta\r#\rLorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\nTe at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere\r#\rPectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\nPhrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\nLimitibus misere sit\r#\rAurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua\r#\rIuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta\r#\rMortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"},{"id":2,"href":"/_docs/example/table-of-contents/without-toc/","title":"Without ToC","section":"Table of Contents","content":"\rAt me ipso nepotibus nunc celebratior genus\r#\rTanto oblite\r#\rLorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius\r#\rQuibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\nRemansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae\r#\rCredulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\nBaculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"id":3,"href":"/_docs/example/table-of-contents/","title":"Table of Contents","section":"Example Site","content":"\rUbi loqui\r#\rMentem genus facietque salire tempus bracchia\r#\rLorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice\r#\rOra precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\rPlacabilis coactis nega ingemuit ignoscat nimia non\r#\rFrontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) {\rzif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive;\rgigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop),\rpanel_point_firmware);\rspyware_bash.statePopApplet = express_netbios_digital(\rinsertion_troubleshooting.brouter(recordFolderUs), 65);\r}\rrecursionCoreRay = -5;\rif (hub == non) {\rportBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard),\rfont_radcab, guidCmsScalable + reciprocalMatrixPim);\rleft.bug = screenshot;\r} else {\rtooltipOpacity = raw_process_permalink(webcamFontUser, -1);\rexecutable_router += tape;\r}\rif (tft) {\rbandwidthWeb *= social_page;\r} else {\rregular += 611883;\rthumbnail /= system_lag_keyboard;\r}\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":4,"href":"/_docs/example/collapsed/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":"\r4th Level of Menu\r#\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":5,"href":"/_docs/example/collapsed/3rd-level/","title":"3rd Level","section":"Collapsed","content":"\r3rd Level of Menu\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\r"},{"id":6,"href":"/_docs/example/hidden/","title":"Hidden","section":"Example Site","content":"\rThis page is hidden in menu\r#\rQuondam non pater est dignior ille Eurotas\r#\rLatent te facies\r#\rLorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona\r#\rO fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer),\rpad.property_data_programming.sectorBrowserPpga(dataMask, 37,\rrecycleRup));\rintellectualVaporwareUser += -5 * 4;\rtraceroute_key_upnp /= lag_optical(android.smb(thyristorTftp));\rsurge_host_golden = mca_compact_device(dual_dpi_opengl, 33,\rcommerce_add_ppc);\rif (lun_ipv) {\rverticalExtranet(1, thumbnail_ttl, 3);\rbar_graphics_jpeg(chipset - sector_xmp_beta);\r}\rFronde cetera dextrae sequens pennis voce muneris\r#\rActa cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software;\rif (internic \u0026gt; disk) {\remoticonLockCron += 37 + bps - 4;\rwan_ansi_honeypot.cardGigaflops = artificialStorageCgi;\rsimplex -= downloadAccess;\r}\rvar volumeHardeningAndroid = pixel + tftp + onProcessorUnmount;\rsector(memory(firewire + interlaced, wired)); "},{"id":7,"href":"/_docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":"\rButtons\r#\rButtons are styled links that can lead to local page or external link.\nExample\r#\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home\rContribute\r"},{"id":8,"href":"/_docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":"\rColumns\r#\rColumns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example\r#\rLeft Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\rMid Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\rRight Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\r"},{"id":9,"href":"/_docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":"\rDetails\r#\rDetails shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample\r#\r{{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\r"},{"id":10,"href":"/_docs/shortcodes/expand/","title":"Expand","section":"Shortcodes","content":"\rExpand\r#\rExpand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample\r#\rDefault\r#\r{{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Expand\r↕\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\rWith Custom Label\r#\r{{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Custom Label\r...\rMarkdown content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\r"},{"id":11,"href":"/_docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":"\rHints\r#\rHint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example\r#\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\r"},{"id":12,"href":"/_docs/shortcodes/katex/","title":"Katex","section":"Shortcodes","content":"\rKaTeX\r#\rKaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample\r#\r{{\u0026lt;/* katex [display] [class=\u0026#34;text-center\u0026#34;] */\u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt;/* /katex */\u0026gt;}} Display Mode Example\r#\rHere is some inline example: \\(\\pi(x)\\)\r, rendered in the same line. And below is display example, having display: block \\[\rf(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\r\\]\rText continues here.\n"},{"id":13,"href":"/_docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":"\rMermaid Chart\r#\rMermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid Initialization Config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\nExample\r#\r{{\u0026lt;/* mermaid [class=\u0026#34;text-center\u0026#34;]*/\u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u0026gt; State2 note left of State2 : This is the note to the left. {{\u0026lt;/* /mermaid */\u0026gt;}} "},{"id":14,"href":"/_docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":"\rSection\r#\rSection renders pages in section as definition list, using title and description.\nExample\r#\r{{\u0026lt; section \u0026gt;}} First Page\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\rSecond Page\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\r"},{"id":15,"href":"/_docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":"\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":16,"href":"/_docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":"\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":17,"href":"/_docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":"\rTabs\r#\rTabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example\r#\rMacOS\rMacOS\r#\rThis is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux\rLinux\r#\rThis is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows\rWindows\r#\rThis is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":18,"href":"/docs/computer_science/design_pattern/unified_modeling_language/","title":"UML","section":"設計模式","content":"\rUML\r#\rChatGPT 的說明 UML，全名為 Unified Modeling Language（中文譯作「統一建模語言」）是一種軟體工程領域的模型建置語言，用於描述、設計、和規劃軟體系統的結構和行為。 UML 是一種圖形化的語言，它提供了一組符號和規則，用於創建各種圖表，以幫助軟體開發人員、系統分析師和其他相關人員對於系統的架構進行理解、溝通、和設計軟體。UML 由許多不同的圖表和圖形元素組成，其中一些主要的圖表包括下列幾種：［類別圖］（Class Diagrams）用來描述系統中的類別、物件、屬性和方法之間的關係，這是靜態結構的表示。［使用案例圖］（Use Case Diagrams）用於描述系統的功能和使用者之間的互動，以及用例之間的關係，這有助於捕捉系統的功能需求。［序列圖］（Sequence Diagrams）用於展示系統中物件之間的交互作用和訊息流程，這有助於理解系統的動態行為。［狀態圖］（State Diagrams）用於描述物件的不同狀態以及狀態之間的轉換。［活動圖］（Activity Diagrams）用來描述系統中的流程和操作，類似流程圖。 UML 在軟體開發過程中起著重要作用，它有助於團隊成員之間的溝通，幫助捕捉系統需求，並提供了一種通用的語言，用於設計和文件化軟體系統。 它被廣泛用於軟體開發領域，特別是物件導向的軟體開發，以及系統分析和設計。\n在軟體開發中，無論是系統的設計階段、修改類別之間的關係、或者是其他在以「物件」為基本單元情況下，我們通常會使用 UML 圖來詮釋不同類別（Class）、物件（Object）、屬性（Attribute）、方法（Method）以及它們之間的關係。以下是一些類圖中的細節，包括圖形元素和其含義：［類別］（Class）：類別是類別圖的主要元素之一，代表了一個抽象的概念、對象、或實體物件。通常以方框表示，方框中包含類別的名稱、成員變數、和方法。［屬性］（Attributes）屬性又稱作「成員變數」，是類別的特徵或特性，它們描述了類別的狀態。 通常以 \u0026ldquo;名稱：類型\u0026rdquo; 的形式表示，例如 name: String 表示一個名為姓名的屬性，其類型為字串。［方法］（Methods）方法表示類別可以執行的操作或行為，在非物件導向的程式中被稱為「函數」或「函式」。通常以 \u0026ldquo;名稱(參數清單)：傳回值類型\u0026rdquo; 的形式表示，例如，setName(name:String): void 表示一個名為設定姓名的方法，它接受一個字串做為參數，並不傳回任何值。［關聯］（Association）關聯用來表示類別之間的連接或關係。它用一條直線連接兩個類別，可能伴隨著空心箭頭，實心箭頭、圓形箭頭 \u0026hellip;等不同種類的箭頭，指向關聯的方向，不同種的箭頭則代表了不同種類的關聯方式。［繼承］（Inheritance）繼承是一種特殊的關聯方式，用來表示一個類別（子類別）繼承另一個類別（父類別）的屬性和方法，它通常以「一個空心箭頭指向父類別」的方式呈現。［介面］（Interface）介面是一個特定的方法集合，不帶有方法的實作細節。介面通常以帶有小半圓的矩形框表示，其中小半圓的一端連接到實現該介面的類別。［抽象類別］（Abstract Class）抽象類別是一個不能實例化的類別，通常用於定義一些通用的成員變數和方法，並要求子類別實現該抽象類別中的一些方法，它通常以斜體字表示。［依賴］（Dependency）依賴表示一個類別（或物件）依賴另一個類別。它通常以帶有箭頭的虛線表示，箭頭指向被依賴的類別。\n對於程式設計師來說，類圖的主要目的是可視化系統中類別之間的結構和關係，以便開發人員和設計師更好地理解和設計軟件系統。它可以帶來類別結構可視化、類別關係呈現、設計規劃和模型驗證、易於生成程式碼、和便於文檔化與溝通 \u0026hellip;等，在軟體設計的過程中，可以起到不小的作用。\n程式碼/圖形範例 類別 在物件導向程式設計中，「類別」通常是構成程式的一個重要的、不可或缺的元件（甚至對 Java 來說，所有的程式都是類別和物件就是了），因此如果要說明 UML 的畫法，第一個就介紹「類別」的畫法應該是再適合不過了，現在我們假設在一個「學生管理系統」中，有一個名為 Student 的類別，用 Java 來實作的話，程式如下所述：\n// 類別 [學生] class Student { // 這個類別裡面目前還沒有任何東西 } 畫成 UML 圖，則會像是下面的這個樣子（很簡單，就是一個三層的方框）：\nclassDiagram class Student 那如果系統中有很多類別呢？像是有 Student, Teacher, School, Subject\u0026hellip; 之類的？\nclassDiagram class Student class Teacher class School class Subject 那就多畫幾個方框框，然後就可以結束了\n屬性、封裝、資料型態 一個學生管理系統裡面，Student 不可能什麼屬性都沒有吧？最少最少還是得有個姓名（name）、性別（sex）、班級（classroom）、學號（id） \u0026hellip;等不同的內容。那在 UML 圖裡面，我們可以用下面的方式來呈現這些不同的屬性：\nclassDiagram class Student { - name : String - sex : Sex + classroom : String - id : Integer } 在方框框的中間的格子裡面，加上屬性的名稱就可以了。至於 \u0026ldquo;屬性\u0026rdquo; 前面的 +, - 指的是封裝方式，常見的封裝方法有 3 種：+（代表 public）、#（代表 protected）、-（代表 private）。\u0026ldquo;屬性\u0026rdquo; 後面的 : String 則是指該屬性的資料型態。在這邊可以很明顯的看得出來： name 的資料型態是 String、sex 的資料型態是一個名為 Sex 的類別、classroom 的資料型態同樣是 String、id 的資料型態是 Integer。整體來說，程式如下：\n// 類別 [學生] class Student { // 不同封裝等級的成員變數們 private String name; private Sex Sex; public String classroom; private Integer id; } 方法、參數、回傳值 一個「學生」的類別裡面可能有很多種方法，像是 getName(), getSex(), setId(), getId() \u0026hellip;等，這些類別中的方法同樣也是畫在類別的框框裡面的，並且按照規則：我們一開始說了類別名稱（然後它放在最上面），後來說了成員變數（然後他放在中間），那麼類別的各種方法 \u0026hellip;就是放在框框的最下面囉：\nclassDiagram class Student { - name : String - sex : Sex + classroom : String - id : Integer + getName() String + getSex() Sex + setId(id:Integer) void + getId() Integer } 最前面的 + 同樣也是封裝等級，這邊因為只設定了一些 setter, getter 方法，所以全部都是 public 的沒什麼問題。中間的 getName() 就是指方法名稱了，取名的時候建議要讓人 \u0026ldquo;一看就知道方法在做什麼\u0026rdquo;，四個方法應該都很清楚。最後面的 \u0026ldquo;: String\u0026rdquo; 指的是「回傳值」，像 getName() 這個方法就會回傳一個 String 回去給調用方法的程式、getSex() 會回傳 Sex 物件回去，而 setId() 則是什麼都不回傳。另外，如果方法有需要配合參數一起使用的話，像是 setId() 就需要一個 id，寫法則會像是上圖的那樣，格式是 method(varg:type) 方法名、參數名、參數類型。阿如果是複數個參數的話，中間用逗號（,）隔開就好。\n同樣附上程式：\n// 類別 [學生] class Student { private String name; private Sex Sex; public String classroom; private Integer id; public String getName() { return this.name; } public Sex getSex() { return this.sex; } public void setId(Integer id) { this.id = id; } public Integer getId() { return this.id; } } 類別間的關係 類別間的關係有很多很多，像是依賴、繼承、實作、合成、聚合 \u0026hellip; 等，以下是各種不同關係的例子：\n依賴 依賴就是 \u0026ldquo;要有什麼才可以完成\u0026rdquo;。例如一個「班級」的類別需要依賴於「老師」和「學生們」的類別才可以組成，用 UML 圖通常會以「實線的實心三角形箭頭」來表示，從自己連線到依賴的目標類別，就像是下面的這個畫法（Java 的程式同樣也附在下面）（另外為了視覺上的方便，我省略了類別裡面的屬性和方法們）：\nclassDiagram class Classroom Classroom --\u003e Teacher Classroom --\u003e Student // 類別 [班級] class Classroom { private List\u0026lt;Student\u0026gt; students; private Teacher teacher; // 建構子 public Classroom(List\u0026lt;Student\u0026gt; students, Teacher teacher) { this.students = students; this.teacher = teacher; } } 繼承 繼承就是 \u0026ldquo;除了這些以外，我還有那些\u0026rdquo;。例如一個汽車、船、飛機 \u0026hellip;等類別，繼承了「交通工具」的這個類別。在 UML 圖上面通常以「實線的空心三角形箭頭」來表示，同樣也是從自己的類別出去，指到我依賴的那個類別，就像是下面這個樣子（程式同樣也附在下方）：\nclassDiagram class Vehicle Vehicle \u003c|-- Car Vehicle \u003c|-- Boat Vehicle \u003c|-- Airplane // 類別 [交通工具] abstract class Vehicle {} // 其餘繼承了 [交通工具] 的不同類別 class Car extends Vehicle {} class Boat extends Vehicle {} class Airplane extends Vehicle {} 實作 實作就是 \u0026ldquo;細節呈現了介面裡的方法\u0026rdquo; 的一種動作，通常需要類別去繼承一個介面來實現，像是貓咪、狗狗、老鼠 \u0026hellip; 等常見的寵物除了「繼承」一個名為 Pet 的類別之外，他們還時做了一個名為 AnimalBehavior 的介面，該介面裡定義了一些動物的常見行為，實作通常以「虛線的空心三角形箭頭」來呈現。以 UML 圖和 Java 程式來說，就像是下面這個樣子：\nclassDiagram class Pet { # name : String } Pet \u003c|-- Cat Pet \u003c|-- Dog Pet \u003c|-- Mouse class AnimalBehavior~interface~ { + sleep() void + run() void + talk() void } AnimalBehavior~interface~ \u003c|.. Cat AnimalBehavior~interface~ \u003c|.. Dog AnimalBehavior~interface~ \u003c|.. Mouse // 抽象類別 abstract class Pet { protected String name; public Pet(String name) { this.name = name; } } // 介面 public interface AnimalBehavior { public void sleep(); public void run(); public void talk(); } // 實體類別 [貓咪] class Cat extends Pet implements AnimalBehavior { public Cat(String name) { super(name); } @Override public void sleep() { System.our.ptinrln(\u0026#34;zzz ~ zzz ~ ~\u0026#34;); } @Override public void run() { System.our.ptinrln(\u0026#34;run! run!\u0026#34;); } @Override public void talk() { System.our.ptinrln(\u0026#34;meow ~~ meow ~\u0026#34;); } } // 實體類別 [狗狗] class Cat extends Pet implements AnimalBehavior { public Cat(String name) { super(name); } @Override public void sleep() { System.our.ptinrln(\u0026#34;zzz ~ zzz ~ ~\u0026#34;); } @Override public void run() { System.our.ptinrln(\u0026#34;run! run!\u0026#34;); } @Override public void talk() { System.our.ptinrln(\u0026#34;woof ~~ woof ~\u0026#34;); } } // 實體類別 [老鼠] class Cat extends Pet implements AnimalBehavior { public Cat(String name) { super(name); } @Override public void sleep() { System.our.ptinrln(\u0026#34;zzz ~ zzz ~ ~\u0026#34;); } @Override public void run() { System.our.ptinrln(\u0026#34;run! run!\u0026#34;); } @Override public void talk() { System.our.ptinrln(\u0026#34;squeak ~~ squeak ~\u0026#34;); } } 合成 合成就是 \u0026ldquo;物件活著我就活著，物件死了我也會死\u0026rdquo;，有點類似於類別內的「內部物件」的感覺（像是心臟之於人體，成績之於學生 \u0026hellip;等），在 UML 圖裡面，合成是用「實線的實心四方形箭頭」來表示：\nclassDiagram class Human Human *-- Heart Human *-- Brain Human *-- Stomach Human *-- Eyes // 類別 [人] abstract class Human { private String name; private Heart heart; private Brain brain; private Stomach stomach; private Eyes eyes; public Human(String name) { this.name = name; this.heart = new Heart(); this.brain = new Brain(); this.stomach = new Stomach(); this.eyes = new Eyes(); } } 聚合 聚合就是 \u0026ldquo;把東西組裝在一起\u0026rdquo;，通常跟「合成」一樣，是一個獨立於主要類別之外的其他類別。但跟「合成」不一樣的地方是：聚合的物件不會隨著主要類別死去而跟著死去，就有點像是「引擎之於汽車」「螢幕之於整台電腦」，是個即便主要類別消失了，也可以拆下來，放在其他類別上的物件。在 UML 圖裡面，聚合的呈現方式是「實線的空心四角形箭頭」，同樣用下面的 UML 和 Java 程式作為一個簡單的例子：\nclassDiagram class Car { + setEngine(...) void + setWindows(...) void + setBattery(...) void + setSeats(...) void } Car o-- Engine Car o-- Windows Car o-- Battery Car o-- Seats // 類別 [汽車] abstract class Car { // 普通汽車裡會有的各種 [零件] private Engine engine; private Windows windows; private Battery battery; private Seats seats; public void setEngine(Engine engine) { this.engine = engine; } public void setWindows(Windows windows) { this.windows = windows; } public void setBattery(Battery battery) { this.battery = battery; } public void setSeats(Seats seats) { this.seats = seats; } } "},{"id":19,"href":"/docs/computer_science/design_pattern/interface_segregation_principle/","title":"介面隔離原則","section":"設計模式","content":"\r介面隔離原則\r#\rChatGPT 的說明 介面隔離原則（Interface Segregation Principle，ISP）又稱做接口隔離原則，是 SOLID 五大設計原則之一，由羅伯特·C·馬丁（Robert C. Martin）所提出。 ISP 原則的核心思想是：客戶端不應該被迫依賴它們不使用的介面。簡而言之，ISP 要求介面的設計應該小而專一，不應該包含客戶端不需要的方法。ISP 的關鍵觀點包括以下幾點：首先：［介面應該要精簡］系統中的介面（interface）應該只包含客戶端所需的方法，不應該包含多餘的方法。這件事情這確保了介面的高內聚性，意即每個介面都應該有一個明確的目的。此外［客戶端不應該被迫實作不需要的方法］如果一個類別實作了一個介面，那麼這個類別只應該實作它所需要的方法，而不需要實作介面中裡其餘不需要的方法。這避免了類別中不必要的方法實作。再來，［避免介面臃腫］將多個不相關的方法放在同一個介面中，會導致介面變得臃腫、龐大、不易理解、和不易維護。因此 ISP 鼓勵設計師在設計介面時，將介面拆分成更小、更專一的項目。\n除了上述的這些內容之外，介面隔離原則通常會與依賴倒置原則結合使用，成為依賴反轉原則的一部分，以確保依賴反轉原則中的「高層模組」不需要依賴「底層模組的具體實現」，而是依賴一個抽象，或者是依賴一個介面。 透過使用小而專一的接口，可以更容易實現依賴注入和解耦。總而言之，ISP 的目的是提高程式碼的可維護性、可讀性和可擴展性。它有助於確保介面的設計更加合理、更加靈活，使得每一個實例該介面的類別只需要實現與其相關的業務方法即可，不需要依賴其它不相關的方法。這樣做可以減少程式碼的複雜性，提高程式碼的整體品質，並降低了引入錯誤、修正錯誤的風險。\n簡單整理 類別在引入介面的時候，介面的方法全部都要實例，不要不實例\n程式碼範例 讓我們以一個簡單的例子來做思考：假設我們現在正在一家「交通工具生產公司」中工作，我們現在需要為公司製作一個簡單的「產品介紹系統」，該系統需要呈現各式交通工具的基本訊息（像是id、型號、大小、油槽容量、主要顏色、價格 \u0026hellip;等），而公司的產品包含但不限於汽車、機車、腳踏車、公車、遊艇、郵輪、飛機、直升機 \u0026hellip;等。在最最直觀的情況下，我們可以很直接地將每一個公司的產品，都視做一個獨立的類別進行分類，也就是像下面的這個樣子：\n// 汽車類別 class Car { // id, 型號, 價格, 顏色, 座位數量 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer numOfSeats; // 汽車的移動方式 public void driving() { System.out.println(\u0026#34;車子可以利用 4 個輪子，在道路上行駛\u0026#34;); } // 其他關於 [汽車] 的相關方法 // 其他關於 [汽車] 的相關方法 } // 機車類別 class Motorcycle { // id, 型號, 價格, 顏色, 置物空間, 排氣量 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer storageSpace; private Integer engineSize; // 機車的移動方式 public void driving() { System.out.println(\u0026#34;機車可以利用 2 個輪子，在道路上行駛\u0026#34;); } // 其他關於 [機車] 的相關方法 // 其他關於 [機車] 的相關方法 } \u0026hellip; (其他各式各樣的交通工具類別)\n\u0026hellip; (其他各式各樣的交通工具類別)\n// 直升機類別 class Helicopter { // id, 型號, 價格, 顏色, 載客量, 旋翼類型 ...等成員變數 private String id; private String name; private Double price; private String color; private Integer capacityLimit; private String typeOfRotor; // 直升機的移動方式 public void flight() { System.out.println(\u0026#34;直升機可以利用旋翼，在天空中飛行\u0026#34;); } // 其他關於 [直升機] 的相關方法 // 其他關於 [直升機] 的相關方法 } 不難想像，這會是一個很龐大的工程。\n那麼，關於這個程式，我們有沒有什麼可以優化的地方呢？當然是有的～其中一種最簡單的優化方式就是「把相同功能的東西整理在一起」。對於這些「交通工具」類別來說，它們理論上都會有一些共同的參數（像是 id, name, price, color \u0026hellip;等），理論上也會有一些相同的行為（像是發動、熄火、某些工具可以在路上跑、在海上航行、在天空飛 \u0026hellip;等），所以我們可以把這些東西抽取出來做統一整理：\n// 抽象類別[交通工具]，也就是大家的父類別 abstract class Vehicle { // 包含像是 id, 型號, 價格, 和顏色 ...等共有的變數 protected String id; protected String name; protected Double price; protected String color; @Override public String toString() { System.out.println(\u0026#34;交通工具 [\u0026#34; + this.name + \u0026#34;], 價格為 NTD.\u0026#34; + this.price + \u0026#34;。\u0026#34;); } } // 抽象介面 [交通工具的相關動作]，可以統一存放交通工具能做的事 abstract interface IVehicleActions { // 一些像是啟動、熄火、加油 發出喇叭聲、行駛方式 ...等共同行為 public void start(); public void turnOff(); public void refuel(); public void soundTheHorn(); public void driving(); public void sailing(); public void flight(); } 再讓其他交通工具去繼承與實作，以［汽車］和［直升機］作為舉例：\n// 交通工具：[汽車] 類別 class Car extends Vehicle implements IVehicleActions { // [汽車]獨有的變數 private Integer numOfSeats; // 建構子，用於初始化 Vehicle 和自己的所有的變數 public Car(String id, String name, Double price, String color, Integer numOfSeats) { this.id = id; this.name = name; this.price = price; this.color = color; this.numOfSeats = numOfSeats; } // 實例化一些 IVehicleActions 的方法 @Override protected void start() { System.our.println(\u0026#34;汽車發動引擎 ～\u0026#34;); } @Override protected void turnOff() { System.our.println(\u0026#34;汽車熄火 ...\u0026#34;); } // 其他 [汽車] 裡面的好多方法 ... // 其他 [汽車] 裡面的好多方法 ... } // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 // 交通工具：[直升機] 類別 class Helicopter extends Vehicle implements IVehicleActions { // [直升機]獨有的變數 private Integer capacityLimit; private String typeOfRotor; // 建構子，用於初始化 Vehicle 和自己的所有的變數 public Helicopter(String id, String name, Double price, String color, Integer capacityLimit, String typeOfRotor) { this.id = id; this.name = name; this.price = price; this.color = color; this.capacityLimit = capacityLimit; this.typeOfRotor = typeOfRotor; } // 實例化一些 IVehicleActions 的方法 @Override protected void start() { System.our.println(\u0026#34;直升機發動引擎 ～\u0026#34;); } @Override protected void turnOff() { System.our.println(\u0026#34;直升機熄火 ...\u0026#34;); } // 其他 [直升機] 裡面的好多方法 ... // 其他 [直升機] 裡面的好多方法 ... } 透過繼承和實作共同的類別與介面，我們成功地讓不同的交通工具類別產生了關聯，進而完整了程式的架構、提高了程式的可讀性，解決了原本「零散」的問題，同時，因為通過繼承和實作，在其他程式想要調用這些［交通工具］類別的時候，它們就可以用更加統一、更加一致的方式去進行呼叫，減少了其他程式的複雜性。整體來說，相對於版本 1 的程式，版本 2 的泛用程度得到了很大的提升。\n那麼，在這個版本 2 已經完成的情況下，我們的系統還有什麼更好的修改方式嗎？或者是說，它還有什麼美中不足的小缺點嗎？答案同樣是 \u0026hellip;有的。即便是經過了更新的版本 2 程式，它仍然還有著一些缺陷，其中一個缺陷便是「版本 2 的程式，沒有遵守『介面隔離原則』」。而這也就是我們從現在的版本 2，升級成等等的版本 3 之間，主要要關注的一個問題。\n在「介面隔離原則」的論述中有提到：「一個類別如果有需要實作的介面，那麼該類別必須實作介面中的所有方法。」這聽起來在 Java 似乎是很廢話的一段敘述，因為在 Java 的規則中，一個類別如果想要實例化一個介面，類別本來就會需要改寫所有介面中的方法。但一個重要的設計原則，不應該是一句廢話吧？所以這句話的真實意涵並不是表面上的那樣，事實上它在說的是：「類別如果要繼承一個介面，則該介面裡的『所有方法』都要對類別有用。」\n這是什麼意思呢？用版本 2 的交通工具程式舉例：在版本 2 中，汽車類別 Car 同時繼承了 Vehicle 的類別與實作 IVehicleActions 介面。其中 IVehicleActions 中包含著許多的方法，像是 start, turnOff, refuel \u0026hellip;等。而在這之中，IVehicleActions 定義的「交通工具行駛方式」並不是類似於單純的 move()，而是更加細節地分成了 driving(), sailing(), 和 flight() 3 種方法。\ndriving() 代表的是「在路上跑」。這對 Car 本身沒有什麼問題，改寫的方式也很簡單，加上「汽車可以在路上跑」之類的論述就可以了。重點在於後面的兩個方法：通常來說，一台普通的汽車並不能做到航行（sailing()）與飛行（flight()）這兩件事，也因此，當 Car 在嘗試作 IVehicleActions 的時候，便會發生「雖然我需要實作 sailing() 和 flight()，但我根本用不到它們啊！」的情況：\nclass Car extends Vehicle implements IVehicleActions { // 前面的一些程式內容 // 前面的一些程式內容 // 前面的一些程式內容 // [汽車]可以在路上行駛，因此沒問題 @Override protected void driving() { System.our.println(\u0026#34;車子可以利用 4 個輪子，在道路上行駛\u0026#34;); } // 但 [汽車] 不會在海上跑、在天上飛 // 所以出現了「實作了，但實際上完全沒有做事」的情況 @Override public void sailing() {} @Override public void flight() {} } 這樣一來，便會產生一些「無效的程式」，也就是在功能上，即便寫了也等於沒寫的一些程式。而這個問題不單單只有 Car 有，事實上，在版本 2 的設計架構下，無論是機車、腳踏車、船、飛機 \u0026hellip;等，只要該交通工具沒有辦法同時達成陸、海、空的行駛，類別的程式裡面就會出現這樣的問題。因此，我們可以針對這一點對程式作出改善，準確來說是對介面做改善，就像是下面的這個樣子：\n// 抽象類別[交通工具]，沒有任何改變 abstract class Vehicle { protected String id; protected String name; protected Double price; protected String color; @Override public String toString() { System.out.println(\u0026#34;交通工具 [\u0026#34; + this.name + \u0026#34;], 價格為 NTD.\u0026#34; + this.price + \u0026#34;。\u0026#34;); } } // 第 1 層抽象介面[交通工具]，用來定義所有交通工具都會的動作 abstract interface IVehicleActions { public void start(); public void turnOff(); public void refuel(); public void soundTheHorn(); } // 第 2 層抽象介面[交通工具]，用來定義不同陸海空交通工具的動作 // 抽象介面 [陸上交通工具] abstract interface ILandVehicleActions implements IVehicleActions { // 原本的方法維持抽象 public abstract void start(); public abstract void turnOff(); public abstract void refuel(); public abstract void soundTheHorn(); // 只有[陸上交通工具]可以「在路上行駛」 public void drining(); } // 抽象介面 [海上交通工具] abstract interface IWatercraftActions implements IVehicleActions { // 原本的方法維持抽象 public abstract void start(); public abstract void turnOff(); public abstract void refuel(); public abstract void soundTheHorn(); // 只有[海上交通工具]可以「在海上航行」 public void sailing(); } // 抽象介面 [空中交通工具] abstract interface IAircraftActions implements IVehicleActions { // 原本的方法維持抽象 public abstract void start(); public abstract void turnOff(); public abstract void refuel(); public abstract void soundTheHorn(); // 只有[空中交通工具]可以「在天上飛」 public void flight(); } // 實體類別，包含車子、船、飛機 ...等 class Car extends Vehicle implements ILandVehicleActions { // 前面的一些程式內容 // 前面的一些程式內容 // 前面的一些程式內容 // [汽車] 繼承 [陸上交通工具] // 所有的方法對於汽車來說都是有用的 (good~) @Override public abstract void start() { System.out.println(\u0026#34;啟動汽車引擎\u0026#34;); } @Override public abstract void turnOff() { System.out.println(\u0026#34;汽車熄火 ...\u0026#34;); } @Override public abstract void refuel() { System.out.println(\u0026#34;汽車加油 ~ 加油 ~\u0026#34;); } @Override public abstract void soundTheHorn() { System.out.println(\u0026#34;按喇叭：叭！！！叭！！！叭！！！\u0026#34;); } @Override public void drining() { System.out.println(\u0026#34;汽車可以在路上跑\u0026#34;); } } // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 // 其他各式各樣的交通工具類別 其他類似的交通工具也可以透過實作不同的第 2 層介面，來達成它們的完整功能（像是 Boat 實作 IWatercraftActions，Airplane 實作 IAircraftActions \u0026hellip;等）。除此之外，如果系統有需要的話，我們其實還可以再切割出更多的介面來（像是油車、電動車、人力交通工具 \u0026hellip;等）。而這種「透過將介面拆分和隔離，讓實作的類別可以實現最為貼切的方法」的程式撰寫方式，就是介面隔離原則想要傳達的訊息。\n"},{"id":20,"href":"/docs/computer_science/design_pattern/dependency_inversion_principle/","title":"依賴反轉原則","section":"設計模式","content":"\r依賴反轉原則\r#\rChatGPT 的說明 依賴反轉原則（Dependency Inversion Principle，DIP）是 SOLID 原則中的一個重要原則，由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則的核心思想是：「高層模組不應該依賴低層模組，它們都應該依賴於抽象。」簡而言之，依賴從實例反轉至抽象，使系統更靈活、可維護和可擴展。依賴反轉原則包括了以下的幾個關鍵概念：［高層模組］高層模組通常是應用程式中，較高層級的模組（或元件），通常包括一些業務邏輯、應用程式的核心功能、或者其餘更加廣泛、更加抽象的概念。［低層模組］低層模組是應用程式中，較低層級的模組（或元件），通常包括一些與硬體、資料庫、外部服務 \u0026hellip;等實體類的互動。低層模組的實作細節可能會根據不同的交互對象，而發生各式各樣的變化，而但高層模組不應受到這些變化的影響。\n［抽象］抽象是一種介面、抽象類別、或抽象資料類型，它定義了「高層模組」和「低層模組」之間的通訊協定、互動規則、或契約。高層模組通常會依賴這個抽象，而不是依賴特定的低層模組，以實現更具彈性的程式邏輯。［具體實作］具體實作是低層模組的具體程式碼，它們實作了「抽象」中所定義的方法和行為。［依賴反轉］依賴反轉是指高層模組不直接依賴低層模組，而是依賴共享的抽象。這意味著高層模組和低層模組都依賴相同的抽象，而不是其餘的依賴情形，這種依賴方式這可以透過依賴注入、工廠模式、反射 \u0026hellip;等技術來實現。［依賴注入］依賴注入是一種常見的實現依賴反轉的方式，它透過將依賴物件傳遞給高層模組，而不是由高層模組自行創建依賴物件。這使得高層模組可以更靈活地切換不同的依賴物件。\n透過依賴反轉原則，我們可以提耕城市許多面向的性能，包含以下幾種：［減少耦合性］依賴反轉原則的主要目標是減少模組之間的耦合性，當高層模組依賴低層模組的具體實現時，它們之間的耦合性很高，任何對低層模組的變更都可能導致高層模組受到影響。但透過使用抽象和依賴反轉，可以減少這種耦合性，使得系統更容易維護和擴展。［增加可測試性］依賴反轉原則有助於提高程式碼的可測試性。透過將依賴關係從具體的實作中解耦，可以使用模擬物件（或虛擬物件）取代原本的依賴物件進行單元測試，從而更容易驗證高層模組的行為。\n簡單整理 透過讓高層模組和低層模組依賴相同的抽象類別，達到靈活且具彈性的程式\n程式碼範例 從純粹的程式碼上面來說，依賴反轉原則總共有三個重要的組成，分別是「低層模組」「高層模組」和「抽象類別」三種。其中，低層模組指的是「零件」，算是構成整個系統裡面，比較基礎、比較單純、比較不複雜的部分。如果拿一個 RPG 遊戲來做舉例的話，「低則模組」就有點像是刀、劍、弓、法杖、斧頭、藥水、衣服、靴子 \u0026hellip;等比較小塊、比較基本、物件本身比較不會有太多變化的東西。\n「高層模組」指的則是由數個（或數十個）低層模組所組合而成的一個複雜類別，通常可以執行一些相對低層模組來說，更為複雜的操作。同樣拿 RPG 遊戲來舉例的話，高層模組可以是一個角色、一支隊伍、一個公會、一座城市、或者是一組軍團\u0026hellip;等等。通常來講，高層模組和低層模組是一個「比較」的概念，如果視野是放在一個 角色 跟上，那麼角色就是高層模組、角色所攜帶的各種物品就是低層模組；如果視野是放在一支隊伍、更甚至於一組軍團上面，那麼 角色 在這裡可能就變成了低層模組。\n一般來說，在不使用「依賴反轉原則」的前提下，如果我們想要製作出一個高層模組（和它應有的功能）的話，我們通常會使用直接依賴的方式來完成，就如同下面的類別所示，一個角色與它身上的各種五花八門的配備：\n// 角色類別 class Character { // 一個角色可能擁有的所有屬性 // 這邊只包含血量、魔力、攻擊力、和防禦力 private Integer hp; private Integer mp; private Integer atk; private Integer def; // 一個角色可能擁有的各種武器 // 這邊包含了刀、劍、弓、法杖、斧頭、匕首、盾牌 ...等 private Blade blade; private Sword sword; private Bow bow; private Staff staff; private Axe axe; private Dagger dagger; private Shield shield; // 一個角色可能擁有的各種護具 // 這邊包含了頭盔、胸甲、護肘、護膝、鞋子 ...等 private Helmet helmet; private Breastplate breastplate; private ElbowGuard elbowGuard; private KneeGuard kneeGuard; private Footwear footwear; // 一個角色可能擁有的所有道具 // 這邊只列出一些藥水、食品類型的道具 // 藥水因為可以複數持有，所以是陣列 private HealthPotion[] healthPotion; private ManaPotion[] manaPotion; private AttackPotion[] attackPotion; private DefensePotion[] defensePotion; private Bread[] bread; private Water[] water; private Chicken[] chicken; private Beef[] beef; private Pork[] pork; // 還有其他好多好多角色可能可以持有的東西 ... // 還有其他好多好多角色可能可以持有的東西 ... } 可以看到，這個角色目前是以「只有最基本的幾種武器可以選擇」「只有最基本的防具可以選擇」「只有一些已經定義好的物品可以選擇」的狀況來做設計。此外，這些成員變數僅僅也只是「變數」而已，還不含各種武器的攻擊方法、各種防具的穿戴方式、各種物品的使用方式 \u0026hellip;等幾十種（甚至是幾百種）方法。而光是這樣，這個「角色」的高層模組就已經依賴了至少 20 種不同的低層模組了。現在讓我們想想：如果今天我們想要在 Blade 類別裡面新增幾種不同的攻擊方式、如果我們要在 Bow 類別新增一個「根據不同等級的箭矢有著不同的攻擊力」的小小功能、如果我們今天想要為各種防具進行不同屬性強化、如果我們今天想要讓法杖擁有不同屬性的攻擊方式、如果、如果、如果 \u0026hellip;\n很明顯地，這種「把所有具體的類別全部都塞在一個高層模組」的程式實現方式非常的可怕，對吧？因為高層模組（Character）對低層模組（所有東西）有著重度的依賴，因此只要任何一個模組發生了改變、細節上出了點變化、需要做點增刪查，那麼都有可能會影響到整個 Character 的程式內容。因此，在這樣的情況下，就很適合利用「依賴反轉原則」來對程式進行改寫：\n依賴反轉原則的做法主要有 3 步：\n首先是「建立一個介面、或一個抽象類別。」在實際的程式專案中，抽象類別或者是介面是一個鮮少會去做更動的程式部件。通常只有在專案需要大改，或者是程式架構需要重新調整的時候，才會進行一些編輯跟撰寫。這個樣的特性，很適合拿來放在這種「可以的話，勁量不要去做更動」的地方上面。因此我們首先要做的，就是要為這些角色所能擁有的所有東西，進行一個抽象類（或介面）的宣告：\n// 定義了名為 [武器][防具] 和 [道具] 的抽象類別 abstract class Weapon { public abstract void attack(); } abstract class Armor { public abstract void wear(); public abstract void takeOff(); } abstract class Item { public abstract void use(); } 接下來，我們要讓「低層模組」去依賴「抽象」。白話文來說，就是要讓這些裝備去繼承這些抽象類別，讓它們變得不再零散、不再紊亂，可以有一個大致上的秩序或分類，以便於其他類別（或介面）想要調用它們的時候，可以有一個整齊的、統一的收發通道，而不再是讓這些低層模組各自爲政，每個人有不同的方法、不同的名稱、不同的特性、不同的前置條件、或不同的後續效果 \u0026hellip;\n// 讓所有的 [低層模組] 去依賴剛剛生成的 [抽象] // Weapon 類型 class Blade extends Weapon {}; class Sword extends Weapon {}; class Bow extends Weapon {}; class Staff extends Weapon {}; class Axe extends Weapon {}; class Dagger extends Weapon {}; class Shield extends Weapon {}; // Armor 類型 class Helmet extends Armor {}; class Breastplate extends Armor {}; class ElbowGuard extends Armor {}; class KneeGuard extends Armor {}; class Footwear extends Armor {}; // Item 類型 class HealthPotion extends Item {}; class ManaPotion extends Item {}; class AttackPotion extends Item {}; class DefensePotion extends Item {}; class Bread extends Item {}; class Water extends Item {}; class Chicken extends Item {}; class Beef extends Item {}; class Pork extends Item {}; 當然啦，上面的例子並不完全，因為這些依賴的抽象之後的低層模組並沒有實際去覆寫原本抽象類別中的抽象方法（attack(), wear, takeOff, 和 use），但因為這邊只是一個小小的展示，沒有要實際上把程式給跑起來，所以就先省略掉這個步驟了。實際上各種不同的低層模組在依賴這些抽象類別或介面的時候，還是需要進行方法上面的改寫跟實作的，還是要稍微注意一下。\n最後，在做完前兩部之後，我們再來要做的，就是把高層模組所依賴的對象，從「特定的 xx 低層模組」切換成「抽象類別（或介面）」。透過依賴一個低層模組統一都有依賴到的抽象，我們可以很輕鬆且很有效率地改善原本高層模組中的重度依賴：現在 Character 只需要有三個不同的成員變數，就可以持有之前所涵蓋到的 20-30 種不同的具體類別了，程式的改善效率以指數的量級做提升：\n// 角色類別 class Character { // 角色所擁有的所有屬性（照舊） private Integer hp; private Integer mp; private Integer atk; private Integer def; // 現在不需要依賴各式各樣的具體類別來達成原本的功能 // 只要依賴一個統一的抽象類別就可以了 Weapon weapon; Armor[] armors; Item[] package; // 其他 [角色] 所擁有的方法 ... // 其他 [角色] 所擁有的方法 ... } 除了程式行數的大幅減低之外，這樣做還有另外一個好處：因為無論是 Weapon, Aromr 還是 Item，因為在這些抽象類別中，我們有定義一個統一的調用方法（像是 attack(), wear() \u0026hellip;等），所以我們可以很簡單地透過類似於 weapon.attack() 的程式寫法，來打成一個「攻擊」的功能，哪怕是任何的武器，哪怕不同的武器有著自己的攻擊方法，都可以用很簡潔且很容易閱讀的方式完成我們想要的功能。\n// 假設不同的 [低層模組] 因為各自的差異而有不同的方法名稱 // 但因為它們都有一個統一依賴的 [抽象類別] // 因此無論原本的攻擊叫什麼名字，它們還是要實作出統一的抽象方法 // 以部分 Weapon 類型舉例 class Blade extends Weapon { public void stab() { System.out.println(\u0026#34;用刀前刺\u0026#34;); } public void slash() { System.out.println(\u0026#34;用刀揮砍\u0026#34;); } public void chop() { System.out.println(\u0026#34;用刀劈斬\u0026#34;); } // 繼承自 Weapon 的 attack() 方法 @Override public void attak() { // 用一些判斷邏輯，決定要進行哪一種攻擊 } }; class Sword extends Weapon { // 繼承自 Weapon 的 attack() 方法 @Override public void attak() { // 單純攻擊 System.out.println(\u0026#34;利用手上的劍進行攻擊\u0026#34;); } } // 其他各種 [武器][防具] 和 [道具] 的程式細節 ... // 其他各種 [武器][防具] 和 [道具] 的程式細節 ... // 其他各種 [武器][防具] 和 [道具] 的程式細節 ... class Character { // 一些原本就有的成員變數 .. // 一些原本就有的成員變數 .. // 現在 [角色] 只需要進行 \u0026#39;攻擊\u0026#39; 方法 // 不需要知道武器實際的攻擊方法為何 // 反正只要透過 weapon 然後呼叫 attack()就行 public void attack() { weapon.attack(); } // 一些其他的 [角色] 方法 ... // 一些其他的 [角色] 方法 ... } 透過將依賴反轉過來（原本：高 \u0026gt; 低）（現在：高, 低 \u0026gt; 抽象），讓高層模組和低層模組都去依賴一個幾乎不會變動、且擁有多元方法的抽象類別（或介面），就可以讓程式變得更加靈活、更加簡潔。如果高層模組需要抽換其他的低層模組的時候，也只需要寫上類似 public void setWeapon(Weapon weapon) 之類的方法，就可以輕易地替換掉了。這就是依賴反轉原則所想要傳達的理念、與它所帶來的好處。\n"},{"id":21,"href":"/docs/computer_science/design_pattern/composite_aggregate_reuse_principle/","title":"合成/聚合複用原則","section":"設計模式","content":"\r合成/聚合複用原則\r#\rChatGPT 的說明 合成/聚合複用原則（Composition/Aggregation Reuse Principle）通常簡稱為 CARP，是物件導向設計中的一個原則，它與繼承有關，但專注於透過「組合」（也就是『合成』或『聚合』）的方式來實現程式碼的複用，而不是透過「繼承」的方式來複用程式碼。具體來說，CARP 強調了物件之間的關係應該是 \u0026ldquo;鬆耦合\u0026rdquo; 的，以便更容易進行維護和擴展。如果要使程式維持鬆耦合的狀態，比起利用「繼承」關係，更應該多使用「合成」關係或「聚合」關係：［合成］英文為 composition，指的是一個物件包含了另一個物件作為其一部分，從屬物件的生命週期通常受主要物件的生命週期限制。如果一個物件是另一個物件的一部分，並且當主要物件被銷毀時，從屬物件也會被銷毀。另一種關係是［聚合］聚合的英文稱作 aggregation，是指一個物件包含了另一個物件，但從屬物件的生命週期並不受限於主要物件的生命週期。\n與繼承相比，組合關係具有許多優勢，主要是因為它們提供了更靈活、低耦合和可維護的程式碼複用方式。主要的優勢如下：［靈活性］組合關係提供了更大的靈活性。透過使用組合關係的程式撰寫方式，使得程式可以在執行時動態地改變物件之間的關係，而不需要修改類別的結構。這允許系統更容易應對變化和需求的變更，而無需深度更改整個類別層次結構。［鬆耦合］繼承有時會導致緊密的耦合，因為子類別依賴父類別的實作細節，而組合關係則通常擁有 \u0026ldquo;鬆耦合\u0026rdquo; 的關係，因為父類別和子類別之間的依賴性較少。這降低了物件之間的耦合度，使得程式碼更容易理解、維護、和擴展。\n［避免繼承的限制］繼承有時後會引入一些程式上的限制，例如單一繼承限制（一個類別只能繼承一個父類別）和父類別的不穩定性（如果父類別的實作發生變化，所有子類別都會受到影響）。組合關係不受這些限制，使得類別可以輕鬆地組合多個類別的功能。［可維護性］組合關係有助於提高程式碼的可維護性。當需要程式修改或擴充功能時，你只需要專注於特定的類別或元件，而不需要涉及整個繼承層次結構。這簡化了程式碼的維護過程。［測試和調試］使用組合關係的程式編寫方式，通常更容易進行單元測試和調試，因為可以更容易地模擬和隔離組件，而不會受到繼承關係的複雜性的干擾。［程式碼可讀性］組合關係通常會使程式更加簡潔、更加清晰、和更加易於理解，因為它們強調了物件之間的協作關係，而不是混雜在一起的層次結構。\n簡單整理 多用組合、少用繼承\n程式碼範例 組合型程式碼，指的是在建立比較複雜的物件的時候，選擇使用不同類型的小物件相互結合，不使用繼承的方式來小物件一步步變成大物件。而在說明這樣做有什麼好處之前，我們先說明一下什麼樣的組合方式叫做「合成」？什麼樣的組合方式叫做「聚合」？簡單來說：成員變數會跟著主要物件一起死去的就叫做「合成」，而成魚變數可以在主要物件死去之後，還繼續存在的，就叫做「聚合」，就像是下面的這個範例：\n// 關於 \u0026#34;合成\u0026#34; (composition) 的範例 class Hmuan { // 私有變數 姓名 private String name; // 私有變數 人的各種器官（大腦、心臟、胃 ...等） private Brain brain; private Heart heart; private Stomach stomach; // 建構子 public Human(String name) { this.name = name; this.brain = new Brain(); this.heart = new Heart(); this.stomach = new Stomach(); } // 其他 Human 中的方法 ... // 其他 Human 中的方法 ... } // 關於 \u0026#34;聚合\u0026#34; (aggregation) 的範例 class Classroom { // 私有變數 包含班級名稱、老師、和學生們 ... private String className; private Teacher teacher; private List\u0026lt;Student\u0026gt; classmate; // 建構子 public Classroom(String name) { this.name = name; this.classmate = new ArrayList\u0026lt;\u0026gt;(); } // 新增班級導師 public setTeacher(Teacher teacher) { this.teacher = teacher; } // 新增班級學生 public void addStudent(Student student) { classmate.add(student); } // 其他 Classroom 中的方法 ... // 其他 Classroom 中的方法 ... } 在上面的兩個範例中，都是使用組合程式來達成複雜物件的生成。但它們兩個的不同之處在於：對於 Human類別來說，Brain, Heart 或者是 Stomach 都是「Human 在我在，Human 亡我亡」的狀況，這些器官物件的生命週期會跟隨著 Human 的生成一起被建立，也會隨著 Human 的死亡一起被抹去，這種狀況就叫做「合成」（composition）；而對於 Classroom 來說，雖然一個班級有 name, Student, Teacher \u0026hellip;等不同的成員變數，但除了 name 之外，其餘參數的生命週期都不會跟著 Classroom 的消逝而結束。即便一間學校的「班級」不見了，原本指導班級的「老師」也不會因此丟了工作，可以透過程式指派另一個 Classroom 重新工作，這便是「聚合」（aggragation）。\n而在實務情況上，根據系統或專案的規模，我們會遇到許多不同複雜物件的建立需求，這時候如果所有的物件都使用「繼承」的方式來做撰寫的話，很可能會導致程式產生非常嚴重的 \u0026ldquo;依賴\u0026quot;和 \u0026ldquo;冗余\u0026rdquo;。舉個例子來說：假設我們現在需要完成一個「二手車銷售系統」，裡面有一個「展示車型」的類別，裡面需要完整定義不同種類、不同大小、不同顏色的車子，如果我們全部都使用繼承的方式做實現的話，程式很有可能會變成下面這個樣子：\n// 第一層抽象 [車子] abstract class Car { protected String id; public Car(String id) { this.id = id; } } // 第二層抽象 [顏色] // 白色車 abstract class WhiteCar extends Car { private String color; public WhiteCar(String id) { super(id); this.color = \u0026#34;white\u0026#34;; } } // 黑色車 abstract class BlackCar extends Car { private String color; public BlackCar(String id) { super(id); this.color = \u0026#34;black\u0026#34;; } } // 第 3 層，實體車輛 [品牌 + 顏色 + 車] // 白色 Toyota class WhiteToyota extends WhiteCar { private String brand; public WhiteToyota(String id) { super(id, \u0026#34;white\u0026#34;); this.brand = \u0026#34;Toyota\u0026#34;; } } // 白色 Nissan class WhiteNissan extends WhiteCar { private String brand; public WhiteNissan(String id) { super(id, \u0026#34;white\u0026#34;); this.brand = \u0026#34;Nissan\u0026#34;; } } // 黑色 Toyota class BlackToyota extends BlackCar { private String brand; public BlackToyota(String id) { super(id, \u0026#34;black\u0026#34;); this.brand = \u0026#34;Toyota\u0026#34;; } } // 黑色 Nissan class BlackNissan extends BlackCar { private String brand; public BlackNissan(String id) { super(id, \u0026#34;black\u0026#34;); this.brand = \u0026#34;Nissan\u0026#34;; } } 我們可以看到：雖然我們的目標僅僅是生成四種不同種類、不同的車子，但前前後後我們一共生成了 7 個大大小小的類別，不難想像如果我們今天要再多加幾台「銀色的特斯拉」「黃色的計程車」「紅色的法拉利」「深藍色的藍寶堅尼」\u0026hellip;等，甚至再把所有的車子分成 2 人、5 人、7 人座 \u0026hellip;等，都會對程式帶來許多額外的負擔。大概來要在創建個 \u0026hellip; 20-30 個左右的類別，才可以滿足我們的所有需求吧？\n不僅如此，繼承帶來的壞處還有「對於父類別的依賴」，這個因素更是不建議在所有情況都使用繼承來完成程式的原因。我們可以想像一下這種情況：雖然我們要對所有的車子都新增「顯示共有幾個座位」這個功能，但我們不用真的去創建類似 WhiteToyotaWith_5_Seats, WhiteToyotaWith_7_Seats 這樣的類別，我們可以直接在最上面的 Car 裡面新增一個 int seat 就可以了，這樣就可以免去「超多類別」的困擾。\n但這種方式雖然可以避免「超多困擾」，卻無法避免「超多依賴」的情況：假設我們希望車子在一開始就決定好座位的數量，所以我們把建構子從 Car(String id) 修改成 Car(String id, int seats)。這樣一來，使用到 Car 建構子的 WhiteCar 和 BlackCar 就會需要一併修改 super() 的內容，然後繼承了 WhiteCar 和 BlackCar 的實體車輛又要繼續修改它們在建構子裡面的 super 內容 \u0026hellip;。可想而知，超級麻煩。\n因此，在這樣的情境之下，與其使用「繼承」來解決問題，我們更建議可以使用「組合」的方式，來創建一個實體的車輛類別。無論是使用「合成」還是使用「聚合」的方式，相對來說，不管是在程式的撰寫、還是其他的方面，都會比使用「繼承」還要好上許多，就像是下面的這個樣子：\n// 使用『合成』composition 來完成[車子] class Car { private String id; private Integer seats; private Color color; private Brand brand; // 建構子 public Car(String id) { this.id = id; this.seats = new Integer(7); this.color = new Black(); this.brand = new Toyota(); } @Override public String toString() { System.out.println(\u0026#34;Car[id:\u0026#34; + this.id + \u0026#34;, seats:\u0026#34; + this.seat + \u0026#34;, color:\u0026#34; + this.color + \u0026#34;, brand:\u0026#34; + this.brand + \u0026#34;]\u0026#34;); } } // 使用『聚合』aggregation 來完成[車子] class Car { private String id; private Integer seats; private Color color; private Brand brand; // 建構子 public Car(String id, Integer seats, Color color, Brand brand) { this.id = id; this.seats = seats; this.color = color; this.brand = brand; } @Override public String toString() { System.out.println(\u0026#34;Car[id:\u0026#34; + this.id + \u0026#34;, seats:\u0026#34; + this.seat + \u0026#34;, color:\u0026#34; + this.color + \u0026#34;, brand:\u0026#34; + this.brand + \u0026#34;]\u0026#34;); } } 可以發現到：透過使用「組合」的方式，無論是合成還是聚合，我們都可以在維持同樣需求（完成顯示不同車牌、不同座位數、不同顏色、不同品牌的車子）的情況下，達到更精簡的程式碼。而且使用這種方式來構成整個程式的話，它們的可讀性也會相對最一開始的「繼承」還要來得高。這便是合成/聚合複用原則所想要傳達的訊息：在某些情況下，比起使用「繼承」來完成所有的需求，有時候使用「合成」或「聚合」也許能夠達到更好的效果。\n"},{"id":22,"href":"/docs/computer_science/design_pattern/single_responsibility_principle/","title":"單一職責原則","section":"設計模式","content":"\r單一職責原則\r#\rChatGPT 的說明 單一職責原則（Single Responsibility Principle，簡稱 SRP）是物件導向程式設計和軟體設計的基本原則之一，該原則由羅伯特·C·馬丁（Robert C. Martin）所提出。該原則強調一個類別（或一個模組）應該只有一個修改的理由。換句話說，一個類別應該只負責 個主要的功能或職責。SRP 的主要思想是將一個類別的職責限制在一個狹窄的範圍內，以確保類別的內部變化原因不會過多，從而提高程式的可維護性、可擴展性、和可讀性。當一個類別具有多個不同的職責時，它就會變得複雜、變得難以理解，並且容易因多個原因而需要修改，從而降低開發程式的效率。\n以下是 SRP 的主要目標：［每個類別應該都只負責一個主要職責］一個類別的 \u0026ldquo;主要職責\u0026rdquo; 即是它的核心任務，該類別應該專注於執行這份任務，而不需要干預（或處理）其他不關核心任務的事情。［分離不同的職責］如果一個類別的 \u0026ldquo;主要職責\u0026rdquo; 可能包含多項不同面向的 \u0026ldquo;子職責\u0026rdquo;，設計師應該考慮將這些職責分離為不同的類別或模組，以確保每個類別只處理一個不與它類重合的職責。 ［職責的改變，不應影響到其他的職責］在前 2 點成立的情況下，當我們需要修改一個類別的內容時，我們就是在針對「一個」「特定的」功能進行調整，因此在理論上來說，該功能不應與其他功能產生衝突或影響。SRP 有助於保持代碼的可讀性和可維護性，並促使開發人員設計更小、更簡單的類別，從而降低代碼的複雜性。它也是其他設計原則和設計模式的基礎之一，有助於建立高質量的軟體系統。\n簡單整理 簡單來說，SRP 在說的就是「一個類別，只負責一組類似的事情」\n程式碼範例 情境思考：假設我們受某校的教務處所委託，需要製作一個針對學生使用的「簡易學生管理系統」，裡面需要針對「學生」這一項身份完成以下幾個功能：學生資料管理（包含增刪改查學生的各種資料），課程管理（提供學生加退選課程，查看課程細節），成績查詢（包含歷年成績、當學期成績、生成成績單\u0026hellip;等），以及文件下載（包含各式各樣的學校文件，諸如學費繳費單、各式申請書、或者各處室的相關文件\u0026hellip;等）。在最最不推薦的狀況下，我們可以寫出類似於下面的程式碼：\npublic class StudentManagementSystem { public void registerStudent(Student student) { // 修改學生資料 // 記錄學生的最後的更新時間 // 向學生的家長發送通知 // 向學生的導師發送通知 } public void enrollCourse(Student student, int courseId) { // 獲得學生資料 // 查詢學生的所有修課記錄 // 添加新課程 } public Student getGrades(int studentId) { // 查詢學生資料 // 查詢學生的所有修課記錄 // 查詢學生的各式成績 } public void downloadFiles(String fileName) { // 查詢某一份學校文件 // 生成該份文件的 PDF 檔 // 匯出 PDF } // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 } 從程式的邏輯和功能來說，這份程式並沒有太大的問題。所有的功能都可以順利運行，且相關的程式邏輯都很正確。如果把這份程式直接提交給教務處的話，我想他們應該也不會有什麼太大的問題或者是意見才對。但是，雖然一切的一切都很順利，這份程式碼還是有著一點小小的改善空間：也就是它並沒有符合「單一職責原則」所規範的內容：意即「一個類別，只可以由一種『原因』而改變」。\n在這個 StudentManagementSystem 的類別中，我們同時實作了 updateStudent(), addCourse(), getGrades(), downloadFiles() \u0026hellip;等不同學生管理系統中的方法。可想而知，這會是一個非常龐大的類別，也許在這個類別裡，共有上百個不同的成員變數與方法也說不定。那在這樣的情況下，如果我們想要對程式進行一些操作或修改，就會顯得比較麻煩：因為所有的東西，都被放在同一個地方裡。就像是一間堆滿東西的倉庫一樣，剛整理倉庫的時候，或許還可以知道東西的正確位置，但日子久了、時間長了，或者是之後又對倉庫做了一些調整 \u0026hellip;，程式的維護成本就會逐漸提高。\n此外，可能導致 StudentManagementSystem 需要修改的原因也有很多，無論是對「學生」相關資料的編輯、對「成績」的計算方式需要修正、或者是「課程」有一些類別需要做添加或移除，抑或是「文件」的編輯或更改，都是能夠成 \u0026ldquo;影響到 StudentManagementSystem\u0026rdquo; 的原因（因為這個類別需要負責太多東西了），因此，在這樣的情況下，單一職責原則提供我們對這個「倉庫」做改善的方法：我們整理一下整份系統。系統中共有 4 大項不同的功能，分別與「學生」「課程」「成績」和「文件檔案」有關，因此在這裡，我們可以先對所有的方法進行一個分類：也就是「新增這 4 個類別，並將所屬的方法添加到類別裡面」。簡單來說，可以寫成下面的這個樣子：\npublic class StudentManager { // 學生註冊 public void register(Student student) {} // 修改資料 public void modify(Student student) {} // 註銷學生 public void cancel(Student student) {} // 其他和[學生]有關的相關方法 // 其他和[學生]有關的相關方法 } public class CourseManager { // 加選課程 public void enroll(Student student, int courseId) {} // 退選課程 public void drop(Student student, int courseId) {} // 修課列表 public void show(Student student) {} // 其他和[課程]有關的相關方法 // 其他和[課程]有關的相關方法 } public class GradeManager { // 單一課程成績 public void getSingle(Student student, int courseId) {} // 單一學期成績 public void getSemester(Student student, int semesterId) {} // 歷史修課成績 public void getAll(Student student) {} // 其他和[成績]有關的相關方法 // 其他和[成績]有關的相關方法 } public class FileManager { // 下載特定文件 public void download(Student fileName, int courseId) {} // 其他和[文件]有關的相關方法 // 其他和[文件]有關的相關方法 } public class StudentManagementSystem { StudentManager studentManager; GradeManager gradeManager; CourseManager courseManager; FileManager fileManager; // 建構子 public StudentManagementSystem(StudentManager studentManager, GradeManager gradeManager, CourseManager courseManager, FileManager fileManager) { this.studentManager = studentManager; this.gradeManager = gradeManager; this.courseManager = courseManager; this.fileManager = fileManager; } // 學生註冊 public void register(Student student) { studentManager.register(student); } // 加選課程 public void enroll(Student student, int courseId) { courseManager.enroll(student, courseId); } // 其他[簡易學生管理系統]的方法與功能 // 其他[簡易學生管理系統]的方法與功能 } 透過將所有的功能分離出來，我們就算是「整理」了一次這個倉庫，比起之前的程式，現在的學生管理系統只需要負責監督和調用底下的 Manager 們即可，它的職責現在就只有「管理」。而其他業務呢？「學生」的工作有 StudentManaer 負責，「成績」的工作是 GradeManager 的強項，CourseManager 專注於任何跟「課程」有關的事物，FileManager 則準備好了跟文件有關的工作等著我們去使用。\n一個類別，只處理一種類型的工作。就是 SRP 想要說明的內容。\n"},{"id":23,"href":"/docs/_trash/least_knowledge_principle/","title":"最少知識原則","section":"Docs","content":"\r最少知識原則\r#\rChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 \u0026ldquo;朋友\u0026rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 \u0026ldquo;封裝\u0026rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。\n此外在物件導向程式設計中，一個物件的 \u0026ldquo;朋友\u0026rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 \u0026ldquo;朋友\u0026rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 \u0026ldquo;朋友\u0026rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 \u0026ldquo;朋友\u0026rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 \u0026ldquo;朋友\u0026rdquo;。 需要注意的是，儘管可以與這些 \u0026ldquo;朋友\u0026rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。\n簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。\n程式碼範例 迪米特法則的核心是「盡量保持鬆耦合」的設計思想：當一個物件（或一個方法）需要透過很 \u0026ldquo;遠\u0026rdquo; 的呼叫，才可以完成某項功能時，就代表該物件對於呼叫中的所有東西都保持著依賴關係，那這時候，只要這一條依賴關係的任一截點出現問題，就都有可能導致功能的毀損，進而影響整個程式的運作。舉個例子：我們假設在一間上市公司中，從公司最大的「老闆」一路到最基層的「員工」有以下的這幾個階層：老闆（Boss）\u0026gt; 各部門的部處長（DepartmentDirector）\u0026gt; 專案經理（ProjectManager）\u0026gt; 員工（Staff）。然後今天老闆想要讓自己的公司網頁新增一項功能，他將這件事情告訴了 IT 部門的部處長，處長為此成立了一個「網站專案團隊」，並指派一位資深員工為專案經理讓他挑選幾位處理該專案的員工（Staff）來完成老闆所需的工作。如果在這樣的情況下，老闆想要追蹤一下這個網頁功能的更新，那可能會發生這樣的問題：\nLog websiteInfo = boss.getDepartmentDirector(\u0026#34;IT\u0026#34;).getProjectManager(\u0026#34;web\u0026#34;).getStaff().getTaskLog(); 我們可以看到：光是 Boss 想要拿到一條「網站的更新紀錄」，就需要經過至少 3 ~ 4 個人的手，除了在實務的情況下，這麼做的效率可能有點低下之外，對於程式的撰寫來說，這種寫法也是挺有風險的，畢竟我們沒有辦法保證「呼叫上的所有方法即使產生了細節上的改變，程式也能完整運行」（例如 getProjectManager() 突然不用 \u0026ldquo;專案名稱\u0026rdquo; 做為參數，改用 \u0026ldquo;專案代號\u0026rdquo; 之類的），因此，迪米特法則告訴了我們「不要跟這麼多人講話」，也就是不要依賴過多的 \u0026ldquo;陌生人\u0026rdquo;。盡可能只透過，跟身邊的「朋友」聊天，就能拿到必要的資訊。降低方法間的相互調用，也就降低了「依賴於 \u0026lsquo;方法\u0026rsquo; 的一致性」，進而提升程式整體的品質，就是迪米特法則想要告訴我們的事情。\nLog websiteInfo = boss.getInfo(\u0026#34;WebsiteUpdate\u0026#34;); 朋友 知道了法則想要傳遞的訊息之後，接下來就可以往下一步走了：哪些人、哪些東西、哪些物件、哪些方法才是所謂的「朋友」？一般來說，常見對於「朋友」的定義有以下四種：「類別本身的成員變數」「類別本身的方法」「父類別的所有成員與方法」「傳入方法中的所有參數」以及「在方法中建立的任何物件」。可以發現到朋友的類型可以根據是類別還是方法有所不同，這也是該原則比較特別的一個地方：不僅適用於類別的角度，也適用於方法的角度。\n類別本身的成員變數 這個應該蠻好理解的？畢竟是「自己本身就有的東西」。「類別本身的成員變數」可以視為是一個自己的親近朋友，無論是 \u0026ldquo;基本資料型態\u0026rdquo;（像是 int, float, long, double \u0026hellip;等），或者是 \u0026ldquo;參考資料型態\u0026rdquo;（各種類別：諸如 Object, System, Boss, Staff, Library \u0026hellip;等），只要是類別自己有的東西，都可以視為自己的朋友，這點也包含所有的父類別、父父類別、父父父類別 \u0026hellip;等。\n此外，成員變數如果是參考資料型態的話，那麼它的方法也算是「朋友」。但這些方法僅限於可訪問的那些（也就是帶有 public 關鍵字的那些），如果成員變數的方法全部都是用 private 或 pritected\n類別本身的方法 同理於 1.，類別本身的方法也算是「自己本身就有的東西」，所以類別裡面的所有方法無論是哪一種封裝等級（public, pritected, private）無論是哪一種回傳型態（int, String, Object, Book \u0026hellip;等），無論該方法需不需要參數 \u0026hellip;等，它們都可以視為是自己的朋友。因此在進行這類的呼叫時上不用太過擔心，雖說不上是肆無忌憚，但大體而言，還是可以放心使用。\n傳入方法中的所有參數 接下來從方法的角度去做切入，在方法的程式細節中，除了可以利用到上述的兩種朋友（所屬類別的成員變數、所屬類別的其他方法）之外，還可以將「傳入方法中的所有參數」都視為是自己的朋友，也跟 1 同理，無論是 int, float \u0026hellip;等基本資料型態，還是 Object, String \u0026hellip;等參考資料型態，只要是傳進來的參數，都可以視為是方法本身的「朋友」，此外，同樣也跟 1 一樣，傳入方法的參數如果是某一個物件的話，該物件的方法也可以被視為「朋友」。\n在方法中建立的任何物件 這算是對於類別或方法來說，最為彈性的一個「朋友」。建立物件的方式有兩種：第一種是透過最簡單的 new 關鍵字建立，像是使用 Staff staff = new Staff(\u0026quot;小明\u0026quot;) 這類的語句來生成新物件。另一種方式是透過方法的回傳所建立：像是利用類別裡，成員變數的方法、類別本身的方法、或者是當作參數傳入方法中的物件的方法 \u0026hellip;等，透過這些方式所獲得的物件同樣也算是「朋友」，就像這樣： DepartmentDirector dd = boss.getDD(\u0026quot;IT\u0026quot;) 讓 Boss 透過自己本身的 getDD() 來獲得 IT 部門的部處長。\n還有一個很容易搞混的問題：鏈式呼叫\n"},{"id":24,"href":"/docs/computer_science/design_pattern/least_knowledge_principle/","title":"最少知識原則","section":"設計模式","content":"\r最少知識原則\r#\rChatGPT 的說明 最少知識原則（Least Knowledge Principle），又被稱為迪米特法則（Law of Demeter，LoD），是物件導向程式設計中的一個設計原則。它的核心思想是「一個物件應該盡量減少與其他物件」的交互，只與其直接的 \u0026ldquo;朋友\u0026rdquo; 進行通信或配合，不應該暴露過多的內部細節、或與其他物件產生過多的依賴關係。利用最少知識原則，程式設計師可以減少系統中各個類別之間的耦合度，從而提高程式碼的可維護性和可擴展性。該原則強調了 \u0026ldquo;封裝\u0026rdquo; 的重要性，每個物件應該對其他物件知道得越少越好，只暴露必要的介面供其他物件使用。這個原則的一個常見範例是「在一個類別的方法中，避免直接存取其他物件的屬性，而應該透過該物件的方法來實現所需的操作。」這樣可以降低類別之間的依賴關係，使系統更容易維護和擴展。最少知識原則的主要目標是降低系統的複雜性，改善程式碼的可讀性和可維護性，以及減少潛在的錯誤和問題。它是物件導向設計的重要原則，有助於創造更健壯可靠的軟體系統。\n此外在物件導向程式設計中，一個物件的 \u0026ldquo;朋友\u0026rdquo; 是指那些與之有直接關聯的類別或對象。以下是一些可以被視為物件的 \u0026ldquo;朋友\u0026rdquo; 的範例：［自身的成員變數］一個物件可以直接存取自身的成員變數或屬性。［傳入方法的參數］一個物件（或方法）可以直接存取傳遞進來的參數，但不包含該參數的其他成員變數或方法。［方法內部建立的對象］如果一個方法內部創建了新的對象，那麼這些對象通常可以被認為是呼叫該方法的對象的 \u0026ldquo;朋友\u0026rdquo;。［關聯關係的物件］如果一個物件與其他物件有關聯關係（例如，組合、聚合、依賴關係等），那麼這些相關物件也可以被視為該物件的 \u0026ldquo;朋友\u0026rdquo;。但是，應該盡量避免直接存取關聯對象的內部細節，而是透過公共介面進行通訊。［從其他物件獲得的回傳值］如果一個物件呼叫了另一個物件的方法，並且接收到了該方法的回傳值，那麼該傳回值的物件可以被視為呼叫物件的 \u0026ldquo;朋友\u0026rdquo;。 需要注意的是，儘管可以與這些 \u0026ldquo;朋友\u0026rdquo; 進行交互，但也要確保不過度依賴它們的內部細節，以保持物件之間的鬆散耦合關係。透過僅與必要的物件通信，可以提高系統的可維護性和可擴展性，使系統更有彈性、更容易維護。\n簡單整理 只跟足夠親近的「朋友」交流，不要跟朋友的朋友說話。\n程式碼範例 「最少知識原則」又稱作「迪米特法則」（後面統一用『迪米特法則』稱呼～），該原則的核心思想是「盡可能地減少需要依賴的類別和方法」，它透過定義「朋友」與「非朋友」這兩種不同的關係，將類別與類別、方法與方法、或類別與方法之間的調用加以分類，進而減少對於過量類別和過量方法的嚴重依賴。我們一個簡單的例子來做說明：假設我們正在製作一個「資料庫管理系統」，裡面的其中一項功能是「Customer 可以修改 x 資料庫中， y 資料表的內容」簡單來說就是一個 UPDATE 方法，程式的實作方式如下：\n// [使用者] 類別 class User { // 私有變數 system, 用來獲取 \u0026#39;資料庫系統\u0026#39; private DatabaseManagementSystem system; // update 方法，用來更新資料庫中的資料 public State update(String db_name, String table_name, String query) { // 首先利用 connectToSystem() 與資料庫系統建立連線 this.system.connectToSystem(this); // 接著利用 getDatabase() 來取得想要操作的資料庫 // 然後利用 getPermission() 取得資料庫得操作權限 // 再來利用 getTable() 獲取想要操作的資料表 // 最後利用 setQuery() 進行資料上的修改 return this.system.getDatabase(db_name).getPermission(this).getTable(table_name).putQuery(query); } } 我們可以看到：雖然只是一個簡單的 User.update() 方法，裡面卻至少依賴了 4-5 種不同的物件方法（像是 getDatabase(), getPermission(), getTable(), setQuery() \u0026hellip;等）。在這樣的程式邏輯下，應該不難想像：如果這一串呼叫中的其中一個環節出了狀況（例如 getTable() 這個方法突然壞掉了？），那麼整個 User.update() 就沒有無法正確地回應預期的結果。這就是沒有使用到「迪米特原則」可能會對程式帶來的潛在風險。\n朋友 知道了違反原則可能會造成的問題之後，接下來就可以來說明迪米特原則的程式風格了。但在直接進入到程式範例之前，我們要先來解決另外一個問題：因為迪米特原則的核心是「應該只與你自己的『朋友』建立依賴」，所以我們要先解釋所謂的「朋友」到底是什麼？一般來說，常見對於「朋友」的定義有以下四種：「類別本身的成員變數」「類別本身的方法」「父類別的所有成員與方法」「傳入方法中的所有參數」以及「在方法中建立的任何物件」。可以發現到朋友的類型能夠根據是類別還是方法有所不同，這也是該原則比較特別的一個地方：不僅適用於類別的角度，也適用於方法的角度。\n類別本身的成員變數 這個應該蠻好理解的？畢竟是「自己本身就有的東西」。「類別本身的成員變數」可以視為是一個自己的親近朋友，無論是 \u0026ldquo;基本資料型態\u0026rdquo;（像是 int, float, long, double \u0026hellip;等），或者是 \u0026ldquo;參考資料型態\u0026rdquo;（各種類別：諸如 Object, System, Database, Table \u0026hellip;等），只要是自己持有的成員變數，都可以視為自己的朋友，這點也包含類別本身的父類別、父父類別、父父父類別 \u0026hellip;等。此外，成員變數如果是 \u0026ldquo;參考資料型態\u0026rdquo; 的話，那麼它封裝成 public 的方法也可以算是「朋友」。\n類別本身的方法 同理於 1.，類別本身的方法也算是「自己本身就有的東西」，所以類別裡面的所有方法無論是哪一種封裝等級（public, pritected, private）無論是哪一種回傳型態（int, String, Object, Book \u0026hellip;等），無論該方法需不需要參數 \u0026hellip;等，它們都可以視為是自己的朋友。因此在進行這類的呼叫時上不用太過擔心，雖說不上是肆無忌憚，但大體而言，還是可以放心使用。\n傳入方法中的所有參數 接下來從方法的角度去做切入：在 \u0026ldquo;方法\u0026rdquo; 的程式細節中，除了可以利用到上述的兩種朋友（所屬類別的成員變數、所屬類別的其他方法）之外，還可以將「傳入方法中的所有參數」都視為是自己的朋友，也跟 1 同理，無論是 int, float \u0026hellip;等基本資料型態，還是 Object, String \u0026hellip;等參考資料型態，只要是傳進來的參數，都可以視為是方法本身的「朋友」，此外，邏輯同樣也跟 1 一樣，傳入方法的參數如果是某一個物件的話，該物件封裝成 public 的方法也可以被視為「朋友」。\n在方法中建立的任何物件 這算是對於類別或方法來說，最為彈性的一個「朋友」。建立物件的方式有兩種：第一種是透過最簡單的 new 關鍵字建立，像是在方法內直接使用 Database db = new Database() 這類的語句來生成新物件。另一種方式是透過回傳值建立起來的物件：可以透過類別本身建立物件、透過成員變數建立物件、或者是物件參數建立物件 \u0026hellip;等，透過這些方式所獲得的物件，同樣可以也算是方法的「朋友」。\n綜上所述，程式的更新可以改寫成以下的樣子：\n// [使用者] 類別 class User { private DatabaseManagementSystem system; public State update(String db_name, String query) { this.system.connectToSystem(this); State State = this.system.update(db_name, query); return State; } // 其他 User 中的方法 ... // 其他 User 中的方法 ... // 其他 User 中的方法 ... } // [資料庫系統] 類別 class DatabaseManagementSystem { private Map\u0026lt;String, Database\u0026gt; databases; public void connectToSystem(User user) { // 一些連接資料庫的程式 ... } public State update(String db_name, String query) { Database db = this.getDatabase(db_name); State state = db.putQuery(query); return state; } private Database getDatabase(String db_name) { // 一些取得資料庫的程式 ... } // 其他 DatabaseManagementSystem 中的方法 ... // 其他 DatabaseManagementSystem 中的方法 ... // 其他 DatabaseManagementSystem 中的方法 ... } // [資料庫] 類別 class Database { public State putQuery(String query) { // 一些執行 query 的操作 } // 其他 Database 中的方法 ... // 其他 Database 中的方法 ... // 其他 Database 中的方法 ... } 現在， User 的 update 方法只跟 system 這個變數，以及 system.update() 這個方法保持依賴，如果程式中的其他部分（例：Database.putQuery()）發生問題，雖然就結果而言，還是會使得 User.update() 無法順利運行，但是因為現在 User 已經沒有再依賴 Database 的相關方法了，因此即便 putQuery() 有需要修改細節上的程式內容、或者是修改傳入的參數 \u0026hellip;等，都不會對 User.update() 方法造成影響。這就是「降低方法依賴」所帶來的好處，也是迪米特原則倡導的一個程式撰寫方法。\n鏈式呼叫 最後，還有一個在該原則上很容易搞混的問題：鏈式呼叫。雖然在大部分的情況下，當我們想要看 Java 內的程式是否符合迪米特原則時，對直觀的方法會是「數一行程式上存在著多少個 .」，但不是所有「超過 1 個 . 的程式」就是需要修改、不符合迪米特法則的程式。一個最常見的例子是：System.out.println()，雖然程式裡面包含了兩個 .，但這句話本質上就是一個單純的輸出指令，不需要做任何的修改。\n還有一種常見情況是 return this 的時候，例如當一個 Database 需要創建一個新的 Table 時，他會不停地對某一個 Table 物件做修改和操作，雖然在視覺上，這個 Database 呼叫了很多不同種類的方法，但追根結底，對於這個 Database 來說，它所依賴的物件易始至終並沒有發生任何的變化，那這樣得情況下，即使呼叫了很多不同種類的方法，也還是可以視為一個「與朋友溝通」的操作，就像是下面這樣：\nclass Database { // 一些 Database 的成員變數 // 一些 Database 的成員變數 public createTable() { Table table = new Table(\u0026#34;Student\u0026#34;); table.charSet(\u0026#34;UTF-8\u0026#34;) .addColumn(\u0026#34;id\u0026#34;, Integer.getClass()); .setUnique(\u0026#34;id\u0026#34;); .setAutoIncrement(\u0026#34;id\u0026#34;); .addColumn(\u0026#34;name\u0026#34;, String.getClass()); .addColumn(\u0026#34;age\u0026#34;, Integer.getClass()); .addColumn(\u0026#34;sex\u0026#34;, String.getClass()); .addColumn(\u0026#34;teacher\u0026#34;, Teacher.getClass()); .addColumn(\u0026#34;parents\u0026#34;, Person.getClass()); .addColumn(\u0026#34;contact\u0026#34;, String.getClass()); } } 對於 createTable() 這個方法來說，雖然在方法裡面出現了「一行程式裡面出現多個 .」的情況，但自始至終，這些方法在執行和操作的過程，都只會影響到最一開始那個被建立的 table 物件，而 table 物件是「方法中被建立的物件」，也就是法則裡面所定義的「朋友」，因此，即便這行程式裡面出現了許多方法間的呼叫，但就本質上而言，這個 createTable() 仍是沒有違反迪米特法則的。\n"},{"id":25,"href":"/docs/finance/track_expenses/202308/","title":"記帳 2023/08","section":"個人記帳","content":"\r記帳 2023/08\r#\r各方面金流\n台幣活存：4098 台股股票淨值：19278 借貸狀況： 借出共 143,500 + 50,000 元 貸款共 0 元 保險： 儲蓄型保單收到了 2 元的回饋 備註\n因為信用卡還沒開辦的原因，所以個人的信用評分應該還算是很低很低。加上現在還是處在比較高利的情況，所以我不打算去做一些跟信貸有關的相關操作。因此貸款的數字是 0。另外借出約 20 萬左右的金額，主要是由兩個人所組成，預計會在近 1-2 年內回收完畢吧？如果到時候還沒回收的話，可能就會採取比較激進一點的行動方針。\n活存的部分 \u0026hellip;只能說相當可怕啦。下個月的花錢必須要非常拮据與謹慎，不然一不小心就會直接死給大家看了。台股的淨值大約是 20k，它是我 4 個月定期應額 006208 的小小成果，基本上台股的部分不會有太多的更動，它就會是一個每個月固定 5000, 5000 投入的狀況。不打算做一點短線的投機，次要原因是目前沒有甚麼了解的標的在低檔位的股價，主要原因是沒有多餘的閒錢 （哭）\n大概是這樣，目前看來沒什麼大問題，除了活存的數字真的是有夠少之外 \u0026hellip;。整體而言，自評的話大概會給 57-58 左右吧？滿分是 100 分。不及格的部分是活存水位過低、沒有緊急預備金。但剩下的 \u0026hellip; 我覺得基本上沒有大問題，但這　1-2　個月要好好調整自己的用錢習慣就是，畢竟已經沒有研究室的研究補貼了，算命的收入要想辦法拉高一點。\n"},{"id":26,"href":"/docs/finance/track_expenses/202309/","title":"記帳 2023/09","section":"個人記帳","content":"\r記帳 2023/09\r#\r各方面金流\n資產的部分 台幣活存 31,222 元 台股股票淨值：28,964 元 借出共 143,500 元 負債的部分 貸款共 157,000 元 備註\n這禮拜活存大概暴增了 3-4 萬有，是因為上個月有一筆的 5 萬的借款拿回來了。股票淨值多了大約 10k，是因為這個月多買了一次 5000 的零股，但台股的錢基本上不會去動啦，畢竟是 006208 的定期定額 \u0026hellip;。另外有一筆借出約 15 萬左右的款項被我劃掉了，因為那筆借貸目前在法院的訴訟中，但我覺得有高機率拿不回來 XDD，所以就先當沒這筆錢，因此目前的總資產大約落在 55-60 k 左右。\n負債的部分 \u0026hellip; 最近妹妹不小心被人騙錢了 XD 大概被騙了 15 萬左右，身為哥哥，當然就是全扛下來啦～雖然寫是寫「負債」，但比較像是「這筆錢妳就當我先跟妳借的，我再慢慢還妳」的那種感覺，所以比較像是無期限(? 的 0 利率貸款，超划算對吧～哈哈哈哈，不過之後還是要慢慢還就是了。\n"},{"id":27,"href":"/docs/computer_science/design_pattern/","title":"設計模式","section":"資工相關","content":"\r設計模式\r#\rChatGPT 的說明 【設計模式】（Design Patterns）是一種軟體工程中的概念，它描述了一種解決特定問題的通用方法或解決方案。設計模式是一種被廣泛接受和應用的軟體設計指南，它們有助於提高程式碼的可讀性、可維護性和可擴展性。通常來說，一個設計模式通常包括下面的 3 種元素：［問題描述］問題描述用來描述該模式被用來解決的問題，或便於使用此模式的情境，通常來說，問題描述可能會涉及到關於程式的複雜性、耦合性、或可讀性\u0026hellip;等不同方面的問題。［解決方案］解決方案可以為我們提供一個關於「問題」的解決方法，通常來說，解決方案會包括含一個設計結構和一個（或多個）設計原則，以便應用在特定的問題或情境中。［程式細節］程式細節用來具體示範如何在程式碼中實現這個 \u0026ldquo;解決方案\u0026rdquo;，包括扮不限於類別的結構、方法、和關係。\n設計模式的主要目標是促進程式碼的重用性、減少程式的冗餘，提高程式的可維護性、可讀性、或可擴展性。通過使用設計模式，程式的開發人員可以借鑒已經證明有效的解決方法對專案中的程式進行撰寫，而不必重新尋找解決方案、重新發明輪子、重新測試方法的可靠性。設計模式也有助於提高程式碼的可讀性，因為這些模式通常都會提供一些通用的語言和程式結構，使得程式的開發人員更容易理解和操作。一些常見的設計模式包括單例模式、工廠模式、觀察者模式、策略模式、適配器模式等。每種設計模式都針對不同的問題和情境提供了一個優雅且經過驗證的解決方案。開發人員可以根據特定的需求選擇適當的設計模式，以改善其軟體設計。\n設計模式通常可以分為創建型模式、結構型模式、和行為型模式 \u0026hellip; 等 3 種類別，每個類別都包含一組相關的設計模式，用於解決特定類型的問題：［創建型模式］創建型模式的重點在於如何創建物件，以及如何管理物件的實例化過程。創建型模式的主要目標是隱藏實例的創建過程，從而使程式更具靈活性和可維護性，同時降低類別對魚特定物件的依賴性。［結構型模式］結構型設計模式關注如何組合類別和物件，以使程式可以形成更大的結構，以解決更高層次的問題。結構型模式的主要目標是改進系統的組織與結構，使其更具有靈活性和可擴展性，同時降低系統中各個部分的耦合程度。［行為型模式］行為型關注主要研究的內容是如何進行物件之間的相互通信和合作，以實現更好的交互作用與職責分工。行為型模式的主要目標是改進類別之間的溝通方式，使系統更容易理解和維護。\n以下是一些設計原則，與常見的設計模式：\n其他東西\nUML（Unified Modeling Language） 設計原則\n單一職責原則（Single Responsibility Principle） 開放封閉原則（Open Closed Principle） 里氏替換原則（Liskov Substitution Principle） 介面隔離原則（Interface Segregation Principle） 依賴反轉原則（Dependency Inversion Principle） 最少知識原則（Least Knowledge Principle） 合成/聚合複用原則（Composite/Aggregate Reuse Principle） 創建型模式\n簡單工廠模式（Simple Factory Pattern） 工廠方法模式（Factory Method Pattern） 抽象工廠模式（Abstract Factory Pattern） 單例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 結構型模式\n適配器模式（Adapter Pattern） 裝飾器模式（Decorator Pattern） 橋接模式（Bridge Pattern） 代理模式（Proxy Pattern） 外觀模式（Facade Pattern） 組合模式（Composite Pattern） 享元模式（Flyweight Pattern） 行為型模式\n策略模式（Strategy Pattern） 模版模式（Template Pattern） 觀察者模式（Observer Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 狀態模式（State Pattern） 職責鏈模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 備忘錄模式（Memento Pattern） 解譯器模式（Interpreter Pattern） 訪客模式（Visitor Pattern） "},{"id":28,"href":"/docs/_trash/liskov_substitution_principle/","title":"里氏替換原則","section":"Docs","content":"\r里氏替換原則\r#\rChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。\nLSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。\n這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。\n簡單整理 簡單來說：父類別沒有的，子別類不一定要有，但是父類別有的，子類別都一定要有\n程式碼範例 里氏替換原則討論的是關於類別（或介面）發生繼承時，應該遵守或者是留意一個規範或想法。大致上的重點在於「子類別應該完全實現父類別的想法」「子類別可以對付類別的想法作出補充」以及「子類別應該遵循與父類別一致的規則」這句話上面。簡單來說就是「父類別的擁有和要求，子類別都要做到」但「父類別沒有要求的，子類別可以不用做到」這兩句話上。\n自己稍微唸了一下，感覺還是有點饒口，直接用一個範例程式碼來做舉例好了：假設我們現在受到了某某大型運輸公司的委託，需要製作一個該公司的「交通工具查閱系統」，裡面需要包含一些常見的交通工具的相關資訊，像是汽車、船、機車、公車、腳踏車、直升機、飛機 \u0026hellip;等，在最最直觀的情況下，我們可以把所有的交通工具都寫成互不相關的獨立類別，就像是下面的這個樣子：\nclass Car { String id; String type; public void driving() { System.out.println(\u0026#34;在馬路上行駛\u0026#34;); } // 其他跟[汽車]有關的方法 // 其他跟[汽車]有關的方法 } class Boat { String id; String type; public void sailing() { System.out.println(\u0026#34;在河道或海中航行\u0026#34;); } // 其他跟[船]有關的方法 // 其他跟[船]有關的方法 } \u0026hellip;（還有其他好多類型的交通工具）\nclass Helicopter { String id; String type; public void flight() { System.out.println(\u0026#34;在天空中飛行\u0026#34;); } // 其他跟[直升機]有關的方法 // 其他跟[直升機]有關的方法 } 但因為不同的交通工具之間，多少還是會有類似的一些屬性或方法，像是大家都有 id, type，陸上交通工具都有 driving() 方法、船型工具都可以 sailing()、飛機跟直升機都可以flight() \u0026hellip;等，因此，一個更好的寫法可能是「把相同的部份提出來，作為一個共用的父類別，以提高程式的重用性，並減少程式的冗余。」就像是下面的這個樣子：先定義一個共同的 Vehicle 類別，然後把所有的變數和方法進行統一的定義跟宣告，再讓其餘的類別（Car, Boat \u0026hellip;等）進行實例化。\nabstract class Vehicle { protected String id; protected String type; public abstract void driving(); public abstract void sailing(); public abstract void flight(); } class Car extends Vehicle { // 實作關於 Vehicle 類別中的方法 }; class Boat extends Vehicle { // 實作關於 Vehicle 類別中的方法 }; // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... class Helicopter { // 實作關於 Vehicle 類別中的方法 }; 不過，這樣改寫的話，一個可能的問題就出現了：我們都知道，Car 這個類別就是一個單純的汽車，它的運輸方式就是普通的「在路上跑」，並不會什麼在海上跑啊、在天上飛啊 \u0026hellip;這類的方法。但因為我們在父類別 Vehicle 裡定義了 sailing() 和 flight() 的方法，理論上來說，我們還是得實利化這一些父類別所定義的抽象方法，所以就有可能會寫出像這樣的程式來：\nclass Car extends Vehicle { // 建構子，用於設定型號及車牌 public Car(String type, String id) { this.type = type; this.id = id; } // 改寫「在路上跑」的方法 @Override public void driving() { System.out.println(\u0026#34;車子利用 4 個輪子在道路上行駛\u0026#34;); }; // 雖然不會用到，但還是得進行改寫的其餘方法 @Override public void sailing() {}; @Override public void flight() {}; }; // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... 同樣的狀況，也會發生在所有無法陸海空三棲的交通工具上。\n所以，如果利用這種方式對原本的系統進行改寫的話，雖然不會產生邏輯上的問題（畢竟車子真的就不會在天上飛，所以車子的 flight() 就什麼都不寫），但這樣的寫法就不遵循里氏替換原則了。因為「子類別 Car 沒有辦法完整的實現父類別 Vehicle 所定義的所有方法。」比較好的改善方式有兩種：第一種是把所有的交通工具運行方式統一定義成像是 move() 這類的方法，再透過各子類進行更加細節的描述：\n// 父類別 Vehicle 用以涵蓋所有交通工具 abstract class Vehicle { protected String id; protected String type; // 抽象方法 move() 用來表示「交通工具都可以『行進』」 public abstract void move(); } // 子類別 Car 用來實現一種「真正的交通工具」 class Car extends Vehicle { // 建構子 public Car(String type, String id) { this.type = type; this.id = id; } // 改寫『行進』這個方法，並作更細節的描述 @Override public void move() { System.out.println(\u0026#34;車子利用 4 個輪子在道路上行駛\u0026#34;); }; }; // 子類別 Airplane 用來實現一種「真正的交通工具」 class Airplane extends Vehicle { // 建構子 public Airplane(String type, String id) { this.type = type; this.id = id; } // 改寫『行進』這個方法，並作更細節的描述 @Override public void move() { System.out.println(\u0026#34;飛機利用機翼在天空中飛行\u0026#34;); }; }; // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... 另一種更加符合「里氏替換原則」的思考模式的改寫方式，則是利用更加細緻的不同類別，來分別對不同的交通工具進行擴充：像是原本只有一個 Vehicle 類別作為父類，其餘子類別則直接實現 Vehicle 類別。現在我們可以修改成「有一個最高類別 Vehicle，中間有三個子類『陸上交通工具』『海上交通工具』和『空中交通工具 』，最最下面才有 Car, Airplane \u0026hellip;等不同的類別」，就像是下面這樣：\n// 父類別 Vehicle，現在只定義了「型號」與「車牌」 abstract class Vehicle { protected String id; protected String type; } // 陸上交通工具，包含了 Vehicle 與『陸上』專有的一些行為 abstract class LandVehicle extends Vehicle { public abstract void driving(); } // 海上交通工具，包含了 Vehicle 與『海上』專有的一些行為 abstract class Watercraft extends Vehicle { public abstract void sailing(); } // 空中交通工具，包含了 Vehicle 與『天上』專有的一些行為 abstract class Aircraft extends Vehicle { public abstract void flight(); } // 實體的交通工具 Car class Car extends LandVehicle { public Car(String type, String id) { this.type = type; this.id = id; } // 因為只繼承『陸上』交通工具 // 因此 Car 不具有海上和天上的行為 @Override public void driving() { System.out.println(\u0026#34;車子利用 4 個輪子在道路上行駛\u0026#34;); }; } // 實體的交通工具 Boat class Boat extends Watercraft { public Boat(String type, String id) { this.type = type; this.id = id; } // 因為只繼承『海上』交通工具 // 因此 Car 不具有陸上與空中的行為 @Override public void sailing() { System.out.println(\u0026#34;船可以在河道或海上航行\u0026#34;); }; } // 其他好多好多交通工具 ... // 其他好多好多交通工具 ... 這樣一來，就保證了子類別會保留（和實現）父類別的所有行為，也就達成了里氏替換原則所想要傳達的訊息。\n值得一提的是：因為 Java 語言不允許多重繼承（也就是同時繼承 1 個以上的類別），所以在這樣的情況下，如果出現了一個「水路兩棲車」的類別，它就沒辦法同時繼承 LandVehicle 和 Watercraft。一個比較好的調整方式是把所有的父類調整成介面（Interface）的形式，再讓多棲的交通工具進行多種介面的實例化，像是下面這個樣子：\n// 父類別 Vehicle，只定義一些相關的成員變數 abstract class Vehicle { protected String id; protected String type; } // 陸上交通工具，宣告陸上的專有行為 abstract interface LandVehicle { public abstract void driving(); } // 海上交通工具，宣告海上的專有行為 abstract class Watercraft { public abstract void sailing(); } // 空中交通工具，宣告天上的專有行為 abstract class Aircraft { public abstract void flight(); } class SuperVehicle implements LandVehicle, Watercraft, Aircraft { public SuperVehicle(String id, String type) { this.id = id; this.type = type; } @Override public void driving() { System.out.println(\u0026#34;超級交通工具可以在『路上』行駛\u0026#34;); } @Override public void sailing() { System.out.println(\u0026#34;超級交通工具可以在『海上』航行\u0026#34;); } @Override public void flight() { System.out.println(\u0026#34;超級交通工具可以在『空中』飛行\u0026#34;); } } 同樣也可以完成里氏替換原則的規範。\n"},{"id":29,"href":"/docs/computer_science/design_pattern/liskov_substitution_principle/","title":"里氏替換原則","section":"設計模式","content":"\r里氏替換原則\r#\rChatGPT 的說明 里氏替換原則（Liskov Substitution Principle，LSP）是 SOLID 設計原則中的一項原則，由電腦科學家芭芭拉·利斯科夫（Barbara Liskov）於 1987 年首次提出。里氏替換原則強調了「子類別應該能夠取代其基底類別，而不會影響程式的正確性。」簡而言之，該原則表明：如果一個類型是某個抽象類型的子類型，那麼它應該可以取代該抽象類型的任何實例而不引發錯誤。\nLSP 的核心觀點包括以下幾個面向：首先，［子類別必須保留基底類別的所有行為］這代表子類別在繼承基底類別時，必須保留基底類別的行為。也就是子類別應該實作基底類別中所定義的方法，並且這些方法的行為不應該與基底類別不同。其次，［子類別可以加強基底類別的行為］雖然子類別必須保留基底類別的行為，但是子類別可以透過覆寫基底類別方法（或添加新的方法）來加強（或擴展）基底類別的行為。這也代表著子類別可以提供相對於基底類別更多的功能，但不應該改變基底類別的行為。此外，［子類別可以限制基底類別的行為］子類別可以限制基底類別的行為，但不能擴展或改變基底類別的行為。這意味著子類別可以透過覆蓋基類方法來限制某些操作的效果，但不能使這些操作變得更強或更複雜。最後，［子類別的方法參數和傳回值要與基底類別一致］子類別的方法參數類型要與基底類別一致（或更為具體），而傳回值類型要與基底類別一致或（更通用）。\n這些面謝確保了客戶端程式碼可以放心地使用子類別對象，而不必擔心類型不匹配的問題。LSP 的遵循有助於保持程式碼的一致性、可維護性和可擴充性。它還有助於實現多態性，使得客戶端程式碼可以處理多個子類別物件而不需要知道特定的子類別類型。LSP 在物件導向程式設計中非常重要，它幫助我們建立穩健的繼承體系，使程式碼更容易理解和維護。\n簡單整理 父類別的方法，如果換成子類別來做，應該要得出一樣的結果\n程式碼範例 在所有的設計原則中，里氏替換原則應該是最難懂的（至少在我自己理解的過程中 XD），作為設計原則中的其中一項原則，里氏替換原則所討論，是關於類別與類別間的繼承（inherit）和改寫（override）的問題。里氏替換原則的核心，就是在確保簡單整理中的那句話：「父類別的方法，如果換成子類別來做，應該要得出一樣的結果。」也就是說，如果在一個程式裡面我們看到了 Parent.method(arg) 這樣的語句。里氏替換原則要求的，就是希望如果我們寫成 Child.method(arg) 時，程式同樣也可以呈現出原本的結果，不應該換了一個子類別執行，程式的結果就發生改變。\n更仔細一點的說，雖然我們在學習的過程中，被告知了「『繼承』即是包含了 is-a 的概念的兩個類別」，但該原則告訴了我們：嚴格一點來說，我們並不能夠單純地因為 A is-a B，就讓 A 跟 B 使用繼承（像是正方形 is-a 矩形，企鵝 is-a 鳥類 \u0026hellip;等），在使用繼承的時候，應該要更加嚴謹，更加小心。里氏替換原則包含以下幾個想法：子類別的參數數量和順序應該與父類別完全相同、子類別的前置條件不應該比父類別嚴格、子類別的後續條件不應該比父類別寬鬆、以及在父類別中沒有被改變的參數，子類別也應該對其保持不變。\n我們用一個簡單的例子，快速了解這之中的差別：在數學的定義上，我們可以知道「矩形」是四個角都是直角的四邊形，「正方形」是四個角都是直角、且四個邊都有相同長度的四邊形。因此，在數學的分類上，我們可以說「正方形是一種矩形」也就是「Sruare is a Rectangle」，那在程式上，我們同樣也能說出「Sruare is a Rectangle」嗎？讓我們用程式來觀察觀察，我們先假設正方形是長方形的一種：\n// 長方形 class Rectangle { protected int width; protected int height; // 建構子 public Rectangle() {} // 長方形的 setter (getter 就先省略了) public void setWidth(int width) { this.width = width; } public void setHeight(int height) { this.height = height; } // 長方形中的一些方法（以面積為例子） public int getArea() { return width * height; } } class Square extends Rectangle { // 建構子 public Square() {} // 描述一下正方形裡更嚴格的定義 ... // 改寫一下原來的方法 // 設定「寬」就等於設定「高」 @Override public void setWidth(int width) { this.width = width; this.height = width; } // 改寫一下原來的方法 // 設定「高」就等於設定「寬」 @Override public void setHeight(int height) { this.width = height; this.height = height; } // 方法 \u0026#39;getArea()\u0026#39; 可以不用改，畢竟也是長 x 寬沒錯 // public int getArea() { // return width * height; // } } 看起來沒什麼問題？我們試著執行一次：\nclass Test { public static void main(String[] args) { Rectangle rectangle = new Rectangle(); rectangle.setHeight(3); rectangle.setWidth(7); System.out.println(\u0026#34;area: \u0026#34; + rectangle.getArea()); Square square = new Square(); square.setHeight(5); System.out.println(\u0026#34;area: \u0026#34; + square.getArea()); } } area: 21 area: 25 結果也很符合預期，那麼應該就沒有什麼問題了吧？的確，如果單純從「程式本身的執行邏輯」還有「繼承的特性」去做切入的話，這支程式無論是在設定還是在執行上面，都沒有什麼需要挑惕的地方，但重點就在於「它在某些情況下『人的預期』和『實際的程式』會不一樣」，什麼意思呢？意思是如果我們之後寫了一組「設定/測試矩形的相關係數」的程式，人的預期和實際的程式就會產生誤差，就像是下面的這個樣子：\n// 測試程式 class Test { public static void main(String args[]) { Test obj = new Test(); obj.testRectangle(new Rectangle()); obj.testRectangle(new Square()); } public void testRectangle(Rectangle rectangle) { System.out.println(\u0026#34;測試類別 \u0026#34; + rectangle.getClass()); rectangle.setHeight(7); rectangle.setWidth(13); if(rectangle.getArea() != 91) { String message = r.getClass() + \u0026#34;area != 91\u0026#34;; throw new AreaCalculationException(message); } } } 測試類別 class Rectangle 測試類別 class Square Exception in thread \u0026#34;main\u0026#34; AreaCalculationException: class Squarearea != 91 at Test.testRectangle(Test.java:71) at Test.main(Test.java:57) 到這邊為止，可能有一部分的人會有「這\u0026hellip;好啦它是有一點問題沒錯，但不就只是一個 Square 或者是一個 Rectangle 的面積嗎？事情是能夠嚴重到哪裡去？」的想法，那讓我們再舉一個比較實際一點的例子：我們假設現在在做一個公司的登入系統，預設密碼不能為空的，然後我們想要讓不同的人（ex. 員工、經理、老闆、客戶 \u0026hellip;等）有各自的類別，於是工程師寫成了以下的樣子：\n// 類別 [系統] class LogInSystem { // 負責登入的主要函數 \u0026#39;logIn()\u0026#39; public boolean logIn(String account, String password) { // pseudo code 用來假設一個獲取資料的情境 Database database = Database.getDatabase(\u0026#34;company_members\u0026#34;); // 假設 table 會回傳像是 \u0026#34;老闆\u0026#34; \u0026#34;經理\u0026#34; \u0026#34;員工\u0026#34; \u0026#34;客戶\u0026#34;... 等不同種類的資料表 // 這邊同樣假設了不同表之間的帳號不會重複 // 所以 \u0026#39;getTable()\u0026#39; 可以依照帳號去判斷要回傳哪個表格 Table table = database.getTable(\u0026#34;position\u0026#34;, account); // 回傳登入的結果，但 \u0026#39;要怎麼判斷能不能登入\u0026#39; 則依照表格自己的方法決定 return table.loginTest(account, password); } } // 抽象類別 [資料表] abstract class Table { // 資料表名稱 protected String name; // 驗證登入的方法 boolean loginTest(String account, String password) { // 密碼想當然不可以是空的 if(password.equals(\u0026#34;\u0026#34;)) { return false; } // 拿到 account 對應的 password String sql = \u0026#34;SELECT `password` from \u0026#34; + name + \u0026#34; where `account` = \u0026#34; account; // 檢查密碼是否一致 String result = Table.getResult(sql); // 回傳結果 return (password == result); } } 現在，公司聘用了好幾個工程師，分別負責不同資料表的登入功能（也許員工登入之前，需要主管給予權限？也許客戶在登入的時候，只允許某些時段 \u0026hellip;等），然後，負責 BossTable 的工程師其實是老闆的兒子，他爸爸跟他說「我就不設密碼了，反正看到是我的帳號，就直接讓我登入就好」所以 BossTable 的程式就變成了類似下面的樣子：\nclass BossTable extends Table { @Override public boolean loginTest(String account, String password) { return true; } } 然後 Boss 的資料表實際上長這個樣子\n+-------+--------+ |account|password| +-------+--------+ | boss| NULL| +-------+--------+ 到這裡為止，如果單看程式邏輯的話，一切都還在很合理的範疇，但接下來問題出現了：公司在原來執行「撤銷離職員工的帳密」的操作的時候，因為一些原因，他們決定「撤銷」這個動作，並不是直接把員工資料刪掉，而是直接把離職員工的密碼刷成 NULL。然後再在 table.loginTest() 裡面寫上一個「如果密碼是 NULL，則直接回傳登入失敗」的語句（畢竟在正常情況下，沒有會把密碼設成 NULL，而且 Table 原本的判斷也防止了有人想要把密碼設成 NULL 的狀況）。\n然後又過了 3-5 年，負責資料庫的主管發現「誒？最近離職員工的資料好像越來越佔空間了欸」所以他就在主管開會的時候，提議了「把離職員工的資料從資料庫中清除」的提案，想當然提案毫無阻礙地通過了。所以他就跟下面的工程師說「幫我寫個程式，檢查一下所有的表格，把離職的員工資料都刪一刪。」然後，因為該員工很直覺的理解成「哦？離職員工，密碼是 NULL 的那些嘛～」，所以 \u0026hellip;沒錯 \u0026hellip;你們想像中的事情就發生了 \u0026hellip;，\nclass Database { // 上面有一些 `getDatabase`, `getTable()` 之類的方法 // 上面有一些 `getDatabase`, `getTable()` 之類的方法 // 上面有一些 `getDatabase`, `getTable()` 之類的方法 public static void deleteDepartedEmployeeData() { // 取出所有資料表 List\u0026lt;Table\u0026gt; tables = Database.getAllTables(); // 對所有的資料表逐一進行操作 for(Table table: tables) { // 取出資料表內所有的帳號和密碼 List\u0026lt;Data\u0026gt; data = table.getAllData(\u0026#34;account\u0026#34;, \u0026#34;password\u0026#34;); // 逐一檢查資料表內的內容 for(Data row_data: data) { // 判斷資料中的密碼欄位是否為 \u0026#39;NULL\u0026#39; if(row_data.get(\u0026#34;password\u0026#34;).isNull()) { // 刪除資料 String account = row_data.get(\u0026#34;account\u0026#34;); String sql = \u0026#34;delete from \u0026#34; + table.name + \u0026#34; where `account` = \u0026#34; account; table.update(sql); } } } } } 嗯\u0026hellip; 或許接下來我們就可以探討「老闆在發現自己的資料都消失後，會有怎樣的反應」以及「誰該負責這件事情」的問題，但在那之前，我們或許可以從程式上的角度上來思考，為什麼這樣的問題會發生？這跟最一開始的長方形、正方形又有什麼關係？可能有些人覺得沒有關係，可能有些人會有自己的解釋或說法，不過在這邊呢，畢竟文章還是跟設計原則有關，所以我會給出的答案是：「它們都沒有達成『父類別的方法，如果換成子類別來做，應該要得出一樣的結果』。」也就是「它們都沒有遵守『里氏替換原則』」。\n說得仔細一點，矩形的案例犯的錯是「明明 Rectangle 的 setWidth() 和 setHeight() 都只有對特定變數行操作，但在 Square() 裡面，無論是 setWidth() 還是 setHeight() 都還有對其他變數進行操作。」而老闆密碼的案例則是「明明 Table 都已經先說了『密碼不可以是 NULL』，但是在 BossTable 那邊卻還是讓 NULL 通過。」\n那麼，如果要系統化一點的說，既然我們知道了他們的錯是「沒有遵守『父類別的方法，如果 \u0026hellip; 的結果』」，那怎麼樣寫才能避免這種事情呢？畢竟在正常思考下，「正方形 is a 長方形」跟「老闆説他不要設密碼，我們就放 NULL 在密碼裡面」都是很人性化也很直覺的邏輯。也因此，里氏替換原則為了讓我們能快速搞懂哪些東西是「乍看之下很有邏輯，實際上在程式裡面會出問題」的寫法，它列舉了好幾項大注意事項。\n而簡單來說，我們只要遵循以下的幾個條件，就可以確保我們的程式能遵守里氏替換原則了，它們分別是「參數的數量跟順序要保持一致」「子類別的輸入，不能減去原本可以的選擇」「子類別的輸出，不能多出原本沒有的選擇」以及「父類別在方法中沒有修改的變數，子類別也不要修改。」聽起來可能有點饒口？直接用一個例子來做說明可能會更好一點，下面我們用一個簡單的計算機父類別（Calculator）來做舉例：\nabstract class Calculator { // 自定義的數字類別 protected RationalNumber add(NaturalNumber x, PrimeNumber y) { if(x \u0026gt; 100 || y \u0026gt; 100) { throw new NumberOverflowException(); } RationalNumber result = x + y; return result; } } 參數的數量跟順序要保持一致 這個沒什麼好說的，很直觀、很好懂。數量要相同、順序不能換。\n子類別的輸入，不能減去原本可以的選擇 用字面上的例子理解：在 Calculator.add() 中，參數可以進到程式主體的條件有三個：分別是 x 為自然數、 y 為質數、以及 x, y 都要小於等於 100。所以如果有一個Calculator 的子類別想要改寫 add() 方法，那這個 add() 的輸入，就不可以少掉原本的這些，像是設定 x 成奇數（讓原本的偶數不見了）、設定 y 成孿生質數（讓原本的非孿生質數不見了）、或者是限制 x,y 都得小於等於 70（讓原本 70-100 的選擇不見了）\u0026hellip;等。\n子類別的輸出，不能多出原本沒有的選擇 理解 2 之後，3 應該就會比較好懂了：輸出選擇一般指的是回傳，或執行回傳的條件。在 Calculator.add() 中，該方法實際上有兩個回傳：分別是比較直觀的 return result 以及例外處理中的 Exception。先從一般的 return 來看，result 的回傳是一個有理數（RationalNumber），所以在想要改寫 add() 的子類別中，我們可以輸出的東西，最多最多就是原定的那些有理數的範圍，因此像無理數、實數、複數\u0026hellip;等，就不可以拿來被回傳。\n但是輸出的選擇可以維持原樣（或者變得更少），所以回傳有理數、整數、自然數、或質數 \u0026hellip;等都是可以的。此外 Exception 的情況是「只要 x 或 y 大於 100，就輸出例外」，因此如果子類別想要改寫這個條件的話，就至少要維持 if 內的判斷可以包含所有 100 以上的數字（因此 x \u0026gt; 101 之類的就不允許）。此外，這一點也是老闆密碼案例裡違反的項目：父類別中並不允許遇到 NULL 可以回傳 true，但這句話 BossTable 那邊被修改了。\n父類別在有修改的變數，子類別也不要修改 這個「變數」指的是父類別和子類別共同擁有的變數，像是在 Rectangle 和 Square 中共有的 width, height \u0026hellip;等。在父類別中，如果我們沒在方法裡對參數進行修改，那麼在子類別的改寫方法中，就不可以對那些沒動的參數進行修改。而這也是矩形案例裡違反原則的原因：在 Rectenglr.setWidth() 中，我們只有對 width 這個變數進行修改，沒有對 height 做操作，但 Square.setWidth() 就犯規了。\n因此，如果我們想要寫出一的類別，讓它繼承 Calculator，並改寫 add() 方法，就可以寫成：\n// 繼承了 [計算機] 類別的 [子計算機] class SubCalculator extends Calculator { @Override public PosisiveInteger add(NaturalNumber x, PositiveNumber y) { if(x \u0026gt; 100 || y \u0026gt; 100) { throw new NumberOverflowException(); } PosisiveInteger result = x + y; return result; } } 稍微檢查一下：［參數的數量跟順序要保持一致］沒什麼問題，都是 2 個參數、都是數字類型。［子類別的輸入，不能減去原本可以的選擇］沒有問題，x 維持在自然數沒有調整，而 y 從質數變成了任何大於 0 的正數，也沒有變少（反而還變多！）。［子類別的輸出，不能多出原本沒有的選擇］同樣成立～原本輸出的類型是任意實數，現在我們把它變成了正整數，雖然減去了一些，但正整數原本就有包含在實數裡面。［父類別在有修改的變數，子類別也不要修改］兩個類別都沒有修改變數，自然就沒有違反囉。\n"},{"id":30,"href":"/docs/computer_science/design_pattern/open_closed_principle/","title":"開放封閉原則","section":"設計模式","content":"\r開放封閉原則\r#\rChatGPT 的說明 開放封閉原則（Open-Closed Principle，OCP）是物件導向程式設計中的一個重要原則，由著名的軟體工程師貝瑞·波 (Bertrand Meyer) 在他的著作《Object-Oriented Software Construction》中首次提出。該原則強調軟體實體（例如類別、模組、函數 \u0026hellip;等）應該對擴展保持開放，對修改保持封閉。這樣做可以實現程式碼的可擴展性和可維護性。具體來說，開放封閉原則有以下兩個重要概念：首先是［開放性］：開放性表示軟體應該在不需要修改現有程式碼的前提下，允許新增新的功能或新的特性。當系統需要新增功能時，應該通過擴展現有的實體，而不是修改原有的程式來完成。這有助於防止對現有程式碼的不必要修改，降低了引入錯誤的風險。其次是［封閉性］：封閉性說明程式實現某一功能後，程式本身應該被封閉，即不應該再對其內容進行修改。當一個實體達到預期的功能時，應該停止對它的修改，而是應該通過擴展或建立新的實體來添加新功能。\n開放封閉原則的優勢包括下列幾項：首先是可擴展性，當需要新增功能時，開發人員可以通過創建新的子類別、新的模組或擴展介面來實現，而不需要修改原有的程式碼，這有助於降低風險，並維護程式碼的穩定性。其次是可維護性，因為不需要經常修改原有的程式碼，所以程式碼變得更容易維護。每個功能都位於獨立的模組、類別、或者介面之中，使得錯誤的追蹤與修復能變得更加容易。此外程式的重用性也會被提高，因為功能被分割成獨立的實體，我們可以更容易地重用這些已經撰寫完成的程式碼，這有助於提高程式的效率和一致性。\n簡單整理 OCP 在說的就是：寫好的程式需要有『容易擴展』和『不再需要更改』兩種特性\n程式碼範例 開放封閉原則算是一個蠻好理解的設計原則，基本上就是「寫好的程式碼，盡量保持在不需要頻繁編輯的狀態」跟「寫好的程式碼，要容易被後來的程式碼飲用或擴充」這兩句話。用一個比較常見的舉例方式來解釋的話，讓我們考慮以下的情境：假設我們需要撰寫一支程式，該程式需要能夠透過不同參數，生成不同的圖形（圓形、正方形、長方形 \u0026hellip;等），並且程式也要能夠計算該圖形的面積。如果不使用開放封閉原則的話，可能會寫出以下的程式：\n// 定義各種不同的圖形 class Circle { Double radius; public Circle(Double radius) { this.radius = radius; } } class Square { Double sideLength; public Square(Double sideLength) { this.sideLength = sideLength; } } class Rectangle { Double width; Double height; public Rectangle(Double width, Double height) { this.width = width; this.height = height; } } // 定義一個用來計算圖形面積的類別 class AreaCalculator { public Double getArea(Object shape) { if(shape instanceof Circle) return ((Circle)shape).radius * ((Circle)shape).radius * Math.PI; else if(shape instanceof Square) return ((Square)shape).sideLength * ((Square)shape).sideLength; else if(shape instanceof Rectangle) return ((Rectangle)shape).width * ((Rectangle)shape).height; else throw new ShapeAreaCalculationException(); } } 程式在邏輯上本身沒有什麼問題，但在可擴展性和可讀性上就有可以著墨的地方了：雖然對於各種不同的圖形（Circle, Square, 或 Rectanle \u0026hellip;等）我們都可以利用 AreaCalculator 類別中的 getArea() 方法進行面積計算，同時這個方法也幫我們寫好了非圖形類別時的例外處理，但 getArea() 本身的內容卻重度依賴著各種不同的圖形。在可預想的範圍內，我們不難思考出：之後每在程式裡面新增一個圖形，getArea() 這個方法就會需要重新被修改一次。因此，對於 getArea() 這個方法來說，就沒有很好地遵守「開放封閉原則」了。\n修改的方法其實很簡單，在類似於上述的狀況下，我們通常會使用「共同的介面」或者是「繼承同一個父類別」來做改進：先在共同的介面（或父類別）裡面定義一個所有子類別都可以使用的方法，再讓其繼承的類別去改寫該方法，就能夠避免其他調用者需要重複調整程式的情況了，就像是下面的這個樣子：\n// 定義一個所有圖形都共同繼承的父類別 abstract class Shape { // 定義父類別中的共同方法 \u0026#39;getArea()\u0026#39; public Double getArea() { throw new ShapeAreaCalculationException(); } } // 定義各種不同的圖形 class Circle extends Shape { Double radius; public Circle(Double radius) { this.radius = radius; } // 改寫父類別的 getArea() 方法 @Override public Double getArea() { return this.radius * this.radius * Math.PI; } } class Square extends Shape { Double sideLength; public Square(Double sideLength) { this.sideLength = sideLength; } // 改寫父類別的 getArea() 方法 @Override public Double getArea() { return this.sideLength * this.sideLength; } } class Rectangle extends Shape { Double width; Double height; public Rectangle(Double width, Double height) { this.width = width; this.height = height; } // 改寫父類別的 getArea() 方法 @Overrie public Double getArea() { return this.width * this.height; } } // 定義一個用來計算圖形面積的類別 class AreaCalculator { public Double getArea(Object obj) { if(obj instanceof Shape) return ((Shape) obj).getArea(); else throw new ObjectIsNotInheritedFromShapeException(); } } 透過定義一個共同的父類別 Shape，並在各個子類別中改寫原父類別的 getArea() 方法，往後如果我們需要再創建其他不同的形狀（像是三角形、橢圓形 \u0026hellip;等），我們只需要讓該形狀繼承 Shape 類別，然後重寫一次類別中的 getArea()，就可以保證能夠被 AreaCalculator 正確地計算面積，也就達成了程式裡「便於擴展」的需求了（開放性(v)）；此外，往後無論我們再增加哪怕是數十種、甚至是數百種不同的形狀，只要那個形狀記得繼承 Shape 類別，AreaCalculator 裡面的 getArea() 都不再需要進行任何的調整，也能夠正確計算出該圖形的面積。也就達到了「寫完程式之後，就不需要再更動這個程式」的需求（封閉性(v)）。\n"}]